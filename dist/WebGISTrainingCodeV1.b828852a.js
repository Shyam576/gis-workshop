// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  externals,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        if (externals[name]) {
          return externals[name];
        }
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  // INSERT_LOAD_HERE

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"93v64":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "439701173a9199ea";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "f3e508fdb828852a";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            // Ignore cloudflare workers error.
            if (err.message && !err.message.includes('Disallowed operation called within global scope')) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"lhpGb":[function(require,module,exports,__globalThis) {
var _mapInitJs = require("./map-init.js");
var _geolocationJs = require("./geolocation.js");
var _flightPathJs = require("./flight-path.js");
var _loadWfsJs = require("./load-wfs.js");
var _loadWmsJs = require("./load-wms.js");
var _proj = require("ol/proj");
var _drawJs = require("./draw.js");
var _loadWmtsJs = require("./load-wmts.js");
var _saveDrawingJs = require("./save-drawing.js");
var _fetchDrawingJs = require("./fetch-drawing.js");
var _deleteDrawingJs = require("./delete-drawing.js");
var _interaction = require("ol/interaction");
var _condition = require("ol/events/condition");
var _bufferToolsJs = require("./buffer-tools.js");
var _selectFeatureJs = require("./select-feature.js");
var _geometryOperationsJs = require("./geometry-operations.js");
var _utilsJs = require("./utils.js");
const geoserverURL = "http://localhost:8080/geoserver";
const geoserverWFSURL = "http://localhost:8080/geoserver/ows";
const workspace = "ne"; // Replace with your workspace
const layerName = "draw_layer"; // Replace with your layer name
const username = "admin"; // Replace with your username
const password = "geoserver"; // Replace with your password
document.addEventListener("DOMContentLoaded", async ()=>{
    // Initialize map
    const map = (0, _mapInitJs.initMap)();
    // Make map available globally for debugging
    window.map = map;
    // Initialize drawing tools with our map instance
    const drawTools = (0, _drawJs.initDrawTools)(map);
    // Add a Select interaction for selecting features to delete or union
    const select = new (0, _interaction.Select)({
        condition: (0, _condition.click)
    });
    // Make select available globally for debugging
    window.select = select;
    map.addInteraction(select);
    // Add event listener for the drawing toggle
    const drawingToggle = document.getElementById('drawing-active');
    drawingToggle.addEventListener('change', (event)=>{
        drawTools.setActive(event.target.checked);
        // Optionally hide/show the draw controls when disabled
        const drawControls = document.getElementById('draw-controls');
        drawControls.style.opacity = event.target.checked ? '1' : '0.5';
        drawControls.style.pointerEvents = event.target.checked ? 'auto' : 'none';
    });
    const features = await (0, _loadWfsJs.fetchFeatures)(geoserverWFSURL, 'ne', 'draw_layer', 'admin', 'geoserver');
    const wfsLayer = (0, _loadWfsJs.createWfsLayer)(features);
    map.addLayer(wfsLayer);
    // Save drawing event listener
    document.getElementById('save-drawing').addEventListener('click', async ()=>{
        const features = drawTools.source.getFeatures();
        if (features.length === 0) {
            (0, _utilsJs.showPopupMessage)('No features to save', 'warning');
            return;
        }
        const result = await (0, _saveDrawingJs.saveDrawing)(features, workspace, layerName, 'EPSG:3857', username, password, geoserverURL);
        if (result.status === 'success') (0, _utilsJs.showPopupMessage)(`Successfully saved ${result.totalInserted || features.length} features`, 'success');
        else (0, _utilsJs.showPopupMessage)(`Error: ${result.message || 'Unknown error'}`, 'error');
    });
    // Load drawing event listener
    document.getElementById('load-drawing').addEventListener('click', async ()=>{
        const result = await (0, _fetchDrawingJs.fetchDrawing)(geoserverWFSURL, workspace, layerName, username, password);
        if (result.status === 'success') {
            // Clear existing features and add the loaded ones
            drawTools.source.clear();
            drawTools.source.addFeatures(result.features);
            // Fit the view to show all features if there are any
            if (result.features.length > 0) map.getView().fit(drawTools.source.getExtent(), {
                padding: [
                    50,
                    50,
                    50,
                    50
                ],
                duration: 1000
            });
            (0, _utilsJs.showPopupMessage)(`Loaded ${result.count} features`, 'success');
        } else (0, _utilsJs.showPopupMessage)(`Error: ${result.message || 'Unknown error'}`, 'error');
    });
    // Delete drawing event listener
    document.getElementById('delete-drawing').addEventListener('click', async ()=>{
        const selectedFeatures = select.getFeatures().getArray();
        if (selectedFeatures.length === 0) {
            (0, _utilsJs.showPopupMessage)('No features selected for deletion', 'warning');
            return;
        }
        if (!confirm(`Are you sure you want to delete ${selectedFeatures.length} features?`)) return;
        const result = await (0, _deleteDrawingJs.deleteDrawing)(selectedFeatures, workspace, layerName, 'EPSG:3857', username, password, geoserverURL);
        if (result.status === 'success') {
            // Remove the features from the local source
            selectedFeatures.forEach((feature)=>{
                drawTools.source.removeFeature(feature);
            });
            // Clear selection
            select.getFeatures().clear();
            (0, _utilsJs.showPopupMessage)(`Successfully deleted ${result.totalDeleted || selectedFeatures.length} features`, 'success');
        } else (0, _utilsJs.showPopupMessage)(`Error: ${result.message || 'Unknown error'}`, 'error');
    });
    // Add union features functionality
    document.getElementById('union-features')?.addEventListener('click', ()=>{
        console.log("Union button clicked");
        const selectedFeatures = select.getFeatures().getArray();
        console.log("Selected features:", selectedFeatures);
        if (selectedFeatures.length < 2) {
            (0, _utilsJs.showPopupMessage)('Select at least two features to union', 'warning');
            return;
        }
        // Import the function dynamically to ensure we're using the latest version
        require("2b29e93450dd6ece").then((module)=>{
            const unionFeature = module.unionFeatures(selectedFeatures, drawTools.source);
            console.log("Union result:", unionFeature);
            if (unionFeature) {
                // Clear selection
                select.getFeatures().clear();
                // Select the new union feature
                select.getFeatures().push(unionFeature);
            }
        }).catch((error)=>{
            console.error("Error importing union-tool module:", error);
            (0, _utilsJs.showPopupMessage)("Failed to perform union operation: " + error.message, "error");
        });
    });
    // Direct union button event listener
    document.getElementById('direct-union')?.addEventListener('click', ()=>{
        console.log("Direct union button clicked");
        const selectedFeatures = select.getFeatures().getArray();
        if (selectedFeatures.length < 2) {
            (0, _utilsJs.showPopupMessage)('Select at least two features to union', 'warning');
            return;
        }
        // Import the function dynamically
        require("2b29e93450dd6ece").then((module)=>{
            try {
                const result = module.unionFeatures(selectedFeatures, drawTools.source);
                console.log("Union result:", result);
                if (result) {
                    // Clear selection
                    select.getFeatures().clear();
                    // Select the new feature
                    select.getFeatures().push(result);
                    (0, _utilsJs.showPopupMessage)("Union completed successfully", "success");
                }
            } catch (error) {
                console.error("Error during union operation:", error);
                (0, _utilsJs.showPopupMessage)("Error during union: " + error.message, "error");
            }
        }).catch((error)=>{
            console.error('Error importing module:', error);
            (0, _utilsJs.showPopupMessage)("Failed to load union module: " + error.message, "error");
        });
    });
    // Simple union button event listener
    document.getElementById('simple-union')?.addEventListener('click', ()=>{
        console.log("Simple union button clicked");
        const selectedFeatures = select.getFeatures().getArray();
        if (selectedFeatures.length < 2) {
            (0, _utilsJs.showPopupMessage)('Select at least two features to union', 'warning');
            return;
        }
        // Import the function dynamically
        require("2b29e93450dd6ece").then((module)=>{
            try {
                const result = module.unionFeatures(selectedFeatures, drawTools.source);
                console.log("Simple union result:", result);
                if (result) {
                    // Clear selection
                    select.getFeatures().clear();
                    // Select the new feature
                    select.getFeatures().push(result);
                    (0, _utilsJs.showPopupMessage)("Simple union completed successfully", "success");
                }
            } catch (error) {
                console.error("Error during simple union operation:", error);
                (0, _utilsJs.showPopupMessage)("Error during simple union: " + error.message, "error");
            }
        }).catch((error)=>{
            console.error('Error importing module:', error);
            (0, _utilsJs.showPopupMessage)("Failed to load union module: " + error.message, "error");
        });
    });
    // Create buffer event listener
    document.getElementById('create-buffer').addEventListener('click', async ()=>{
        const selectedFeatures = select.getFeatures();
        if (selectedFeatures.getArray().length > 0) {
            selectedFeatures.forEach((feature)=>{
                (0, _bufferToolsJs.createBuffer)(feature, 10, wfsLayer);
            });
            (0, _utilsJs.showPopupMessage)("Buffer created successfully", "success");
        } else (0, _utilsJs.showPopupMessage)("No features selected for buffer", "warning");
    });
    // Add WMTS layer event listener
    document.getElementById("add-wmts").addEventListener("click", async ()=>{
        const extent = [
            9975165.7992,
            3174385.502833938,
            9983429.539675102,
            3192174.929474232
        ];
        const wmtsLayer = (0, _loadWmtsJs.createWMTSLayer)(geoserverURL, "ne", "thromdeBoundary", extent);
        map.addLayer(wmtsLayer);
        map.getView().fit(extent);
        (0, _utilsJs.showPopupMessage)("WMTS layer added", "success");
    });
    // Export GeoJSON event listener
    document.getElementById('export-drawing')?.addEventListener('click', ()=>{
        const features = drawTools.source.getFeatures();
        if (features.length === 0) {
            (0, _utilsJs.showPopupMessage)('No features to export', 'warning');
            return;
        }
        try {
            const format = new GeoJSON();
            const geojson = format.writeFeatures(features, {
                dataProjection: 'EPSG:4326',
                featureProjection: 'EPSG:3857'
            });
            // Create a download link
            const blob = new Blob([
                geojson
            ], {
                type: 'application/json'
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'export.geojson';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            (0, _utilsJs.showPopupMessage)(`Exported ${features.length} features to GeoJSON`, 'success');
        } catch (error) {
            console.error("Error exporting to GeoJSON:", error);
            (0, _utilsJs.showPopupMessage)(`Error exporting to GeoJSON: ${error.message}`, 'error');
        }
    });
    setTimeout(()=>{
        document.body.classList.remove("initial-load");
    }, 3000);
});

},{"./map-init.js":"dDQRS","./geolocation.js":"gp2Gj","./flight-path.js":"aG9FU","./load-wfs.js":"bsKzT","./load-wms.js":"8l3Ji","ol/proj":"8OK47","./draw.js":"9euAx","./load-wmts.js":"cLSxx","./save-drawing.js":"lpmgp","./fetch-drawing.js":"cVrUZ","./delete-drawing.js":"3LDLH","ol/interaction":"9kyTl","ol/events/condition":"gm0iA","./buffer-tools.js":"ef2iZ","./select-feature.js":"5Qkjh","./geometry-operations.js":"a2P7c","./utils.js":"bMpAD","2b29e93450dd6ece":"5IIWm"}],"dDQRS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
//initialize the map on the web
parcelHelpers.export(exports, "initMap", ()=>initMap);
var _olCss = require("ol/ol.css");
var _map = require("ol/Map");
var _mapDefault = parcelHelpers.interopDefault(_map);
var _view = require("ol/View");
var _viewDefault = parcelHelpers.interopDefault(_view);
var _tile = require("ol/layer/Tile");
var _tileDefault = parcelHelpers.interopDefault(_tile);
var _osm = require("ol/source/OSM");
var _osmDefault = parcelHelpers.interopDefault(_osm);
var _vector = require("ol/layer/Vector");
var _vectorDefault = parcelHelpers.interopDefault(_vector);
var _vector1 = require("ol/source/Vector");
var _vectorDefault1 = parcelHelpers.interopDefault(_vector1);
var _style = require("ol/style/Style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _stroke = require("ol/style/Stroke");
var _strokeDefault = parcelHelpers.interopDefault(_stroke);
var _proj = require("ol/proj");
function initMap() {
    const map = new (0, _mapDefault.default)({
        target: 'map',
        //in open layer each layers is a table
        layers: [
            new (0, _tileDefault.default)({
                source: new (0, _osmDefault.default)()
            })
        ],
        view: new (0, _viewDefault.default)({
            center: (0, _proj.fromLonLat)([
                89.638427,
                27.478586000000004
            ]),
            zoom: 2
        })
    });
    return map; // Make sure this return statement is here
}

},{"ol/ol.css":"2wn4y","ol/Map":"fTPcq","ol/View":"fJPFQ","ol/layer/Tile":"8sJWw","ol/source/OSM":"90vGx","ol/layer/Vector":"6bOIK","ol/source/Vector":"7wT1g","ol/style/Style":"8opjn","ol/style/Stroke":"1uQwy","ol/proj":"8OK47","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2wn4y":[function() {},{}],"fTPcq":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Map
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("./CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _compositeJs = require("./renderer/Composite.js");
var _compositeJsDefault = parcelHelpers.interopDefault(_compositeJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _layerJs = require("./layer/Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _groupJs = require("./layer/Group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
var _mapBrowserEventJs = require("./MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventHandlerJs = require("./MapBrowserEventHandler.js");
var _mapBrowserEventHandlerJsDefault = parcelHelpers.interopDefault(_mapBrowserEventHandlerJs);
var _mapBrowserEventTypeJs = require("./MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _mapEventJs = require("./MapEvent.js");
var _mapEventJsDefault = parcelHelpers.interopDefault(_mapEventJs);
var _mapEventTypeJs = require("./MapEventType.js");
var _mapEventTypeJsDefault = parcelHelpers.interopDefault(_mapEventTypeJs);
var _mapPropertyJs = require("./MapProperty.js");
var _mapPropertyJsDefault = parcelHelpers.interopDefault(_mapPropertyJs);
var _objectEventTypeJs = require("./ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _eventTypeJs1 = require("./pointer/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _eventTypeJs2 = require("./render/EventType.js");
var _eventTypeJsDefault2 = parcelHelpers.interopDefault(_eventTypeJs2);
var _tileQueueJs = require("./TileQueue.js");
var _tileQueueJsDefault = parcelHelpers.interopDefault(_tileQueueJs);
var _viewJs = require("./View.js");
var _viewJsDefault = parcelHelpers.interopDefault(_viewJs);
var _viewHintJs = require("./ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _hasJs = require("./has.js");
var _functionsJs = require("./functions.js");
var _transformJs = require("./transform.js");
var _assertsJs = require("./asserts.js");
var _extentJs = require("./extent.js");
var _defaultsJs = require("./control/defaults.js");
var _defaultsJs1 = require("./interaction/defaults.js");
var _arrayJs = require("./array.js");
var _projJs = require("./proj.js");
var _utilJs = require("./util.js");
var _sizeJs = require("./size.js");
var _eventsJs = require("./events.js");
var _domJs = require("./dom.js");
var _consoleJs = require("./console.js");
/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate Animate.
 * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
 * @property {import("rbush").default} declutterTree DeclutterTree.
 * @property {null|import("./extent.js").Extent} extent Extent (in view projection coordinates).
 * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
 * @property {number} index Index.
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
 * @property {number} layerIndex LayerIndex.
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
 * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
 * @property {import("./size.js").Size} size Size.
 * @property {TileQueue} tileQueue TileQueue.
 * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
 * @property {Array<number>} viewHints ViewHints.
 * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
 * @property {string} mapId The id of the map.
 * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.
 */ /**
 * @typedef {function(Map, ?FrameState): any} PostRenderFunction
 */ /**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */ /**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
 * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
 * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
 * @property {Object<string, *>} values Values.
 */ /**
 * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
 *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
 *      import("./render/EventType").MapRenderEventTypes, Return>} MapEventHandler
 */ /**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control/defaults.defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction/defaults.defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * **Note:** CSS `transform` support for the target element is limited to `scale`.
 * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */ /**
 * @param {import("./layer/Base.js").default} layer Layer.
 */ function removeLayerMapProperty(layer) {
    if (layer instanceof (0, _layerJsDefault.default)) {
        layer.setMapInternal(null);
        return;
    }
    if (layer instanceof (0, _groupJsDefault.default)) layer.getLayers().forEach(removeLayerMapProperty);
}
/**
 * @param {import("./layer/Base.js").default} layer Layer.
 * @param {Map} map Map.
 */ function setLayerMapProperty(layer, map) {
    if (layer instanceof (0, _layerJsDefault.default)) {
        layer.setMapInternal(map);
        return;
    }
    if (layer instanceof (0, _groupJsDefault.default)) {
        const layers = layer.getLayers().getArray();
        for(let i = 0, ii = layers.length; i < ii; ++i)setLayerMapProperty(layers[i], map);
    }
}
/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map.js';
 *     import View from 'ol/View.js';
 *     import TileLayer from 'ol/layer/Tile.js';
 *     import OSM from 'ol/source/OSM.js';
 *
 *     const map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1,
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM(),
 *         }),
 *       ],
 *       target: 'map',
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}
 * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */ class Map extends (0, _objectJsDefault.default) {
    /**
   * @param {MapOptions} [options] Map options.
   */ constructor(options){
        super();
        options = options || {};
        /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {MapEventHandler<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {MapEventHandler<void>}
     */ this.un;
        const optionsInternal = createOptionsInternal(options);
        /**
     * @private
     * @type {boolean|undefined}
     */ this.renderComplete_;
        /**
     * @private
     * @type {boolean}
     */ this.loaded_ = true;
        /** @private */ this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
        /**
     * @type {number}
     * @private
     */ this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : (0, _hasJs.DEVICE_PIXEL_RATIO);
        /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */ this.postRenderTimeoutHandle_;
        /**
     * @private
     * @type {number|undefined}
     */ this.animationDelayKey_;
        /**
     * @private
     */ this.animationDelay_ = this.animationDelay_.bind(this);
        /**
     * @private
     * @type {import("./transform.js").Transform}
     */ this.coordinateToPixelTransform_ = (0, _transformJs.create)();
        /**
     * @private
     * @type {import("./transform.js").Transform}
     */ this.pixelToCoordinateTransform_ = (0, _transformJs.create)();
        /**
     * @private
     * @type {number}
     */ this.frameIndex_ = 0;
        /**
     * @private
     * @type {?FrameState}
     */ this.frameState_ = null;
        /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */ this.previousExtent_ = null;
        /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */ this.viewPropertyListenerKey_ = null;
        /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */ this.viewChangeListenerKey_ = null;
        /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */ this.layerGroupPropertyListenerKeys_ = null;
        /**
     * @private
     * @type {!HTMLElement}
     */ this.viewport_ = document.createElement('div');
        this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
        this.viewport_.style.position = 'relative';
        this.viewport_.style.overflow = 'hidden';
        this.viewport_.style.width = '100%';
        this.viewport_.style.height = '100%';
        /**
     * @private
     * @type {!HTMLElement}
     */ this.overlayContainer_ = document.createElement('div');
        this.overlayContainer_.style.position = 'absolute';
        this.overlayContainer_.style.zIndex = '0';
        this.overlayContainer_.style.width = '100%';
        this.overlayContainer_.style.height = '100%';
        this.overlayContainer_.style.pointerEvents = 'none';
        this.overlayContainer_.className = 'ol-overlaycontainer';
        this.viewport_.appendChild(this.overlayContainer_);
        /**
     * @private
     * @type {!HTMLElement}
     */ this.overlayContainerStopEvent_ = document.createElement('div');
        this.overlayContainerStopEvent_.style.position = 'absolute';
        this.overlayContainerStopEvent_.style.zIndex = '0';
        this.overlayContainerStopEvent_.style.width = '100%';
        this.overlayContainerStopEvent_.style.height = '100%';
        this.overlayContainerStopEvent_.style.pointerEvents = 'none';
        this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
        this.viewport_.appendChild(this.overlayContainerStopEvent_);
        /**
     * @private
     * @type {MapBrowserEventHandler}
     */ this.mapBrowserEventHandler_ = null;
        /**
     * @private
     * @type {number}
     */ this.moveTolerance_ = options.moveTolerance;
        /**
     * @private
     * @type {HTMLElement|Document}
     */ this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
        /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */ this.targetChangeHandlerKeys_ = null;
        /**
     * @private
     * @type {HTMLElement|null}
     */ this.targetElement_ = null;
        /**
     * @type {ResizeObserver}
     */ this.resizeObserver_ = new ResizeObserver(()=>this.updateSize());
        /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */ this.controls = optionsInternal.controls || (0, _defaultsJs.defaults)();
        /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */ this.interactions = optionsInternal.interactions || (0, _defaultsJs1.defaults)({
            onFocusOnly: true
        });
        /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */ this.overlays_ = optionsInternal.overlays;
        /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */ this.overlayIdIndex_ = {};
        /**
     * @type {import("./renderer/Map.js").default|null}
     * @private
     */ this.renderer_ = null;
        /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */ this.postRenderFunctions_ = [];
        /**
     * @private
     * @type {TileQueue}
     */ this.tileQueue_ = new (0, _tileQueueJsDefault.default)(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));
        this.addChangeListener((0, _mapPropertyJsDefault.default).LAYERGROUP, this.handleLayerGroupChanged_);
        this.addChangeListener((0, _mapPropertyJsDefault.default).VIEW, this.handleViewChanged_);
        this.addChangeListener((0, _mapPropertyJsDefault.default).SIZE, this.handleSizeChanged_);
        this.addChangeListener((0, _mapPropertyJsDefault.default).TARGET, this.handleTargetChanged_);
        // setProperties will trigger the rendering of the map if the map
        // is "defined" already.
        this.setProperties(optionsInternal.values);
        const map = this;
        if (options.view && !(options.view instanceof (0, _viewJsDefault.default))) options.view.then(function(viewOptions) {
            map.setView(new (0, _viewJsDefault.default)(viewOptions));
        });
        this.controls.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */ (event)=>{
            event.element.setMap(this);
        });
        this.controls.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */ (event)=>{
            event.element.setMap(null);
        });
        this.interactions.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */ (event)=>{
            event.element.setMap(this);
        });
        this.interactions.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */ (event)=>{
            event.element.setMap(null);
        });
        this.overlays_.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */ (event)=>{
            this.addOverlayInternal_(event.element);
        });
        this.overlays_.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */ (event)=>{
            const id = event.element.getId();
            if (id !== undefined) delete this.overlayIdIndex_[id.toString()];
            event.element.setMap(null);
        });
        this.controls.forEach(/**
       * @param {import("./control/Control.js").default} control Control.
       */ (control)=>{
            control.setMap(this);
        });
        this.interactions.forEach(/**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */ (interaction)=>{
            interaction.setMap(this);
        });
        this.overlays_.forEach(this.addOverlayInternal_.bind(this));
    }
    /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */ addControl(control) {
        this.getControls().push(control);
    }
    /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */ addInteraction(interaction) {
        this.getInteractions().push(interaction);
    }
    /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */ addLayer(layer) {
        const layers = this.getLayerGroup().getLayers();
        layers.push(layer);
    }
    /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */ handleLayerAdd_(event) {
        setLayerMapProperty(event.layer, this);
    }
    /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */ addOverlay(overlay) {
        this.getOverlays().push(overlay);
    }
    /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */ addOverlayInternal_(overlay) {
        const id = overlay.getId();
        if (id !== undefined) this.overlayIdIndex_[id.toString()] = overlay;
        overlay.setMap(this);
    }
    /**
   *
   * Clean up.
   */ disposeInternal() {
        this.controls.clear();
        this.interactions.clear();
        this.overlays_.clear();
        this.resizeObserver_.disconnect();
        this.setTarget(null);
        super.disposeInternal();
    }
    /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */ forEachFeatureAtPixel(pixel, callback, options) {
        if (!this.frameState_ || !this.renderer_) return;
        const coordinate = this.getCoordinateFromPixelInternal(pixel);
        options = options !== undefined ? options : {};
        const hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
        const layerFilter = options.layerFilter !== undefined ? options.layerFilter : (0, _functionsJs.TRUE);
        const checkWrapped = options.checkWrapped !== false;
        return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
    }
    /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */ getFeaturesAtPixel(pixel, options) {
        const features = [];
        this.forEachFeatureAtPixel(pixel, function(feature) {
            features.push(feature);
        }, options);
        return features;
    }
    /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */ getAllLayers() {
        const layers = [];
        function addLayersFrom(layerGroup) {
            layerGroup.forEach(function(layer) {
                if (layer instanceof (0, _groupJsDefault.default)) addLayersFrom(layer.getLayers());
                else layers.push(layer);
            });
        }
        addLayersFrom(this.getLayers());
        return layers;
    }
    /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */ hasFeatureAtPixel(pixel, options) {
        if (!this.frameState_ || !this.renderer_) return false;
        const coordinate = this.getCoordinateFromPixelInternal(pixel);
        options = options !== undefined ? options : {};
        const layerFilter = options.layerFilter !== undefined ? options.layerFilter : (0, _functionsJs.TRUE);
        const hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
        const checkWrapped = options.checkWrapped !== false;
        return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
    }
    /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */ getEventCoordinate(event) {
        return this.getCoordinateFromPixel(this.getEventPixel(event));
    }
    /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */ getEventCoordinateInternal(event) {
        return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
    }
    /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */ getEventPixel(event) {
        const viewport = this.viewport_;
        const viewportPosition = viewport.getBoundingClientRect();
        const viewportSize = this.getSize();
        const scaleX = viewportPosition.width / viewportSize[0];
        const scaleY = viewportPosition.height / viewportSize[1];
        const eventPosition = //FIXME Are we really calling this with a TouchEvent anywhere?
        'changedTouches' in event ? /** @type {TouchEvent} */ event.changedTouches[0] : /** @type {MouseEvent} */ event;
        return [
            (eventPosition.clientX - viewportPosition.left) / scaleX,
            (eventPosition.clientY - viewportPosition.top) / scaleY
        ];
    }
    /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */ getTarget() {
        return /** @type {HTMLElement|string|undefined} */ this.get((0, _mapPropertyJsDefault.default).TARGET);
    }
    /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */ getTargetElement() {
        return this.targetElement_;
    }
    /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */ getCoordinateFromPixel(pixel) {
        return (0, _projJs.toUserCoordinate)(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
    }
    /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */ getCoordinateFromPixelInternal(pixel) {
        const frameState = this.frameState_;
        if (!frameState) return null;
        return (0, _transformJs.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
    }
    /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */ getControls() {
        return this.controls;
    }
    /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */ getOverlays() {
        return this.overlays_;
    }
    /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */ getOverlayById(id) {
        const overlay = this.overlayIdIndex_[id.toString()];
        return overlay !== undefined ? overlay : null;
    }
    /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */ getInteractions() {
        return this.interactions;
    }
    /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */ getLayerGroup() {
        return /** @type {LayerGroup} */ this.get((0, _mapPropertyJsDefault.default).LAYERGROUP);
    }
    /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */ setLayers(layers) {
        const group = this.getLayerGroup();
        if (layers instanceof (0, _collectionJsDefault.default)) {
            group.setLayers(layers);
            return;
        }
        const collection = group.getLayers();
        collection.clear();
        collection.extend(layers);
    }
    /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */ getLayers() {
        const layers = this.getLayerGroup().getLayers();
        return layers;
    }
    /**
   * @return {boolean} Layers have sources that are still loading.
   */ getLoadingOrNotReady() {
        const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
        for(let i = 0, ii = layerStatesArray.length; i < ii; ++i){
            const state = layerStatesArray[i];
            if (!state.visible) continue;
            const renderer = state.layer.getRenderer();
            if (renderer && !renderer.ready) return true;
            const source = state.layer.getSource();
            if (source && source.loading) return true;
        }
        return false;
    }
    /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */ getPixelFromCoordinate(coordinate) {
        const viewCoordinate = (0, _projJs.fromUserCoordinate)(coordinate, this.getView().getProjection());
        return this.getPixelFromCoordinateInternal(viewCoordinate);
    }
    /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */ getPixelFromCoordinateInternal(coordinate) {
        const frameState = this.frameState_;
        if (!frameState) return null;
        return (0, _transformJs.apply)(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
    /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */ getRenderer() {
        return this.renderer_;
    }
    /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */ getSize() {
        return /** @type {import("./size.js").Size|undefined} */ this.get((0, _mapPropertyJsDefault.default).SIZE);
    }
    /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */ getView() {
        return /** @type {View} */ this.get((0, _mapPropertyJsDefault.default).VIEW);
    }
    /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */ getViewport() {
        return this.viewport_;
    }
    /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */ getOverlayContainer() {
        return this.overlayContainer_;
    }
    /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */ getOverlayContainerStopEvent() {
        return this.overlayContainerStopEvent_;
    }
    /**
   * @return {!Document} The document where the map is displayed.
   */ getOwnerDocument() {
        const targetElement = this.getTargetElement();
        return targetElement ? targetElement.ownerDocument : document;
    }
    /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */ getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
        return (0, _tileQueueJs.getTilePriority)(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
    }
    /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */ handleBrowserEvent(browserEvent, type) {
        type = type || browserEvent.type;
        const mapBrowserEvent = new (0, _mapBrowserEventJsDefault.default)(type, this, browserEvent);
        this.handleMapBrowserEvent(mapBrowserEvent);
    }
    /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */ handleMapBrowserEvent(mapBrowserEvent) {
        if (!this.frameState_) // With no view defined, we cannot translate pixels into geographical
        // coordinates so interactions cannot be used.
        return;
        const originalEvent = /** @type {PointerEvent} */ mapBrowserEvent.originalEvent;
        const eventType = originalEvent.type;
        if (eventType === (0, _eventTypeJsDefault1.default).POINTERDOWN || eventType === (0, _eventTypeJsDefault.default).WHEEL || eventType === (0, _eventTypeJsDefault.default).KEYDOWN) {
            const doc = this.getOwnerDocument();
            const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
            const target = /** @type {Node} */ originalEvent.target;
            if (// Abort if the target is a child of the container for elements whose events are not meant
            // to be handled by map interactions.
            this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
            // It's possible for the target to no longer be in the page if it has been removed in an
            // event listener, this might happen in a Control that recreates it's content based on
            // user interaction either manually or via a render in something like https://reactjs.org/
            !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) return;
        }
        mapBrowserEvent.frameState = this.frameState_;
        if (this.dispatchEvent(mapBrowserEvent) !== false) {
            const interactionsArray = this.getInteractions().getArray().slice();
            for(let i = interactionsArray.length - 1; i >= 0; i--){
                const interaction = interactionsArray[i];
                if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) continue;
                const cont = interaction.handleEvent(mapBrowserEvent);
                if (!cont || mapBrowserEvent.propagationStopped) break;
            }
        }
    }
    /**
   * @protected
   */ handlePostRender() {
        const frameState = this.frameState_;
        // Manage the tile queue
        // Image loads are expensive and a limited resource, so try to use them
        // efficiently:
        // * When the view is static we allow a large number of parallel tile loads
        //   to complete the frame as quickly as possible.
        // * When animating or interacting, image loads can cause janks, so we reduce
        //   the maximum number of loads per frame and limit the number of parallel
        //   tile loads to remain reactive to view changes and to reduce the chance of
        //   loading tiles that will quickly disappear from view.
        const tileQueue = this.tileQueue_;
        if (!tileQueue.isEmpty()) {
            let maxTotalLoading = this.maxTilesLoading_;
            let maxNewLoads = maxTotalLoading;
            if (frameState) {
                const hints = frameState.viewHints;
                if (hints[(0, _viewHintJsDefault.default).ANIMATING] || hints[(0, _viewHintJsDefault.default).INTERACTING]) {
                    const lowOnFrameBudget = Date.now() - frameState.time > 8;
                    maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                    maxNewLoads = lowOnFrameBudget ? 0 : 2;
                }
            }
            if (tileQueue.getTilesLoading() < maxTotalLoading) {
                tileQueue.reprioritize(); // FIXME only call if view has changed
                tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
            }
        }
        if (frameState && this.renderer_ && !frameState.animate) {
            if (this.renderComplete_ === true) {
                if (this.hasListener((0, _eventTypeJsDefault2.default).RENDERCOMPLETE)) this.renderer_.dispatchRenderEvent((0, _eventTypeJsDefault2.default).RENDERCOMPLETE, frameState);
                if (this.loaded_ === false) {
                    this.loaded_ = true;
                    this.dispatchEvent(new (0, _mapEventJsDefault.default)((0, _mapEventTypeJsDefault.default).LOADEND, this, frameState));
                }
            } else if (this.loaded_ === true) {
                this.loaded_ = false;
                this.dispatchEvent(new (0, _mapEventJsDefault.default)((0, _mapEventTypeJsDefault.default).LOADSTART, this, frameState));
            }
        }
        const postRenderFunctions = this.postRenderFunctions_;
        for(let i = 0, ii = postRenderFunctions.length; i < ii; ++i)postRenderFunctions[i](this, frameState);
        postRenderFunctions.length = 0;
    }
    /**
   * @private
   */ handleSizeChanged_() {
        if (this.getView() && !this.getView().getAnimating()) this.getView().resolveConstraints(0);
        this.render();
    }
    /**
   * @private
   */ handleTargetChanged_() {
        if (this.mapBrowserEventHandler_) {
            for(let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i)(0, _eventsJs.unlistenByKey)(this.targetChangeHandlerKeys_[i]);
            this.targetChangeHandlerKeys_ = null;
            this.viewport_.removeEventListener((0, _eventTypeJsDefault.default).CONTEXTMENU, this.boundHandleBrowserEvent_);
            this.viewport_.removeEventListener((0, _eventTypeJsDefault.default).WHEEL, this.boundHandleBrowserEvent_);
            this.mapBrowserEventHandler_.dispose();
            this.mapBrowserEventHandler_ = null;
            (0, _domJs.removeNode)(this.viewport_);
        }
        if (this.targetElement_) {
            this.resizeObserver_.unobserve(this.targetElement_);
            const rootNode = this.targetElement_.getRootNode();
            if (rootNode instanceof ShadowRoot) this.resizeObserver_.unobserve(rootNode.host);
            this.setSize(undefined);
        }
        // target may be undefined, null, a string or an Element.
        // If it's a string we convert it to an Element before proceeding.
        // If it's not now an Element we remove the viewport from the DOM.
        // If it's an Element we append the viewport element to it.
        const target = this.getTarget();
        const targetElement = typeof target === 'string' ? document.getElementById(target) : target;
        this.targetElement_ = targetElement;
        if (!targetElement) {
            if (this.renderer_) {
                clearTimeout(this.postRenderTimeoutHandle_);
                this.postRenderTimeoutHandle_ = undefined;
                this.postRenderFunctions_.length = 0;
                this.renderer_.dispose();
                this.renderer_ = null;
            }
            if (this.animationDelayKey_) {
                cancelAnimationFrame(this.animationDelayKey_);
                this.animationDelayKey_ = undefined;
            }
        } else {
            targetElement.appendChild(this.viewport_);
            if (!this.renderer_) this.renderer_ = new (0, _compositeJsDefault.default)(this);
            this.mapBrowserEventHandler_ = new (0, _mapBrowserEventHandlerJsDefault.default)(this, this.moveTolerance_);
            for(const key in 0, _mapBrowserEventTypeJsDefault.default)this.mapBrowserEventHandler_.addEventListener((0, _mapBrowserEventTypeJsDefault.default)[key], this.handleMapBrowserEvent.bind(this));
            this.viewport_.addEventListener((0, _eventTypeJsDefault.default).CONTEXTMENU, this.boundHandleBrowserEvent_, false);
            this.viewport_.addEventListener((0, _eventTypeJsDefault.default).WHEEL, this.boundHandleBrowserEvent_, (0, _hasJs.PASSIVE_EVENT_LISTENERS) ? {
                passive: false
            } : false);
            const keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
            this.targetChangeHandlerKeys_ = [
                (0, _eventsJs.listen)(keyboardEventTarget, (0, _eventTypeJsDefault.default).KEYDOWN, this.handleBrowserEvent, this),
                (0, _eventsJs.listen)(keyboardEventTarget, (0, _eventTypeJsDefault.default).KEYPRESS, this.handleBrowserEvent, this)
            ];
            const rootNode = targetElement.getRootNode();
            if (rootNode instanceof ShadowRoot) this.resizeObserver_.observe(rootNode.host);
            this.resizeObserver_.observe(targetElement);
        }
        this.updateSize();
    // updateSize calls setSize, so no need to call this.render
    // ourselves here.
    }
    /**
   * @private
   */ handleTileChange_() {
        this.render();
    }
    /**
   * @private
   */ handleViewPropertyChanged_() {
        this.render();
    }
    /**
   * @private
   */ handleViewChanged_() {
        if (this.viewPropertyListenerKey_) {
            (0, _eventsJs.unlistenByKey)(this.viewPropertyListenerKey_);
            this.viewPropertyListenerKey_ = null;
        }
        if (this.viewChangeListenerKey_) {
            (0, _eventsJs.unlistenByKey)(this.viewChangeListenerKey_);
            this.viewChangeListenerKey_ = null;
        }
        const view = this.getView();
        if (view) {
            this.updateViewportSize_(this.getSize());
            this.viewPropertyListenerKey_ = (0, _eventsJs.listen)(view, (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
            this.viewChangeListenerKey_ = (0, _eventsJs.listen)(view, (0, _eventTypeJsDefault.default).CHANGE, this.handleViewPropertyChanged_, this);
            view.resolveConstraints(0);
        }
        this.render();
    }
    /**
   * @private
   */ handleLayerGroupChanged_() {
        if (this.layerGroupPropertyListenerKeys_) {
            this.layerGroupPropertyListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
            this.layerGroupPropertyListenerKeys_ = null;
        }
        const layerGroup = this.getLayerGroup();
        if (layerGroup) {
            this.handleLayerAdd_(new (0, _groupJs.GroupEvent)('addlayer', layerGroup));
            this.layerGroupPropertyListenerKeys_ = [
                (0, _eventsJs.listen)(layerGroup, (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, this.render, this),
                (0, _eventsJs.listen)(layerGroup, (0, _eventTypeJsDefault.default).CHANGE, this.render, this),
                (0, _eventsJs.listen)(layerGroup, 'addlayer', this.handleLayerAdd_, this),
                (0, _eventsJs.listen)(layerGroup, 'removelayer', this.handleLayerRemove_, this)
            ];
        }
        this.render();
    }
    /**
   * @return {boolean} Is rendered.
   */ isRendered() {
        return !!this.frameState_;
    }
    /**
   * @private
   */ animationDelay_() {
        this.animationDelayKey_ = undefined;
        this.renderFrame_(Date.now());
    }
    /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */ renderSync() {
        if (this.animationDelayKey_) cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelay_();
    }
    /**
   * Redraws all text after new fonts have loaded
   */ redrawText() {
        const layerStates = this.getLayerGroup().getLayerStatesArray();
        for(let i = 0, ii = layerStates.length; i < ii; ++i){
            const layer = layerStates[i].layer;
            if (layer.hasRenderer()) layer.getRenderer().handleFontsChanged();
        }
    }
    /**
   * Request a map rendering (at the next animation frame).
   * @api
   */ render() {
        if (this.renderer_ && this.animationDelayKey_ === undefined) this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
    /**
   * This method is meant to be called in a layer's `prerender` listener. It causes all collected
   * declutter items to be decluttered and rendered on the map immediately. This is useful for
   * layers that need to appear entirely above the decluttered items of layers lower in the layer
   * stack.
   * @api
   */ flushDeclutterItems() {
        const frameState = this.frameState_;
        if (!frameState) return;
        this.renderer_.flushDeclutterItems(frameState);
    }
    /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */ removeControl(control) {
        return this.getControls().remove(control);
    }
    /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */ removeInteraction(interaction) {
        return this.getInteractions().remove(interaction);
    }
    /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */ removeLayer(layer) {
        const layers = this.getLayerGroup().getLayers();
        return layers.remove(layer);
    }
    /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */ handleLayerRemove_(event) {
        removeLayerMapProperty(event.layer);
    }
    /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */ removeOverlay(overlay) {
        return this.getOverlays().remove(overlay);
    }
    /**
   * @param {number} time Time.
   * @private
   */ renderFrame_(time) {
        const size = this.getSize();
        const view = this.getView();
        const previousFrameState = this.frameState_;
        /** @type {?FrameState} */ let frameState = null;
        if (size !== undefined && (0, _sizeJs.hasArea)(size) && view && view.isDef()) {
            const viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
            const viewState = view.getState();
            frameState = {
                animate: false,
                coordinateToPixelTransform: this.coordinateToPixelTransform_,
                declutterTree: null,
                extent: (0, _extentJs.getForViewAndSize)(viewState.center, viewState.resolution, viewState.rotation, size),
                index: this.frameIndex_++,
                layerIndex: 0,
                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                pixelRatio: this.pixelRatio_,
                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                postRenderFunctions: [],
                size: size,
                tileQueue: this.tileQueue_,
                time: time,
                usedTiles: {},
                viewState: viewState,
                viewHints: viewHints,
                wantedTiles: {},
                mapId: (0, _utilJs.getUid)(this),
                renderTargets: {}
            };
            if (viewState.nextCenter && viewState.nextResolution) {
                const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
                frameState.nextExtent = (0, _extentJs.getForViewAndSize)(viewState.nextCenter, viewState.nextResolution, rotation, size);
            }
        }
        this.frameState_ = frameState;
        this.renderer_.renderFrame(frameState);
        if (frameState) {
            if (frameState.animate) this.render();
            Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
            if (previousFrameState) {
                const moveStart = !this.previousExtent_ || !(0, _extentJs.isEmpty)(this.previousExtent_) && !(0, _extentJs.equals)(frameState.extent, this.previousExtent_);
                if (moveStart) {
                    this.dispatchEvent(new (0, _mapEventJsDefault.default)((0, _mapEventTypeJsDefault.default).MOVESTART, this, previousFrameState));
                    this.previousExtent_ = (0, _extentJs.createOrUpdateEmpty)(this.previousExtent_);
                }
            }
            const idle = this.previousExtent_ && !frameState.viewHints[(0, _viewHintJsDefault.default).ANIMATING] && !frameState.viewHints[(0, _viewHintJsDefault.default).INTERACTING] && !(0, _extentJs.equals)(frameState.extent, this.previousExtent_);
            if (idle) {
                this.dispatchEvent(new (0, _mapEventJsDefault.default)((0, _mapEventTypeJsDefault.default).MOVEEND, this, frameState));
                (0, _extentJs.clone)(frameState.extent, this.previousExtent_);
            }
        }
        this.dispatchEvent(new (0, _mapEventJsDefault.default)((0, _mapEventTypeJsDefault.default).POSTRENDER, this, frameState));
        this.renderComplete_ = this.hasListener((0, _mapEventTypeJsDefault.default).LOADSTART) || this.hasListener((0, _mapEventTypeJsDefault.default).LOADEND) || this.hasListener((0, _eventTypeJsDefault2.default).RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : undefined;
        if (!this.postRenderTimeoutHandle_) this.postRenderTimeoutHandle_ = setTimeout(()=>{
            this.postRenderTimeoutHandle_ = undefined;
            this.handlePostRender();
        }, 0);
    }
    /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */ setLayerGroup(layerGroup) {
        const oldLayerGroup = this.getLayerGroup();
        if (oldLayerGroup) this.handleLayerRemove_(new (0, _groupJs.GroupEvent)('removelayer', oldLayerGroup));
        this.set((0, _mapPropertyJsDefault.default).LAYERGROUP, layerGroup);
    }
    /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */ setSize(size) {
        this.set((0, _mapPropertyJsDefault.default).SIZE, size);
    }
    /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */ setTarget(target) {
        this.set((0, _mapPropertyJsDefault.default).TARGET, target);
    }
    /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */ setView(view) {
        if (!view || view instanceof (0, _viewJsDefault.default)) {
            this.set((0, _mapPropertyJsDefault.default).VIEW, view);
            return;
        }
        this.set((0, _mapPropertyJsDefault.default).VIEW, new (0, _viewJsDefault.default)());
        const map = this;
        view.then(function(viewOptions) {
            map.setView(new (0, _viewJsDefault.default)(viewOptions));
        });
    }
    /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */ updateSize() {
        const targetElement = this.getTargetElement();
        let size = undefined;
        if (targetElement) {
            const computedStyle = getComputedStyle(targetElement);
            const width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);
            const height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);
            if (!isNaN(width) && !isNaN(height)) {
                size = [
                    width,
                    height
                ];
                if (!(0, _sizeJs.hasArea)(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) (0, _consoleJs.warn)("No map visible because the map container's width or height are 0.");
            }
        }
        const oldSize = this.getSize();
        if (size && (!oldSize || !(0, _arrayJs.equals)(size, oldSize))) {
            this.setSize(size);
            this.updateViewportSize_(size);
        }
    }
    /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */ updateViewportSize_(size) {
        const view = this.getView();
        if (view) view.setViewportSize(size);
    }
}
/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */ function createOptionsInternal(options) {
    /**
   * @type {HTMLElement|Document}
   */ let keyboardEventTarget = null;
    if (options.keyboardEventTarget !== undefined) keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
    /**
   * @type {Object<string, *>}
   */ const values = {};
    const layerGroup = options.layers && typeof /** @type {?} */ options.layers.getLayers === 'function' ? /** @type {LayerGroup} */ options.layers : new (0, _groupJsDefault.default)({
        layers: /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */ options.layers
    });
    values[(0, _mapPropertyJsDefault.default).LAYERGROUP] = layerGroup;
    values[(0, _mapPropertyJsDefault.default).TARGET] = options.target;
    values[(0, _mapPropertyJsDefault.default).VIEW] = options.view instanceof (0, _viewJsDefault.default) ? options.view : new (0, _viewJsDefault.default)();
    /** @type {Collection<import("./control/Control.js").default>} */ let controls;
    if (options.controls !== undefined) {
        if (Array.isArray(options.controls)) controls = new (0, _collectionJsDefault.default)(options.controls.slice());
        else {
            (0, _assertsJs.assert)(typeof /** @type {?} */ options.controls.getArray === 'function', 'Expected `controls` to be an array or an `ol/Collection.js`');
            controls = options.controls;
        }
    }
    /** @type {Collection<import("./interaction/Interaction").default>} */ let interactions;
    if (options.interactions !== undefined) {
        if (Array.isArray(options.interactions)) interactions = new (0, _collectionJsDefault.default)(options.interactions.slice());
        else {
            (0, _assertsJs.assert)(typeof /** @type {?} */ options.interactions.getArray === 'function', 'Expected `interactions` to be an array or an `ol/Collection.js`');
            interactions = options.interactions;
        }
    }
    /** @type {Collection<import("./Overlay.js").default>} */ let overlays;
    if (options.overlays !== undefined) {
        if (Array.isArray(options.overlays)) overlays = new (0, _collectionJsDefault.default)(options.overlays.slice());
        else {
            (0, _assertsJs.assert)(typeof /** @type {?} */ options.overlays.getArray === 'function', 'Expected `overlays` to be an array or an `ol/Collection.js`');
            overlays = options.overlays;
        }
    } else overlays = new (0, _collectionJsDefault.default)();
    return {
        controls: controls,
        interactions: interactions,
        keyboardEventTarget: keyboardEventTarget,
        overlays: overlays,
        values: values
    };
}
exports.default = Map;

},{"./Object.js":"N6yIf","./Collection.js":"hzcJw","./CollectionEventType.js":"auN7R","./renderer/Composite.js":"cmuwk","./events/EventType.js":"3uT2C","./layer/Layer.js":"ixGac","./layer/Group.js":"aXuQD","./MapBrowserEvent.js":"9dn5c","./MapBrowserEventHandler.js":"eIMRV","./MapBrowserEventType.js":"2Xhyu","./MapEvent.js":"f5jvU","./MapEventType.js":"lytOT","./MapProperty.js":"k5jat","./ObjectEventType.js":"cu9ir","./pointer/EventType.js":"d5kzv","./render/EventType.js":"1ajEk","./TileQueue.js":"390Pw","./View.js":"fJPFQ","./ViewHint.js":"9EJlo","./has.js":"i07p3","./functions.js":"1QSsQ","./transform.js":"9LrRk","./asserts.js":"k0OL6","./extent.js":"bGUel","./control/defaults.js":"d6ZU0","./interaction/defaults.js":"fwCpz","./array.js":"hyet5","./proj.js":"8OK47","./util.js":"l1iPW","./size.js":"fXEON","./events.js":"lh4km","./dom.js":"h98kD","./console.js":"2VK4U","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"N6yIf":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Object
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */ parcelHelpers.export(exports, "ObjectEvent", ()=>ObjectEvent);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _objectEventTypeJs = require("./ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _observableJs = require("./Observable.js");
var _observableJsDefault = parcelHelpers.interopDefault(_observableJs);
var _utilJs = require("./util.js");
var _objJs = require("./obj.js");
class ObjectEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */ constructor(type, key, oldValue){
        super(type);
        /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */ this.key = key;
        /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */ this.oldValue = oldValue;
    }
}
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */ class BaseObject extends (0, _observableJsDefault.default) {
    /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */ constructor(values){
        super();
        /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {ObjectOnSignature<void>}
     */ this.un;
        // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
        // the same as the order in which they were created.  This also helps to
        // ensure that object properties are always added in the same order, which
        // helps many JavaScript engines generate faster code.
        (0, _utilJs.getUid)(this);
        /**
     * @private
     * @type {Object<string, *>|null}
     */ this.values_ = null;
        if (values !== undefined) this.setProperties(values);
    }
    /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */ get(key) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key)) value = this.values_[key];
        return value;
    }
    /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */ getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
    }
    /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */ getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
    }
    /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */ getPropertiesInternal() {
        return this.values_;
    }
    /**
   * @return {boolean} The object has properties.
   */ hasProperties() {
        return !!this.values_;
    }
    /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */ notify(key, oldValue) {
        let eventType;
        eventType = `change:${key}`;
        if (this.hasListener(eventType)) this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        eventType = (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE;
        if (this.hasListener(eventType)) this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */ addChangeListener(key, listener) {
        this.addEventListener(`change:${key}`, listener);
    }
    /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */ removeChangeListener(key, listener) {
        this.removeEventListener(`change:${key}`, listener);
    }
    /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */ set(key, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) values[key] = value;
        else {
            const oldValue = values[key];
            values[key] = value;
            if (oldValue !== value) this.notify(key, oldValue);
        }
    }
    /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */ setProperties(values, silent) {
        for(const key in values)this.set(key, values[key], silent);
    }
    /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */ applyProperties(source) {
        if (!source.values_) return;
        Object.assign(this.values_ || (this.values_ = {}), source.values_);
    }
    /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */ unset(key, silent) {
        if (this.values_ && key in this.values_) {
            const oldValue = this.values_[key];
            delete this.values_[key];
            if ((0, _objJs.isEmpty)(this.values_)) this.values_ = null;
            if (!silent) this.notify(key, oldValue);
        }
    }
}
exports.default = BaseObject;

},{"./events/Event.js":"kooRA","./ObjectEventType.js":"cu9ir","./Observable.js":"eKbGA","./util.js":"l1iPW","./obj.js":"7RZD4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kooRA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/Event
 */ /**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Event|import("./Event.js").default} evt Event
 */ parcelHelpers.export(exports, "stopPropagation", ()=>stopPropagation);
/**
 * @param {Event|import("./Event.js").default} evt Event
 */ parcelHelpers.export(exports, "preventDefault", ()=>preventDefault);
class BaseEvent {
    /**
   * @param {string} type Type.
   */ constructor(type){
        /**
     * @type {boolean}
     */ this.propagationStopped;
        /**
     * @type {boolean}
     */ this.defaultPrevented;
        /**
     * The event type.
     * @type {string}
     * @api
     */ this.type = type;
        /**
     * The event target.
     * @type {Object}
     * @api
     */ this.target = null;
    }
    /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */ preventDefault() {
        this.defaultPrevented = true;
    }
    /**
   * Stop event propagation.
   * @api
   */ stopPropagation() {
        this.propagationStopped = true;
    }
}
function stopPropagation(evt) {
    evt.stopPropagation();
}
function preventDefault(evt) {
    evt.preventDefault();
}
exports.default = BaseEvent;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jnFvT":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"cu9ir":[function(require,module,exports,__globalThis) {
/**
 * @module ol/ObjectEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */ PROPERTYCHANGE: 'propertychange'
}; /**
 * @typedef {'propertychange'} Types
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eKbGA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Observable
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */ parcelHelpers.export(exports, "unByKey", ()=>unByKey);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _eventsJs = require("./events.js");
/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */ /***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */ /**
 * @typedef {'change'|'error'} EventTypes
 */ /***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */ class Observable extends (0, _targetJsDefault.default) {
    constructor(){
        super();
        this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */ this.onInternal;
        this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */ this.onceInternal;
        this.un = /** @type {ObservableOnSignature<void>} */ this.unInternal;
        /**
     * @private
     * @type {number}
     */ this.revision_ = 0;
    }
    /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */ changed() {
        ++this.revision_;
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */ getRevision() {
        return this.revision_;
    }
    /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */ onInternal(type, listener) {
        if (Array.isArray(type)) {
            const len = type.length;
            const keys = new Array(len);
            for(let i = 0; i < len; ++i)keys[i] = (0, _eventsJs.listen)(this, type[i], listener);
            return keys;
        }
        return (0, _eventsJs.listen)(this, /** @type {string} */ type, listener);
    }
    /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */ onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
            const len = type.length;
            key = new Array(len);
            for(let i = 0; i < len; ++i)key[i] = (0, _eventsJs.listenOnce)(this, type[i], listener);
        } else key = (0, _eventsJs.listenOnce)(this, /** @type {string} */ type, listener);
        /** @type {Object} */ listener.ol_key = key;
        return key;
    }
    /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */ unInternal(type, listener) {
        const key = /** @type {Object} */ listener.ol_key;
        if (key) unByKey(key);
        else if (Array.isArray(type)) for(let i = 0, ii = type.length; i < ii; ++i)this.removeEventListener(type[i], listener);
        else this.removeEventListener(type, listener);
    }
}
/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */ Observable.prototype.on;
/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */ Observable.prototype.once;
/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */ Observable.prototype.un;
function unByKey(key) {
    if (Array.isArray(key)) for(let i = 0, ii = key.length; i < ii; ++i)(0, _eventsJs.unlistenByKey)(key[i]);
    else (0, _eventsJs.unlistenByKey)(/** @type {import("./events.js").EventsKey} */ key);
}
exports.default = Observable;

},{"./events/Target.js":"dZel6","./events/EventType.js":"3uT2C","./events.js":"lh4km","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dZel6":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/Target
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _eventJs = require("./Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _functionsJs = require("../functions.js");
var _objJs = require("../obj.js");
/**
 * @typedef {EventTarget|Target} EventTargetLike
 */ /**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */ class Target extends (0, _disposableJsDefault.default) {
    /**
   * @param {*} [target] Default event target for dispatched events.
   */ constructor(target){
        super();
        /**
     * @private
     * @type {*}
     */ this.eventTarget_ = target;
        /**
     * @private
     * @type {Object<string, number>|null}
     */ this.pendingRemovals_ = null;
        /**
     * @private
     * @type {Object<string, number>|null}
     */ this.dispatching_ = null;
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>|null}
     */ this.listeners_ = null;
    }
    /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */ addEventListener(type, listener) {
        if (!type || !listener) return;
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) listenersForType.push(listener);
    }
    /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */ dispatchEvent(event) {
        const isString = typeof event === 'string';
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) return;
        const evt = isString ? new (0, _eventJsDefault.default)(event) : /** @type {Event} */ event;
        if (!evt.target) evt.target = this.eventTarget_ || this;
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
            dispatching[type] = 0;
            pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for(let i = 0, ii = listeners.length; i < ii; ++i){
            if ('handleEvent' in listeners[i]) propagate = /** @type {import("../events.js").ListenerObject} */ listeners[i].handleEvent(evt);
            else propagate = /** @type {import("../events.js").ListenerFunction} */ listeners[i].call(this, evt);
            if (propagate === false || evt.propagationStopped) {
                propagate = false;
                break;
            }
        }
        if (--dispatching[type] === 0) {
            let pr = pendingRemovals[type];
            delete pendingRemovals[type];
            while(pr--)this.removeEventListener(type, (0, _functionsJs.VOID));
            delete dispatching[type];
        }
        return propagate;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        this.listeners_ && (0, _objJs.clear)(this.listeners_);
    }
    /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */ getListeners(type) {
        return this.listeners_ && this.listeners_[type] || undefined;
    }
    /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */ hasListener(type) {
        if (!this.listeners_) return false;
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
    }
    /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */ removeEventListener(type, listener) {
        if (!this.listeners_) return;
        const listeners = this.listeners_[type];
        if (!listeners) return;
        const index = listeners.indexOf(listener);
        if (index !== -1) {
            if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                // make listener a no-op, and remove later in #dispatchEvent()
                listeners[index] = (0, _functionsJs.VOID);
                ++this.pendingRemovals_[type];
            } else {
                listeners.splice(index, 1);
                if (listeners.length === 0) delete this.listeners_[type];
            }
        }
    }
}
exports.default = Target;

},{"../Disposable.js":"7pfJR","./Event.js":"kooRA","../functions.js":"1QSsQ","../obj.js":"7RZD4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7pfJR":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Disposable
 */ /**
 * @classdesc
 * Objects that need to clean up after themselves.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Disposable {
    constructor(){
        /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */ this.disposed = false;
    }
    /**
   * Clean up.
   */ dispose() {
        if (!this.disposed) {
            this.disposed = true;
            this.disposeInternal();
        }
    }
    /**
   * Extension point for disposable objects.
   * @protected
   */ disposeInternal() {}
}
exports.default = Disposable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1QSsQ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/functions
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Always returns true.
 * @return {boolean} true.
 */ parcelHelpers.export(exports, "TRUE", ()=>TRUE);
/**
 * Always returns false.
 * @return {boolean} false.
 */ parcelHelpers.export(exports, "FALSE", ()=>FALSE);
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */ parcelHelpers.export(exports, "VOID", ()=>VOID);
/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */ parcelHelpers.export(exports, "memoizeOne", ()=>memoizeOne);
/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */ parcelHelpers.export(exports, "toPromise", ()=>toPromise);
var _arrayJs = require("./array.js");
function TRUE() {
    return true;
}
function FALSE() {
    return false;
}
function VOID() {}
function memoizeOne(fn) {
    let called = false;
    /** @type {ReturnType} */ let lastResult;
    /** @type {Array<any>} */ let lastArgs;
    let lastThis;
    return function() {
        const nextArgs = Array.prototype.slice.call(arguments);
        if (!called || this !== lastThis || !(0, _arrayJs.equals)(nextArgs, lastArgs)) {
            called = true;
            lastThis = this;
            lastArgs = nextArgs;
            lastResult = fn.apply(this, arguments);
        }
        return lastResult;
    };
}
function toPromise(getter) {
    function promiseGetter() {
        let value;
        try {
            value = getter();
        } catch (err) {
            return Promise.reject(err);
        }
        if (value instanceof Promise) return value;
        return Promise.resolve(value);
    }
    return promiseGetter();
}

},{"./array.js":"hyet5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hyet5":[function(require,module,exports,__globalThis) {
/**
 * @module ol/array
 */ /**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "binarySearch", ()=>binarySearch);
/**
 * Compare function sorting arrays in ascending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */ parcelHelpers.export(exports, "ascending", ()=>ascending);
/**
 * Compare function sorting arrays in descending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is greater than, equal to, or less than the second.
 */ parcelHelpers.export(exports, "descending", ()=>descending);
/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */ /**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */ parcelHelpers.export(exports, "linearFindNearest", ()=>linearFindNearest);
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */ parcelHelpers.export(exports, "reverseSubArray", ()=>reverseSubArray);
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */ parcelHelpers.export(exports, "extend", ()=>extend);
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */ parcelHelpers.export(exports, "remove", ()=>remove);
/**
 * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */ parcelHelpers.export(exports, "equals", ()=>equals);
/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */ parcelHelpers.export(exports, "stableSort", ()=>stableSort);
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [func] Comparison function.
 * @param {boolean} [strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */ parcelHelpers.export(exports, "isSorted", ()=>isSorted);
function binarySearch(haystack, needle, comparator) {
    let mid, cmp;
    comparator = comparator || ascending;
    let low = 0;
    let high = haystack.length;
    let found = false;
    while(low < high){
        /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */ mid = low + (high - low >> 1);
        cmp = +comparator(haystack[mid], needle);
        if (cmp < 0.0) /* Too low. */ low = mid + 1;
        else {
            /* Key found or too high */ high = mid;
            found = !cmp;
        }
    }
    /* Key not found. */ return found ? low : ~low;
}
function ascending(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
}
function descending(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
    if (arr[0] <= target) return 0;
    const n = arr.length;
    if (target <= arr[n - 1]) return n - 1;
    if (typeof direction === 'function') {
        for(let i = 1; i < n; ++i){
            const candidate = arr[i];
            if (candidate === target) return i;
            if (candidate < target) {
                if (direction(target, arr[i - 1], candidate) > 0) return i - 1;
                return i;
            }
        }
        return n - 1;
    }
    if (direction > 0) {
        for(let i = 1; i < n; ++i){
            if (arr[i] < target) return i - 1;
        }
        return n - 1;
    }
    if (direction < 0) {
        for(let i = 1; i < n; ++i){
            if (arr[i] <= target) return i;
        }
        return n - 1;
    }
    for(let i = 1; i < n; ++i){
        if (arr[i] == target) return i;
        if (arr[i] < target) {
            if (arr[i - 1] - target < target - arr[i]) return i - 1;
            return i;
        }
    }
    return n - 1;
}
function reverseSubArray(arr, begin, end) {
    while(begin < end){
        const tmp = arr[begin];
        arr[begin] = arr[end];
        arr[end] = tmp;
        ++begin;
        --end;
    }
}
function extend(arr, data) {
    const extension = Array.isArray(data) ? data : [
        data
    ];
    const length = extension.length;
    for(let i = 0; i < length; i++)arr[arr.length] = extension[i];
}
function remove(arr, obj) {
    const i = arr.indexOf(obj);
    const found = i > -1;
    if (found) arr.splice(i, 1);
    return found;
}
function equals(arr1, arr2) {
    const len1 = arr1.length;
    if (len1 !== arr2.length) return false;
    for(let i = 0; i < len1; i++){
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}
function stableSort(arr, compareFnc) {
    const length = arr.length;
    const tmp = Array(arr.length);
    let i;
    for(i = 0; i < length; i++)tmp[i] = {
        index: i,
        value: arr[i]
    };
    tmp.sort(function(a, b) {
        return compareFnc(a.value, b.value) || a.index - b.index;
    });
    for(i = 0; i < arr.length; i++)arr[i] = tmp[i].value;
}
function isSorted(arr, func, strict) {
    const compare = func || ascending;
    return arr.every(function(currentVal, index) {
        if (index === 0) return true;
        const res = compare(arr[index - 1], currentVal);
        return !(res > 0 || strict && res === 0);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7RZD4":[function(require,module,exports,__globalThis) {
/**
 * @module ol/obj
 */ /**
 * Removes all properties from an object.
 * @param {Object<string, unknown>} object The object to clear.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clear", ()=>clear);
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */ parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
function clear(object) {
    for(const property in object)delete object[property];
}
function isEmpty(object) {
    let property;
    for(property in object)return false;
    return !property;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3uT2C":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/EventType
 */ /**
 * @enum {string}
 * @const
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */ CHANGE: 'change',
    /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */ ERROR: 'error',
    BLUR: 'blur',
    CLEAR: 'clear',
    CONTEXTMENU: 'contextmenu',
    CLICK: 'click',
    DBLCLICK: 'dblclick',
    DRAGENTER: 'dragenter',
    DRAGOVER: 'dragover',
    DROP: 'drop',
    FOCUS: 'focus',
    KEYDOWN: 'keydown',
    KEYPRESS: 'keypress',
    LOAD: 'load',
    RESIZE: 'resize',
    TOUCHMOVE: 'touchmove',
    WHEEL: 'wheel'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lh4km":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Key to use with {@link module:ol/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */ /**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */ /**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */ /**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */ /**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */ parcelHelpers.export(exports, "listen", ()=>listen);
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */ parcelHelpers.export(exports, "listenOnce", ()=>listenOnce);
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */ parcelHelpers.export(exports, "unlistenByKey", ()=>unlistenByKey);
var _objJs = require("./obj.js");
function listen(target, type, listener, thisArg, once) {
    if (thisArg && thisArg !== target) listener = listener.bind(thisArg);
    if (once) {
        const originalListener = listener;
        listener = function() {
            target.removeEventListener(type, listener);
            originalListener.apply(this, arguments);
        };
    }
    const eventsKey = {
        target: target,
        type: type,
        listener: listener
    };
    target.addEventListener(type, listener);
    return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
    return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
    if (key && key.target) {
        key.target.removeEventListener(key.type, key.listener);
        (0, _objJs.clear)(key);
    }
}

},{"./obj.js":"7RZD4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l1iPW":[function(require,module,exports,__globalThis) {
/**
 * @module ol/util
 */ /**
 * @return {never} Any return.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "abstract", ()=>abstract);
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */ parcelHelpers.export(exports, "getUid", ()=>getUid);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
function abstract() {
    throw new Error('Unimplemented abstract method.');
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */ let uidCounter_ = 0;
function getUid(obj) {
    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
const VERSION = '8.2.0';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hzcJw":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Collection
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 * @template T
 */ parcelHelpers.export(exports, "CollectionEvent", ()=>CollectionEvent);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _collectionEventTypeJs = require("./CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
/**
 * @enum {string}
 * @private
 */ const Property = {
    LENGTH: 'length'
};
class CollectionEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */ constructor(type, element, index){
        super(type);
        /**
     * The element that is added to or removed from the collection.
     * @type {T}
     * @api
     */ this.element = element;
        /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */ this.index = index;
    }
}
/***
 * @template T
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */ /**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */ class Collection extends (0, _objectJsDefault.default) {
    /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */ constructor(array, options){
        super();
        /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {CollectionOnSignature<T, void>}
     */ this.un;
        options = options || {};
        /**
     * @private
     * @type {boolean}
     */ this.unique_ = !!options.unique;
        /**
     * @private
     * @type {!Array<T>}
     */ this.array_ = array ? array : [];
        if (this.unique_) for(let i = 0, ii = this.array_.length; i < ii; ++i)this.assertUnique_(this.array_[i], i);
        this.updateLength_();
    }
    /**
   * Remove all elements from the collection.
   * @api
   */ clear() {
        while(this.getLength() > 0)this.pop();
    }
    /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */ extend(arr) {
        for(let i = 0, ii = arr.length; i < ii; ++i)this.push(arr[i]);
        return this;
    }
    /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */ forEach(f) {
        const array = this.array_;
        for(let i = 0, ii = array.length; i < ii; ++i)f(array[i], i, array);
    }
    /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */ getArray() {
        return this.array_;
    }
    /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */ item(index) {
        return this.array_[index];
    }
    /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */ getLength() {
        return this.get(Property.LENGTH);
    }
    /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */ insertAt(index, elem) {
        if (index < 0 || index > this.getLength()) throw new Error('Index out of bounds: ' + index);
        if (this.unique_) this.assertUnique_(elem);
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent((0, _collectionEventTypeJsDefault.default).ADD, elem, index));
    }
    /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */ pop() {
        return this.removeAt(this.getLength() - 1);
    }
    /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */ push(elem) {
        if (this.unique_) this.assertUnique_(elem);
        const n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
    }
    /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */ remove(elem) {
        const arr = this.array_;
        for(let i = 0, ii = arr.length; i < ii; ++i){
            if (arr[i] === elem) return this.removeAt(i);
        }
        return undefined;
    }
    /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */ removeAt(index) {
        if (index < 0 || index >= this.getLength()) return undefined;
        const prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(/** @type {CollectionEvent<T>} */ new CollectionEvent((0, _collectionEventTypeJsDefault.default).REMOVE, prev, index));
        return prev;
    }
    /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */ setAt(index, elem) {
        const n = this.getLength();
        if (index >= n) {
            this.insertAt(index, elem);
            return;
        }
        if (index < 0) throw new Error('Index out of bounds: ' + index);
        if (this.unique_) this.assertUnique_(elem, index);
        const prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(/** @type {CollectionEvent<T>} */ new CollectionEvent((0, _collectionEventTypeJsDefault.default).REMOVE, prev, index));
        this.dispatchEvent(/** @type {CollectionEvent<T>} */ new CollectionEvent((0, _collectionEventTypeJsDefault.default).ADD, elem, index));
    }
    /**
   * @private
   */ updateLength_() {
        this.set(Property.LENGTH, this.array_.length);
    }
    /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */ assertUnique_(elem, except) {
        for(let i = 0, ii = this.array_.length; i < ii; ++i){
            if (this.array_[i] === elem && i !== except) throw new Error('Duplicate item added to a unique collection');
        }
    }
}
exports.default = Collection;

},{"./Object.js":"N6yIf","./CollectionEventType.js":"auN7R","./events/Event.js":"kooRA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"auN7R":[function(require,module,exports,__globalThis) {
/**
 * @module ol/CollectionEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */ ADD: 'add',
    /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */ REMOVE: 'remove'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cmuwk":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/Composite
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapJs = require("./Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _eventJs = require("../render/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _canvasJs = require("../render/canvas.js");
var _layerJs = require("../layer/Layer.js");
var _eventsJs = require("../events.js");
var _domJs = require("../dom.js");
/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */ class CompositeMapRenderer extends (0, _mapJsDefault.default) {
    /**
   * @param {import("../Map.js").default} map Map.
   */ constructor(map){
        super(map);
        /**
     * @type {import("../events.js").EventsKey}
     */ this.fontChangeListenerKey_ = (0, _eventsJs.listen)((0, _canvasJs.checkedFonts), (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, map.redrawText.bind(map));
        /**
     * @private
     * @type {HTMLDivElement}
     */ this.element_ = document.createElement('div');
        const style = this.element_.style;
        style.position = 'absolute';
        style.width = '100%';
        style.height = '100%';
        style.zIndex = '0';
        this.element_.className = (0, _cssJs.CLASS_UNSELECTABLE) + ' ol-layers';
        const container = map.getViewport();
        container.insertBefore(this.element_, container.firstChild || null);
        /**
     * @private
     * @type {Array<HTMLElement>}
     */ this.children_ = [];
        /**
     * @private
     * @type {boolean}
     */ this.renderedVisible_ = true;
        /**
     * @type {Array<import("../layer/BaseVector.js").default>}
     */ this.declutterLayers_ = [];
    }
    /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ dispatchRenderEvent(type, frameState) {
        const map = this.getMap();
        if (map.hasListener(type)) {
            const event = new (0, _eventJsDefault.default)(type, undefined, frameState);
            map.dispatchEvent(event);
        }
    }
    disposeInternal() {
        (0, _eventsJs.unlistenByKey)(this.fontChangeListenerKey_);
        this.element_.parentNode.removeChild(this.element_);
        super.disposeInternal();
    }
    /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */ renderFrame(frameState) {
        if (!frameState) {
            if (this.renderedVisible_) {
                this.element_.style.display = 'none';
                this.renderedVisible_ = false;
            }
            return;
        }
        this.calculateMatrices2D(frameState);
        this.dispatchRenderEvent((0, _eventTypeJsDefault.default).PRECOMPOSE, frameState);
        const layerStatesArray = frameState.layerStatesArray.sort(function(a, b) {
            return a.zIndex - b.zIndex;
        });
        const viewState = frameState.viewState;
        this.children_.length = 0;
        const declutterLayers = this.declutterLayers_;
        declutterLayers.length = 0;
        let previousElement = null;
        for(let i = 0, ii = layerStatesArray.length; i < ii; ++i){
            const layerState = layerStatesArray[i];
            frameState.layerIndex = i;
            const layer = layerState.layer;
            const sourceState = layer.getSourceState();
            if (!(0, _layerJs.inView)(layerState, viewState) || sourceState != 'ready' && sourceState != 'undefined') {
                layer.unrender();
                continue;
            }
            const element = layer.render(frameState, previousElement);
            if (!element) continue;
            if (element !== previousElement) {
                this.children_.push(element);
                previousElement = element;
            }
            if ('getDeclutter' in layer) declutterLayers.push(/** @type {import("../layer/BaseVector.js").default} */ layer);
        }
        this.flushDeclutterItems(frameState);
        (0, _domJs.replaceChildren)(this.element_, this.children_);
        this.dispatchRenderEvent((0, _eventTypeJsDefault.default).POSTCOMPOSE, frameState);
        if (!this.renderedVisible_) {
            this.element_.style.display = '';
            this.renderedVisible_ = true;
        }
        this.scheduleExpireIconCache(frameState);
    }
    /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ flushDeclutterItems(frameState) {
        const layers = this.declutterLayers_;
        for(let i = layers.length - 1; i >= 0; --i)layers[i].renderDeclutter(frameState);
        layers.length = 0;
    }
}
exports.default = CompositeMapRenderer;

},{"./Map.js":"lT01G","../ObjectEventType.js":"cu9ir","../render/Event.js":"e6ARE","../render/EventType.js":"1ajEk","../css.js":"b247l","../render/canvas.js":"6S9WQ","../layer/Layer.js":"ixGac","../events.js":"lh4km","../dom.js":"h98kD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lT01G":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/Map
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _functionsJs = require("../functions.js");
var _utilJs = require("../util.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _iconImageCacheJs = require("../style/IconImageCache.js");
var _layerJs = require("../layer/Layer.js");
var _coordinateJs = require("../coordinate.js");
/**
 * @template T
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 */ /**
 * @abstract
 */ class MapRenderer extends (0, _disposableJsDefault.default) {
    /**
   * @param {import("../Map.js").default} map Map.
   */ constructor(map){
        super();
        /**
     * @private
     * @type {import("../Map.js").default}
     */ this.map_ = map;
    }
    /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ dispatchRenderEvent(type, frameState) {
        (0, _utilJs.abstract)();
    }
    /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */ calculateMatrices2D(frameState) {
        const viewState = frameState.viewState;
        const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
        const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
        (0, _transformJs.compose)(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
        (0, _transformJs.makeInverse)(pixelToCoordinateTransform, coordinateToPixelTransform);
    }
    /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
        let result;
        const viewState = frameState.viewState;
        /**
     * @param {boolean} managed Managed layer.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */ function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
            return callback.call(thisArg, feature, managed ? layer : null, geometry);
        }
        const projection = viewState.projection;
        const translatedCoordinate = (0, _coordinateJs.wrapX)(coordinate.slice(), projection);
        const offsets = [
            [
                0,
                0
            ]
        ];
        if (projection.canWrapX() && checkWrapped) {
            const projectionExtent = projection.getExtent();
            const worldWidth = (0, _extentJs.getWidth)(projectionExtent);
            offsets.push([
                -worldWidth,
                0
            ], [
                worldWidth,
                0
            ]);
        }
        const layerStates = frameState.layerStatesArray;
        const numLayers = layerStates.length;
        const matches = /** @type {Array<HitMatch<T>>} */ [];
        const tmpCoord = [];
        for(let i = 0; i < offsets.length; i++)for(let j = numLayers - 1; j >= 0; --j){
            const layerState = layerStates[j];
            const layer = layerState.layer;
            if (layer.hasRenderer() && (0, _layerJs.inView)(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
                const layerRenderer = layer.getRenderer();
                const source = layer.getSource();
                if (layerRenderer && source) {
                    const coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
                    const callback = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                    tmpCoord[0] = coordinates[0] + offsets[i][0];
                    tmpCoord[1] = coordinates[1] + offsets[i][1];
                    result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback, matches);
                }
                if (result) return result;
            }
        }
        if (matches.length === 0) return undefined;
        const order = 1 / matches.length;
        matches.forEach((m, i)=>m.distanceSq += i * order);
        matches.sort((a, b)=>a.distanceSq - b.distanceSq);
        matches.some((m)=>{
            return result = m.callback(m.feature, m.layer, m.geometry);
        });
        return result;
    }
    /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */ hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
        const hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, (0, _functionsJs.TRUE), this, layerFilter, thisArg);
        return hasFeature !== undefined;
    }
    /**
   * @return {import("../Map.js").default} Map.
   */ getMap() {
        return this.map_;
    }
    /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */ renderFrame(frameState) {
        (0, _utilJs.abstract)();
    }
    /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ flushDeclutterItems(frameState) {}
    /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */ scheduleExpireIconCache(frameState) {
        if ((0, _iconImageCacheJs.shared).canExpireCache()) frameState.postRenderFunctions.push(expireIconCache);
    }
}
/**
 * @param {import("../Map.js").default} map Map.
 * @param {import("../Map.js").FrameState} frameState Frame state.
 */ function expireIconCache(map, frameState) {
    (0, _iconImageCacheJs.shared).expire();
}
exports.default = MapRenderer;

},{"../Disposable.js":"7pfJR","../functions.js":"1QSsQ","../util.js":"l1iPW","../transform.js":"9LrRk","../extent.js":"bGUel","../style/IconImageCache.js":"aj9Mo","../layer/Layer.js":"ixGac","../coordinate.js":"fqHXJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9LrRk":[function(require,module,exports,__globalThis) {
/**
 * @module ol/transform
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */ parcelHelpers.export(exports, "create", ()=>create);
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */ parcelHelpers.export(exports, "reset", ()=>reset);
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */ parcelHelpers.export(exports, "multiply", ()=>multiply);
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */ parcelHelpers.export(exports, "set", ()=>set);
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */ parcelHelpers.export(exports, "setFromArray", ()=>setFromArray);
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */ parcelHelpers.export(exports, "apply", ()=>apply);
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */ parcelHelpers.export(exports, "makeScale", ()=>makeScale);
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */ parcelHelpers.export(exports, "translate", ()=>translate);
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */ parcelHelpers.export(exports, "compose", ()=>compose);
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */ parcelHelpers.export(exports, "composeCssTransform", ()=>composeCssTransform);
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */ parcelHelpers.export(exports, "invert", ()=>invert);
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */ parcelHelpers.export(exports, "makeInverse", ()=>makeInverse);
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */ parcelHelpers.export(exports, "determinant", ()=>determinant);
/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */ parcelHelpers.export(exports, "toString", ()=>toString);
var _hasJs = require("./has.js");
var _assertsJs = require("./asserts.js");
/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */ /**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */ /**
 * @private
 * @type {Transform}
 */ const tmp_ = new Array(6);
function create() {
    return [
        1,
        0,
        0,
        1,
        0,
        0
    ];
}
function reset(transform) {
    return set(transform, 1, 0, 0, 1, 0, 0);
}
function multiply(transform1, transform2) {
    const a1 = transform1[0];
    const b1 = transform1[1];
    const c1 = transform1[2];
    const d1 = transform1[3];
    const e1 = transform1[4];
    const f1 = transform1[5];
    const a2 = transform2[0];
    const b2 = transform2[1];
    const c2 = transform2[2];
    const d2 = transform2[3];
    const e2 = transform2[4];
    const f2 = transform2[5];
    transform1[0] = a1 * a2 + c1 * b2;
    transform1[1] = b1 * a2 + d1 * b2;
    transform1[2] = a1 * c2 + c1 * d2;
    transform1[3] = b1 * c2 + d1 * d2;
    transform1[4] = a1 * e2 + c1 * f2 + e1;
    transform1[5] = b1 * e2 + d1 * f2 + f1;
    return transform1;
}
function set(transform, a, b, c, d, e, f) {
    transform[0] = a;
    transform[1] = b;
    transform[2] = c;
    transform[3] = d;
    transform[4] = e;
    transform[5] = f;
    return transform;
}
function setFromArray(transform1, transform2) {
    transform1[0] = transform2[0];
    transform1[1] = transform2[1];
    transform1[2] = transform2[2];
    transform1[3] = transform2[3];
    transform1[4] = transform2[4];
    transform1[5] = transform2[5];
    return transform1;
}
function apply(transform, coordinate) {
    const x = coordinate[0];
    const y = coordinate[1];
    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
    return coordinate;
}
function rotate(transform, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
function scale(transform, x, y) {
    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
function makeScale(target, x, y) {
    return set(target, x, 0, 0, y, 0, 0);
}
function translate(transform, dx, dy) {
    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    transform[0] = sx * cos;
    transform[1] = sy * sin;
    transform[2] = -sx * sin;
    transform[3] = sy * cos;
    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
    return transform;
}
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
function invert(source) {
    return makeInverse(source, source);
}
function makeInverse(target, source) {
    const det = determinant(source);
    (0, _assertsJs.assert)(det !== 0, 'Transformation matrix cannot be inverted');
    const a = source[0];
    const b = source[1];
    const c = source[2];
    const d = source[3];
    const e = source[4];
    const f = source[5];
    target[0] = d / det;
    target[1] = -b / det;
    target[2] = -c / det;
    target[3] = a / det;
    target[4] = (c * f - d * e) / det;
    target[5] = -(a * f - b * e) / det;
    return target;
}
function determinant(mat) {
    return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * @type {HTMLElement}
 * @private
 */ let transformStringDiv;
function toString(mat) {
    const transformString = 'matrix(' + mat.join(', ') + ')';
    if (0, _hasJs.WORKER_OFFSCREEN_CANVAS) return transformString;
    const node = transformStringDiv || (transformStringDiv = document.createElement('div'));
    node.style.transform = transformString;
    return node.style.transform;
}

},{"./has.js":"i07p3","./asserts.js":"k0OL6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i07p3":[function(require,module,exports,__globalThis) {
/**
 * @module ol/has
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FIREFOX", ()=>FIREFOX);
parcelHelpers.export(exports, "SAFARI", ()=>SAFARI);
parcelHelpers.export(exports, "SAFARI_BUG_237906", ()=>SAFARI_BUG_237906);
parcelHelpers.export(exports, "WEBKIT", ()=>WEBKIT);
parcelHelpers.export(exports, "MAC", ()=>MAC);
parcelHelpers.export(exports, "DEVICE_PIXEL_RATIO", ()=>DEVICE_PIXEL_RATIO);
parcelHelpers.export(exports, "WORKER_OFFSCREEN_CANVAS", ()=>WORKER_OFFSCREEN_CANVAS);
parcelHelpers.export(exports, "IMAGE_DECODE", ()=>IMAGE_DECODE);
parcelHelpers.export(exports, "CREATE_IMAGE_BITMAP", ()=>CREATE_IMAGE_BITMAP);
parcelHelpers.export(exports, "PASSIVE_EVENT_LISTENERS", ()=>PASSIVE_EVENT_LISTENERS);
const ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
const FIREFOX = ua.includes('firefox');
const SAFARI = ua.includes('safari') && !ua.includes('chrom');
const SAFARI_BUG_237906 = SAFARI && (ua.includes('version/15.4') || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
const WEBKIT = ua.includes('webkit') && !ua.includes('edge');
const MAC = ua.includes('macintosh');
const DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
const WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' && typeof OffscreenCanvas !== 'undefined' && self instanceof WorkerGlobalScope; //eslint-disable-line
const IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
const CREATE_IMAGE_BITMAP = typeof createImageBitmap === 'function';
const PASSIVE_EVENT_LISTENERS = function() {
    let passive = false;
    try {
        const options = Object.defineProperty({}, 'passive', {
            get: function() {
                passive = true;
            }
        });
        // @ts-ignore Ignore invalid event type '_'
        window.addEventListener('_', null, options);
        // @ts-ignore Ignore invalid event type '_'
        window.removeEventListener('_', null, options);
    } catch (error) {
    // passive not supported
    }
    return passive;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k0OL6":[function(require,module,exports,__globalThis) {
/**
 * @module ol/asserts
 */ /**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {string} errorMessage Error message.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assert", ()=>assert);
function assert(assertion, errorMessage) {
    if (!assertion) throw new Error(errorMessage);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bGUel":[function(require,module,exports,__globalThis) {
/**
 * @module ol/extent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */ /**
 * Extent corner.
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner
 */ /**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */ parcelHelpers.export(exports, "boundingExtent", ()=>boundingExtent);
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 * @api
 */ parcelHelpers.export(exports, "buffer", ()=>buffer);
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [dest] Extent.
 * @return {Extent} The clone.
 */ parcelHelpers.export(exports, "clone", ()=>clone);
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */ parcelHelpers.export(exports, "closestSquaredDistanceXY", ()=>closestSquaredDistanceXY);
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */ parcelHelpers.export(exports, "containsCoordinate", ()=>containsCoordinate);
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */ parcelHelpers.export(exports, "containsExtent", ()=>containsExtent);
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */ parcelHelpers.export(exports, "containsXY", ()=>containsXY);
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */ parcelHelpers.export(exports, "coordinateRelationship", ()=>coordinateRelationship);
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */ parcelHelpers.export(exports, "createEmpty", ()=>createEmpty);
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdate", ()=>createOrUpdate);
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateEmpty", ()=>createOrUpdateEmpty);
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromCoordinate", ()=>createOrUpdateFromCoordinate);
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromCoordinates", ()=>createOrUpdateFromCoordinates);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromFlatCoordinates", ()=>createOrUpdateFromFlatCoordinates);
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromRings", ()=>createOrUpdateFromRings);
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */ parcelHelpers.export(exports, "equals", ()=>equals);
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */ parcelHelpers.export(exports, "approximatelyEquals", ()=>approximatelyEquals);
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */ parcelHelpers.export(exports, "extend", ()=>extend);
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */ parcelHelpers.export(exports, "extendCoordinate", ()=>extendCoordinate);
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendCoordinates", ()=>extendCoordinates);
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendFlatCoordinates", ()=>extendFlatCoordinates);
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendRings", ()=>extendRings);
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */ parcelHelpers.export(exports, "extendXY", ()=>extendXY);
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */ parcelHelpers.export(exports, "forEachCorner", ()=>forEachCorner);
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */ parcelHelpers.export(exports, "getArea", ()=>getArea);
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */ parcelHelpers.export(exports, "getBottomLeft", ()=>getBottomLeft);
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */ parcelHelpers.export(exports, "getBottomRight", ()=>getBottomRight);
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */ parcelHelpers.export(exports, "getCenter", ()=>getCenter);
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */ parcelHelpers.export(exports, "getCorner", ()=>getCorner);
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */ parcelHelpers.export(exports, "getEnlargedArea", ()=>getEnlargedArea);
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "getForViewAndSize", ()=>getForViewAndSize);
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @return {Array<number>} Linear ring representing the viewport.
 */ parcelHelpers.export(exports, "getRotatedViewport", ()=>getRotatedViewport);
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */ parcelHelpers.export(exports, "getHeight", ()=>getHeight);
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */ parcelHelpers.export(exports, "getIntersectionArea", ()=>getIntersectionArea);
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [dest] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */ parcelHelpers.export(exports, "getIntersection", ()=>getIntersection);
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */ parcelHelpers.export(exports, "getMargin", ()=>getMargin);
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */ parcelHelpers.export(exports, "getSize", ()=>getSize);
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */ parcelHelpers.export(exports, "getTopLeft", ()=>getTopLeft);
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */ parcelHelpers.export(exports, "getTopRight", ()=>getTopRight);
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */ parcelHelpers.export(exports, "getWidth", ()=>getWidth);
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */ parcelHelpers.export(exports, "intersects", ()=>intersects);
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */ parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
/**
 * @param {Extent} extent Extent.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "returnOrUpdate", ()=>returnOrUpdate);
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */ parcelHelpers.export(exports, "scaleFromCenter", ()=>scaleFromCenter);
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */ parcelHelpers.export(exports, "intersectsSegment", ()=>intersectsSegment);
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [dest] Destination extent.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */ parcelHelpers.export(exports, "applyTransform", ()=>applyTransform);
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX);
/**
 * Fits the extent to the real world
 *
 * If the extent does not cross the anti meridian, this will return the extent in an array
 * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the
 * real world
 *
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Array<Extent>} The extent within the real world extent.
 */ parcelHelpers.export(exports, "wrapAndSliceX", ()=>wrapAndSliceX);
var _relationshipJs = require("./extent/Relationship.js");
var _relationshipJsDefault = parcelHelpers.interopDefault(_relationshipJs);
function boundingExtent(coordinates) {
    const extent = createEmpty();
    for(let i = 0, ii = coordinates.length; i < ii; ++i)extendCoordinate(extent, coordinates[i]);
    return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [dest] Destination extent.
 * @private
 * @return {Extent} Extent.
 */ function _boundingExtentXYs(xs, ys, dest) {
    const minX = Math.min.apply(null, xs);
    const minY = Math.min.apply(null, ys);
    const maxX = Math.max.apply(null, xs);
    const maxY = Math.max.apply(null, ys);
    return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function buffer(extent, value, dest) {
    if (dest) {
        dest[0] = extent[0] - value;
        dest[1] = extent[1] - value;
        dest[2] = extent[2] + value;
        dest[3] = extent[3] + value;
        return dest;
    }
    return [
        extent[0] - value,
        extent[1] - value,
        extent[2] + value,
        extent[3] + value
    ];
}
function clone(extent, dest) {
    if (dest) {
        dest[0] = extent[0];
        dest[1] = extent[1];
        dest[2] = extent[2];
        dest[3] = extent[3];
        return dest;
    }
    return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
    let dx, dy;
    if (x < extent[0]) dx = extent[0] - x;
    else if (extent[2] < x) dx = x - extent[2];
    else dx = 0;
    if (y < extent[1]) dy = extent[1] - y;
    else if (extent[3] < y) dy = y - extent[3];
    else dy = 0;
    return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
    return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
    return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const x = coordinate[0];
    const y = coordinate[1];
    let relationship = (0, _relationshipJsDefault.default).UNKNOWN;
    if (x < minX) relationship = relationship | (0, _relationshipJsDefault.default).LEFT;
    else if (x > maxX) relationship = relationship | (0, _relationshipJsDefault.default).RIGHT;
    if (y < minY) relationship = relationship | (0, _relationshipJsDefault.default).BELOW;
    else if (y > maxY) relationship = relationship | (0, _relationshipJsDefault.default).ABOVE;
    if (relationship === (0, _relationshipJsDefault.default).UNKNOWN) relationship = (0, _relationshipJsDefault.default).INTERSECTING;
    return relationship;
}
function createEmpty() {
    return [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
    if (dest) {
        dest[0] = minX;
        dest[1] = minY;
        dest[2] = maxX;
        dest[3] = maxY;
        return dest;
    }
    return [
        minX,
        minY,
        maxX,
        maxY
    ];
}
function createOrUpdateEmpty(dest) {
    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
    const x = coordinate[0];
    const y = coordinate[1];
    return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromCoordinates(coordinates, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendCoordinates(extent, coordinates);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function createOrUpdateFromRings(rings, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendRings(extent, rings);
}
function equals(extent1, extent2) {
    return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function approximatelyEquals(extent1, extent2, tolerance) {
    return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
function extend(extent1, extent2) {
    if (extent2[0] < extent1[0]) extent1[0] = extent2[0];
    if (extent2[2] > extent1[2]) extent1[2] = extent2[2];
    if (extent2[1] < extent1[1]) extent1[1] = extent2[1];
    if (extent2[3] > extent1[3]) extent1[3] = extent2[3];
    return extent1;
}
function extendCoordinate(extent, coordinate) {
    if (coordinate[0] < extent[0]) extent[0] = coordinate[0];
    if (coordinate[0] > extent[2]) extent[2] = coordinate[0];
    if (coordinate[1] < extent[1]) extent[1] = coordinate[1];
    if (coordinate[1] > extent[3]) extent[3] = coordinate[1];
}
function extendCoordinates(extent, coordinates) {
    for(let i = 0, ii = coordinates.length; i < ii; ++i)extendCoordinate(extent, coordinates[i]);
    return extent;
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
    for(; offset < end; offset += stride)extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
    return extent;
}
function extendRings(extent, rings) {
    for(let i = 0, ii = rings.length; i < ii; ++i)extendCoordinates(extent, rings[i]);
    return extent;
}
function extendXY(extent, x, y) {
    extent[0] = Math.min(extent[0], x);
    extent[1] = Math.min(extent[1], y);
    extent[2] = Math.max(extent[2], x);
    extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
    let val;
    val = callback(getBottomLeft(extent));
    if (val) return val;
    val = callback(getBottomRight(extent));
    if (val) return val;
    val = callback(getTopRight(extent));
    if (val) return val;
    val = callback(getTopLeft(extent));
    if (val) return val;
    return false;
}
function getArea(extent) {
    let area = 0;
    if (!isEmpty(extent)) area = getWidth(extent) * getHeight(extent);
    return area;
}
function getBottomLeft(extent) {
    return [
        extent[0],
        extent[1]
    ];
}
function getBottomRight(extent) {
    return [
        extent[2],
        extent[1]
    ];
}
function getCenter(extent) {
    return [
        (extent[0] + extent[2]) / 2,
        (extent[1] + extent[3]) / 2
    ];
}
function getCorner(extent, corner) {
    let coordinate;
    if (corner === 'bottom-left') coordinate = getBottomLeft(extent);
    else if (corner === 'bottom-right') coordinate = getBottomRight(extent);
    else if (corner === 'top-left') coordinate = getTopLeft(extent);
    else if (corner === 'top-right') coordinate = getTopRight(extent);
    else throw new Error('Invalid corner');
    return coordinate;
}
function getEnlargedArea(extent1, extent2) {
    const minX = Math.min(extent1[0], extent2[0]);
    const minY = Math.min(extent1[1], extent2[1]);
    const maxX = Math.max(extent1[2], extent2[2]);
    const maxY = Math.max(extent1[3], extent2[3]);
    return (maxX - minX) * (maxY - minY);
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
    const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(center, resolution, rotation, size);
    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), dest);
}
function getRotatedViewport(center, resolution, rotation, size) {
    const dx = resolution * size[0] / 2;
    const dy = resolution * size[1] / 2;
    const cosRotation = Math.cos(rotation);
    const sinRotation = Math.sin(rotation);
    const xCos = dx * cosRotation;
    const xSin = dx * sinRotation;
    const yCos = dy * cosRotation;
    const ySin = dy * sinRotation;
    const x = center[0];
    const y = center[1];
    return [
        x - xCos + ySin,
        y - xSin - yCos,
        x - xCos - ySin,
        y - xSin + yCos,
        x + xCos - ySin,
        y + xSin + yCos,
        x + xCos + ySin,
        y + xSin - yCos,
        x - xCos + ySin,
        y - xSin - yCos
    ];
}
function getHeight(extent) {
    return extent[3] - extent[1];
}
function getIntersectionArea(extent1, extent2) {
    const intersection = getIntersection(extent1, extent2);
    return getArea(intersection);
}
function getIntersection(extent1, extent2, dest) {
    const intersection = dest ? dest : createEmpty();
    if (intersects(extent1, extent2)) {
        if (extent1[0] > extent2[0]) intersection[0] = extent1[0];
        else intersection[0] = extent2[0];
        if (extent1[1] > extent2[1]) intersection[1] = extent1[1];
        else intersection[1] = extent2[1];
        if (extent1[2] < extent2[2]) intersection[2] = extent1[2];
        else intersection[2] = extent2[2];
        if (extent1[3] < extent2[3]) intersection[3] = extent1[3];
        else intersection[3] = extent2[3];
    } else createOrUpdateEmpty(intersection);
    return intersection;
}
function getMargin(extent) {
    return getWidth(extent) + getHeight(extent);
}
function getSize(extent) {
    return [
        extent[2] - extent[0],
        extent[3] - extent[1]
    ];
}
function getTopLeft(extent) {
    return [
        extent[0],
        extent[3]
    ];
}
function getTopRight(extent) {
    return [
        extent[2],
        extent[3]
    ];
}
function getWidth(extent) {
    return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
    return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty(extent) {
    return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
    if (dest) {
        dest[0] = extent[0];
        dest[1] = extent[1];
        dest[2] = extent[2];
        dest[3] = extent[3];
        return dest;
    }
    return extent;
}
function scaleFromCenter(extent, value) {
    const deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
    const deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
    extent[0] -= deltaX;
    extent[2] += deltaX;
    extent[1] -= deltaY;
    extent[3] += deltaY;
}
function intersectsSegment(extent, start, end) {
    let intersects = false;
    const startRel = coordinateRelationship(extent, start);
    const endRel = coordinateRelationship(extent, end);
    if (startRel === (0, _relationshipJsDefault.default).INTERSECTING || endRel === (0, _relationshipJsDefault.default).INTERSECTING) intersects = true;
    else {
        const minX = extent[0];
        const minY = extent[1];
        const maxX = extent[2];
        const maxY = extent[3];
        const startX = start[0];
        const startY = start[1];
        const endX = end[0];
        const endY = end[1];
        const slope = (endY - startY) / (endX - startX);
        let x, y;
        if (!!(endRel & (0, _relationshipJsDefault.default).ABOVE) && !(startRel & (0, _relationshipJsDefault.default).ABOVE)) {
            // potentially intersects top
            x = endX - (endY - maxY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects && !!(endRel & (0, _relationshipJsDefault.default).RIGHT) && !(startRel & (0, _relationshipJsDefault.default).RIGHT)) {
            // potentially intersects right
            y = endY - (endX - maxX) * slope;
            intersects = y >= minY && y <= maxY;
        }
        if (!intersects && !!(endRel & (0, _relationshipJsDefault.default).BELOW) && !(startRel & (0, _relationshipJsDefault.default).BELOW)) {
            // potentially intersects bottom
            x = endX - (endY - minY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects && !!(endRel & (0, _relationshipJsDefault.default).LEFT) && !(startRel & (0, _relationshipJsDefault.default).LEFT)) {
            // potentially intersects left
            y = endY - (endX - minX) * slope;
            intersects = y >= minY && y <= maxY;
        }
    }
    return intersects;
}
function applyTransform(extent, transformFn, dest, stops) {
    if (isEmpty(extent)) return createOrUpdateEmpty(dest);
    let coordinates = [];
    if (stops > 1) {
        const width = extent[2] - extent[0];
        const height = extent[3] - extent[1];
        for(let i = 0; i < stops; ++i)coordinates.push(extent[0] + width * i / stops, extent[1], extent[2], extent[1] + height * i / stops, extent[2] - width * i / stops, extent[3], extent[0], extent[3] - height * i / stops);
    } else coordinates = [
        extent[0],
        extent[1],
        extent[2],
        extent[1],
        extent[2],
        extent[3],
        extent[0],
        extent[3]
    ];
    transformFn(coordinates, coordinates, 2);
    const xs = [];
    const ys = [];
    for(let i = 0, l = coordinates.length; i < l; i += 2){
        xs.push(coordinates[i]);
        ys.push(coordinates[i + 1]);
    }
    return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
    const projectionExtent = projection.getExtent();
    const center = getCenter(extent);
    if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
        const worldWidth = getWidth(projectionExtent);
        const worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
        const offset = worldsAway * worldWidth;
        extent[0] -= offset;
        extent[2] -= offset;
    }
    return extent;
}
function wrapAndSliceX(extent, projection) {
    if (projection.canWrapX()) {
        const projectionExtent = projection.getExtent();
        if (!isFinite(extent[0]) || !isFinite(extent[2])) return [
            [
                projectionExtent[0],
                extent[1],
                projectionExtent[2],
                extent[3]
            ]
        ];
        wrapX(extent, projection);
        const worldWidth = getWidth(projectionExtent);
        if (getWidth(extent) > worldWidth) // the extent wraps around on itself
        return [
            [
                projectionExtent[0],
                extent[1],
                projectionExtent[2],
                extent[3]
            ]
        ];
        if (extent[0] < projectionExtent[0]) // the extent crosses the anti meridian, so it needs to be sliced
        return [
            [
                extent[0] + worldWidth,
                extent[1],
                projectionExtent[2],
                extent[3]
            ],
            [
                projectionExtent[0],
                extent[1],
                extent[2],
                extent[3]
            ]
        ];
        if (extent[2] > projectionExtent[2]) // the extent crosses the anti meridian, so it needs to be sliced
        return [
            [
                extent[0],
                extent[1],
                projectionExtent[2],
                extent[3]
            ],
            [
                projectionExtent[0],
                extent[1],
                extent[2] - worldWidth,
                extent[3]
            ]
        ];
    }
    return [
        extent
    ];
}

},{"./extent/Relationship.js":"7qhKb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7qhKb":[function(require,module,exports,__globalThis) {
/**
 * @module ol/extent/Relationship
 */ /**
 * Relationship to an extent.
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aj9Mo":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/IconImageCache
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shared", ()=>shared);
var _colorJs = require("../color.js");
/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.
 */ class IconImageCache {
    constructor(){
        /**
     * @type {!Object<string, import("./IconImage.js").default>}
     * @private
     */ this.cache_ = {};
        /**
     * @type {number}
     * @private
     */ this.cacheSize_ = 0;
        /**
     * @type {number}
     * @private
     */ this.maxCacheSize_ = 32;
    }
    /**
   * FIXME empty description for jsdoc
   */ clear() {
        this.cache_ = {};
        this.cacheSize_ = 0;
    }
    /**
   * @return {boolean} Can expire cache.
   */ canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_;
    }
    /**
   * FIXME empty description for jsdoc
   */ expire() {
        if (this.canExpireCache()) {
            let i = 0;
            for(const key in this.cache_){
                const iconImage = this.cache_[key];
                if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                    delete this.cache_[key];
                    --this.cacheSize_;
                }
            }
        }
    }
    /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */ get(src, crossOrigin, color) {
        const key = getKey(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
    }
    /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @param {import("./IconImage.js").default} iconImage Icon image.
   */ set(src, crossOrigin, color, iconImage) {
        const key = getKey(src, crossOrigin, color);
        this.cache_[key] = iconImage;
        ++this.cacheSize_;
    }
    /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */ setSize(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
    }
}
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */ function getKey(src, crossOrigin, color) {
    const colorString = color ? (0, _colorJs.asString)(color) : 'null';
    return crossOrigin + ':' + src + ':' + colorString;
}
exports.default = IconImageCache;
const shared = new IconImageCache();

},{"../color.js":"h6hAX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h6hAX":[function(require,module,exports,__globalThis) {
/**
 * @module ol/color
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */ /**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */ parcelHelpers.export(exports, "asString", ()=>asString);
/**
 * @param {Color} color A color that may or may not have an alpha channel.
 * @return {Color} The input color with an alpha channel.  If the input color has
 * an alpha channel, the input color will be returned unchanged.  Otherwise, a new
 * array will be returned with the input color and an alpha channel of 1.
 */ parcelHelpers.export(exports, "withAlpha", ()=>withAlpha);
/**
 * @param {Color} color RGBA color.
 * @return {Color} LCHuv color with alpha.
 */ parcelHelpers.export(exports, "rgbaToLcha", ()=>rgbaToLcha);
/**
 * @param {Color} color LCHuv color with alpha.
 * @return {Color} RGBA color.
 */ parcelHelpers.export(exports, "lchaToRgba", ()=>lchaToRgba);
/**
 * @param {string} s String.
 * @return {Color} Color.
 */ parcelHelpers.export(exports, "fromString", ()=>fromString);
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */ parcelHelpers.export(exports, "asArray", ()=>asArray);
/**
 * Exported for the tests.
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */ parcelHelpers.export(exports, "normalize", ()=>normalize);
/**
 * @param {Color} color Color.
 * @return {string} String.
 */ parcelHelpers.export(exports, "toString", ()=>toString);
/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */ parcelHelpers.export(exports, "isStringColor", ()=>isStringColor);
var _lchuvJs = require("color-space/lchuv.js");
var _lchuvJsDefault = parcelHelpers.interopDefault(_lchuvJs);
var _colorRgba = require("color-rgba");
var _colorRgbaDefault = parcelHelpers.interopDefault(_colorRgba);
var _rgbJs = require("color-space/rgb.js");
var _rgbJsDefault = parcelHelpers.interopDefault(_rgbJs);
var _xyzJs = require("color-space/xyz.js");
var _xyzJsDefault = parcelHelpers.interopDefault(_xyzJs);
var _mathJs = require("./math.js");
function asString(color) {
    if (typeof color === 'string') return color;
    return toString(color);
}
/**
 * @type {number}
 */ const MAX_CACHE_SIZE = 1024;
/**
 * We maintain a small cache of parsed strings.  Whenever the cache grows too large,
 * we delete an arbitrary set of the entries.
 *
 * @type {Object<string, Color>}
 */ const cache = {};
/**
 * @type {number}
 */ let cacheSize = 0;
function withAlpha(color) {
    if (color.length === 4) return color;
    const output = color.slice();
    output[3] = 1;
    return output;
}
function rgbaToLcha(color) {
    const output = (0, _xyzJsDefault.default).lchuv((0, _rgbJsDefault.default).xyz(color));
    output[3] = color[3];
    return output;
}
function lchaToRgba(color) {
    const output = (0, _xyzJsDefault.default).rgb((0, _lchuvJsDefault.default).xyz(color));
    output[3] = color[3];
    return output;
}
function fromString(s) {
    if (cache.hasOwnProperty(s)) return cache[s];
    if (cacheSize >= MAX_CACHE_SIZE) {
        let i = 0;
        for(const key in cache)if ((i++ & 3) === 0) {
            delete cache[key];
            --cacheSize;
        }
    }
    const color = (0, _colorRgbaDefault.default)(s);
    if (color.length !== 4) throw new Error('Failed to parse "' + s + '" as color');
    for (const c of color){
        if (isNaN(c)) throw new Error('Failed to parse "' + s + '" as color');
    }
    normalize(color);
    cache[s] = color;
    ++cacheSize;
    return color;
}
function asArray(color) {
    if (Array.isArray(color)) return color;
    return fromString(color);
}
function normalize(color) {
    color[0] = (0, _mathJs.clamp)(color[0] + 0.5 | 0, 0, 255);
    color[1] = (0, _mathJs.clamp)(color[1] + 0.5 | 0, 0, 255);
    color[2] = (0, _mathJs.clamp)(color[2] + 0.5 | 0, 0, 255);
    color[3] = (0, _mathJs.clamp)(color[3], 0, 1);
    return color;
}
function toString(color) {
    let r = color[0];
    if (r != (r | 0)) r = r + 0.5 | 0;
    let g = color[1];
    if (g != (g | 0)) g = g + 0.5 | 0;
    let b = color[2];
    if (b != (b | 0)) b = b + 0.5 | 0;
    const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}
function isStringColor(s) {
    try {
        fromString(s);
        return true;
    } catch (_) {
        return false;
    }
}

},{"color-space/lchuv.js":"9hxgw","color-rgba":"3Oig4","color-space/rgb.js":"bO4xZ","color-space/xyz.js":"aTG7m","./math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9hxgw":[function(require,module,exports,__globalThis) {
/**
 * Cylindrical CIE LUV
 *
 * @module color-space/lchuv
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _luvJs = require("./luv.js");
var _luvJsDefault = parcelHelpers.interopDefault(_luvJs);
var _xyzJs = require("./xyz.js");
var _xyzJsDefault = parcelHelpers.interopDefault(_xyzJs);
// cylindrical luv
var lchuv = {
    name: 'lchuv',
    channel: [
        'lightness',
        'chroma',
        'hue'
    ],
    alias: [
        'LCHuv',
        'cielchuv'
    ],
    min: [
        0,
        0,
        0
    ],
    max: [
        100,
        100,
        360
    ],
    luv: function(luv) {
        var l = luv[0], c = luv[1], h = luv[2], u, v, hr;
        hr = h / 360 * 2 * Math.PI;
        u = c * Math.cos(hr);
        v = c * Math.sin(hr);
        return [
            l,
            u,
            v
        ];
    },
    xyz: function(arg) {
        return (0, _luvJsDefault.default).xyz(lchuv.luv(arg));
    }
};
exports.default = lchuv;
(0, _luvJsDefault.default).lchuv = function(luv) {
    var l = luv[0], u = luv[1], v = luv[2];
    var c = Math.sqrt(u * u + v * v);
    var hr = Math.atan2(v, u);
    var h = hr * 360 / 2 / Math.PI;
    if (h < 0) h += 360;
    return [
        l,
        c,
        h
    ];
};
(0, _xyzJsDefault.default).lchuv = function(arg) {
    return (0, _luvJsDefault.default).lchuv((0, _xyzJsDefault.default).luv(arg));
};

},{"./luv.js":"i17YA","./xyz.js":"aTG7m","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i17YA":[function(require,module,exports,__globalThis) {
/**
 * CIE LUV (C'est la vie)
 *
 * @module color-space/luv
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _xyzJs = require("./xyz.js");
var _xyzJsDefault = parcelHelpers.interopDefault(_xyzJs);
var luv = {
    name: 'luv',
    //NOTE: luv has no rigidly defined limits
    //easyrgb fails to get proper coords
    //boronine states no rigid limits
    //colorMine refers this ones:
    min: [
        0,
        -134,
        -140
    ],
    max: [
        100,
        224,
        122
    ],
    channel: [
        'lightness',
        'u',
        'v'
    ],
    alias: [
        'LUV',
        'cieluv',
        'cie1976'
    ],
    xyz: function(arg, i, o) {
        var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
        l = arg[0], u = arg[1], v = arg[2];
        if (l === 0) return [
            0,
            0,
            0
        ];
        //get constants
        //var e = 0.008856451679035631; //(6/29)^3
        var k = 0.0011070564598794539; //(3/29)^3
        //get illuminant/observer
        i = i || 'D65';
        o = o || 2;
        xn = (0, _xyzJsDefault.default).whitepoint[o][i][0];
        yn = (0, _xyzJsDefault.default).whitepoint[o][i][1];
        zn = (0, _xyzJsDefault.default).whitepoint[o][i][2];
        un = 4 * xn / (xn + 15 * yn + 3 * zn);
        vn = 9 * yn / (xn + 15 * yn + 3 * zn);
        // un = 0.19783000664283;
        // vn = 0.46831999493879;
        _u = u / (13 * l) + un || 0;
        _v = v / (13 * l) + vn || 0;
        y = l > 8 ? yn * Math.pow((l + 16) / 116, 3) : yn * l * k;
        //wikipedia method
        x = y * 9 * _u / (4 * _v) || 0;
        z = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;
        //boronine method
        //https://github.com/boronine/husl/blob/master/husl.coffee#L201
        // x = 0 - (9 * y * _u) / ((_u - 4) * _v - _u * _v);
        // z = (9 * y - (15 * _v * y) - (_v * x)) / (3 * _v);
        return [
            x,
            y,
            z
        ];
    }
};
exports.default = luv;
// http://www.brucelindbloom.com/index.html?Equations.html
// https://github.com/boronine/husl/blob/master/husl.coffee
//i - illuminant
//o - observer
(0, _xyzJsDefault.default).luv = function(arg, i, o) {
    var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
    //get constants
    var e = 0.008856451679035631; //(6/29)^3
    var k = 903.2962962962961; //(29/3)^3
    //get illuminant/observer coords
    i = i || 'D65';
    o = o || 2;
    xn = (0, _xyzJsDefault.default).whitepoint[o][i][0];
    yn = (0, _xyzJsDefault.default).whitepoint[o][i][1];
    zn = (0, _xyzJsDefault.default).whitepoint[o][i][2];
    un = 4 * xn / (xn + 15 * yn + 3 * zn);
    vn = 9 * yn / (xn + 15 * yn + 3 * zn);
    x = arg[0], y = arg[1], z = arg[2];
    _u = 4 * x / (x + 15 * y + 3 * z) || 0;
    _v = 9 * y / (x + 15 * y + 3 * z) || 0;
    var yr = y / yn;
    l = yr <= e ? k * yr : 116 * Math.pow(yr, 1 / 3) - 16;
    u = 13 * l * (_u - un);
    v = 13 * l * (_v - vn);
    return [
        l,
        u,
        v
    ];
};

},{"./xyz.js":"aTG7m","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aTG7m":[function(require,module,exports,__globalThis) {
/**
 * CIE XYZ
 *
 * @module  color-space/xyz
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rgbJs = require("./rgb.js");
var _rgbJsDefault = parcelHelpers.interopDefault(_rgbJs);
const xyz = {
    name: 'xyz',
    min: [
        0,
        0,
        0
    ],
    channel: [
        'X',
        'Y',
        'Z'
    ],
    alias: [
        'XYZ',
        'ciexyz',
        'cie1931'
    ],
    // Whitepoint reference values with observer/illuminant
    // http://en.wikipedia.org/wiki/Standard_illuminant
    whitepoint: {
        //1931 2°
        2: {
            //incadescent
            A: [
                109.85,
                100,
                35.585
            ],
            // B:[],
            C: [
                98.074,
                100,
                118.232
            ],
            D50: [
                96.422,
                100,
                82.521
            ],
            D55: [
                95.682,
                100,
                92.149
            ],
            //daylight
            D65: [
                95.045592705167,
                100,
                108.9057750759878
            ],
            D75: [
                94.972,
                100,
                122.638
            ],
            //flourescent
            // F1: [],
            F2: [
                99.187,
                100,
                67.395
            ],
            // F3: [],
            // F4: [],
            // F5: [],
            // F6:[],
            F7: [
                95.044,
                100,
                108.755
            ],
            // F8: [],
            // F9: [],
            // F10: [],
            F11: [
                100.966,
                100,
                64.370
            ],
            // F12: [],
            E: [
                100,
                100,
                100
            ]
        },
        //1964  10°
        10: {
            //incadescent
            A: [
                111.144,
                100,
                35.200
            ],
            C: [
                97.285,
                100,
                116.145
            ],
            D50: [
                96.720,
                100,
                81.427
            ],
            D55: [
                95.799,
                100,
                90.926
            ],
            //daylight
            D65: [
                94.811,
                100,
                107.304
            ],
            D75: [
                94.416,
                100,
                120.641
            ],
            //flourescent
            F2: [
                103.280,
                100,
                69.026
            ],
            F7: [
                95.792,
                100,
                107.687
            ],
            F11: [
                103.866,
                100,
                65.627
            ],
            E: [
                100,
                100,
                100
            ]
        }
    }
};
/**
 * Top values are the whitepoint’s top values, default are D65
 */ xyz.max = xyz.whitepoint[2].D65;
/**
 * Transform xyz to rgb
 *
 * @param {Array<number>} _xyz Array of xyz values
 * @param {Array<number>} white Whitepoint reference
 * @return {Array<number>} RGB values
 */ xyz.rgb = function(_xyz, white) {
    // FIXME: make sure we have to divide like this. Probably we have to replace matrix as well then
    white = white || xyz.whitepoint[2].E;
    var x = _xyz[0] / white[0], y = _xyz[1] / white[1], z = _xyz[2] / white[2], r, g, b;
    // assume sRGB
    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
    r = x * 3.240969941904521 + y * -1.537383177570093 + z * -0.498610760293;
    g = x * -0.96924363628087 + y * 1.87596750150772 + z * 0.041555057407175;
    b = x * 0.055630079696993 + y * -0.20397695888897 + z * 1.056971514242878;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
/**
 * RGB to XYZ
 *
 * @param {Array<number>} rgb RGB channels
 *
 * @return {Array<number>} XYZ channels
 */ (0, _rgbJsDefault.default).xyz = function(rgb, white) {
    var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
    // assume sRGB
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.41239079926595 + g * 0.35758433938387 + b * 0.18048078840183;
    var y = r * 0.21263900587151 + g * 0.71516867876775 + b * 0.072192315360733;
    var z = r * 0.019330818715591 + g * 0.11919477979462 + b * 0.95053215224966;
    white = white || xyz.whitepoint[2].E;
    return [
        x * white[0],
        y * white[1],
        z * white[2]
    ];
};
exports.default = xyz;

},{"./rgb.js":"bO4xZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bO4xZ":[function(require,module,exports,__globalThis) {
/**
 * RGB space.
 *
 * @module  color-space/rgb
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const rgb = {
    name: 'rgb',
    min: [
        0,
        0,
        0
    ],
    max: [
        255,
        255,
        255
    ],
    channel: [
        'red',
        'green',
        'blue'
    ],
    alias: [
        'RGB'
    ]
};
exports.default = rgb;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Oig4":[function(require,module,exports,__globalThis) {
/** @module  color-rgba */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>rgba);
var _colorParse = require("color-parse");
var _colorParseDefault = parcelHelpers.interopDefault(_colorParse);
var _rgbJs = require("color-space/rgb.js");
var _rgbJsDefault = parcelHelpers.interopDefault(_rgbJs);
var _hslJs = require("color-space/hsl.js");
var _hslJsDefault = parcelHelpers.interopDefault(_hslJs);
function rgba(color) {
    // template literals
    if (Array.isArray(color) && color.raw) color = String.raw(...arguments);
    if (color instanceof Number) color = +color;
    var values, i, l;
    //attempt to parse non-array arguments
    var parsed = (0, _colorParseDefault.default)(color);
    if (!parsed.space) return [];
    const min = parsed.space[0] === 'h' ? (0, _hslJsDefault.default).min : (0, _rgbJsDefault.default).min;
    const max = parsed.space[0] === 'h' ? (0, _hslJsDefault.default).max : (0, _rgbJsDefault.default).max;
    values = Array(3);
    values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
    values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
    values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);
    if (parsed.space[0] === 'h') values = (0, _hslJsDefault.default).rgb(values);
    values.push(Math.min(Math.max(parsed.alpha, 0), 1));
    return values;
}

},{"color-parse":"aNO7Y","color-space/rgb.js":"bO4xZ","color-space/hsl.js":"iWN7f","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aNO7Y":[function(require,module,exports,__globalThis) {
/**
 * @module color-parse
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorName = require("color-name");
var _colorNameDefault = parcelHelpers.interopDefault(_colorName);
exports.default = parse;
/**
 * Base hues
 * http://dev.w3.org/csswg/css-color/#typedef-named-hue
 */ //FIXME: use external hue detector
var baseHues = {
    red: 0,
    orange: 60,
    yellow: 120,
    green: 180,
    blue: 240,
    purple: 300
};
/**
 * Parse color from the string passed
 *
 * @return {Object} A space indicator `space`, an array `values` and `alpha`
 */ function parse(cstr) {
    var m, parts = [], alpha = 1, space;
    //numeric case
    if (typeof cstr === 'number') return {
        space: 'rgb',
        values: [
            cstr >>> 16,
            (cstr & 0x00ff00) >>> 8,
            cstr & 0x0000ff
        ],
        alpha: 1
    };
    if (typeof cstr === 'number') return {
        space: 'rgb',
        values: [
            cstr >>> 16,
            (cstr & 0x00ff00) >>> 8,
            cstr & 0x0000ff
        ],
        alpha: 1
    };
    cstr = String(cstr).toLowerCase();
    //keyword
    if ((0, _colorNameDefault.default)[cstr]) {
        parts = (0, _colorNameDefault.default)[cstr].slice();
        space = 'rgb';
    } else if (cstr === 'transparent') {
        alpha = 0;
        space = 'rgb';
        parts = [
            0,
            0,
            0
        ];
    } else if (cstr[0] === '#') {
        var base = cstr.slice(1);
        var size = base.length;
        var isShort = size <= 4;
        alpha = 1;
        if (isShort) {
            parts = [
                parseInt(base[0] + base[0], 16),
                parseInt(base[1] + base[1], 16),
                parseInt(base[2] + base[2], 16)
            ];
            if (size === 4) alpha = parseInt(base[3] + base[3], 16) / 255;
        } else {
            parts = [
                parseInt(base[0] + base[1], 16),
                parseInt(base[2] + base[3], 16),
                parseInt(base[4] + base[5], 16)
            ];
            if (size === 8) alpha = parseInt(base[6] + base[7], 16) / 255;
        }
        if (!parts[0]) parts[0] = 0;
        if (!parts[1]) parts[1] = 0;
        if (!parts[2]) parts[2] = 0;
        space = 'rgb';
    } else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
        var name = m[1];
        space = name.replace(/a$/, '');
        var dims = space === 'cmyk' ? 4 : space === 'gray' ? 1 : 3;
        parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);
        // color(srgb-linear x x x) -> srgb-linear(x x x)
        if (space === 'color') space = parts.shift();
        parts = parts.map(function(x, i) {
            //<percentage>
            if (x[x.length - 1] === '%') {
                x = parseFloat(x) / 100;
                // alpha -> 0..1
                if (i === 3) return x;
                // rgb -> 0..255
                if (space === 'rgb') return x * 255;
                // hsl, hwb H -> 0..100
                if (space[0] === 'h') return x * 100;
                // lch, lab L -> 0..100
                if (space[0] === 'l' && !i) return x * 100;
                // lab A B -> -125..125
                if (space === 'lab') return x * 125;
                // lch C -> 0..150, H -> 0..360
                if (space === 'lch') return i < 2 ? x * 150 : x * 360;
                // oklch/oklab L -> 0..1
                if (space[0] === 'o' && !i) return x;
                // oklab A B -> -0.4..0.4
                if (space === 'oklab') return x * 0.4;
                // oklch C -> 0..0.4, H -> 0..360
                if (space === 'oklch') return i < 2 ? x * 0.4 : x * 360;
                // color(xxx) -> 0..1
                return x;
            }
            //hue
            if (space[i] === 'h' || i === 2 && space[space.length - 1] === 'h') {
                //<base-hue>
                if (baseHues[x] !== undefined) return baseHues[x];
                //<deg>
                if (x.endsWith('deg')) return parseFloat(x);
                //<turn>
                if (x.endsWith('turn')) return parseFloat(x) * 360;
                if (x.endsWith('grad')) return parseFloat(x) * 360 / 400;
                if (x.endsWith('rad')) return parseFloat(x) * 180 / Math.PI;
            }
            if (x === 'none') return 0;
            return parseFloat(x);
        });
        alpha = parts.length > dims ? parts.pop() : 1;
    } else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
        parts = cstr.match(/([0-9]+)/g).map(function(value) {
            return parseFloat(value);
        });
        space = cstr.match(/([a-z])/ig)?.join('')?.toLowerCase() || 'rgb';
    }
    return {
        space,
        values: parts,
        alpha
    };
}

},{"color-name":"ivHwe","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ivHwe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iWN7f":[function(require,module,exports,__globalThis) {
/**
 * @module color-space/hsl
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rgbJs = require("./rgb.js");
var _rgbJsDefault = parcelHelpers.interopDefault(_rgbJs);
var hsl = {
    name: 'hsl',
    min: [
        0,
        0,
        0
    ],
    max: [
        360,
        100,
        100
    ],
    channel: [
        'hue',
        'saturation',
        'lightness'
    ],
    alias: [
        'HSL'
    ],
    rgb: function(hsl) {
        var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val, i = 0;
        if (s === 0) return val = l * 255, [
            val,
            val,
            val
        ];
        t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
        t1 = 2 * l - t2;
        rgb = [
            0,
            0,
            0
        ];
        for(; i < 3;){
            t3 = h + 1 / 3 * -(i - 1);
            t3 < 0 ? t3++ : t3 > 1 && t3--;
            val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
            rgb[i++] = val * 255;
        }
        return rgb;
    }
};
exports.default = hsl;
//extend rgb
(0, _rgbJsDefault.default).hsl = function(rgb) {
    var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
    if (max === min) h = 0;
    else if (r === max) h = (g - b) / delta;
    else if (g === max) h = 2 + (b - r) / delta;
    else if (b === max) h = 4 + (r - g) / delta;
    //FIXME h is possibly undefined
    //@ts-ignore
    h = Math.min(h * 60, 360);
    if (h < 0) h += 360;
    l = (min + max) / 2;
    if (max === min) s = 0;
    else if (l <= 0.5) s = delta / (max + min);
    else s = delta / (2 - max - min);
    return [
        h,
        s * 100,
        l * 100
    ];
};

},{"./rgb.js":"bO4xZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d8zSj":[function(require,module,exports,__globalThis) {
/**
 * @module ol/math
 */ /**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clamp", ()=>clamp);
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */ parcelHelpers.export(exports, "squaredSegmentDistance", ()=>squaredSegmentDistance);
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance);
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>|null} The resulting vector.
 */ parcelHelpers.export(exports, "solveLinearSystem", ()=>solveLinearSystem);
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */ parcelHelpers.export(exports, "toDegrees", ()=>toDegrees);
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */ parcelHelpers.export(exports, "toRadians", ()=>toRadians);
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */ parcelHelpers.export(exports, "modulo", ()=>modulo);
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */ parcelHelpers.export(exports, "lerp", ()=>lerp);
/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */ parcelHelpers.export(exports, "toFixed", ()=>toFixed);
/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */ parcelHelpers.export(exports, "round", ()=>round);
/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */ parcelHelpers.export(exports, "floor", ()=>floor);
/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */ parcelHelpers.export(exports, "ceil", ()=>ceil);
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    if (dx !== 0 || dy !== 0) {
        const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x1 = x2;
            y1 = y2;
        } else if (t > 0) {
            x1 += dx * t;
            y1 += dy * t;
        }
    }
    return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
    const n = mat.length;
    for(let i = 0; i < n; i++){
        // Find max in the i-th column (ignoring i - 1 first rows)
        let maxRow = i;
        let maxEl = Math.abs(mat[i][i]);
        for(let r = i + 1; r < n; r++){
            const absValue = Math.abs(mat[r][i]);
            if (absValue > maxEl) {
                maxEl = absValue;
                maxRow = r;
            }
        }
        if (maxEl === 0) return null; // matrix is singular
        // Swap max row with i-th (current) row
        const tmp = mat[maxRow];
        mat[maxRow] = mat[i];
        mat[i] = tmp;
        // Subtract the i-th row to make all the remaining rows 0 in the i-th column
        for(let j = i + 1; j < n; j++){
            const coef = -mat[j][i] / mat[i][i];
            for(let k = i; k < n + 1; k++)if (i == k) mat[j][k] = 0;
            else mat[j][k] += coef * mat[i][k];
        }
    }
    // Solve Ax=b for upper triangular matrix A (mat)
    const x = new Array(n);
    for(let l = n - 1; l >= 0; l--){
        x[l] = mat[l][n] / mat[l][l];
        for(let m = l - 1; m >= 0; m--)mat[m][n] -= mat[m][l] * x[l];
    }
    return x;
}
function toDegrees(angleInRadians) {
    return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
    return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
    const r = a % b;
    return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
    return a + x * (b - a);
}
function toFixed(n, decimals) {
    const factor = Math.pow(10, decimals);
    return Math.round(n * factor) / factor;
}
function round(n, decimals) {
    return Math.round(toFixed(n, decimals));
}
function floor(n, decimals) {
    return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
    return Math.ceil(toFixed(n, decimals));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ixGac":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/Layer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */ parcelHelpers.export(exports, "inView", ()=>inView);
var _baseJs = require("./Base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _eventTypeJs1 = require("../render/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _viewJs = require("../View.js");
var _viewJsDefault = parcelHelpers.interopDefault(_viewJs);
var _assertsJs = require("../asserts.js");
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
/**
 * @typedef {function(import("../Map.js").FrameState):HTMLElement} RenderFunction
 */ /**
 * @typedef {'sourceready'|'change:source'} LayerEventType
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     LayerEventType, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|LayerEventType|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */ /**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../Map.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number | undefined} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */ /**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 * A `sourceready` event is fired when the layer's source is ready.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 * @fires import("../events/Event.js").BaseEvent#sourceready
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */ class Layer extends (0, _baseJsDefault.default) {
    /**
   * @param {Options<SourceType>} options Layer options.
   */ constructor(options){
        const baseOptions = Object.assign({}, options);
        delete baseOptions.source;
        super(baseOptions);
        /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {LayerOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.mapPrecomposeKey_ = null;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.mapRenderKey_ = null;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.sourceChangeKey_ = null;
        /**
     * @private
     * @type {RendererType}
     */ this.renderer_ = null;
        /**
     * @private
     * @type {boolean}
     */ this.sourceReady_ = false;
        /**
     * @protected
     * @type {boolean}
     */ this.rendered = false;
        // Overwrite default render method with a custom one
        if (options.render) this.render = options.render;
        if (options.map) this.setMap(options.map);
        this.addChangeListener((0, _propertyJsDefault.default).SOURCE, this.handleSourcePropertyChange_);
        const source = options.source ? /** @type {SourceType} */ options.source : null;
        this.setSource(source);
    }
    /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */ getLayersArray(array) {
        array = array ? array : [];
        array.push(this);
        return array;
    }
    /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */ getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
    }
    /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */ getSource() {
        return /** @type {SourceType} */ this.get((0, _propertyJsDefault.default).SOURCE) || null;
    }
    /**
   * @return {SourceType|null} The source being rendered.
   */ getRenderSource() {
        return this.getSource();
    }
    /**
   * @return {import("../source/Source.js").State} Source state.
   */ getSourceState() {
        const source = this.getSource();
        return !source ? 'undefined' : source.getState();
    }
    /**
   * @private
   */ handleSourceChange_() {
        this.changed();
        if (this.sourceReady_ || this.getSource().getState() !== 'ready') return;
        this.sourceReady_ = true;
        this.dispatchEvent('sourceready');
    }
    /**
   * @private
   */ handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
            (0, _eventsJs.unlistenByKey)(this.sourceChangeKey_);
            this.sourceChangeKey_ = null;
        }
        this.sourceReady_ = false;
        const source = this.getSource();
        if (source) {
            this.sourceChangeKey_ = (0, _eventsJs.listen)(source, (0, _eventTypeJsDefault.default).CHANGE, this.handleSourceChange_, this);
            if (source.getState() === 'ready') {
                this.sourceReady_ = true;
                setTimeout(()=>{
                    this.dispatchEvent('sourceready');
                }, 0);
            }
        }
        this.changed();
    }
    /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */ getFeatures(pixel) {
        if (!this.renderer_) return Promise.resolve([]);
        return this.renderer_.getFeatures(pixel);
    }
    /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */ getData(pixel) {
        if (!this.renderer_ || !this.rendered) return null;
        return this.renderer_.getData(pixel);
    }
    /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */ isVisible(view) {
        let frameState;
        const map = this.getMapInternal();
        if (!view && map) view = map.getView();
        if (view instanceof (0, _viewJsDefault.default)) frameState = {
            viewState: view.getState(),
            extent: view.calculateExtent()
        };
        else frameState = view;
        if (!frameState.layerStatesArray && map) frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
        let layerState;
        if (frameState.layerStatesArray) layerState = frameState.layerStatesArray.find((layerState)=>layerState.layer === this);
        else layerState = this.getLayerState();
        const layerExtent = this.getExtent();
        return inView(layerState, frameState.viewState) && (!layerExtent || (0, _extentJs.intersects)(layerExtent, frameState.extent));
    }
    /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */ getAttributions(view) {
        if (!this.isVisible(view)) return [];
        let getAttributions;
        const source = this.getSource();
        if (source) getAttributions = source.getAttributions();
        if (!getAttributions) return [];
        const frameState = view instanceof (0, _viewJsDefault.default) ? view.getViewStateAndExtent() : view;
        let attributions = getAttributions(frameState);
        if (!Array.isArray(attributions)) attributions = [
            attributions
        ];
        return attributions;
    }
    /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */ render(frameState, target) {
        const layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
            this.rendered = true;
            return layerRenderer.renderFrame(frameState, target);
        }
        return null;
    }
    /**
   * Called when a layer is not visible during a map render.
   */ unrender() {
        this.rendered = false;
    }
    /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */ setMapInternal(map) {
        if (!map) this.unrender();
        this.set((0, _propertyJsDefault.default).MAP, map);
    }
    /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */ getMapInternal() {
        return this.get((0, _propertyJsDefault.default).MAP);
    }
    /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */ setMap(map) {
        if (this.mapPrecomposeKey_) {
            (0, _eventsJs.unlistenByKey)(this.mapPrecomposeKey_);
            this.mapPrecomposeKey_ = null;
        }
        if (!map) this.changed();
        if (this.mapRenderKey_) {
            (0, _eventsJs.unlistenByKey)(this.mapRenderKey_);
            this.mapRenderKey_ = null;
        }
        if (map) {
            this.mapPrecomposeKey_ = (0, _eventsJs.listen)(map, (0, _eventTypeJsDefault1.default).PRECOMPOSE, function(evt) {
                const renderEvent = /** @type {import("../render/Event.js").default} */ evt;
                const layerStatesArray = renderEvent.frameState.layerStatesArray;
                const layerState = this.getLayerState(false);
                (0, _assertsJs.assert)(!layerStatesArray.some(function(arrayLayerState) {
                    return arrayLayerState.layer === layerState.layer;
                }), 'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.');
                layerStatesArray.push(layerState);
            }, this);
            this.mapRenderKey_ = (0, _eventsJs.listen)(this, (0, _eventTypeJsDefault.default).CHANGE, map.render, map);
            this.changed();
        }
    }
    /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */ setSource(source) {
        this.set((0, _propertyJsDefault.default).SOURCE, source);
    }
    /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */ getRenderer() {
        if (!this.renderer_) this.renderer_ = this.createRenderer();
        return this.renderer_;
    }
    /**
   * @return {boolean} The layer has a renderer.
   */ hasRenderer() {
        return !!this.renderer_;
    }
    /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */ createRenderer() {
        return null;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        if (this.renderer_) {
            this.renderer_.dispose();
            delete this.renderer_;
        }
        this.setSource(null);
        super.disposeInternal();
    }
}
function inView(layerState, viewState) {
    if (!layerState.visible) return false;
    const resolution = viewState.resolution;
    if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) return false;
    const zoom = viewState.zoom;
    return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
exports.default = Layer;

},{"./Base.js":"eAjKR","../events/EventType.js":"3uT2C","./Property.js":"50gL3","../render/EventType.js":"1ajEk","../View.js":"fJPFQ","../asserts.js":"k0OL6","../extent.js":"bGUel","../events.js":"lh4km","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eAjKR":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/Base
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _utilJs = require("../util.js");
var _assertsJs = require("../asserts.js");
var _mathJs = require("../math.js");
/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */ /**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */ class BaseLayer extends (0, _objectJsDefault.default) {
    /**
   * @param {Options} options Layer options.
   */ constructor(options){
        super();
        /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {BaseLayerOnSignature<void>}
     */ this.un;
        /**
     * @type {BackgroundColor|false}
     * @private
     */ this.background_ = options.background;
        /**
     * @type {Object<string, *>}
     */ const properties = Object.assign({}, options);
        if (typeof options.properties === 'object') {
            delete properties.properties;
            Object.assign(properties, options.properties);
        }
        properties[(0, _propertyJsDefault.default).OPACITY] = options.opacity !== undefined ? options.opacity : 1;
        (0, _assertsJs.assert)(typeof properties[(0, _propertyJsDefault.default).OPACITY] === 'number', 'Layer opacity must be a number');
        properties[(0, _propertyJsDefault.default).VISIBLE] = options.visible !== undefined ? options.visible : true;
        properties[(0, _propertyJsDefault.default).Z_INDEX] = options.zIndex;
        properties[(0, _propertyJsDefault.default).MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
        properties[(0, _propertyJsDefault.default).MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
        properties[(0, _propertyJsDefault.default).MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
        properties[(0, _propertyJsDefault.default).MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;
        /**
     * @type {string}
     * @private
     */ this.className_ = properties.className !== undefined ? properties.className : 'ol-layer';
        delete properties.className;
        this.setProperties(properties);
        /**
     * @type {import("./Layer.js").State}
     * @private
     */ this.state_ = null;
    }
    /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */ getBackground() {
        return this.background_;
    }
    /**
   * @return {string} CSS class name.
   */ getClassName() {
        return this.className_;
    }
    /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */ getLayerState(managed) {
        /** @type {import("./Layer.js").State} */ const state = this.state_ || /** @type {?} */ {
            layer: this,
            managed: managed === undefined ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = (0, _mathJs.clamp)(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
    }
    /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */ getLayersArray(array) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */ getLayerStatesArray(states) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */ getExtent() {
        return /** @type {import("../extent.js").Extent|undefined} */ this.get((0, _propertyJsDefault.default).EXTENT);
    }
    /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */ getMaxResolution() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MAX_RESOLUTION);
    }
    /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */ getMinResolution() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MIN_RESOLUTION);
    }
    /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */ getMinZoom() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MIN_ZOOM);
    }
    /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */ getMaxZoom() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MAX_ZOOM);
    }
    /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */ getOpacity() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).OPACITY);
    }
    /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */ getSourceState() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */ getVisible() {
        return /** @type {boolean} */ this.get((0, _propertyJsDefault.default).VISIBLE);
    }
    /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */ getZIndex() {
        return /** @type {number|undefined} */ this.get((0, _propertyJsDefault.default).Z_INDEX);
    }
    /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */ setBackground(background) {
        this.background_ = background;
        this.changed();
    }
    /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */ setExtent(extent) {
        this.set((0, _propertyJsDefault.default).EXTENT, extent);
    }
    /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */ setMaxResolution(maxResolution) {
        this.set((0, _propertyJsDefault.default).MAX_RESOLUTION, maxResolution);
    }
    /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */ setMinResolution(minResolution) {
        this.set((0, _propertyJsDefault.default).MIN_RESOLUTION, minResolution);
    }
    /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */ setMaxZoom(maxZoom) {
        this.set((0, _propertyJsDefault.default).MAX_ZOOM, maxZoom);
    }
    /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */ setMinZoom(minZoom) {
        this.set((0, _propertyJsDefault.default).MIN_ZOOM, minZoom);
    }
    /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */ setOpacity(opacity) {
        (0, _assertsJs.assert)(typeof opacity === 'number', 'Layer opacity must be a number');
        this.set((0, _propertyJsDefault.default).OPACITY, opacity);
    }
    /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */ setVisible(visible) {
        this.set((0, _propertyJsDefault.default).VISIBLE, visible);
    }
    /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */ setZIndex(zindex) {
        this.set((0, _propertyJsDefault.default).Z_INDEX, zindex);
    }
    /**
   * Clean up.
   */ disposeInternal() {
        if (this.state_) {
            this.state_.layer = null;
            this.state_ = null;
        }
        super.disposeInternal();
    }
}
exports.default = BaseLayer;

},{"../Object.js":"N6yIf","./Property.js":"50gL3","../util.js":"l1iPW","../asserts.js":"k0OL6","../math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"50gL3":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/Property
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    OPACITY: 'opacity',
    VISIBLE: 'visible',
    EXTENT: 'extent',
    Z_INDEX: 'zIndex',
    MAX_RESOLUTION: 'maxResolution',
    MIN_RESOLUTION: 'minResolution',
    MAX_ZOOM: 'maxZoom',
    MIN_ZOOM: 'minZoom',
    SOURCE: 'source',
    MAP: 'map'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1ajEk":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/EventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */ PRERENDER: 'prerender',
    /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */ POSTRENDER: 'postrender',
    /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */ PRECOMPOSE: 'precompose',
    /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */ POSTCOMPOSE: 'postcompose',
    /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */ RENDERCOMPLETE: 'rendercomplete'
}; /**
 * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
 */  /**
 * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fJPFQ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/View
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */ parcelHelpers.export(exports, "createCenterConstraint", ()=>createCenterConstraint);
/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */ parcelHelpers.export(exports, "createResolutionConstraint", ()=>createResolutionConstraint);
/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createRotationConstraint", ()=>createRotationConstraint);
/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */ parcelHelpers.export(exports, "isNoopAnimation", ()=>isNoopAnimation);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _viewHintJs = require("./ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _viewPropertyJs = require("./ViewProperty.js");
var _viewPropertyJsDefault = parcelHelpers.interopDefault(_viewPropertyJs);
var _commonJs = require("./tilegrid/common.js");
var _projJs = require("./proj.js");
var _functionsJs = require("./functions.js");
var _coordinateJs = require("./coordinate.js");
var _assertsJs = require("./asserts.js");
var _centerconstraintJs = require("./centerconstraint.js");
var _mathJs = require("./math.js");
var _resolutionconstraintJs = require("./resolutionconstraint.js");
var _rotationconstraintJs = require("./rotationconstraint.js");
var _easingJs = require("./easing.js");
var _extentJs = require("./extent.js");
var _arrayJs = require("./array.js");
var _polygonJs = require("./geom/Polygon.js");
/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */ /**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */ /**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to
 * fit the extent into. Defaults to the size of the map the view is associated with.
 * If no map or multiple maps are connected to the view, provide the desired box size
 * (e.g. `map.getSize()`).
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */ /**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */ /**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */ /**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center (in view projection coordinates).
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */ /**
 * Like {@link import("./Map.js").FrameState}, but just `viewState` and `extent`.
 * @typedef {Object} ViewStateLayerStateExtent
 * @property {State} viewState View state.
 * @property {import("./extent.js").Extent} extent Extent (in user projection coordinates).
 * @property {Array<import("./layer/Layer.js").State>} [layerStatesArray] Layer states.
 */ /**
 * Default min zoom level for the map view.
 * @type {number}
 */ const DEFAULT_MIN_ZOOM = 0;
/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */ /**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */ class View extends (0, _objectJsDefault.default) {
    /**
   * @param {ViewOptions} [options] View options.
   */ constructor(options){
        super();
        /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {ViewOnSignature<void>}
     */ this.un;
        options = Object.assign({}, options);
        /**
     * @private
     * @type {Array<number>}
     */ this.hints_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {Array<Array<Animation>>}
     */ this.animations_ = [];
        /**
     * @private
     * @type {number|undefined}
     */ this.updateAnimationKey_;
        /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */ this.projection_ = (0, _projJs.createProjection)(options.projection, 'EPSG:3857');
        /**
     * @private
     * @type {import("./size.js").Size}
     */ this.viewportSize_ = [
            100,
            100
        ];
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */ this.targetCenter_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.targetResolution_;
        /**
     * @private
     * @type {number|undefined}
     */ this.targetRotation_;
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */ this.nextCenter_ = null;
        /**
     * @private
     * @type {number}
     */ this.nextResolution_;
        /**
     * @private
     * @type {number}
     */ this.nextRotation_;
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */ this.cancelAnchor_ = undefined;
        if (options.projection) (0, _projJs.disableCoordinateWarning)();
        if (options.center) options.center = (0, _projJs.fromUserCoordinate)(options.center, this.projection_);
        if (options.extent) options.extent = (0, _projJs.fromUserExtent)(options.extent, this.projection_);
        this.applyOptions_(options);
    }
    /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */ applyOptions_(options) {
        const properties = Object.assign({}, options);
        for(const key in 0, _viewPropertyJsDefault.default)delete properties[key];
        this.setProperties(properties, true);
        const resolutionConstraintInfo = createResolutionConstraint(options);
        /**
     * @private
     * @type {number}
     */ this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        /**
     * @private
     * @type {number}
     */ this.minResolution_ = resolutionConstraintInfo.minResolution;
        /**
     * @private
     * @type {number}
     */ this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        /**
     * @private
     * @type {Array<number>|undefined}
     */ this.resolutions_ = options.resolutions;
        /**
     * @type {Array<number>|undefined}
     * @private
     */ this.padding_ = options.padding;
        /**
     * @private
     * @type {number}
     */ this.minZoom_ = resolutionConstraintInfo.minZoom;
        const centerConstraint = createCenterConstraint(options);
        const resolutionConstraint = resolutionConstraintInfo.constraint;
        const rotationConstraint = createRotationConstraint(options);
        /**
     * @private
     * @type {Constraints}
     */ this.constraints_ = {
            center: centerConstraint,
            resolution: resolutionConstraint,
            rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== undefined ? options.rotation : 0);
        this.setCenterInternal(options.center !== undefined ? options.center : null);
        if (options.resolution !== undefined) this.setResolution(options.resolution);
        else if (options.zoom !== undefined) this.setZoom(options.zoom);
    }
    /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */ get padding() {
        return this.padding_;
    }
    set padding(padding) {
        let oldPadding = this.padding_;
        this.padding_ = padding;
        const center = this.getCenterInternal();
        if (center) {
            const newPadding = padding || [
                0,
                0,
                0,
                0
            ];
            oldPadding = oldPadding || [
                0,
                0,
                0,
                0
            ];
            const resolution = this.getResolution();
            const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
            const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
            this.setCenterInternal([
                center[0] + offsetX,
                center[1] - offsetY
            ]);
        }
    }
    /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */ getUpdatedOptions_(newOptions) {
        const options = this.getProperties();
        // preserve resolution (or zoom)
        if (options.resolution !== undefined) options.resolution = this.getResolution();
        else options.zoom = this.getZoom();
        // preserve center
        options.center = this.getCenterInternal();
        // preserve rotation
        options.rotation = this.getRotation();
        return Object.assign({}, options, newOptions);
    }
    /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */ animate(var_args) {
        if (this.isDef() && !this.getAnimating()) this.resolveConstraints(0);
        const args = new Array(arguments.length);
        for(let i = 0; i < args.length; ++i){
            let options = arguments[i];
            if (options.center) {
                options = Object.assign({}, options);
                options.center = (0, _projJs.fromUserCoordinate)(options.center, this.getProjection());
            }
            if (options.anchor) {
                options = Object.assign({}, options);
                options.anchor = (0, _projJs.fromUserCoordinate)(options.anchor, this.getProjection());
            }
            args[i] = options;
        }
        this.animateInternal.apply(this, args);
    }
    /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */ animateInternal(var_args) {
        let animationCount = arguments.length;
        let callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
            callback = arguments[animationCount - 1];
            --animationCount;
        }
        let i = 0;
        for(; i < animationCount && !this.isDef(); ++i){
            // if view properties are not yet set, shortcut to the final state
            const state = arguments[i];
            if (state.center) this.setCenterInternal(state.center);
            if (state.zoom !== undefined) this.setZoom(state.zoom);
            else if (state.resolution) this.setResolution(state.resolution);
            if (state.rotation !== undefined) this.setRotation(state.rotation);
        }
        if (i === animationCount) {
            if (callback) animationCallback(callback, true);
            return;
        }
        let start = Date.now();
        let center = this.targetCenter_.slice();
        let resolution = this.targetResolution_;
        let rotation = this.targetRotation_;
        const series = [];
        for(; i < animationCount; ++i){
            const options = /** @type {AnimationOptions} */ arguments[i];
            const animation = {
                start: start,
                complete: false,
                anchor: options.anchor,
                duration: options.duration !== undefined ? options.duration : 1000,
                easing: options.easing || (0, _easingJs.inAndOut),
                callback: callback
            };
            if (options.center) {
                animation.sourceCenter = center;
                animation.targetCenter = options.center.slice();
                center = animation.targetCenter;
            }
            if (options.zoom !== undefined) {
                animation.sourceResolution = resolution;
                animation.targetResolution = this.getResolutionForZoom(options.zoom);
                resolution = animation.targetResolution;
            } else if (options.resolution) {
                animation.sourceResolution = resolution;
                animation.targetResolution = options.resolution;
                resolution = animation.targetResolution;
            }
            if (options.rotation !== undefined) {
                animation.sourceRotation = rotation;
                const delta = (0, _mathJs.modulo)(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                animation.targetRotation = rotation + delta;
                rotation = animation.targetRotation;
            }
            // check if animation is a no-op
            if (isNoopAnimation(animation)) animation.complete = true;
            else start += animation.duration;
            series.push(animation);
        }
        this.animations_.push(series);
        this.setHint((0, _viewHintJsDefault.default).ANIMATING, 1);
        this.updateAnimations_();
    }
    /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */ getAnimating() {
        return this.hints_[(0, _viewHintJsDefault.default).ANIMATING] > 0;
    }
    /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */ getInteracting() {
        return this.hints_[(0, _viewHintJsDefault.default).INTERACTING] > 0;
    }
    /**
   * Cancel any ongoing animations.
   * @api
   */ cancelAnimations() {
        this.setHint((0, _viewHintJsDefault.default).ANIMATING, -this.hints_[(0, _viewHintJsDefault.default).ANIMATING]);
        let anchor;
        for(let i = 0, ii = this.animations_.length; i < ii; ++i){
            const series = this.animations_[i];
            if (series[0].callback) animationCallback(series[0].callback, false);
            if (!anchor) for(let j = 0, jj = series.length; j < jj; ++j){
                const animation = series[j];
                if (!animation.complete) {
                    anchor = animation.anchor;
                    break;
                }
            }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
    }
    /**
   * Update all animations.
   */ updateAnimations_() {
        if (this.updateAnimationKey_ !== undefined) {
            cancelAnimationFrame(this.updateAnimationKey_);
            this.updateAnimationKey_ = undefined;
        }
        if (!this.getAnimating()) return;
        const now = Date.now();
        let more = false;
        for(let i = this.animations_.length - 1; i >= 0; --i){
            const series = this.animations_[i];
            let seriesComplete = true;
            for(let j = 0, jj = series.length; j < jj; ++j){
                const animation = series[j];
                if (animation.complete) continue;
                const elapsed = now - animation.start;
                let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                if (fraction >= 1) {
                    animation.complete = true;
                    fraction = 1;
                } else seriesComplete = false;
                const progress = animation.easing(fraction);
                if (animation.sourceCenter) {
                    const x0 = animation.sourceCenter[0];
                    const y0 = animation.sourceCenter[1];
                    const x1 = animation.targetCenter[0];
                    const y1 = animation.targetCenter[1];
                    this.nextCenter_ = animation.targetCenter;
                    const x = x0 + progress * (x1 - x0);
                    const y = y0 + progress * (y1 - y0);
                    this.targetCenter_ = [
                        x,
                        y
                    ];
                }
                if (animation.sourceResolution && animation.targetResolution) {
                    const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
                    if (animation.anchor) {
                        const size = this.getViewportSize_(this.getRotation());
                        const constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                        this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                    }
                    this.nextResolution_ = animation.targetResolution;
                    this.targetResolution_ = resolution;
                    this.applyTargetState_(true);
                }
                if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
                    const rotation = progress === 1 ? (0, _mathJs.modulo)(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
                    if (animation.anchor) {
                        const constrainedRotation = this.constraints_.rotation(rotation, true);
                        this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                    }
                    this.nextRotation_ = animation.targetRotation;
                    this.targetRotation_ = rotation;
                }
                this.applyTargetState_(true);
                more = true;
                if (!animation.complete) break;
            }
            if (seriesComplete) {
                this.animations_[i] = null;
                this.setHint((0, _viewHintJsDefault.default).ANIMATING, -1);
                this.nextCenter_ = null;
                this.nextResolution_ = NaN;
                this.nextRotation_ = NaN;
                const callback = series[0].callback;
                if (callback) animationCallback(callback, true);
            }
        }
        // prune completed series
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === undefined) this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
    }
    /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */ calculateCenterRotate(rotation, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        if (currentCenter !== undefined) {
            center = [
                currentCenter[0] - anchor[0],
                currentCenter[1] - anchor[1]
            ];
            (0, _coordinateJs.rotate)(center, rotation - this.getRotation());
            (0, _coordinateJs.add)(center, anchor);
        }
        return center;
    }
    /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */ calculateCenterZoom(resolution, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        const currentResolution = this.getResolution();
        if (currentCenter !== undefined && currentResolution !== undefined) {
            const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
            const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
            center = [
                x,
                y
            ];
        }
        return center;
    }
    /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */ getViewportSize_(rotation) {
        const size = this.viewportSize_;
        if (rotation) {
            const w = size[0];
            const h = size[1];
            return [
                Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
                Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
            ];
        }
        return size;
    }
    /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */ setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [
            100,
            100
        ];
        if (!this.getAnimating()) this.resolveConstraints(0);
    }
    /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */ getCenter() {
        const center = this.getCenterInternal();
        if (!center) return center;
        return (0, _projJs.toUserCoordinate)(center, this.getProjection());
    }
    /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */ getCenterInternal() {
        return /** @type {import("./coordinate.js").Coordinate|undefined} */ this.get((0, _viewPropertyJsDefault.default).CENTER);
    }
    /**
   * @return {Constraints} Constraints.
   */ getConstraints() {
        return this.constraints_;
    }
    /**
   * @return {boolean} Resolution constraint is set
   */ getConstrainResolution() {
        return this.get('constrainResolution');
    }
    /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */ getHints(hints) {
        if (hints !== undefined) {
            hints[0] = this.hints_[0];
            hints[1] = this.hints_[1];
            return hints;
        }
        return this.hints_.slice();
    }
    /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */ calculateExtent(size) {
        const extent = this.calculateExtentInternal(size);
        return (0, _projJs.toUserExtent)(extent, this.getProjection());
    }
    /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */ calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        const center = /** @type {!import("./coordinate.js").Coordinate} */ this.getCenterInternal();
        (0, _assertsJs.assert)(center, 'The view center is not defined');
        const resolution = /** @type {!number} */ this.getResolution();
        (0, _assertsJs.assert)(resolution !== undefined, 'The view resolution is not defined');
        const rotation = /** @type {!number} */ this.getRotation();
        (0, _assertsJs.assert)(rotation !== undefined, 'The view rotation is not defined');
        return (0, _extentJs.getForViewAndSize)(center, resolution, rotation, size);
    }
    /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */ getMaxResolution() {
        return this.maxResolution_;
    }
    /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */ getMinResolution() {
        return this.minResolution_;
    }
    /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */ getMaxZoom() {
        return /** @type {number} */ this.getZoomForResolution(this.minResolution_);
    }
    /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */ setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
            maxZoom: zoom
        }));
    }
    /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */ getMinZoom() {
        return /** @type {number} */ this.getZoomForResolution(this.maxResolution_);
    }
    /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */ setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
            minZoom: zoom
        }));
    }
    /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */ setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({
            constrainResolution: enabled
        }));
    }
    /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */ getProjection() {
        return this.projection_;
    }
    /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */ getResolution() {
        return /** @type {number|undefined} */ this.get((0, _viewPropertyJsDefault.default).RESOLUTION);
    }
    /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */ getResolutions() {
        return this.resolutions_;
    }
    /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */ getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal((0, _projJs.fromUserExtent)(extent, this.getProjection()), size);
    }
    /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */ getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        const xResolution = (0, _extentJs.getWidth)(extent) / size[0];
        const yResolution = (0, _extentJs.getHeight)(extent) / size[1];
        return Math.max(xResolution, yResolution);
    }
    /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */ getResolutionForValueFunction(power) {
        power = power || 2;
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return(/**
       * @param {number} value Value.
       * @return {number} Resolution.
       */ function(value) {
            const resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
        });
    }
    /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */ getRotation() {
        return /** @type {number} */ this.get((0, _viewPropertyJsDefault.default).ROTATION);
    }
    /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */ getValueForResolutionFunction(power) {
        const logPower = Math.log(power || 2);
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / logPower;
        return(/**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */ function(resolution) {
            const value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
        });
    }
    /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */ getViewportSizeMinusPadding_(rotation) {
        let size = this.getViewportSize_(rotation);
        const padding = this.padding_;
        if (padding) size = [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
        ];
        return size;
    }
    /**
   * @return {State} View state.
   */ getState() {
        const projection = this.getProjection();
        const resolution = this.getResolution();
        const rotation = this.getRotation();
        let center = /** @type {import("./coordinate.js").Coordinate} */ this.getCenterInternal();
        const padding = this.padding_;
        if (padding) {
            const reducedSize = this.getViewportSizeMinusPadding_();
            center = calculateCenterOn(center, this.getViewportSize_(), [
                reducedSize[0] / 2 + padding[3],
                reducedSize[1] / 2 + padding[0]
            ], resolution, rotation);
        }
        return {
            center: center.slice(0),
            projection: projection !== undefined ? projection : null,
            resolution: resolution,
            nextCenter: this.nextCenter_,
            nextResolution: this.nextResolution_,
            nextRotation: this.nextRotation_,
            rotation: rotation,
            zoom: this.getZoom()
        };
    }
    /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */ getViewStateAndExtent() {
        return {
            viewState: this.getState(),
            extent: this.calculateExtent()
        };
    }
    /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */ getZoom() {
        let zoom;
        const resolution = this.getResolution();
        if (resolution !== undefined) zoom = this.getZoomForResolution(resolution);
        return zoom;
    }
    /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */ getZoomForResolution(resolution) {
        let offset = this.minZoom_ || 0;
        let max, zoomFactor;
        if (this.resolutions_) {
            const nearest = (0, _arrayJs.linearFindNearest)(this.resolutions_, resolution, 1);
            offset = nearest;
            max = this.resolutions_[nearest];
            if (nearest == this.resolutions_.length - 1) zoomFactor = 2;
            else zoomFactor = max / this.resolutions_[nearest + 1];
        } else {
            max = this.maxResolution_;
            zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
    }
    /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */ getResolutionForZoom(zoom) {
        if (this.resolutions_) {
            if (this.resolutions_.length <= 1) return 0;
            const baseLevel = (0, _mathJs.clamp)(Math.floor(zoom), 0, this.resolutions_.length - 2);
            const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
            return this.resolutions_[baseLevel] / Math.pow(zoomFactor, (0, _mathJs.clamp)(zoom - baseLevel, 0, 1));
        }
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
    /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */ fit(geometryOrExtent, options) {
        /** @type {import("./geom/SimpleGeometry.js").default} */ let geometry;
        (0, _assertsJs.assert)(Array.isArray(geometryOrExtent) || typeof /** @type {?} */ geometryOrExtent.getSimplifiedGeometry === 'function', 'Invalid extent or geometry provided as `geometry`');
        if (Array.isArray(geometryOrExtent)) {
            (0, _assertsJs.assert)(!(0, _extentJs.isEmpty)(geometryOrExtent), 'Cannot fit empty extent provided as `geometry`');
            const extent = (0, _projJs.fromUserExtent)(geometryOrExtent, this.getProjection());
            geometry = (0, _polygonJs.fromExtent)(extent);
        } else if (geometryOrExtent.getType() === 'Circle') {
            const extent = (0, _projJs.fromUserExtent)(geometryOrExtent.getExtent(), this.getProjection());
            geometry = (0, _polygonJs.fromExtent)(extent);
            geometry.rotate(this.getRotation(), (0, _extentJs.getCenter)(extent));
        } else {
            const userProjection = (0, _projJs.getUserProjection)();
            if (userProjection) geometry = /** @type {import("./geom/SimpleGeometry.js").default} */ geometryOrExtent.clone().transform(userProjection, this.getProjection());
            else geometry = geometryOrExtent;
        }
        this.fitInternal(geometry, options);
    }
    /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */ rotatedExtentForGeometry(geometry) {
        const rotation = this.getRotation();
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(-rotation);
        const coords = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        let minRotX = Infinity;
        let minRotY = Infinity;
        let maxRotX = -Infinity;
        let maxRotY = -Infinity;
        for(let i = 0, ii = coords.length; i < ii; i += stride){
            const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
            const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
            minRotX = Math.min(minRotX, rotX);
            minRotY = Math.min(minRotY, rotY);
            maxRotX = Math.max(maxRotX, rotX);
            maxRotY = Math.max(maxRotY, rotY);
        }
        return [
            minRotX,
            minRotY,
            maxRotX,
            maxRotY
        ];
    }
    /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */ fitInternal(geometry, options) {
        options = options || {};
        let size = options.size;
        if (!size) size = this.getViewportSizeMinusPadding_();
        const padding = options.padding !== undefined ? options.padding : [
            0,
            0,
            0,
            0
        ];
        const nearest = options.nearest !== undefined ? options.nearest : false;
        let minResolution;
        if (options.minResolution !== undefined) minResolution = options.minResolution;
        else if (options.maxZoom !== undefined) minResolution = this.getResolutionForZoom(options.maxZoom);
        else minResolution = 0;
        const rotatedExtent = this.rotatedExtentForGeometry(geometry);
        // calculate resolution
        let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        // calculate center
        const rotation = this.getRotation();
        const sinAngle = Math.sin(rotation);
        const cosAngle = Math.cos(rotation);
        const centerRot = (0, _extentJs.getCenter)(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        const center = this.getConstrainedCenter([
            centerX,
            centerY
        ], resolution);
        const callback = options.callback ? options.callback : (0, _functionsJs.VOID);
        if (options.duration !== undefined) this.animateInternal({
            resolution: resolution,
            center: center,
            duration: options.duration,
            easing: options.easing
        }, callback);
        else {
            this.targetResolution_ = resolution;
            this.targetCenter_ = center;
            this.applyTargetState_(false, true);
            animationCallback(callback, true);
        }
    }
    /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */ centerOn(coordinate, size, position) {
        this.centerOnInternal((0, _projJs.fromUserCoordinate)(coordinate, this.getProjection()), size, position);
    }
    /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */ centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
    }
    /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */ calculateCenterShift(center, resolution, rotation, size) {
        let centerShift;
        const padding = this.padding_;
        if (padding && center) {
            const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
            const shiftedCenter = calculateCenterOn(center, size, [
                reducedSize[0] / 2 + padding[3],
                reducedSize[1] / 2 + padding[0]
            ], resolution, rotation);
            centerShift = [
                center[0] - shiftedCenter[0],
                center[1] - shiftedCenter[1]
            ];
        }
        return centerShift;
    }
    /**
   * @return {boolean} Is defined.
   */ isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== undefined;
    }
    /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */ adjustCenter(deltaCoordinates) {
        const center = (0, _projJs.toUserCoordinate)(this.targetCenter_, this.getProjection());
        this.setCenter([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1]
        ]);
    }
    /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */ adjustCenterInternal(deltaCoordinates) {
        const center = this.targetCenter_;
        this.setCenterInternal([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1]
        ]);
    }
    /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ adjustResolution(ratio, anchor) {
        anchor = anchor && (0, _projJs.fromUserCoordinate)(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
    }
    /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ adjustResolutionInternal(ratio, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const size = this.getViewportSize_(this.getRotation());
        const newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
        if (anchor) this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
    }
    /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
    }
    /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */ adjustRotation(delta, anchor) {
        if (anchor) anchor = (0, _projJs.fromUserCoordinate)(anchor, this.getProjection());
        this.adjustRotationInternal(delta, anchor);
    }
    /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */ adjustRotationInternal(delta, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
        if (anchor) this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        this.targetRotation_ += delta;
        this.applyTargetState_();
    }
    /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */ setCenter(center) {
        this.setCenterInternal(center ? (0, _projJs.fromUserCoordinate)(center, this.getProjection()) : center);
    }
    /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */ setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
    }
    /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */ setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
    }
    /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */ setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
    }
    /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */ setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
    }
    /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */ setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
    }
    /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */ applyTargetState_(doNotCancelAnims, forceMoving) {
        const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
        // compute rotation
        const newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
        const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (this.get((0, _viewPropertyJsDefault.default).ROTATION) !== newRotation) this.set((0, _viewPropertyJsDefault.default).ROTATION, newRotation);
        if (this.get((0, _viewPropertyJsDefault.default).RESOLUTION) !== newResolution) {
            this.set((0, _viewPropertyJsDefault.default).RESOLUTION, newResolution);
            this.set('zoom', this.getZoom(), true);
        }
        if (!newCenter || !this.get((0, _viewPropertyJsDefault.default).CENTER) || !(0, _coordinateJs.equals)(this.get((0, _viewPropertyJsDefault.default).CENTER), newCenter)) this.set((0, _viewPropertyJsDefault.default).CENTER, newCenter);
        if (this.getAnimating() && !doNotCancelAnims) this.cancelAnimations();
        this.cancelAnchor_ = undefined;
    }
    /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== undefined ? duration : 200;
        const direction = resolutionDirection || 0;
        const newRotation = this.constraints_.rotation(this.targetRotation_);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
        const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (duration === 0 && !this.cancelAnchor_) {
            this.targetResolution_ = newResolution;
            this.targetRotation_ = newRotation;
            this.targetCenter_ = newCenter;
            this.applyTargetState_();
            return;
        }
        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
        this.cancelAnchor_ = undefined;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !(0, _coordinateJs.equals)(this.getCenterInternal(), newCenter)) {
            if (this.getAnimating()) this.cancelAnimations();
            this.animateInternal({
                rotation: newRotation,
                center: newCenter,
                resolution: newResolution,
                duration: duration,
                easing: (0, _easingJs.easeOut),
                anchor: anchor
            });
        }
    }
    /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */ beginInteraction() {
        this.resolveConstraints(0);
        this.setHint((0, _viewHintJsDefault.default).INTERACTING, 1);
    }
    /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && (0, _projJs.fromUserCoordinate)(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
    }
    /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ endInteractionInternal(duration, resolutionDirection, anchor) {
        if (!this.getInteracting()) return;
        this.setHint((0, _viewHintJsDefault.default).INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
    }
    /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */ getConstrainedCenter(targetCenter, targetResolution) {
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(targetCenter, targetResolution || this.getResolution(), size);
    }
    /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */ getConstrainedZoom(targetZoom, direction) {
        const targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(this.getConstrainedResolution(targetRes, direction));
    }
    /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */ getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
    }
}
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */ function animationCallback(callback, returnValue) {
    setTimeout(function() {
        callback(returnValue);
    }, 0);
}
function createCenterConstraint(options) {
    if (options.extent !== undefined) {
        const smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
        return (0, _centerconstraintJs.createExtent)(options.extent, options.constrainOnlyCenter, smooth);
    }
    const projection = (0, _projJs.createProjection)(options.projection, 'EPSG:3857');
    if (options.multiWorld !== true && projection.isGlobal()) {
        const extent = projection.getExtent().slice();
        extent[0] = -Infinity;
        extent[2] = Infinity;
        return (0, _centerconstraintJs.createExtent)(extent, false, false);
    }
    return 0, _centerconstraintJs.none;
}
function createResolutionConstraint(options) {
    let resolutionConstraint;
    let maxResolution;
    let minResolution;
    // TODO: move these to be ol constants
    // see https://github.com/openlayers/openlayers/issues/2076
    const defaultMaxZoom = 28;
    const defaultZoomFactor = 2;
    let minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
    let maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
    const zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
    const multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
    const smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
    const showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
    const projection = (0, _projJs.createProjection)(options.projection, 'EPSG:3857');
    const projExtent = projection.getExtent();
    let constrainOnlyCenter = options.constrainOnlyCenter;
    let extent = options.extent;
    if (!multiWorld && !extent && projection.isGlobal()) {
        constrainOnlyCenter = false;
        extent = projExtent;
    }
    if (options.resolutions !== undefined) {
        const resolutions = options.resolutions;
        maxResolution = resolutions[minZoom];
        minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
        if (options.constrainResolution) resolutionConstraint = (0, _resolutionconstraintJs.createSnapToResolutions)(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
        else resolutionConstraint = (0, _resolutionconstraintJs.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
        // calculate the default min and max resolution
        const size = !projExtent ? 360 * (0, _projJs.METERS_PER_UNIT).degrees / projection.getMetersPerUnit() : Math.max((0, _extentJs.getWidth)(projExtent), (0, _extentJs.getHeight)(projExtent));
        const defaultMaxResolution = size / (0, _commonJs.DEFAULT_TILE_SIZE) / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
        const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
        // user provided maxResolution takes precedence
        maxResolution = options.maxResolution;
        if (maxResolution !== undefined) minZoom = 0;
        else maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
        // user provided minResolution takes precedence
        minResolution = options.minResolution;
        if (minResolution === undefined) {
            if (options.maxZoom !== undefined) {
                if (options.maxResolution !== undefined) minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                else minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
            } else minResolution = defaultMinResolution;
        }
        // given discrete zoom levels, minResolution may be different than provided
        maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
        minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
        if (options.constrainResolution) resolutionConstraint = (0, _resolutionconstraintJs.createSnapToPower)(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
        else resolutionConstraint = (0, _resolutionconstraintJs.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
    return {
        constraint: resolutionConstraint,
        maxResolution: maxResolution,
        minResolution: minResolution,
        minZoom: minZoom,
        zoomFactor: zoomFactor
    };
}
function createRotationConstraint(options) {
    const enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
    if (enableRotation) {
        const constrainRotation = options.constrainRotation;
        if (constrainRotation === undefined || constrainRotation === true) return (0, _rotationconstraintJs.createSnapToZero)();
        if (constrainRotation === false) return 0, _rotationconstraintJs.none;
        if (typeof constrainRotation === 'number') return (0, _rotationconstraintJs.createSnapToN)(constrainRotation);
        return 0, _rotationconstraintJs.none;
    }
    return 0, _rotationconstraintJs.disable;
}
function isNoopAnimation(animation) {
    if (animation.sourceCenter && animation.targetCenter) {
        if (!(0, _coordinateJs.equals)(animation.sourceCenter, animation.targetCenter)) return false;
    }
    if (animation.sourceResolution !== animation.targetResolution) return false;
    if (animation.sourceRotation !== animation.targetRotation) return false;
    return true;
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */ function calculateCenterOn(coordinate, size, position, resolution, rotation) {
    // calculate rotated position
    const cosAngle = Math.cos(-rotation);
    let sinAngle = Math.sin(-rotation);
    let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution;
    // go back to original angle
    sinAngle = -sinAngle; // go back to original rotation
    const centerX = rotX * cosAngle - rotY * sinAngle;
    const centerY = rotY * cosAngle + rotX * sinAngle;
    return [
        centerX,
        centerY
    ];
}
exports.default = View;

},{"./Object.js":"N6yIf","./ViewHint.js":"9EJlo","./ViewProperty.js":"bUvLh","./tilegrid/common.js":"bQNAJ","./proj.js":"8OK47","./functions.js":"1QSsQ","./coordinate.js":"fqHXJ","./asserts.js":"k0OL6","./centerconstraint.js":"gxpQR","./math.js":"d8zSj","./resolutionconstraint.js":"8VkUn","./rotationconstraint.js":"6TPbY","./easing.js":"jskwM","./extent.js":"bGUel","./array.js":"hyet5","./geom/Polygon.js":"8Vwps","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9EJlo":[function(require,module,exports,__globalThis) {
/**
 * @module ol/ViewHint
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    ANIMATING: 0,
    INTERACTING: 1
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bUvLh":[function(require,module,exports,__globalThis) {
/**
 * @module ol/ViewProperty
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    CENTER: 'center',
    RESOLUTION: 'resolution',
    ROTATION: 'rotation'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bQNAJ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/tilegrid/common
 */ /**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_MAX_ZOOM", ()=>DEFAULT_MAX_ZOOM);
parcelHelpers.export(exports, "DEFAULT_TILE_SIZE", ()=>DEFAULT_TILE_SIZE);
const DEFAULT_MAX_ZOOM = 42;
const DEFAULT_TILE_SIZE = 256;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8OK47":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj
 */ /**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection~Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */ /**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */ parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>(0, _unitsJs.METERS_PER_UNIT));
parcelHelpers.export(exports, "Projection", ()=>(0, _projectionJsDefault.default));
/**
 * @param {boolean} [disable = true] Disable console info about `useGeographic()`
 */ parcelHelpers.export(exports, "disableCoordinateWarning", ()=>disableCoordinateWarning);
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */ parcelHelpers.export(exports, "cloneTransform", ()=>cloneTransform);
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Input coordinate array (same array as input).
 */ parcelHelpers.export(exports, "identityTransform", ()=>identityTransform);
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */ parcelHelpers.export(exports, "addProjection", ()=>addProjection);
/**
 * @param {Array<Projection>} projections Projections.
 */ parcelHelpers.export(exports, "addProjections", ()=>addProjections);
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */ parcelHelpers.export(exports, "get", ()=>get);
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */ parcelHelpers.export(exports, "getPointResolution", ()=>getPointResolution);
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */ parcelHelpers.export(exports, "addEquivalentProjections", ()=>addEquivalentProjections);
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */ parcelHelpers.export(exports, "addEquivalentTransforms", ()=>addEquivalentTransforms);
/**
 * Clear all cached projections and transforms.
 */ parcelHelpers.export(exports, "clearAllProjections", ()=>clearAllProjections);
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */ parcelHelpers.export(exports, "createProjection", ()=>createProjection);
/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */ parcelHelpers.export(exports, "createTransformFromCoordinateTransform", ()=>createTransformFromCoordinateTransform);
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only
 *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate
 *     with only the length it can transform. The other dimensions will be taken unchanged from the
 *     source.
 * @api
 */ parcelHelpers.export(exports, "addCoordinateTransforms", ()=>addCoordinateTransforms);
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */ parcelHelpers.export(exports, "fromLonLat", ()=>fromLonLat);
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */ parcelHelpers.export(exports, "toLonLat", ()=>toLonLat);
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */ parcelHelpers.export(exports, "equivalent", ()=>equivalent);
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */ parcelHelpers.export(exports, "getTransformFromProjections", ()=>getTransformFromProjections);
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */ parcelHelpers.export(exports, "getTransform", ()=>getTransform);
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */ parcelHelpers.export(exports, "transform", ()=>transform);
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */ parcelHelpers.export(exports, "transformExtent", ()=>transformExtent);
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */ parcelHelpers.export(exports, "transformWithProjections", ()=>transformWithProjections);
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */ parcelHelpers.export(exports, "setUserProjection", ()=>setUserProjection);
/**
 * Clear the user projection if set.
 * @api
 */ parcelHelpers.export(exports, "clearUserProjection", ()=>clearUserProjection);
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */ parcelHelpers.export(exports, "getUserProjection", ()=>getUserProjection);
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @api
 */ parcelHelpers.export(exports, "useGeographic", ()=>useGeographic);
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */ parcelHelpers.export(exports, "toUserCoordinate", ()=>toUserCoordinate);
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */ parcelHelpers.export(exports, "fromUserCoordinate", ()=>fromUserCoordinate);
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */ parcelHelpers.export(exports, "toUserExtent", ()=>toUserExtent);
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */ parcelHelpers.export(exports, "fromUserExtent", ()=>fromUserExtent);
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */ parcelHelpers.export(exports, "toUserResolution", ()=>toUserResolution);
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */ parcelHelpers.export(exports, "fromUserResolution", ()=>fromUserResolution);
/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destination).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destination).
 */ parcelHelpers.export(exports, "createSafeCoordinateTransform", ()=>createSafeCoordinateTransform);
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */ parcelHelpers.export(exports, "addCommon", ()=>addCommon);
var _projectionJs = require("./proj/Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
var _epsg3857Js = require("./proj/epsg3857.js");
var _epsg4326Js = require("./proj/epsg4326.js");
var _unitsJs = require("./proj/Units.js");
var _projectionsJs = require("./proj/projections.js");
var _transformsJs = require("./proj/transforms.js");
var _extentJs = require("./extent.js");
var _mathJs = require("./math.js");
var _coordinateJs = require("./coordinate.js");
var _sphereJs = require("./sphere.js");
var _consoleJs = require("./console.js");
let showCoordinateWarning = true;
function disableCoordinateWarning(disable) {
    const hide = disable === undefined ? true : disable;
    showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
    if (output !== undefined) {
        for(let i = 0, ii = input.length; i < ii; ++i)output[i] = input[i];
        output;
    } else output = input.slice();
    return output;
}
function identityTransform(input, output) {
    if (output !== undefined && input !== output) {
        for(let i = 0, ii = input.length; i < ii; ++i)output[i] = input[i];
        input = output;
    }
    return input;
}
function addProjection(projection) {
    (0, _projectionsJs.add)(projection.getCode(), projection);
    (0, _transformsJs.add)(projection, projection, cloneTransform);
}
function addProjections(projections) {
    projections.forEach(addProjection);
}
function get(projectionLike) {
    return typeof projectionLike === 'string' ? (0, _projectionsJs.get)(/** @type {string} */ projectionLike) : /** @type {Projection} */ projectionLike || null;
}
function getPointResolution(projection, resolution, point, units) {
    projection = get(projection);
    let pointResolution;
    const getter = projection.getPointResolutionFunc();
    if (getter) {
        pointResolution = getter(resolution, point);
        if (units && units !== projection.getUnits()) {
            const metersPerUnit = projection.getMetersPerUnit();
            if (metersPerUnit) pointResolution = pointResolution * metersPerUnit / (0, _unitsJs.METERS_PER_UNIT)[units];
        }
    } else {
        const projUnits = projection.getUnits();
        if (projUnits == 'degrees' && !units || units == 'degrees') pointResolution = resolution;
        else {
            // Estimate point resolution by transforming the center pixel to EPSG:4326,
            // measuring its width and height on the normal sphere, and taking the
            // average of the width and height.
            const toEPSG4326 = getTransformFromProjections(projection, get('EPSG:4326'));
            if (toEPSG4326 === identityTransform && projUnits !== 'degrees') // no transform is available
            pointResolution = resolution * projection.getMetersPerUnit();
            else {
                let vertices = [
                    point[0] - resolution / 2,
                    point[1],
                    point[0] + resolution / 2,
                    point[1],
                    point[0],
                    point[1] - resolution / 2,
                    point[0],
                    point[1] + resolution / 2
                ];
                vertices = toEPSG4326(vertices, vertices, 2);
                const width = (0, _sphereJs.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
                const height = (0, _sphereJs.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
                pointResolution = (width + height) / 2;
            }
            const metersPerUnit = units ? (0, _unitsJs.METERS_PER_UNIT)[units] : projection.getMetersPerUnit();
            if (metersPerUnit !== undefined) pointResolution /= metersPerUnit;
        }
    }
    return pointResolution;
}
function addEquivalentProjections(projections) {
    addProjections(projections);
    projections.forEach(function(source) {
        projections.forEach(function(destination) {
            if (source !== destination) (0, _transformsJs.add)(source, destination, cloneTransform);
        });
    });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
    projections1.forEach(function(projection1) {
        projections2.forEach(function(projection2) {
            (0, _transformsJs.add)(projection1, projection2, forwardTransform);
            (0, _transformsJs.add)(projection2, projection1, inverseTransform);
        });
    });
}
function clearAllProjections() {
    (0, _projectionsJs.clear)();
    (0, _transformsJs.clear)();
}
function createProjection(projection, defaultCode) {
    if (!projection) return get(defaultCode);
    if (typeof projection === 'string') return get(projection);
    return /** @type {Projection} */ projection;
}
function createTransformFromCoordinateTransform(coordTransform) {
    return(/**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */ function(input, output, dimension) {
        const length = input.length;
        dimension = dimension !== undefined ? dimension : 2;
        output = output !== undefined ? output : new Array(length);
        for(let i = 0; i < length; i += dimension){
            const point = coordTransform(input.slice(i, i + dimension));
            const pointLength = point.length;
            for(let j = 0, jj = dimension; j < jj; ++j)output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
        return output;
    });
}
function addCoordinateTransforms(source, destination, forward, inverse) {
    const sourceProj = get(source);
    const destProj = get(destination);
    (0, _transformsJs.add)(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
    (0, _transformsJs.add)(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
function fromLonLat(coordinate, projection) {
    disableCoordinateWarning();
    return transform(coordinate, 'EPSG:4326', projection !== undefined ? projection : 'EPSG:3857');
}
function toLonLat(coordinate, projection) {
    const lonLat = transform(coordinate, projection !== undefined ? projection : 'EPSG:3857', 'EPSG:4326');
    const lon = lonLat[0];
    if (lon < -180 || lon > 180) lonLat[0] = (0, _mathJs.modulo)(lon + 180, 360) - 180;
    return lonLat;
}
function equivalent(projection1, projection2) {
    if (projection1 === projection2) return true;
    const equalUnits = projection1.getUnits() === projection2.getUnits();
    if (projection1.getCode() === projection2.getCode()) return equalUnits;
    const transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
    const sourceCode = sourceProjection.getCode();
    const destinationCode = destinationProjection.getCode();
    let transformFunc = (0, _transformsJs.get)(sourceCode, destinationCode);
    if (!transformFunc) transformFunc = identityTransform;
    return transformFunc;
}
function getTransform(source, destination) {
    const sourceProjection = get(source);
    const destinationProjection = get(destination);
    return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
    const transformFunc = getTransform(source, destination);
    return transformFunc(coordinate, undefined, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
    const transformFunc = getTransform(source, destination);
    return (0, _extentJs.applyTransform)(extent, transformFunc, undefined, stops);
}
function transformWithProjections(point, sourceProjection, destinationProjection) {
    const transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
    return transformFunc(point);
}
/**
 * @type {Projection|null}
 */ let userProjection = null;
function setUserProjection(projection) {
    userProjection = get(projection);
}
function clearUserProjection() {
    userProjection = null;
}
function getUserProjection() {
    return userProjection;
}
function useGeographic() {
    setUserProjection('EPSG:4326');
}
function toUserCoordinate(coordinate, sourceProjection) {
    if (!userProjection) return coordinate;
    return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
    if (!userProjection) {
        if (showCoordinateWarning && !(0, _coordinateJs.equals)(coordinate, [
            0,
            0
        ]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
            showCoordinateWarning = false;
            (0, _consoleJs.warn)('Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.');
        }
        return coordinate;
    }
    return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
    if (!userProjection) return extent;
    return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
    if (!userProjection) return extent;
    return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
    if (!userProjection) return resolution;
    const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();
    const userMetersPerUnit = userProjection.getMetersPerUnit();
    return sourceMetersPerUnit && userMetersPerUnit ? resolution * sourceMetersPerUnit / userMetersPerUnit : resolution;
}
function fromUserResolution(resolution, destProjection) {
    if (!userProjection) return resolution;
    const destMetersPerUnit = get(destProjection).getMetersPerUnit();
    const userMetersPerUnit = userProjection.getMetersPerUnit();
    return destMetersPerUnit && userMetersPerUnit ? resolution * userMetersPerUnit / destMetersPerUnit : resolution;
}
function createSafeCoordinateTransform(sourceProj, destProj, transform) {
    return function(coord) {
        let transformed, worldsAway;
        if (sourceProj.canWrapX()) {
            const sourceExtent = sourceProj.getExtent();
            const sourceExtentWidth = (0, _extentJs.getWidth)(sourceExtent);
            coord = coord.slice(0);
            worldsAway = (0, _coordinateJs.getWorldsAway)(coord, sourceProj, sourceExtentWidth);
            if (worldsAway) // Move x to the real world
            coord[0] = coord[0] - worldsAway * sourceExtentWidth;
            coord[0] = (0, _mathJs.clamp)(coord[0], sourceExtent[0], sourceExtent[2]);
            coord[1] = (0, _mathJs.clamp)(coord[1], sourceExtent[1], sourceExtent[3]);
            transformed = transform(coord);
        } else transformed = transform(coord);
        if (worldsAway && destProj.canWrapX()) // Move transformed coordinate back to the offset world
        transformed[0] += worldsAway * (0, _extentJs.getWidth)(destProj.getExtent());
        return transformed;
    };
}
function addCommon() {
    // Add transformations that don't alter coordinates to convert within set of
    // projections with equal meaning.
    addEquivalentProjections((0, _epsg3857Js.PROJECTIONS));
    addEquivalentProjections((0, _epsg4326Js.PROJECTIONS));
    // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
    // coordinates and back.
    addEquivalentTransforms((0, _epsg4326Js.PROJECTIONS), (0, _epsg3857Js.PROJECTIONS), (0, _epsg3857Js.fromEPSG4326), (0, _epsg3857Js.toEPSG4326));
}
addCommon();

},{"./proj/Projection.js":"4Qs1P","./proj/epsg3857.js":"3A1FW","./proj/epsg4326.js":"bRbmC","./proj/Units.js":"11Xt4","./proj/projections.js":"7FSHl","./proj/transforms.js":"idXql","./extent.js":"bGUel","./math.js":"d8zSj","./coordinate.js":"fqHXJ","./sphere.js":"dCFM7","./console.js":"2VK4U","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4Qs1P":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/Projection
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _unitsJs = require("./Units.js");
/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").Units} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution} function will be used.
 */ /**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4.register} function.
 *
 * @api
 */ class Projection {
    /**
   * @param {Options} options Projection options.
   */ constructor(options){
        /**
     * @private
     * @type {string}
     */ this.code_ = options.code;
        /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").Units}
     */ this.units_ = /** @type {import("./Units.js").Units} */ options.units;
        /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */ this.extent_ = options.extent !== undefined ? options.extent : null;
        /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */ this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
        /**
     * @private
     * @type {string}
     */ this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
        /**
     * @private
     * @type {boolean}
     */ this.global_ = options.global !== undefined ? options.global : false;
        /**
     * @private
     * @type {boolean}
     */ this.canWrapX_ = !!(this.global_ && this.extent_);
        /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */ this.getPointResolutionFunc_ = options.getPointResolution;
        /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */ this.defaultTileGrid_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.metersPerUnit_ = options.metersPerUnit;
    }
    /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */ canWrapX() {
        return this.canWrapX_;
    }
    /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */ getCode() {
        return this.code_;
    }
    /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent() {
        return this.extent_;
    }
    /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */ getUnits() {
        return this.units_;
    }
    /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */ getMetersPerUnit() {
        return this.metersPerUnit_ || (0, _unitsJs.METERS_PER_UNIT)[this.units_];
    }
    /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getWorldExtent() {
        return this.worldExtent_;
    }
    /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */ getAxisOrientation() {
        return this.axisOrientation_;
    }
    /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */ isGlobal() {
        return this.global_;
    }
    /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */ setGlobal(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
    }
    /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */ getDefaultTileGrid() {
        return this.defaultTileGrid_;
    }
    /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */ setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
    }
    /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */ setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
    }
    /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */ setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
    }
    /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */ setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
    }
    /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */ getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
    }
}
exports.default = Projection;

},{"./Units.js":"11Xt4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"11Xt4":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/Units
 */ /**
 * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units
 * Projection units.
 */ /**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */ parcelHelpers.export(exports, "fromCode", ()=>fromCode);
parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>METERS_PER_UNIT);
const unitByCode = {
    '9001': 'm',
    '9002': 'ft',
    '9003': 'us-ft',
    '9101': 'radians',
    '9102': 'degrees'
};
function fromCode(code) {
    return unitByCode[code];
}
const METERS_PER_UNIT = {
    // use the radius of the Normal sphere
    'radians': 6370997 / (2 * Math.PI),
    'degrees': 2 * Math.PI * 6370997 / 360,
    'ft': 0.3048,
    'm': 1,
    'us-ft': 1200 / 3937
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3A1FW":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/epsg3857
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RADIUS", ()=>RADIUS);
parcelHelpers.export(exports, "HALF_SIZE", ()=>HALF_SIZE);
parcelHelpers.export(exports, "EXTENT", ()=>EXTENT);
parcelHelpers.export(exports, "WORLD_EXTENT", ()=>WORLD_EXTENT);
parcelHelpers.export(exports, "MAX_SAFE_Y", ()=>MAX_SAFE_Y);
parcelHelpers.export(exports, "PROJECTIONS", ()=>PROJECTIONS);
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */ parcelHelpers.export(exports, "fromEPSG4326", ()=>fromEPSG4326);
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */ parcelHelpers.export(exports, "toEPSG4326", ()=>toEPSG4326);
var _projectionJs = require("./Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
const RADIUS = 6378137;
const HALF_SIZE = Math.PI * RADIUS;
const EXTENT = [
    -HALF_SIZE,
    -HALF_SIZE,
    HALF_SIZE,
    HALF_SIZE
];
const WORLD_EXTENT = [
    -180,
    -85,
    180,
    85
];
const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */ class EPSG3857Projection extends (0, _projectionJsDefault.default) {
    /**
   * @param {string} code Code.
   */ constructor(code){
        super({
            code: code,
            units: 'm',
            extent: EXTENT,
            global: true,
            worldExtent: WORLD_EXTENT,
            getPointResolution: function(resolution, point) {
                return resolution / Math.cosh(point[1] / RADIUS);
            }
        });
    }
}
const PROJECTIONS = [
    new EPSG3857Projection('EPSG:3857'),
    new EPSG3857Projection('EPSG:102100'),
    new EPSG3857Projection('EPSG:102113'),
    new EPSG3857Projection('EPSG:900913'),
    new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),
    new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')
];
function fromEPSG4326(input, output, dimension) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    if (output === undefined) {
        if (dimension > 2) // preserve values beyond second dimension
        output = input.slice();
        else output = new Array(length);
    }
    for(let i = 0; i < length; i += dimension){
        output[i] = HALF_SIZE * input[i] / 180;
        let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
        if (y > MAX_SAFE_Y) y = MAX_SAFE_Y;
        else if (y < -MAX_SAFE_Y) y = -MAX_SAFE_Y;
        output[i + 1] = y;
    }
    return output;
}
function toEPSG4326(input, output, dimension) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    if (output === undefined) {
        if (dimension > 2) // preserve values beyond second dimension
        output = input.slice();
        else output = new Array(length);
    }
    for(let i = 0; i < length; i += dimension){
        output[i] = 180 * input[i] / HALF_SIZE;
        output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
    }
    return output;
}

},{"./Projection.js":"4Qs1P","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bRbmC":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/epsg4326
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RADIUS", ()=>RADIUS);
parcelHelpers.export(exports, "EXTENT", ()=>EXTENT);
parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>METERS_PER_UNIT);
parcelHelpers.export(exports, "PROJECTIONS", ()=>PROJECTIONS);
var _projectionJs = require("./Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
const RADIUS = 6378137;
const EXTENT = [
    -180,
    -90,
    180,
    90
];
const METERS_PER_UNIT = Math.PI * RADIUS / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */ class EPSG4326Projection extends (0, _projectionJsDefault.default) {
    /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */ constructor(code, axisOrientation){
        super({
            code: code,
            units: 'degrees',
            extent: EXTENT,
            axisOrientation: axisOrientation,
            global: true,
            metersPerUnit: METERS_PER_UNIT,
            worldExtent: EXTENT
        });
    }
}
const PROJECTIONS = [
    new EPSG4326Projection('CRS:84'),
    new EPSG4326Projection('EPSG:4326', 'neu'),
    new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
    new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
    new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),
    new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
    new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu')
];

},{"./Projection.js":"4Qs1P","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7FSHl":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/projections
 */ /**
 * @type {Object<string, import("./Projection.js").default>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Clear the projections cache.
 */ parcelHelpers.export(exports, "clear", ()=>clear);
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */ parcelHelpers.export(exports, "get", ()=>get);
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */ parcelHelpers.export(exports, "add", ()=>add);
let cache = {};
function clear() {
    cache = {};
}
function get(code) {
    return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] || null;
}
function add(code, projection) {
    cache[code] = projection;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"idXql":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/transforms
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Clear the transform cache.
 */ parcelHelpers.export(exports, "clear", ()=>clear);
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */ parcelHelpers.export(exports, "add", ()=>add);
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */ parcelHelpers.export(exports, "remove", ()=>remove);
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */ parcelHelpers.export(exports, "get", ()=>get);
var _objJs = require("../obj.js");
/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */ let transforms = {};
function clear() {
    transforms = {};
}
function add(source, destination, transformFn) {
    const sourceCode = source.getCode();
    const destinationCode = destination.getCode();
    if (!(sourceCode in transforms)) transforms[sourceCode] = {};
    transforms[sourceCode][destinationCode] = transformFn;
}
function remove(source, destination) {
    const sourceCode = source.getCode();
    const destinationCode = destination.getCode();
    const transform = transforms[sourceCode][destinationCode];
    delete transforms[sourceCode][destinationCode];
    if ((0, _objJs.isEmpty)(transforms[sourceCode])) delete transforms[sourceCode];
    return transform;
}
function get(sourceCode, destinationCode) {
    let transform;
    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) transform = transforms[sourceCode][destinationCode];
    return transform;
}

},{"../obj.js":"7RZD4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fqHXJ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/coordinate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.
 * Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */ /**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */ /**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */ parcelHelpers.export(exports, "add", ()=>add);
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */ parcelHelpers.export(exports, "closestOnCircle", ()=>closestOnCircle);
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */ parcelHelpers.export(exports, "closestOnSegment", ()=>closestOnSegment);
/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY();
 *     const out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY(2);
 *     const out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */ parcelHelpers.export(exports, "createStringXY", ()=>createStringXY);
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */ parcelHelpers.export(exports, "degreesToStringHDMS", ()=>degreesToStringHDMS);
/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */ parcelHelpers.export(exports, "format", ()=>format);
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */ parcelHelpers.export(exports, "equals", ()=>equals);
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance);
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */ parcelHelpers.export(exports, "distance", ()=>distance);
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */ parcelHelpers.export(exports, "squaredDistanceToSegment", ()=>squaredDistanceToSegment);
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */ parcelHelpers.export(exports, "toStringHDMS", ()=>toStringHDMS);
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */ parcelHelpers.export(exports, "toStringXY", ()=>toStringXY);
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX);
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */ parcelHelpers.export(exports, "getWorldsAway", ()=>getWorldsAway);
var _extentJs = require("./extent.js");
var _mathJs = require("./math.js");
var _stringJs = require("./string.js");
function add(coordinate, delta) {
    coordinate[0] += +delta[0];
    coordinate[1] += +delta[1];
    return coordinate;
}
function closestOnCircle(coordinate, circle) {
    const r = circle.getRadius();
    const center = circle.getCenter();
    const x0 = center[0];
    const y0 = center[1];
    const x1 = coordinate[0];
    const y1 = coordinate[1];
    let dx = x1 - x0;
    const dy = y1 - y0;
    if (dx === 0 && dy === 0) dx = 1;
    const d = Math.sqrt(dx * dx + dy * dy);
    const x = x0 + r * dx / d;
    const y = y0 + r * dy / d;
    return [
        x,
        y
    ];
}
function closestOnSegment(coordinate, segment) {
    const x0 = coordinate[0];
    const y0 = coordinate[1];
    const start = segment[0];
    const end = segment[1];
    const x1 = start[0];
    const y1 = start[1];
    const x2 = end[0];
    const y2 = end[1];
    const dx = x2 - x1;
    const dy = y2 - y1;
    const along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
    let x, y;
    if (along <= 0) {
        x = x1;
        y = y1;
    } else if (along >= 1) {
        x = x2;
        y = y2;
    } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return [
        x,
        y
    ];
}
function createStringXY(fractionDigits) {
    return(/**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */ function(coordinate) {
        return toStringXY(coordinate, fractionDigits);
    });
}
function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
    const normalizedDegrees = (0, _mathJs.modulo)(degrees + 180, 360) - 180;
    const x = Math.abs(3600 * normalizedDegrees);
    const decimals = fractionDigits || 0;
    let deg = Math.floor(x / 3600);
    let min = Math.floor((x - deg * 3600) / 60);
    let sec = (0, _mathJs.toFixed)(x - deg * 3600 - min * 60, decimals);
    if (sec >= 60) {
        sec = 0;
        min += 1;
    }
    if (min >= 60) {
        min = 0;
        deg += 1;
    }
    let hdms = deg + '\u00b0';
    if (min !== 0 || sec !== 0) hdms += ' ' + (0, _stringJs.padNumber)(min, 2) + '\u2032';
    if (sec !== 0) hdms += ' ' + (0, _stringJs.padNumber)(sec, 2, decimals) + '\u2033';
    if (normalizedDegrees !== 0) hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
    return hdms;
}
function format(coordinate, template, fractionDigits) {
    if (coordinate) return template.replace('{x}', coordinate[0].toFixed(fractionDigits)).replace('{y}', coordinate[1].toFixed(fractionDigits));
    return '';
}
function equals(coordinate1, coordinate2) {
    let equals = true;
    for(let i = coordinate1.length - 1; i >= 0; --i)if (coordinate1[i] != coordinate2[i]) {
        equals = false;
        break;
    }
    return equals;
}
function rotate(coordinate, angle) {
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    coordinate[0] = x;
    coordinate[1] = y;
    return coordinate;
}
function scale(coordinate, scale) {
    coordinate[0] *= scale;
    coordinate[1] *= scale;
    return coordinate;
}
function squaredDistance(coord1, coord2) {
    const dx = coord1[0] - coord2[0];
    const dy = coord1[1] - coord2[1];
    return dx * dx + dy * dy;
}
function distance(coord1, coord2) {
    return Math.sqrt(squaredDistance(coord1, coord2));
}
function squaredDistanceToSegment(coordinate, segment) {
    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
function toStringHDMS(coordinate, fractionDigits) {
    if (coordinate) return degreesToStringHDMS('NS', coordinate[1], fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], fractionDigits);
    return '';
}
function toStringXY(coordinate, fractionDigits) {
    return format(coordinate, '{x}, {y}', fractionDigits);
}
function wrapX(coordinate, projection) {
    if (projection.canWrapX()) {
        const worldWidth = (0, _extentJs.getWidth)(projection.getExtent());
        const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
        if (worldsAway) coordinate[0] -= worldsAway * worldWidth;
    }
    return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
    const projectionExtent = projection.getExtent();
    let worldsAway = 0;
    if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
        sourceExtentWidth = sourceExtentWidth || (0, _extentJs.getWidth)(projectionExtent);
        worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
    }
    return worldsAway;
}

},{"./extent.js":"bGUel","./math.js":"d8zSj","./string.js":"3uF0z","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3uF0z":[function(require,module,exports,__globalThis) {
/**
 * @module ol/string
 */ /**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "padNumber", ()=>padNumber);
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */ parcelHelpers.export(exports, "compareVersions", ()=>compareVersions);
function padNumber(number, width, precision) {
    const numberString = precision !== undefined ? number.toFixed(precision) : '' + number;
    let decimal = numberString.indexOf('.');
    decimal = decimal === -1 ? numberString.length : decimal;
    return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}
function compareVersions(v1, v2) {
    const s1 = ('' + v1).split('.');
    const s2 = ('' + v2).split('.');
    for(let i = 0; i < Math.max(s1.length, s2.length); i++){
        const n1 = parseInt(s1[i] || '0', 10);
        const n2 = parseInt(s2[i] || '0', 10);
        if (n1 > n2) return 1;
        if (n2 > n1) return -1;
    }
    return 0;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dCFM7":[function(require,module,exports,__globalThis) {
/**
 * @module ol/sphere
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_RADIUS", ()=>DEFAULT_RADIUS);
/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */ parcelHelpers.export(exports, "getDistance", ()=>getDistance);
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */ parcelHelpers.export(exports, "getLength", ()=>getLength);
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */ parcelHelpers.export(exports, "getArea", ()=>getArea);
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */ parcelHelpers.export(exports, "offset", ()=>offset);
var _mathJs = require("./math.js");
const DEFAULT_RADIUS = 6371008.8;
function getDistance(c1, c2, radius) {
    radius = radius || DEFAULT_RADIUS;
    const lat1 = (0, _mathJs.toRadians)(c1[1]);
    const lat2 = (0, _mathJs.toRadians)(c2[1]);
    const deltaLatBy2 = (lat2 - lat1) / 2;
    const deltaLonBy2 = (0, _mathJs.toRadians)(c2[0] - c1[0]) / 2;
    const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */ function getLengthInternal(coordinates, radius) {
    let length = 0;
    for(let i = 0, ii = coordinates.length; i < ii - 1; ++i)length += getDistance(coordinates[i], coordinates[i + 1], radius);
    return length;
}
function getLength(geometry, options) {
    options = options || {};
    const radius = options.radius || DEFAULT_RADIUS;
    const projection = options.projection || 'EPSG:3857';
    const type = geometry.getType();
    if (type !== 'GeometryCollection') geometry = geometry.clone().transform(projection, 'EPSG:4326');
    let length = 0;
    let coordinates, coords, i, ii, j, jj;
    switch(type){
        case 'Point':
        case 'MultiPoint':
            break;
        case 'LineString':
        case 'LinearRing':
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            length = getLengthInternal(coordinates, radius);
            break;
        case 'MultiLineString':
        case 'Polygon':
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i)length += getLengthInternal(coordinates[i], radius);
            break;
        case 'MultiPolygon':
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i){
                coords = coordinates[i];
                for(j = 0, jj = coords.length; j < jj; ++j)length += getLengthInternal(coords[j], radius);
            }
            break;
        case 'GeometryCollection':
            {
                const geometries = /** @type {import("./geom/GeometryCollection.js").default} */ geometry.getGeometries();
                for(i = 0, ii = geometries.length; i < ii; ++i)length += getLength(geometries[i], options);
                break;
            }
        default:
            throw new Error('Unsupported geometry type: ' + type);
    }
    return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */ function getAreaInternal(coordinates, radius) {
    let area = 0;
    const len = coordinates.length;
    let x1 = coordinates[len - 1][0];
    let y1 = coordinates[len - 1][1];
    for(let i = 0; i < len; i++){
        const x2 = coordinates[i][0];
        const y2 = coordinates[i][1];
        area += (0, _mathJs.toRadians)(x2 - x1) * (2 + Math.sin((0, _mathJs.toRadians)(y1)) + Math.sin((0, _mathJs.toRadians)(y2)));
        x1 = x2;
        y1 = y2;
    }
    return area * radius * radius / 2.0;
}
function getArea(geometry, options) {
    options = options || {};
    const radius = options.radius || DEFAULT_RADIUS;
    const projection = options.projection || 'EPSG:3857';
    const type = geometry.getType();
    if (type !== 'GeometryCollection') geometry = geometry.clone().transform(projection, 'EPSG:4326');
    let area = 0;
    let coordinates, coords, i, ii, j, jj;
    switch(type){
        case 'Point':
        case 'MultiPoint':
        case 'LineString':
        case 'MultiLineString':
        case 'LinearRing':
            break;
        case 'Polygon':
            coordinates = /** @type {import("./geom/Polygon.js").default} */ geometry.getCoordinates();
            area = Math.abs(getAreaInternal(coordinates[0], radius));
            for(i = 1, ii = coordinates.length; i < ii; ++i)area -= Math.abs(getAreaInternal(coordinates[i], radius));
            break;
        case 'MultiPolygon':
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i){
                coords = coordinates[i];
                area += Math.abs(getAreaInternal(coords[0], radius));
                for(j = 1, jj = coords.length; j < jj; ++j)area -= Math.abs(getAreaInternal(coords[j], radius));
            }
            break;
        case 'GeometryCollection':
            {
                const geometries = /** @type {import("./geom/GeometryCollection.js").default} */ geometry.getGeometries();
                for(i = 0, ii = geometries.length; i < ii; ++i)area += getArea(geometries[i], options);
                break;
            }
        default:
            throw new Error('Unsupported geometry type: ' + type);
    }
    return area;
}
function offset(c1, distance, bearing, radius) {
    radius = radius || DEFAULT_RADIUS;
    const lat1 = (0, _mathJs.toRadians)(c1[1]);
    const lon1 = (0, _mathJs.toRadians)(c1[0]);
    const dByR = distance / radius;
    const lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
    const lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
    return [
        (0, _mathJs.toDegrees)(lon),
        (0, _mathJs.toDegrees)(lat)
    ];
}

},{"./math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2VK4U":[function(require,module,exports,__globalThis) {
/**
 * @module ol/console
 */ /**
 * @typedef {'info'|'warn'|'error'|'none'} Level
 */ /**
 * @type {Object<Level, number>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Set the logging level.  By default, the level is set to 'info' and all
 * messages will be logged.  Set to 'warn' to only display warnings and errors.
 * Set to 'error' to only display errors.  Set to 'none' to silence all messages.
 *
 * @param {Level} l The new level.
 */ parcelHelpers.export(exports, "setLevel", ()=>setLevel);
/**
 * @param  {...any} args Arguments to log
 */ parcelHelpers.export(exports, "log", ()=>log);
/**
 * @param  {...any} args Arguments to log
 */ parcelHelpers.export(exports, "warn", ()=>warn);
/**
 * @param  {...any} args Arguments to log
 */ parcelHelpers.export(exports, "error", ()=>error);
const levels = {
    info: 1,
    warn: 2,
    error: 3,
    none: 4
};
/**
 * @type {number}
 */ let level = levels.info;
function setLevel(l) {
    level = levels[l];
}
function log(...args) {
    if (level > levels.info) return;
    console.log(...args); // eslint-disable-line no-console
}
function warn(...args) {
    if (level > levels.warn) return;
    console.warn(...args); // eslint-disable-line no-console
}
function error(...args) {
    if (level > levels.error) return;
    console.error(...args); // eslint-disable-line no-console
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gxpQR":[function(require,module,exports,__globalThis) {
/**
 * @module ol/centerconstraint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */ /**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */ parcelHelpers.export(exports, "createExtent", ()=>createExtent);
/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */ parcelHelpers.export(exports, "none", ()=>none);
var _mathJs = require("./math.js");
function createExtent(extent, onlyCenter, smooth) {
    return(/**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */ function(center, resolution, size, isMoving, centerShift) {
        if (!center) return undefined;
        if (!resolution && !onlyCenter) return center;
        const viewWidth = onlyCenter ? 0 : size[0] * resolution;
        const viewHeight = onlyCenter ? 0 : size[1] * resolution;
        const shiftX = centerShift ? centerShift[0] : 0;
        const shiftY = centerShift ? centerShift[1] : 0;
        let minX = extent[0] + viewWidth / 2 + shiftX;
        let maxX = extent[2] - viewWidth / 2 + shiftX;
        let minY = extent[1] + viewHeight / 2 + shiftY;
        let maxY = extent[3] - viewHeight / 2 + shiftY;
        // note: when zooming out of bounds, min and max values for x and y may
        // end up inverted (min > max); this has to be accounted for
        if (minX > maxX) {
            minX = (maxX + minX) / 2;
            maxX = minX;
        }
        if (minY > maxY) {
            minY = (maxY + minY) / 2;
            maxY = minY;
        }
        let x = (0, _mathJs.clamp)(center[0], minX, maxX);
        let y = (0, _mathJs.clamp)(center[1], minY, maxY);
        // during an interaction, allow some overscroll
        if (isMoving && smooth && resolution) {
            const ratio = 30 * resolution;
            x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
            y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
        }
        return [
            x,
            y
        ];
    });
}
function none(center) {
    return center;
}

},{"./math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8VkUn":[function(require,module,exports,__globalThis) {
/**
 * @module ol/resolutionconstraint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createSnapToResolutions", ()=>createSnapToResolutions);
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [minResolution] Minimum resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createSnapToPower", ()=>createSnapToPower);
/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createMinMaxResolution", ()=>createMinMaxResolution);
var _mathJs = require("./math.js");
var _extentJs = require("./extent.js");
var _arrayJs = require("./array.js");
/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */ /**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */ function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
    const xResolution = (0, _extentJs.getWidth)(maxExtent) / viewportSize[0];
    const yResolution = (0, _extentJs.getHeight)(maxExtent) / viewportSize[1];
    if (showFullExtent) return Math.min(resolution, Math.max(xResolution, yResolution));
    return Math.min(resolution, Math.min(xResolution, yResolution));
}
/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */ function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
    let result = Math.min(resolution, maxResolution);
    const ratio = 50;
    result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
    if (minResolution) {
        result = Math.max(result, minResolution);
        result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
    }
    return (0, _mathJs.clamp)(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const maxResolution = resolutions[0];
            const minResolution = resolutions[resolutions.length - 1];
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            // during interacting or animating, allow intermediary values
            if (isMoving) {
                if (!smooth) return (0, _mathJs.clamp)(resolution, minResolution, cappedMaxRes);
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            const capped = Math.min(cappedMaxRes, resolution);
            const z = Math.floor((0, _arrayJs.linearFindNearest)(resolutions, capped, direction));
            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) return resolutions[z + 1];
            return resolutions[z];
        }
        return undefined;
    });
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    minResolution = minResolution !== undefined ? minResolution : 0;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            // during interacting or animating, allow intermediary values
            if (isMoving) {
                if (!smooth) return (0, _mathJs.clamp)(resolution, minResolution, cappedMaxRes);
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            const tolerance = 1e-9;
            const minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
            const offset = -direction * (0.5 - tolerance) + 0.5;
            const capped = Math.min(cappedMaxRes, resolution);
            const cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
            const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
            const newResolution = maxResolution / Math.pow(power, zoomLevel);
            return (0, _mathJs.clamp)(newResolution, minResolution, cappedMaxRes);
        }
        return undefined;
    });
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            if (!smooth || !isMoving) return (0, _mathJs.clamp)(resolution, minResolution, cappedMaxRes);
            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }
        return undefined;
    });
}

},{"./math.js":"d8zSj","./extent.js":"bGUel","./array.js":"hyet5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6TPbY":[function(require,module,exports,__globalThis) {
/**
 * @module ol/rotationconstraint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */ /**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */ parcelHelpers.export(exports, "disable", ()=>disable);
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */ parcelHelpers.export(exports, "none", ()=>none);
/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createSnapToN", ()=>createSnapToN);
/**
 * @param {number} [tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createSnapToZero", ()=>createSnapToZero);
var _mathJs = require("./math.js");
function disable(rotation) {
    if (rotation !== undefined) return 0;
    return undefined;
}
function none(rotation) {
    if (rotation !== undefined) return rotation;
    return undefined;
}
function createSnapToN(n) {
    const theta = 2 * Math.PI / n;
    return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */ function(rotation, isMoving) {
        if (isMoving) return rotation;
        if (rotation !== undefined) {
            rotation = Math.floor(rotation / theta + 0.5) * theta;
            return rotation;
        }
        return undefined;
    });
}
function createSnapToZero(tolerance) {
    const t = tolerance === undefined ? (0, _mathJs.toRadians)(5) : tolerance;
    return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */ function(rotation, isMoving) {
        if (isMoving || rotation === undefined) return rotation;
        if (Math.abs(rotation) <= t) return 0;
        return rotation;
    });
}

},{"./math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jskwM":[function(require,module,exports,__globalThis) {
/**
 * @module ol/easing
 */ /**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "easeIn", ()=>easeIn);
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "easeOut", ()=>easeOut);
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "inAndOut", ()=>inAndOut);
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "linear", ()=>linear);
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "upAndDown", ()=>upAndDown);
function easeIn(t) {
    return Math.pow(t, 3);
}
function easeOut(t) {
    return 1 - easeIn(1 - t);
}
function inAndOut(t) {
    return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
    return t;
}
function upAndDown(t) {
    if (t < 0.5) return inAndOut(2 * t);
    return 1 - inAndOut(2 * (t - 0.5));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8Vwps":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/Polygon
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */ parcelHelpers.export(exports, "circular", ()=>circular);
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */ parcelHelpers.export(exports, "fromExtent", ()=>fromExtent);
/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [sides] Number of sides of the polygon. Default is 32.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */ parcelHelpers.export(exports, "fromCircle", ()=>fromCircle);
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */ parcelHelpers.export(exports, "makeRegular", ()=>makeRegular);
var _linearRingJs = require("./LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _pointJs = require("./Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("./flat/interiorpoint.js");
var _inflateJs = require("./flat/inflate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _orientJs = require("./flat/orient.js");
var _areaJs = require("./flat/area.js");
var _containsJs = require("./flat/contains.js");
var _mathJs = require("../math.js");
var _simplifyJs = require("./flat/simplify.js");
var _sphereJs = require("../sphere.js");
/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */ class Polygon extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */ constructor(coordinates, layout, ends){
        super();
        /**
     * @type {Array<number>}
     * @private
     */ this.ends_ = [];
        /**
     * @private
     * @type {number}
     */ this.flatInteriorPointRevision_ = -1;
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */ this.flatInteriorPoint_ = null;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.orientedRevision_ = -1;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.orientedFlatCoordinates_ = null;
        if (layout !== undefined && ends) {
            this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
            this.ends_ = ends;
        } else this.setCoordinates(/** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ coordinates, layout);
    }
    /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */ appendLinearRing(linearRing) {
        if (!this.flatCoordinates) this.flatCoordinates = linearRing.getFlatCoordinates().slice();
        else (0, _arrayJs.extend)(this.flatCoordinates, linearRing.getFlatCoordinates());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */ clone() {
        const polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        polygon.applyProperties(this);
        return polygon;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        return (0, _containsJs.linearRingsContainsXY)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
    }
    /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */ getArea() {
        return (0, _areaJs.linearRings)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
    }
    /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */ getCoordinates(right) {
        let flatCoordinates;
        if (right !== undefined) {
            flatCoordinates = this.getOrientedFlatCoordinates().slice();
            (0, _orientJs.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, right);
        } else flatCoordinates = this.flatCoordinates;
        return (0, _inflateJs.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
    }
    /**
   * @return {Array<number>} Ends.
   */ getEnds() {
        return this.ends_;
    }
    /**
   * @return {Array<number>} Interior point.
   */ getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
            const flatCenter = (0, _extentJs.getCenter)(this.getExtent());
            this.flatInteriorPoint_ = (0, _interiorpointJs.getInteriorPointOfArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
            this.flatInteriorPointRevision_ = this.getRevision();
        }
        return /** @type {import("../coordinate.js").Coordinate} */ this.flatInteriorPoint_;
    }
    /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */ getInteriorPoint() {
        return new (0, _pointJsDefault.default)(this.getFlatInteriorPoint(), 'XYM');
    }
    /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */ getLinearRingCount() {
        return this.ends_.length;
    }
    /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */ getLinearRing(index) {
        if (index < 0 || this.ends_.length <= index) return null;
        return new (0, _linearRingJsDefault.default)(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    }
    /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */ getLinearRings() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const linearRings = [];
        let offset = 0;
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const linearRing = new (0, _linearRingJsDefault.default)(flatCoordinates.slice(offset, end), layout);
            linearRings.push(linearRing);
            offset = end;
        }
        return linearRings;
    }
    /**
   * @return {Array<number>} Oriented flat coordinates.
   */ getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
            const flatCoordinates = this.flatCoordinates;
            if ((0, _orientJs.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride)) this.orientedFlatCoordinates_ = flatCoordinates;
            else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = (0, _orientJs.orientLinearRings)(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
            }
            this.orientedRevision_ = this.getRevision();
        }
        return /** @type {Array<number>} */ this.orientedFlatCoordinates_;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        /** @type {Array<number>} */ const simplifiedFlatCoordinates = [];
        /** @type {Array<number>} */ const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.quantizeArray)(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'Polygon';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLinearRingArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
    }
    /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 2);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        const ends = (0, _deflateJs.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
    }
}
exports.default = Polygon;
function circular(center, radius, n, sphereRadius) {
    n = n ? n : 32;
    /** @type {Array<number>} */ const flatCoordinates = [];
    for(let i = 0; i < n; ++i)(0, _arrayJs.extend)(flatCoordinates, (0, _sphereJs.offset)(center, radius, 2 * Math.PI * i / n, sphereRadius));
    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
    return new Polygon(flatCoordinates, 'XY', [
        flatCoordinates.length
    ]);
}
function fromExtent(extent) {
    if ((0, _extentJs.isEmpty)(extent)) throw new Error('Cannot create polygon from empty extent');
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const flatCoordinates = [
        minX,
        minY,
        minX,
        maxY,
        maxX,
        maxY,
        maxX,
        minY,
        minX,
        minY
    ];
    return new Polygon(flatCoordinates, 'XY', [
        flatCoordinates.length
    ]);
}
function fromCircle(circle, sides, angle) {
    sides = sides ? sides : 32;
    const stride = circle.getStride();
    const layout = circle.getLayout();
    const center = circle.getCenter();
    const arrayLength = stride * (sides + 1);
    const flatCoordinates = new Array(arrayLength);
    for(let i = 0; i < arrayLength; i += stride){
        flatCoordinates[i] = 0;
        flatCoordinates[i + 1] = 0;
        for(let j = 2; j < stride; j++)flatCoordinates[i + j] = center[j];
    }
    const ends = [
        flatCoordinates.length
    ];
    const polygon = new Polygon(flatCoordinates, layout, ends);
    makeRegular(polygon, center, circle.getRadius(), angle);
    return polygon;
}
function makeRegular(polygon, center, radius, angle) {
    const flatCoordinates = polygon.getFlatCoordinates();
    const stride = polygon.getStride();
    const sides = flatCoordinates.length / stride - 1;
    const startAngle = angle ? angle : 0;
    for(let i = 0; i <= sides; ++i){
        const offset = i * stride;
        const angle = startAngle + (0, _mathJs.modulo)(i, sides) * 2 * Math.PI / sides;
        flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
        flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
    }
    polygon.changed();
}

},{"./LinearRing.js":"gT85H","./Point.js":"6SybV","./SimpleGeometry.js":"iZYIt","./flat/closest.js":"5urVB","../extent.js":"bGUel","./flat/deflate.js":"is4mF","../array.js":"hyet5","./flat/interiorpoint.js":"ii0ve","./flat/inflate.js":"hm7Zu","./flat/intersectsextent.js":"empkw","./flat/orient.js":"kVTqd","./flat/area.js":"8w7cR","./flat/contains.js":"kCfKA","../math.js":"d8zSj","./flat/simplify.js":"gXvXA","../sphere.js":"dCFM7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gT85H":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/LinearRing
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _inflateJs = require("./flat/inflate.js");
var _areaJs = require("./flat/area.js");
/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */ class LinearRing extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        if (layout !== undefined && !Array.isArray(coordinates[0])) this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
        else this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ coordinates, layout);
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */ clone() {
        return new LinearRing(this.flatCoordinates.slice(), this.layout);
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */ getArea() {
        return (0, _areaJs.linearRing)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        /** @type {Array<number>} */ const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LinearRing(simplifiedFlatCoordinates, 'XY');
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'LinearRing';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return false;
    }
    /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = LinearRing;

},{"./SimpleGeometry.js":"iZYIt","./flat/closest.js":"5urVB","../extent.js":"bGUel","./flat/deflate.js":"is4mF","./flat/simplify.js":"gXvXA","./flat/inflate.js":"hm7Zu","./flat/area.js":"8w7cR","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iZYIt":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/SimpleGeometry
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {number} stride Stride.
 * @return {import("./Geometry.js").GeometryLayout} layout Layout.
 */ parcelHelpers.export(exports, "getLayoutForStride", ()=>getLayoutForStride);
/**
 * @param {import("./Geometry.js").GeometryLayout} layout Layout.
 * @return {number} Stride.
 */ parcelHelpers.export(exports, "getStrideForLayout", ()=>getStrideForLayout);
/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */ parcelHelpers.export(exports, "transformGeom2D", ()=>transformGeom2D);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _utilJs = require("../util.js");
var _extentJs = require("../extent.js");
var _transformJs = require("./flat/transform.js");
/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */ class SimpleGeometry extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        /**
     * @protected
     * @type {import("./Geometry.js").GeometryLayout}
     */ this.layout = 'XY';
        /**
     * @protected
     * @type {number}
     */ this.stride = 2;
        /**
     * @protected
     * @type {Array<number>}
     */ this.flatCoordinates;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        return (0, _extentJs.createOrUpdateFromFlatCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    }
    /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */ getCoordinates() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */ getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
    }
    /**
   * @return {Array<number>} Flat coordinates.
   */ getFlatCoordinates() {
        return this.flatCoordinates;
    }
    /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */ getLastCoordinate() {
        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
    }
    /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */ getLayout() {
        return this.layout;
    }
    /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */ getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
            this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            this.simplifiedGeometryRevision = this.getRevision();
        }
        // If squaredTolerance is negative or if we know that simplification will not
        // have any effect then just return this.
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) return this;
        const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) return simplifiedGeometry;
        // Simplification did not actually remove any coordinates.  We now know
        // that any calls to getSimplifiedGeometry with a squaredTolerance less
        // than or equal to the current squaredTolerance will also not have any
        // effect.  This allows us to short circuit simplification (saving CPU
        // cycles) and prevents the cache of simplified geometries from filling
        // up with useless identical copies of this geometry (saving memory).
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        return this;
    }
    /**
   * @return {number} Stride.
   */ getStride() {
        return this.stride;
    }
    /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */ setFlatCoordinates(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
    }
    /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ setCoordinates(coordinates, layout) {
        (0, _utilJs.abstract)();
    }
    /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */ setLayout(layout, coordinates, nesting) {
        let stride;
        if (layout) stride = getStrideForLayout(layout);
        else {
            for(let i = 0; i < nesting; ++i){
                if (coordinates.length === 0) {
                    this.layout = 'XY';
                    this.stride = 2;
                    return;
                }
                coordinates = /** @type {Array<unknown>} */ coordinates[0];
            }
            stride = coordinates.length;
            layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */ applyTransform(transformFn) {
        if (this.flatCoordinates) {
            transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
            this.changed();
        }
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            const stride = this.getStride();
            (0, _transformJs.rotate)(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
            this.changed();
        }
    }
    /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */ scale(sx, sy, anchor) {
        if (sy === undefined) sy = sx;
        if (!anchor) anchor = (0, _extentJs.getCenter)(this.getExtent());
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            const stride = this.getStride();
            (0, _transformJs.scale)(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
            this.changed();
        }
    }
    /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */ translate(deltaX, deltaY) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            const stride = this.getStride();
            (0, _transformJs.translate)(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
            this.changed();
        }
    }
}
function getLayoutForStride(stride) {
    let layout;
    if (stride == 2) layout = 'XY';
    else if (stride == 3) layout = 'XYZ';
    else if (stride == 4) layout = 'XYZM';
    return /** @type {import("./Geometry.js").GeometryLayout} */ layout;
}
function getStrideForLayout(layout) {
    let stride;
    if (layout == 'XY') stride = 2;
    else if (layout == 'XYZ' || layout == 'XYM') stride = 3;
    else if (layout == 'XYZM') stride = 4;
    return /** @type {number} */ stride;
}
function transformGeom2D(simpleGeometry, transform, dest) {
    const flatCoordinates = simpleGeometry.getFlatCoordinates();
    if (!flatCoordinates) return null;
    const stride = simpleGeometry.getStride();
    return (0, _transformJs.transform2D)(flatCoordinates, 0, flatCoordinates.length, stride, transform, dest);
}
exports.default = SimpleGeometry;

},{"./Geometry.js":"6K9DH","../util.js":"l1iPW","../extent.js":"bGUel","./flat/transform.js":"7FFJr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6K9DH":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/Geometry
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _utilJs = require("../util.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _functionsJs = require("../functions.js");
var _transformJs1 = require("./flat/transform.js");
/**
 * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available.
 */ /**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, or `'Circle'`.
 */ /**
 * @type {import("../transform.js").Transform}
 */ const tmpTransform = (0, _transformJs.create)();
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */ class Geometry extends (0, _objectJsDefault.default) {
    constructor(){
        super();
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.extent_ = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {number}
     */ this.extentRevision_ = -1;
        /**
     * @protected
     * @type {number}
     */ this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        /**
     * @protected
     * @type {number}
     */ this.simplifiedGeometryRevision = 0;
        /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */ this.simplifyTransformedInternal = (0, _functionsJs.memoizeOne)((revision, squaredTolerance, transform)=>{
            if (!transform) return this.getSimplifiedGeometry(squaredTolerance);
            const clone = this.clone();
            clone.applyTransform(transform);
            return clone.getSimplifiedGeometry(squaredTolerance);
        });
    }
    /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */ simplifyTransformed(squaredTolerance, transform) {
        return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, transform);
    }
    /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */ clone() {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        const coord = this.getClosestPoint([
            x,
            y
        ]);
        return coord[0] === x && coord[1] === y;
    }
    /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */ getClosestPoint(point, closestPoint) {
        closestPoint = closestPoint ? closestPoint : [
            NaN,
            NaN
        ];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
    }
    /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */ intersectsCoordinate(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
    }
    /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */ getExtent(extent) {
        if (this.extentRevision_ != this.getRevision()) {
            const extent = this.computeExtent(this.extent_);
            if (isNaN(extent[0]) || isNaN(extent[1])) (0, _extentJs.createOrUpdateEmpty)(extent);
            this.extentRevision_ = this.getRevision();
        }
        return (0, _extentJs.returnOrUpdate)(this.extent_, extent);
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        (0, _utilJs.abstract)();
    }
    /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */ scale(sx, sy, anchor) {
        (0, _utilJs.abstract)();
    }
    /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */ simplify(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
    }
    /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */ getSimplifiedGeometry(squaredTolerance) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */ getType() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */ applyTransform(transformFn) {
        (0, _utilJs.abstract)();
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */ intersectsExtent(extent) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */ translate(deltaX, deltaY) {
        (0, _utilJs.abstract)();
    }
    /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */ transform(source, destination) {
        /** @type {import("../proj/Projection.js").default} */ const sourceProj = (0, _projJs.get)(source);
        const transformFn = sourceProj.getUnits() == 'tile-pixels' ? function(inCoordinates, outCoordinates, stride) {
            const pixelExtent = sourceProj.getExtent();
            const projectedExtent = sourceProj.getWorldExtent();
            const scale = (0, _extentJs.getHeight)(projectedExtent) / (0, _extentJs.getHeight)(pixelExtent);
            (0, _transformJs.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
            (0, _transformJs1.transform2D)(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
            return (0, _projJs.getTransform)(sourceProj, destination)(inCoordinates, outCoordinates, stride);
        } : (0, _projJs.getTransform)(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
    }
}
exports.default = Geometry;

},{"../Object.js":"N6yIf","../util.js":"l1iPW","../transform.js":"9LrRk","../extent.js":"bGUel","../proj.js":"8OK47","../functions.js":"1QSsQ","./flat/transform.js":"7FFJr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7FFJr":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/transform
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transform2D", ()=>transform2D);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "translate", ()=>translate);
function transform2D(flatCoordinates, offset, end, stride, transform, dest) {
    dest = dest ? dest : [];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        const x = flatCoordinates[j];
        const y = flatCoordinates[j + 1];
        dest[i++] = transform[0] * x + transform[2] * y + transform[4];
        dest[i++] = transform[1] * x + transform[3] * y + transform[5];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}
function rotate(flatCoordinates, offset, end, stride, angle, anchor, dest) {
    dest = dest ? dest : [];
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const anchorX = anchor[0];
    const anchorY = anchor[1];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        const deltaX = flatCoordinates[j] - anchorX;
        const deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + deltaX * cos - deltaY * sin;
        dest[i++] = anchorY + deltaX * sin + deltaY * cos;
        for(let k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
    dest = dest ? dest : [];
    const anchorX = anchor[0];
    const anchorY = anchor[1];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        const deltaX = flatCoordinates[j] - anchorX;
        const deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + sx * deltaX;
        dest[i++] = anchorY + sy * deltaY;
        for(let k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
    dest = dest ? dest : [];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        dest[i++] = flatCoordinates[j] + deltaX;
        dest[i++] = flatCoordinates[j + 1] + deltaY;
        for(let k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5urVB":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/closest
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "maxSquaredDelta", ()=>maxSquaredDelta);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "arrayMaxSquaredDelta", ()=>arrayMaxSquaredDelta);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "multiArrayMaxSquaredDelta", ()=>multiArrayMaxSquaredDelta);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestPoint", ()=>assignClosestPoint);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestArrayPoint", ()=>assignClosestArrayPoint);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestMultiArrayPoint", ()=>assignClosestMultiArrayPoint);
var _mathJs = require("../../math.js");
/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */ function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
    const x1 = flatCoordinates[offset1];
    const y1 = flatCoordinates[offset1 + 1];
    const dx = flatCoordinates[offset2] - x1;
    const dy = flatCoordinates[offset2 + 1] - y1;
    let offset;
    if (dx === 0 && dy === 0) offset = offset1;
    else {
        const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) offset = offset2;
        else if (t > 0) {
            for(let i = 0; i < stride; ++i)closestPoint[i] = (0, _mathJs.lerp)(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
            closestPoint.length = stride;
            return;
        } else offset = offset1;
    }
    for(let i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[offset + i];
    closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    for(offset += stride; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        const squaredDelta = (0, _mathJs.squaredDistance)(x1, y1, x2, y2);
        if (squaredDelta > max) max = squaredDelta;
        x1 = x2;
        y1 = y2;
    }
    return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
        offset = end;
    }
    return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
        offset = ends[ends.length - 1];
    }
    return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    if (offset == end) return minSquaredDistance;
    let i, squaredDistance;
    if (maxDelta === 0) {
        // All points are identical, so just test the first point.
        squaredDistance = (0, _mathJs.squaredDistance)(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
        if (squaredDistance < minSquaredDistance) {
            for(i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[offset + i];
            closestPoint.length = stride;
            return squaredDistance;
        }
        return minSquaredDistance;
    }
    tmpPoint = tmpPoint ? tmpPoint : [
        NaN,
        NaN
    ];
    let index = offset + stride;
    while(index < end){
        assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
        squaredDistance = (0, _mathJs.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance < minSquaredDistance) {
            minSquaredDistance = squaredDistance;
            for(i = 0; i < stride; ++i)closestPoint[i] = tmpPoint[i];
            closestPoint.length = stride;
            index += stride;
        } else // Skip ahead multiple points, because we know that all the skipped
        // points cannot be any closer than the closest point we have found so
        // far.  We know this because we know how close the current point is, how
        // close the closest point we have found so far is, and the maximum
        // distance between consecutive points.  For example, if we're currently
        // at distance 10, the best we've found so far is 3, and that the maximum
        // distance between consecutive points is 2, then we'll need to skip at
        // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
        // finding a closer point.  We use Math.max(..., 1) to ensure that we
        // always advance at least one point, to avoid an infinite loop.
        index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
    if (isRing) {
        // Check the closing segment.
        assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
        squaredDistance = (0, _mathJs.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance < minSquaredDistance) {
            minSquaredDistance = squaredDistance;
            for(i = 0; i < stride; ++i)closestPoint[i] = tmpPoint[i];
            closestPoint.length = stride;
        }
    }
    return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [
        NaN,
        NaN
    ];
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = end;
    }
    return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [
        NaN,
        NaN
    ];
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = ends[ends.length - 1];
    }
    return minSquaredDistance;
}

},{"../../math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"is4mF":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/deflate
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "deflateCoordinate", ()=>deflateCoordinate);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */ parcelHelpers.export(exports, "deflateCoordinates", ()=>deflateCoordinates);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [ends] Ends.
 * @return {Array<number>} Ends.
 */ parcelHelpers.export(exports, "deflateCoordinatesArray", ()=>deflateCoordinatesArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */ parcelHelpers.export(exports, "deflateMultiCoordinatesArray", ()=>deflateMultiCoordinatesArray);
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
    for(let i = 0, ii = coordinate.length; i < ii; ++i)flatCoordinates[offset++] = coordinate[i];
    return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
    for(let i = 0, ii = coordinates.length; i < ii; ++i){
        const coordinate = coordinates[i];
        for(let j = 0; j < stride; ++j)flatCoordinates[offset++] = coordinate[j];
    }
    return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
    ends = ends ? ends : [];
    let i = 0;
    for(let j = 0, jj = coordinatess.length; j < jj; ++j){
        const end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
        ends[i++] = end;
        offset = end;
    }
    ends.length = i;
    return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, endss) {
    endss = endss ? endss : [];
    let i = 0;
    for(let j = 0, jj = coordinatesss.length; j < jj; ++j){
        const ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
        if (ends.length === 0) ends[0] = offset;
        endss[i++] = ends;
        offset = ends[ends.length - 1];
    }
    endss.length = i;
    return endss;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gXvXA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/simplify
 */ // Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */ parcelHelpers.export(exports, "simplifyLineString", ()=>simplifyLineString);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeucker", ()=>douglasPeucker);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeuckerArray", ()=>douglasPeuckerArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeuckerMultiArray", ()=>douglasPeuckerMultiArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "radialDistance", ()=>radialDistance);
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */ parcelHelpers.export(exports, "snap", ()=>snap);
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantize", ()=>quantize);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantizeArray", ()=>quantizeArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantizeMultiArray", ()=>quantizeMultiArray);
var _mathJs = require("../../math.js");
function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, simplifiedFlatCoordinates) {
    simplifiedFlatCoordinates = simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];
    if (!highQuality) {
        end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        flatCoordinates = simplifiedFlatCoordinates;
        offset = 0;
        stride = 2;
    }
    simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return simplifiedFlatCoordinates;
}
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    const n = (end - offset) / stride;
    if (n < 3) {
        for(; offset < end; offset += stride){
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
    }
    /** @type {Array<number>} */ const markers = new Array(n);
    markers[0] = 1;
    markers[n - 1] = 1;
    /** @type {Array<number>} */ const stack = [
        offset,
        end - stride
    ];
    let index = 0;
    while(stack.length > 0){
        const last = stack.pop();
        const first = stack.pop();
        let maxSquaredDistance = 0;
        const x1 = flatCoordinates[first];
        const y1 = flatCoordinates[first + 1];
        const x2 = flatCoordinates[last];
        const y2 = flatCoordinates[last + 1];
        for(let i = first + stride; i < last; i += stride){
            const x = flatCoordinates[i];
            const y = flatCoordinates[i + 1];
            const squaredDistance = (0, _mathJs.squaredSegmentDistance)(x, y, x1, y1, x2, y2);
            if (squaredDistance > maxSquaredDistance) {
                index = i;
                maxSquaredDistance = squaredDistance;
            }
        }
        if (maxSquaredDistance > squaredTolerance) {
            markers[(index - offset) / stride] = 1;
            if (first + stride < index) stack.push(first, index);
            if (index + stride < last) stack.push(index, last);
        }
    }
    for(let i = 0; i < n; ++i)if (markers[i]) {
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
    return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
    }
    return simplifiedOffset;
}
function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        /** @type {Array<number>} */ const simplifiedEnds = [];
        simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
}
function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    if (end <= offset + stride) {
        // zero or one point, no simplification possible, so copy and return
        for(; offset < end; offset += stride){
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
    }
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    // copy first point
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    let x2 = x1;
    let y2 = y1;
    for(offset += stride; offset < end; offset += stride){
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        if ((0, _mathJs.squaredDistance)(x1, y1, x2, y2) > squaredTolerance) {
            // copy point at offset
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            x1 = x2;
            y1 = y2;
        }
    }
    if (x2 != x1 || y2 != y1) {
        // copy last point
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    }
    return simplifiedOffset;
}
function snap(value, tolerance) {
    return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    // do nothing if the line is empty
    if (offset == end) return simplifiedOffset;
    // snap the first coordinate (P1)
    let x1 = snap(flatCoordinates[offset], tolerance);
    let y1 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // add the first coordinate to the output
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    // find the next coordinate that does not snap to the same value as the first
    // coordinate (P2)
    let x2, y2;
    do {
        x2 = snap(flatCoordinates[offset], tolerance);
        y2 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        if (offset == end) {
            // all coordinates snap to the same value, the line collapses to a point
            // push the last snapped value anyway to ensure that the output contains
            // at least two points
            // FIXME should we really return at least two points anyway?
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            return simplifiedOffset;
        }
    }while (x2 == x1 && y2 == y1);
    while(offset < end){
        // snap the next coordinate (P3)
        const x3 = snap(flatCoordinates[offset], tolerance);
        const y3 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        // skip P3 if it is equal to P2
        if (x3 == x2 && y3 == y2) continue;
        // calculate the delta between P1 and P2
        const dx1 = x2 - x1;
        const dy1 = y2 - y1;
        // calculate the delta between P3 and P1
        const dx2 = x3 - x1;
        const dy2 = y3 - y1;
        // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
        // P1 in the same direction then P2 is on the straight line between P1 and
        // P3
        if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
            // discard P2 and set P2 = P3
            x2 = x3;
            y2 = y3;
            continue;
        }
        // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
        // between P3 and P1 or on the opposite half of the line to P2.  add P2,
        // and continue with P1 = P2 and P2 = P3
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
        x1 = x2;
        y1 = y2;
        x2 = x3;
        y2 = y3;
    }
    // add the last point (P2)
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
    }
    return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        /** @type {Array<number>} */ const simplifiedEnds = [];
        simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
}

},{"../../math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hm7Zu":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/inflate
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inflateCoordinates", ()=>inflateCoordinates);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */ parcelHelpers.export(exports, "inflateCoordinatesArray", ()=>inflateCoordinatesArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */ parcelHelpers.export(exports, "inflateMultiCoordinatesArray", ()=>inflateMultiCoordinatesArray);
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates) {
    coordinates = coordinates !== undefined ? coordinates : [];
    let i = 0;
    for(let j = offset; j < end; j += stride)coordinates[i++] = flatCoordinates.slice(j, j + stride);
    coordinates.length = i;
    return coordinates;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
    coordinatess = coordinatess !== undefined ? coordinatess : [];
    let i = 0;
    for(let j = 0, jj = ends.length; j < jj; ++j){
        const end = ends[j];
        coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
        offset = end;
    }
    coordinatess.length = i;
    return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
    coordinatesss = coordinatesss !== undefined ? coordinatesss : [];
    let i = 0;
    for(let j = 0, jj = endss.length; j < jj; ++j){
        const ends = endss[j];
        coordinatesss[i++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
        offset = ends[ends.length - 1];
    }
    coordinatesss.length = i;
    return coordinatesss;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8w7cR":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/area
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "linearRing", ()=>linearRing);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ parcelHelpers.export(exports, "linearRings", ()=>linearRings);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ parcelHelpers.export(exports, "linearRingss", ()=>linearRingss);
function linearRing(flatCoordinates, offset, end, stride) {
    let twiceArea = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        twiceArea += y1 * x2 - x1 * y2;
        x1 = x2;
        y1 = y2;
    }
    return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
    let area = 0;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        area += linearRing(flatCoordinates, offset, end, stride);
        offset = end;
    }
    return area;
}
function linearRingss(flatCoordinates, offset, endss, stride) {
    let area = 0;
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        area += linearRings(flatCoordinates, offset, ends, stride);
        offset = ends[ends.length - 1];
    }
    return area;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6SybV":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/Point
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _mathJs = require("../math.js");
/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */ class Point extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        this.setCoordinates(coordinates, layout);
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */ clone() {
        const point = new Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const squaredDistance = (0, _mathJs.squaredDistance)(x, y, flatCoordinates[0], flatCoordinates[1]);
        if (squaredDistance < minSquaredDistance) {
            const stride = this.stride;
            for(let i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[i];
            closestPoint.length = stride;
            return squaredDistance;
        }
        return minSquaredDistance;
    }
    /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */ getCoordinates() {
        return this.flatCoordinates.slice();
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        return (0, _extentJs.createOrUpdateFromCoordinate)(this.flatCoordinates, extent);
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'Point';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _extentJs.containsXY)(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
    }
    /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 0);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinate)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = Point;

},{"./SimpleGeometry.js":"iZYIt","../extent.js":"bGUel","./flat/deflate.js":"is4mF","../math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ii0ve":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/interiorpoint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */ parcelHelpers.export(exports, "getInteriorPointOfArray", ()=>getInteriorPointOfArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */ parcelHelpers.export(exports, "getInteriorPointsOfMultiArray", ()=>getInteriorPointsOfMultiArray);
var _arrayJs = require("../../array.js");
var _containsJs = require("./contains.js");
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
    let i, ii, x, x1, x2, y1, y2;
    const y = flatCenters[flatCentersOffset + 1];
    /** @type {Array<number>} */ const intersections = [];
    // Calculate intersections with the horizontal line
    for(let r = 0, rr = ends.length; r < rr; ++r){
        const end = ends[r];
        x1 = flatCoordinates[end - stride];
        y1 = flatCoordinates[end - stride + 1];
        for(i = offset; i < end; i += stride){
            x2 = flatCoordinates[i];
            y2 = flatCoordinates[i + 1];
            if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
                x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
                intersections.push(x);
            }
            x1 = x2;
            y1 = y2;
        }
    }
    // Find the longest segment of the horizontal line that has its center point
    // inside the linear ring.
    let pointX = NaN;
    let maxSegmentLength = -Infinity;
    intersections.sort((0, _arrayJs.ascending));
    x1 = intersections[0];
    for(i = 1, ii = intersections.length; i < ii; ++i){
        x2 = intersections[i];
        const segmentLength = Math.abs(x2 - x1);
        if (segmentLength > maxSegmentLength) {
            x = (x1 + x2) / 2;
            if ((0, _containsJs.linearRingsContainsXY)(flatCoordinates, offset, ends, stride, x, y)) {
                pointX = x;
                maxSegmentLength = segmentLength;
            }
        }
        x1 = x2;
    }
    if (isNaN(pointX)) // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
    if (dest) {
        dest.push(pointX, y, maxSegmentLength);
        return dest;
    }
    return [
        pointX,
        y,
        maxSegmentLength
    ];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
    /** @type {Array<number>} */ let interiorPoints = [];
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
        offset = ends[ends.length - 1];
    }
    return interiorPoints;
}

},{"../../array.js":"hyet5","./contains.js":"kCfKA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kCfKA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/contains
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */ parcelHelpers.export(exports, "linearRingContainsExtent", ()=>linearRingContainsExtent);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingContainsXY", ()=>linearRingContainsXY);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingsContainsXY", ()=>linearRingsContainsXY);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingssContainsXY", ()=>linearRingssContainsXY);
var _extentJs = require("../../extent.js");
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
    const outside = (0, _extentJs.forEachCorner)(extent, /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */ function(coordinate) {
        return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
    });
    return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
    // https://geomalgorithms.com/a03-_inclusion.html
    // Copyright 2000 softSurfer, 2012 Dan Sunday
    // This code may be freely used and modified for any purpose
    // providing that this copyright notice is included with it.
    // SoftSurfer makes no warranty for this code, and cannot be held
    // liable for any real or imagined damage resulting from its use.
    // Users of this code must verify correctness for their application.
    let wn = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        if (y1 <= y) {
            if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) wn++;
        } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) wn--;
        x1 = x2;
        y1 = y2;
    }
    return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
    if (ends.length === 0) return false;
    if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) return false;
    for(let i = 1, ii = ends.length; i < ii; ++i){
        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) return false;
    }
    return true;
}
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
    if (endss.length === 0) return false;
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) return true;
        offset = ends[ends.length - 1];
    }
    return false;
}

},{"../../extent.js":"bGUel","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"empkw":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/intersectsextent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLineString", ()=>intersectsLineString);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLineStringArray", ()=>intersectsLineStringArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRing", ()=>intersectsLinearRing);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRingArray", ()=>intersectsLinearRingArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRingMultiArray", ()=>intersectsLinearRingMultiArray);
var _extentJs = require("../../extent.js");
var _segmentsJs = require("./segments.js");
var _containsJs = require("./contains.js");
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
    const coordinatesExtent = (0, _extentJs.extendFlatCoordinates)((0, _extentJs.createEmpty)(), flatCoordinates, offset, end, stride);
    if (!(0, _extentJs.intersects)(extent, coordinatesExtent)) return false;
    if ((0, _extentJs.containsExtent)(extent, coordinatesExtent)) return true;
    if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) return true;
    if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) return true;
    return (0, _segmentsJs.forEach)(flatCoordinates, offset, end, stride, /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */ function(point1, point2) {
        return (0, _extentJs.intersectsSegment)(extent, point1, point2);
    });
}
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) return true;
        offset = ends[i];
    }
    return false;
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
    if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[1])) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[3])) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[1])) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[3])) return true;
    return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
    if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) return false;
    if (ends.length === 1) return true;
    for(let i = 1, ii = ends.length; i < ii; ++i)if ((0, _containsJs.linearRingContainsExtent)(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) return false;
    }
    return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) return true;
        offset = ends[ends.length - 1];
    }
    return false;
}

},{"../../extent.js":"bGUel","./segments.js":"1jUrz","./contains.js":"kCfKA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1jUrz":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/segments
 */ /**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "forEach", ()=>forEach);
function forEach(flatCoordinates, offset, end, stride, callback) {
    let ret;
    offset += stride;
    for(; offset < end; offset += stride){
        ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));
        if (ret) return ret;
    }
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kVTqd":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/orient
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean|undefined} Is clockwise.
 */ parcelHelpers.export(exports, "linearRingIsClockwise", ()=>linearRingIsClockwise);
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */ parcelHelpers.export(exports, "linearRingsAreOriented", ()=>linearRingsAreOriented);
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */ parcelHelpers.export(exports, "linearRingssAreOriented", ()=>linearRingssAreOriented);
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */ parcelHelpers.export(exports, "orientLinearRings", ()=>orientLinearRings);
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */ parcelHelpers.export(exports, "orientLinearRingsArray", ()=>orientLinearRingsArray);
/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to construct a MultiPolygon
 */ parcelHelpers.export(exports, "inflateEnds", ()=>inflateEnds);
var _reverseJs = require("./reverse.js");
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
    // https://stackoverflow.com/q/1165647/clockwise-method#1165943
    // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
    let edge = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        edge += (x2 - x1) * (y2 + y1);
        x1 = x2;
        y1 = y2;
    }
    return edge === 0 ? undefined : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
    right = right !== undefined ? right : false;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        const isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
        if (i === 0) {
            if (right && isClockwise || !right && !isClockwise) return false;
        } else {
            if (right && !isClockwise || !right && isClockwise) return false;
        }
        offset = end;
    }
    return true;
}
function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) return false;
        if (ends.length) offset = ends[ends.length - 1];
    }
    return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
    right = right !== undefined ? right : false;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        const isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
        const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
        if (reverse) (0, _reverseJs.coordinates)(flatCoordinates, offset, end, stride);
        offset = end;
    }
    return offset;
}
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {
    for(let i = 0, ii = endss.length; i < ii; ++i)offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, right);
    return offset;
}
function inflateEnds(flatCoordinates, ends) {
    const endss = [];
    let offset = 0;
    let prevEndIndex = 0;
    let startOrientation;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        // classifies an array of rings into polygons with outer rings and holes
        const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
        if (startOrientation === undefined) startOrientation = orientation;
        if (orientation === startOrientation) endss.push(ends.slice(prevEndIndex, i + 1));
        else {
            if (endss.length === 0) continue;
            endss[endss.length - 1].push(ends[prevEndIndex]);
        }
        prevEndIndex = i + 1;
        offset = end;
    }
    return endss;
}

},{"./reverse.js":"1s4T7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1s4T7":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/reverse
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "coordinates", ()=>coordinates);
function coordinates(flatCoordinates, offset, end, stride) {
    while(offset < end - stride){
        for(let i = 0; i < stride; ++i){
            const tmp = flatCoordinates[offset + i];
            flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
            flatCoordinates[end - stride + i] = tmp;
        }
        offset += stride;
        end -= stride;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e6ARE":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/Event
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
class RenderEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */ constructor(type, inversePixelTransform, frameState, context){
        super(type);
        /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */ this.inversePixelTransform = inversePixelTransform;
        /**
     * An object representing the current render frame state.
     * @type {import("../Map.js").FrameState|undefined}
     * @api
     */ this.frameState = frameState;
        /**
     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
     * context.
     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
     * @api
     */ this.context = context;
    }
}
exports.default = RenderEvent;

},{"../events/Event.js":"kooRA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b247l":[function(require,module,exports,__globalThis) {
/**
 * @module ol/css
 */ /**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */ /**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CLASS_HIDDEN", ()=>CLASS_HIDDEN);
parcelHelpers.export(exports, "CLASS_SELECTABLE", ()=>CLASS_SELECTABLE);
parcelHelpers.export(exports, "CLASS_UNSELECTABLE", ()=>CLASS_UNSELECTABLE);
parcelHelpers.export(exports, "CLASS_UNSUPPORTED", ()=>CLASS_UNSUPPORTED);
parcelHelpers.export(exports, "CLASS_CONTROL", ()=>CLASS_CONTROL);
parcelHelpers.export(exports, "CLASS_COLLAPSED", ()=>CLASS_COLLAPSED);
parcelHelpers.export(exports, "getFontParameters", ()=>getFontParameters);
const CLASS_HIDDEN = 'ol-hidden';
const CLASS_SELECTABLE = 'ol-selectable';
const CLASS_UNSELECTABLE = 'ol-unselectable';
const CLASS_UNSUPPORTED = 'ol-unsupported';
const CLASS_CONTROL = 'ol-control';
const CLASS_COLLAPSED = 'ol-collapsed';
/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */ const fontRegEx = new RegExp([
    '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
    '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
    '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
    '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
    '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$'
].join(''), 'i');
/** @type {Array<'style'|'variant'|'weight'|'size'|'lineHeight'|'family'>} */ const fontRegExMatchIndex = [
    'style',
    'variant',
    'weight',
    'size',
    'lineHeight',
    'family'
];
const getFontParameters = function(fontSpec) {
    const match = fontSpec.match(fontRegEx);
    if (!match) return null;
    const style = /** @type {FontParameters} */ {
        lineHeight: 'normal',
        size: '1.2em',
        style: 'normal',
        weight: 'normal',
        variant: 'normal'
    };
    for(let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i){
        const value = match[i + 1];
        if (value !== undefined) style[fontRegExMatchIndex[i]] = value;
    }
    style.families = style.family.split(/,\s?/);
    return style;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6S9WQ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultFont", ()=>defaultFont);
parcelHelpers.export(exports, "defaultFillStyle", ()=>defaultFillStyle);
parcelHelpers.export(exports, "defaultLineCap", ()=>defaultLineCap);
parcelHelpers.export(exports, "defaultLineDash", ()=>defaultLineDash);
parcelHelpers.export(exports, "defaultLineDashOffset", ()=>defaultLineDashOffset);
parcelHelpers.export(exports, "defaultLineJoin", ()=>defaultLineJoin);
parcelHelpers.export(exports, "defaultMiterLimit", ()=>defaultMiterLimit);
parcelHelpers.export(exports, "defaultStrokeStyle", ()=>defaultStrokeStyle);
parcelHelpers.export(exports, "defaultTextAlign", ()=>defaultTextAlign);
parcelHelpers.export(exports, "defaultTextBaseline", ()=>defaultTextBaseline);
parcelHelpers.export(exports, "defaultPadding", ()=>defaultPadding);
parcelHelpers.export(exports, "defaultLineWidth", ()=>defaultLineWidth);
parcelHelpers.export(exports, "checkedFonts", ()=>checkedFonts);
parcelHelpers.export(exports, "textHeights", ()=>textHeights);
parcelHelpers.export(exports, "registerFont", ()=>registerFont);
parcelHelpers.export(exports, "measureTextHeight", ()=>measureTextHeight);
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */ parcelHelpers.export(exports, "measureTextWidth", ()=>measureTextWidth);
/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */ parcelHelpers.export(exports, "measureAndCacheTextWidth", ()=>measureAndCacheTextWidth);
/**
 * @param {TextState} baseStyle Base style.
 * @param {Array<string>} chunks Text chunks to measure.
 * @return {{width: number, height: number, widths: Array<number>, heights: Array<number>, lineWidths: Array<number>}}} Text metrics.
 */ parcelHelpers.export(exports, "getTextDimensions", ()=>getTextDimensions);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */ parcelHelpers.export(exports, "rotateAtOffset", ()=>rotateAtOffset);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */ parcelHelpers.export(exports, "drawImageOrLabel", ()=>drawImageOrLabel);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _hasJs = require("../has.js");
var _objJs = require("../obj.js");
var _domJs = require("../dom.js");
var _cssJs = require("../css.js");
const defaultFont = '10px sans-serif';
const defaultFillStyle = '#000';
const defaultLineCap = 'round';
const defaultLineDash = [];
const defaultLineDashOffset = 0;
const defaultLineJoin = 'round';
const defaultMiterLimit = 10;
const defaultStrokeStyle = '#000';
const defaultTextAlign = 'center';
const defaultTextBaseline = 'middle';
const defaultPadding = [
    0,
    0,
    0,
    0
];
const defaultLineWidth = 1;
const checkedFonts = new (0, _objectJsDefault.default)();
/**
 * @type {CanvasRenderingContext2D}
 */ let measureContext = null;
/**
 * @type {string}
 */ let measureFont;
const textHeights = {};
const registerFont = function() {
    const retries = 100;
    const size = '32px ';
    const referenceFonts = [
        'monospace',
        'serif'
    ];
    const len = referenceFonts.length;
    const text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
    let interval, referenceWidth;
    /**
   * @param {string} fontStyle Css font-style
   * @param {string} fontWeight Css font-weight
   * @param {*} fontFamily Css font-family
   * @return {boolean} Font with style and weight is available
   */ function isAvailable(fontStyle, fontWeight, fontFamily) {
        let available = true;
        for(let i = 0; i < len; ++i){
            const referenceFont = referenceFonts[i];
            referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);
            if (fontFamily != referenceFont) {
                const width = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + fontFamily + ',' + referenceFont, text);
                // If width and referenceWidth are the same, then the fallback was used
                // instead of the font we wanted, so the font is not available.
                available = available && width != referenceWidth;
            }
        }
        if (available) return true;
        return false;
    }
    function check() {
        let done = true;
        const fonts = checkedFonts.getKeys();
        for(let i = 0, ii = fonts.length; i < ii; ++i){
            const font = fonts[i];
            if (checkedFonts.get(font) < retries) {
                if (isAvailable.apply(this, font.split('\n'))) {
                    (0, _objJs.clear)(textHeights);
                    // Make sure that loaded fonts are picked up by Safari
                    measureContext = null;
                    measureFont = undefined;
                    checkedFonts.set(font, retries);
                } else {
                    checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                    done = false;
                }
            }
        }
        if (done) {
            clearInterval(interval);
            interval = undefined;
        }
    }
    return function(fontSpec) {
        const font = (0, _cssJs.getFontParameters)(fontSpec);
        if (!font) return;
        const families = font.families;
        for(let i = 0, ii = families.length; i < ii; ++i){
            const family = families[i];
            const key = font.style + '\n' + font.weight + '\n' + family;
            if (checkedFonts.get(key) === undefined) {
                checkedFonts.set(key, retries, true);
                if (!isAvailable(font.style, font.weight, family)) {
                    checkedFonts.set(key, 0, true);
                    if (interval === undefined) interval = setInterval(check, 32);
                }
            }
        }
    };
}();
const measureTextHeight = function() {
    /**
   * @type {HTMLDivElement}
   */ let measureElement;
    return function(fontSpec) {
        let height = textHeights[fontSpec];
        if (height == undefined) {
            if (0, _hasJs.WORKER_OFFSCREEN_CANVAS) {
                const font = (0, _cssJs.getFontParameters)(fontSpec);
                const metrics = measureText(fontSpec, "\u017Dg");
                const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
                height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
            } else {
                if (!measureElement) {
                    measureElement = document.createElement('div');
                    measureElement.innerHTML = 'M';
                    measureElement.style.minHeight = '0';
                    measureElement.style.maxHeight = 'none';
                    measureElement.style.height = 'auto';
                    measureElement.style.padding = '0';
                    measureElement.style.border = 'none';
                    measureElement.style.position = 'absolute';
                    measureElement.style.display = 'block';
                    measureElement.style.left = '-99999px';
                }
                measureElement.style.font = fontSpec;
                document.body.appendChild(measureElement);
                height = measureElement.offsetHeight;
                document.body.removeChild(measureElement);
            }
            textHeights[fontSpec] = height;
        }
        return height;
    };
}();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */ function measureText(font, text) {
    if (!measureContext) measureContext = (0, _domJs.createCanvasContext2D)(1, 1);
    if (font != measureFont) {
        measureContext.font = font;
        measureFont = measureContext.font;
    }
    return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
    return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache) {
    if (text in cache) return cache[text];
    const width = text.split('\n').reduce((prev, curr)=>Math.max(prev, measureTextWidth(font, curr)), 0);
    cache[text] = width;
    return width;
}
function getTextDimensions(baseStyle, chunks) {
    const widths = [];
    const heights = [];
    const lineWidths = [];
    let width = 0;
    let lineWidth = 0;
    let height = 0;
    let lineHeight = 0;
    for(let i = 0, ii = chunks.length; i <= ii; i += 2){
        const text = chunks[i];
        if (text === '\n' || i === ii) {
            width = Math.max(width, lineWidth);
            lineWidths.push(lineWidth);
            lineWidth = 0;
            height += lineHeight;
            continue;
        }
        const font = chunks[i + 1] || baseStyle.font;
        const currentWidth = measureTextWidth(font, text);
        widths.push(currentWidth);
        lineWidth += currentWidth;
        const currentHeight = measureTextHeight(font);
        heights.push(currentHeight);
        lineHeight = Math.max(lineHeight, currentHeight);
    }
    return {
        width,
        height,
        widths,
        heights,
        lineWidths
    };
}
function rotateAtOffset(context, rotation, offsetX, offsetY) {
    if (rotation !== 0) {
        context.translate(offsetX, offsetY);
        context.rotate(rotation);
        context.translate(-offsetX, -offsetY);
    }
}
function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
    context.save();
    if (opacity !== 1) context.globalAlpha *= opacity;
    if (transform) context.transform.apply(context, transform);
    if (/** @type {*} */ labelOrImage.contextInstructions) {
        // label
        context.translate(x, y);
        context.scale(scale[0], scale[1]);
        executeLabelInstructions(/** @type {Label} */ labelOrImage, context);
    } else if (scale[0] < 0 || scale[1] < 0) {
        // flipped image
        context.translate(x, y);
        context.scale(scale[0], scale[1]);
        context.drawImage(/** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ labelOrImage, originX, originY, w, h, 0, 0, w, h);
    } else // if image not flipped translate and scale can be avoided
    context.drawImage(/** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ labelOrImage, originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
    context.restore();
}
/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */ function executeLabelInstructions(label, context) {
    const contextInstructions = label.contextInstructions;
    for(let i = 0, ii = contextInstructions.length; i < ii; i += 2)if (Array.isArray(contextInstructions[i + 1])) context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    else context[contextInstructions[i]] = contextInstructions[i + 1];
}

},{"../Object.js":"N6yIf","../has.js":"i07p3","../obj.js":"7RZD4","../dom.js":"h98kD","../css.js":"b247l","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h98kD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/dom
 */ //FIXME Move this function to the canvas module
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [width] Canvas width.
 * @param {number} [height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */ parcelHelpers.export(exports, "createCanvasContext2D", ()=>createCanvasContext2D);
/**
 * Releases canvas memory to avoid exceeding memory limits in Safari.
 * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
 * @param {CanvasRenderingContext2D} context Context.
 */ parcelHelpers.export(exports, "releaseCanvas", ()=>releaseCanvas);
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */ parcelHelpers.export(exports, "outerWidth", ()=>outerWidth);
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */ parcelHelpers.export(exports, "outerHeight", ()=>outerHeight);
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */ parcelHelpers.export(exports, "replaceNode", ()=>replaceNode);
/**
 * @param {Node} node The node to remove.
 * @return {Node|null} The node that was removed or null.
 */ parcelHelpers.export(exports, "removeNode", ()=>removeNode);
/**
 * @param {Node} node The node to remove the children from.
 */ parcelHelpers.export(exports, "removeChildren", ()=>removeChildren);
/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */ parcelHelpers.export(exports, "replaceChildren", ()=>replaceChildren);
var _hasJs = require("./has.js");
function createCanvasContext2D(width, height, canvasPool, settings) {
    /** @type {HTMLCanvasElement|OffscreenCanvas} */ let canvas;
    if (canvasPool && canvasPool.length) canvas = /** @type {HTMLCanvasElement} */ canvasPool.shift();
    else if (0, _hasJs.WORKER_OFFSCREEN_CANVAS) canvas = new OffscreenCanvas(width || 300, height || 300);
    else canvas = document.createElement('canvas');
    if (width) canvas.width = width;
    if (height) canvas.height = height;
    //FIXME Allow OffscreenCanvasRenderingContext2D as return type
    return /** @type {CanvasRenderingContext2D} */ canvas.getContext('2d', settings);
}
function releaseCanvas(context) {
    const canvas = context.canvas;
    canvas.width = 1;
    canvas.height = 1;
    context.clearRect(0, 0, 1, 1);
}
function outerWidth(element) {
    let width = element.offsetWidth;
    const style = getComputedStyle(element);
    width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
    return width;
}
function outerHeight(element) {
    let height = element.offsetHeight;
    const style = getComputedStyle(element);
    height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
    return height;
}
function replaceNode(newNode, oldNode) {
    const parent = oldNode.parentNode;
    if (parent) parent.replaceChild(newNode, oldNode);
}
function removeNode(node) {
    return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
function removeChildren(node) {
    while(node.lastChild)node.removeChild(node.lastChild);
}
function replaceChildren(node, children) {
    const oldChildren = node.childNodes;
    for(let i = 0;; ++i){
        const oldChild = oldChildren[i];
        const newChild = children[i];
        // check if our work is done
        if (!oldChild && !newChild) break;
        // check if children match
        if (oldChild === newChild) continue;
        // check if a new child needs to be added
        if (!oldChild) {
            node.appendChild(newChild);
            continue;
        }
        // check if an old child needs to be removed
        if (!newChild) {
            node.removeChild(oldChild);
            --i;
            continue;
        }
        // reorder
        node.insertBefore(newChild, oldChild);
    }
}

},{"./has.js":"i07p3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aXuQD":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/Group
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {'addlayer'|'removelayer'} EventType
 */ /**
 * @classdesc
 * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from
 * the group or one of its child groups.  When a layer group is added to or removed from another layer group,
 * a single event will be triggered (instead of one per layer in the group added or removed).
 */ parcelHelpers.export(exports, "GroupEvent", ()=>GroupEvent);
var _baseJs = require("./Base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _assertsJs = require("../asserts.js");
var _objJs = require("../obj.js");
var _extentJs = require("../extent.js");
var _utilJs = require("../util.js");
var _eventsJs = require("../events.js");
class GroupEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */ constructor(type, layer){
        super(type);
        /**
     * The added or removed layer.
     * @type {BaseLayer}
     * @api
     */ this.layer = layer;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:layers', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|Collection<import("./Base.js").default>} [layers] Child layers.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @enum {string}
 * @private
 */ const Property = {
    LAYERS: 'layers'
};
/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */ class LayerGroup extends (0, _baseJsDefault.default) {
    /**
   * @param {Options} [options] Layer options.
   */ constructor(options){
        options = options || {};
        const baseOptions = /** @type {Options} */ Object.assign({}, options);
        delete baseOptions.layers;
        let layers = options.layers;
        super(baseOptions);
        /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {GroupOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {GroupOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */ this.layersListenerKeys_ = [];
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */ this.listenerKeys_ = {};
        this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);
        if (layers) {
            if (Array.isArray(layers)) layers = new (0, _collectionJsDefault.default)(layers.slice(), {
                unique: true
            });
            else (0, _assertsJs.assert)(typeof /** @type {?} */ layers.getArray === 'function', 'Expected `layers` to be an array or a `Collection`');
        } else layers = new (0, _collectionJsDefault.default)(undefined, {
            unique: true
        });
        this.setLayers(layers);
    }
    /**
   * @private
   */ handleLayerChange_() {
        this.changed();
    }
    /**
   * @private
   */ handleLayersChanged_() {
        this.layersListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
        this.layersListenerKeys_.length = 0;
        const layers = this.getLayers();
        this.layersListenerKeys_.push((0, _eventsJs.listen)(layers, (0, _collectionEventTypeJsDefault.default).ADD, this.handleLayersAdd_, this), (0, _eventsJs.listen)(layers, (0, _collectionEventTypeJsDefault.default).REMOVE, this.handleLayersRemove_, this));
        for(const id in this.listenerKeys_)this.listenerKeys_[id].forEach((0, _eventsJs.unlistenByKey));
        (0, _objJs.clear)(this.listenerKeys_);
        const layersArray = layers.getArray();
        for(let i = 0, ii = layersArray.length; i < ii; i++){
            const layer = layersArray[i];
            this.registerLayerListeners_(layer);
            this.dispatchEvent(new GroupEvent('addlayer', layer));
        }
        this.changed();
    }
    /**
   * @param {BaseLayer} layer The layer.
   */ registerLayerListeners_(layer) {
        const listenerKeys = [
            (0, _eventsJs.listen)(layer, (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, this.handleLayerChange_, this),
            (0, _eventsJs.listen)(layer, (0, _eventTypeJsDefault.default).CHANGE, this.handleLayerChange_, this)
        ];
        if (layer instanceof LayerGroup) listenerKeys.push((0, _eventsJs.listen)(layer, 'addlayer', this.handleLayerGroupAdd_, this), (0, _eventsJs.listen)(layer, 'removelayer', this.handleLayerGroupRemove_, this));
        this.listenerKeys_[(0, _utilJs.getUid)(layer)] = listenerKeys;
    }
    /**
   * @param {GroupEvent} event The layer group event.
   */ handleLayerGroupAdd_(event) {
        this.dispatchEvent(new GroupEvent('addlayer', event.layer));
    }
    /**
   * @param {GroupEvent} event The layer group event.
   */ handleLayerGroupRemove_(event) {
        this.dispatchEvent(new GroupEvent('removelayer', event.layer));
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */ handleLayersAdd_(collectionEvent) {
        const layer = collectionEvent.element;
        this.registerLayerListeners_(layer);
        this.dispatchEvent(new GroupEvent('addlayer', layer));
        this.changed();
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */ handleLayersRemove_(collectionEvent) {
        const layer = collectionEvent.element;
        const key = (0, _utilJs.getUid)(layer);
        this.listenerKeys_[key].forEach((0, _eventsJs.unlistenByKey));
        delete this.listenerKeys_[key];
        this.dispatchEvent(new GroupEvent('removelayer', layer));
        this.changed();
    }
    /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */ getLayers() {
        return /** @type {!Collection<import("./Base.js").default>} */ this.get(Property.LAYERS);
    }
    /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */ setLayers(layers) {
        const collection = this.getLayers();
        if (collection) {
            const currentLayers = collection.getArray();
            for(let i = 0, ii = currentLayers.length; i < ii; ++i)this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));
        }
        this.set(Property.LAYERS, layers);
    }
    /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */ getLayersArray(array) {
        array = array !== undefined ? array : [];
        this.getLayers().forEach(function(layer) {
            layer.getLayersArray(array);
        });
        return array;
    }
    /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */ getLayerStatesArray(dest) {
        const states = dest !== undefined ? dest : [];
        const pos = states.length;
        this.getLayers().forEach(function(layer) {
            layer.getLayerStatesArray(states);
        });
        const ownLayerState = this.getLayerState();
        let defaultZIndex = ownLayerState.zIndex;
        if (!dest && ownLayerState.zIndex === undefined) defaultZIndex = 0;
        for(let i = pos, ii = states.length; i < ii; i++){
            const layerState = states[i];
            layerState.opacity *= ownLayerState.opacity;
            layerState.visible = layerState.visible && ownLayerState.visible;
            layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
            layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
            layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
            layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
            if (ownLayerState.extent !== undefined) {
                if (layerState.extent !== undefined) layerState.extent = (0, _extentJs.getIntersection)(layerState.extent, ownLayerState.extent);
                else layerState.extent = ownLayerState.extent;
            }
            if (layerState.zIndex === undefined) layerState.zIndex = defaultZIndex;
        }
        return states;
    }
    /**
   * @return {import("../source/Source.js").State} Source state.
   */ getSourceState() {
        return 'ready';
    }
}
exports.default = LayerGroup;

},{"./Base.js":"eAjKR","../Collection.js":"hzcJw","../CollectionEventType.js":"auN7R","../events/Event.js":"kooRA","../events/EventType.js":"3uT2C","../ObjectEventType.js":"cu9ir","../asserts.js":"k0OL6","../obj.js":"7RZD4","../extent.js":"bGUel","../util.js":"l1iPW","../events.js":"lh4km","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9dn5c":[function(require,module,exports,__globalThis) {
/**
 * @module ol/MapBrowserEvent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapEventJs = require("./MapEvent.js");
var _mapEventJsDefault = parcelHelpers.interopDefault(_mapEventJs);
/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */ class MapBrowserEvent extends (0, _mapEventJsDefault.default) {
    /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */ constructor(type, map, originalEvent, dragging, frameState, activePointers){
        super(type, map, frameState);
        /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */ this.originalEvent = originalEvent;
        /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     */ this.pixel_ = null;
        /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     */ this.coordinate_ = null;
        /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */ this.dragging = dragging !== undefined ? dragging : false;
        /**
     * @type {Array<PointerEvent>|undefined}
     */ this.activePointers = activePointers;
    }
    /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */ get pixel() {
        if (!this.pixel_) this.pixel_ = this.map.getEventPixel(this.originalEvent);
        return this.pixel_;
    }
    set pixel(pixel) {
        this.pixel_ = pixel;
    }
    /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */ get coordinate() {
        if (!this.coordinate_) this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
        return this.coordinate_;
    }
    set coordinate(coordinate) {
        this.coordinate_ = coordinate;
    }
    /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */ preventDefault() {
        super.preventDefault();
        if ('preventDefault' in this.originalEvent) /** @type {UIEvent} */ this.originalEvent.preventDefault();
    }
    /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */ stopPropagation() {
        super.stopPropagation();
        if ('stopPropagation' in this.originalEvent) /** @type {UIEvent} */ this.originalEvent.stopPropagation();
    }
}
exports.default = MapBrowserEvent;

},{"./MapEvent.js":"f5jvU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f5jvU":[function(require,module,exports,__globalThis) {
/**
 * @module ol/MapEvent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map event.
 */ class MapEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */ constructor(type, map, frameState){
        super(type);
        /**
     * The map where the event occurred.
     * @type {import("./Map.js").default}
     * @api
     */ this.map = map;
        /**
     * The frame state at the time of the event.
     * @type {?import("./Map.js").FrameState}
     * @api
     */ this.frameState = frameState !== undefined ? frameState : null;
    }
}
exports.default = MapEvent;

},{"./events/Event.js":"kooRA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eIMRV":[function(require,module,exports,__globalThis) {
/**
 * @module ol/MapBrowserEventHandler
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _mapBrowserEventJs = require("./MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventTypeJs = require("./MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _eventTypeJs1 = require("./pointer/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _hasJs = require("./has.js");
var _eventsJs = require("./events.js");
class MapBrowserEventHandler extends (0, _targetJsDefault.default) {
    /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */ constructor(map, moveTolerance){
        super(map);
        /**
     * This is the element that we will listen to the real events on.
     * @type {import("./Map.js").default}
     * @private
     */ this.map_ = map;
        /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */ this.clickTimeoutId_;
        /**
     * Emulate dblclick and singleclick. Will be true when only one pointer is active.
     * @type {boolean}
     */ this.emulateClicks_ = false;
        /**
     * @type {boolean}
     * @private
     */ this.dragging_ = false;
        /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */ this.dragListenerKeys_ = [];
        /**
     * @type {number}
     * @private
     */ this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;
        /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent|null}
     * @private
     */ this.down_ = null;
        const element = this.map_.getViewport();
        /**
     * @type {Array<PointerEvent>}
     * @private
     */ this.activePointers_ = [];
        /**
     * @type {!Object<number, Event>}
     * @private
     */ this.trackedTouches_ = {};
        this.element_ = element;
        /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */ this.pointerdownListenerKey_ = (0, _eventsJs.listen)(element, (0, _eventTypeJsDefault1.default).POINTERDOWN, this.handlePointerDown_, this);
        /**
     * @type {PointerEvent}
     * @private
     */ this.originalPointerMoveEvent_;
        /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */ this.relayedListenerKey_ = (0, _eventsJs.listen)(element, (0, _eventTypeJsDefault1.default).POINTERMOVE, this.relayMoveEvent_, this);
        /**
     * @private
     */ this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
        this.element_.addEventListener((0, _eventTypeJsDefault.default).TOUCHMOVE, this.boundHandleTouchMove_, (0, _hasJs.PASSIVE_EVENT_LISTENERS) ? {
            passive: false
        } : false);
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ emulateClick_(pointerEvent) {
        let newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).CLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
        if (this.clickTimeoutId_ !== undefined) {
            // double-click
            clearTimeout(this.clickTimeoutId_);
            this.clickTimeoutId_ = undefined;
            newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).DBLCLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
        } else // click
        this.clickTimeoutId_ = setTimeout(()=>{
            this.clickTimeoutId_ = undefined;
            const newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).SINGLECLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
        }, 250);
    }
    /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ updateActivePointers_(pointerEvent) {
        const event = pointerEvent;
        const id = event.pointerId;
        if (event.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERUP || event.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERCANCEL) {
            delete this.trackedTouches_[id];
            for(const pointerId in this.trackedTouches_)if (this.trackedTouches_[pointerId].target !== event.target) {
                // Some platforms assign a new pointerId when the target changes.
                // If this happens, delete one tracked pointer. If there is more
                // than one tracked pointer for the old target, it will be cleared
                // by subsequent POINTERUP events from other pointers.
                delete this.trackedTouches_[pointerId];
                break;
            }
        } else if (event.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERDOWN || event.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE) this.trackedTouches_[id] = event;
        this.activePointers_ = Object.values(this.trackedTouches_);
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ handlePointerUp_(pointerEvent) {
        this.updateActivePointers_(pointerEvent);
        const newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
        this.dispatchEvent(newEvent);
        // We emulate click events on left mouse button click, touch contact, and pen
        // contact. isMouseActionButton returns true in these cases (evt.button is set
        // to 0).
        // See http://www.w3.org/TR/pointerevents/#button-states
        // We only fire click, singleclick, and doubleclick if nobody has called
        // event.preventDefault().
        if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) this.emulateClick_(this.down_);
        if (this.activePointers_.length === 0) {
            this.dragListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
            this.dragListenerKeys_.length = 0;
            this.dragging_ = false;
            this.down_ = null;
        }
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */ isMouseActionButton_(pointerEvent) {
        return pointerEvent.button === 0;
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ handlePointerDown_(pointerEvent) {
        this.emulateClicks_ = this.activePointers_.length === 0;
        this.updateActivePointers_(pointerEvent);
        const newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
        this.dispatchEvent(newEvent);
        this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
        Object.defineProperty(this.down_, 'target', {
            writable: false,
            value: pointerEvent.target
        });
        if (this.dragListenerKeys_.length === 0) {
            const doc = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push((0, _eventsJs.listen)(doc, (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE, this.handlePointerMove_, this), (0, _eventsJs.listen)(doc, (0, _mapBrowserEventTypeJsDefault.default).POINTERUP, this.handlePointerUp_, this), /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */ (0, _eventsJs.listen)(this.element_, (0, _mapBrowserEventTypeJsDefault.default).POINTERCANCEL, this.handlePointerUp_, this));
            if (this.element_.getRootNode && this.element_.getRootNode() !== doc) this.dragListenerKeys_.push((0, _eventsJs.listen)(this.element_.getRootNode(), (0, _mapBrowserEventTypeJsDefault.default).POINTERUP, this.handlePointerUp_, this));
        }
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ handlePointerMove_(pointerEvent) {
        // Between pointerdown and pointerup, pointermove events are triggered.
        // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
        // moved a significant distance.
        if (this.isMoving_(pointerEvent)) {
            this.updateActivePointers_(pointerEvent);
            this.dragging_ = true;
            const newEvent = new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);
            this.dispatchEvent(newEvent);
        }
    }
    /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */ relayMoveEvent_(pointerEvent) {
        this.originalPointerMoveEvent_ = pointerEvent;
        const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
        this.dispatchEvent(new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE, this.map_, pointerEvent, dragging));
    }
    /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */ handleTouchMove_(event) {
        // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
        // may not be initialized yet when we get here on a platform without native pointer events,
        // when elm-pep is used as pointer events polyfill.
        const originalEvent = this.originalPointerMoveEvent_;
        if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) event.preventDefault();
    }
    /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */ isMoving_(pointerEvent) {
        return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        if (this.relayedListenerKey_) {
            (0, _eventsJs.unlistenByKey)(this.relayedListenerKey_);
            this.relayedListenerKey_ = null;
        }
        this.element_.removeEventListener((0, _eventTypeJsDefault.default).TOUCHMOVE, this.boundHandleTouchMove_);
        if (this.pointerdownListenerKey_) {
            (0, _eventsJs.unlistenByKey)(this.pointerdownListenerKey_);
            this.pointerdownListenerKey_ = null;
        }
        this.dragListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
        this.dragListenerKeys_.length = 0;
        this.element_ = null;
        super.disposeInternal();
    }
}
exports.default = MapBrowserEventHandler;

},{"./events/EventType.js":"3uT2C","./MapBrowserEvent.js":"9dn5c","./MapBrowserEventType.js":"2Xhyu","./pointer/EventType.js":"d5kzv","./events/Target.js":"dZel6","./has.js":"i07p3","./events.js":"lh4km","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2Xhyu":[function(require,module,exports,__globalThis) {
/**
 * @module ol/MapBrowserEventType
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
/**
 * Constants for event names.
 * @enum {string}
 */ exports.default = {
    /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */ SINGLECLICK: 'singleclick',
    /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */ CLICK: (0, _eventTypeJsDefault.default).CLICK,
    /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */ DBLCLICK: (0, _eventTypeJsDefault.default).DBLCLICK,
    /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */ POINTERDRAG: 'pointerdrag',
    /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */ POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel'
}; /***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */ 

},{"./events/EventType.js":"3uT2C","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d5kzv":[function(require,module,exports,__globalThis) {
/**
 * @module ol/pointer/EventType
 */ /**
 * Constants for event names.
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lytOT":[function(require,module,exports,__globalThis) {
/**
 * @module ol/MapEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */ POSTRENDER: 'postrender',
    /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */ MOVESTART: 'movestart',
    /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */ MOVEEND: 'moveend',
    /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */ LOADSTART: 'loadstart',
    /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */ LOADEND: 'loadend'
}; /***
 * @typedef {'postrender'|'movestart'|'moveend'|'loadstart'|'loadend'} Types
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k5jat":[function(require,module,exports,__globalThis) {
/**
 * @module ol/MapProperty
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    LAYERGROUP: 'layergroup',
    SIZE: 'size',
    TARGET: 'target',
    VIEW: 'view'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"390Pw":[function(require,module,exports,__globalThis) {
/**
 * @module ol/TileQueue
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import('./Map.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */ parcelHelpers.export(exports, "getTilePriority", ()=>getTilePriority);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _priorityQueueJs = require("./structs/PriorityQueue.js");
var _priorityQueueJsDefault = parcelHelpers.interopDefault(_priorityQueueJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */ class TileQueue extends (0, _priorityQueueJsDefault.default) {
    /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */ constructor(tilePriorityFunction, tileChangeCallback){
        super(/**
       * @param {Array} element Element.
       * @return {number} Priority.
       */ function(element) {
            return tilePriorityFunction.apply(null, element);
        }, /**
       * @param {Array} element Element.
       * @return {string} Key.
       */ function(element) {
            return /** @type {import("./Tile.js").default} */ element[0].getKey();
        });
        /** @private */ this.boundHandleTileChange_ = this.handleTileChange.bind(this);
        /**
     * @private
     * @type {function(): ?}
     */ this.tileChangeCallback_ = tileChangeCallback;
        /**
     * @private
     * @type {number}
     */ this.tilesLoading_ = 0;
        /**
     * @private
     * @type {!Object<string,boolean>}
     */ this.tilesLoadingKeys_ = {};
    }
    /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */ enqueue(element) {
        const added = super.enqueue(element);
        if (added) {
            const tile = element[0];
            tile.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleTileChange_);
        }
        return added;
    }
    /**
   * @return {number} Number of tiles loading.
   */ getTilesLoading() {
        return this.tilesLoading_;
    }
    /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */ handleTileChange(event) {
        const tile = /** @type {import("./Tile.js").default} */ event.target;
        const state = tile.getState();
        if (state === (0, _tileStateJsDefault.default).LOADED || state === (0, _tileStateJsDefault.default).ERROR || state === (0, _tileStateJsDefault.default).EMPTY) {
            if (state !== (0, _tileStateJsDefault.default).ERROR) tile.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleTileChange_);
            const tileKey = tile.getKey();
            if (tileKey in this.tilesLoadingKeys_) {
                delete this.tilesLoadingKeys_[tileKey];
                --this.tilesLoading_;
            }
            this.tileChangeCallback_();
        }
    }
    /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */ loadMoreTiles(maxTotalLoading, maxNewLoads) {
        let newLoads = 0;
        let state, tile, tileKey;
        while(this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0){
            tile = /** @type {import("./Tile.js").default} */ this.dequeue()[0];
            tileKey = tile.getKey();
            state = tile.getState();
            if (state === (0, _tileStateJsDefault.default).IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                this.tilesLoadingKeys_[tileKey] = true;
                ++this.tilesLoading_;
                ++newLoads;
                tile.load();
            }
        }
    }
}
exports.default = TileQueue;
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
    // Filter out tiles at higher zoom levels than the current zoom level, or that
    // are outside the visible extent.
    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) return 0, _priorityQueueJs.DROP;
    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) return 0, _priorityQueueJs.DROP;
    // Prioritize the highest zoom level tiles closest to the focus.
    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
    // Within a zoom level, tiles are prioritized by the distance in pixels between
    // the center of the tile and the center of the viewport.  The factor of 65536
    // means that the prioritization should behave as desired for tiles up to
    // 65536 * Math.log(2) = 45426 pixels from the focus.
    const center = frameState.viewState.center;
    const deltaX = tileCenter[0] - center[0];
    const deltaY = tileCenter[1] - center[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

},{"./events/EventType.js":"3uT2C","./structs/PriorityQueue.js":"1Ueru","./TileState.js":"2J5J5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1Ueru":[function(require,module,exports,__globalThis) {
/**
 * @module ol/structs/PriorityQueue
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DROP", ()=>DROP);
var _assertsJs = require("../asserts.js");
var _objJs = require("../obj.js");
const DROP = Infinity;
/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */ class PriorityQueue {
    /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */ constructor(priorityFunction, keyFunction){
        /**
     * @type {function(T): number}
     * @private
     */ this.priorityFunction_ = priorityFunction;
        /**
     * @type {function(T): string}
     * @private
     */ this.keyFunction_ = keyFunction;
        /**
     * @type {Array<T>}
     * @private
     */ this.elements_ = [];
        /**
     * @type {Array<number>}
     * @private
     */ this.priorities_ = [];
        /**
     * @type {!Object<string, boolean>}
     * @private
     */ this.queuedElements_ = {};
    }
    /**
   * FIXME empty description for jsdoc
   */ clear() {
        this.elements_.length = 0;
        this.priorities_.length = 0;
        (0, _objJs.clear)(this.queuedElements_);
    }
    /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */ dequeue() {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const element = elements[0];
        if (elements.length == 1) {
            elements.length = 0;
            priorities.length = 0;
        } else {
            elements[0] = /** @type {T} */ elements.pop();
            priorities[0] = /** @type {number} */ priorities.pop();
            this.siftUp_(0);
        }
        const elementKey = this.keyFunction_(element);
        delete this.queuedElements_[elementKey];
        return element;
    }
    /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */ enqueue(element) {
        (0, _assertsJs.assert)(!(this.keyFunction_(element) in this.queuedElements_), 'Tried to enqueue an `element` that was already added to the queue');
        const priority = this.priorityFunction_(element);
        if (priority != DROP) {
            this.elements_.push(element);
            this.priorities_.push(priority);
            this.queuedElements_[this.keyFunction_(element)] = true;
            this.siftDown_(0, this.elements_.length - 1);
            return true;
        }
        return false;
    }
    /**
   * @return {number} Count.
   */ getCount() {
        return this.elements_.length;
    }
    /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */ getLeftChildIndex_(index) {
        return index * 2 + 1;
    }
    /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */ getRightChildIndex_(index) {
        return index * 2 + 2;
    }
    /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */ getParentIndex_(index) {
        return index - 1 >> 1;
    }
    /**
   * Make this a heap. O(N).
   * @private
   */ heapify_() {
        let i;
        for(i = (this.elements_.length >> 1) - 1; i >= 0; i--)this.siftUp_(i);
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return this.elements_.length === 0;
    }
    /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */ isKeyQueued(key) {
        return key in this.queuedElements_;
    }
    /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */ isQueued(element) {
        return this.isKeyQueued(this.keyFunction_(element));
    }
    /**
   * @param {number} index The index of the node to move down.
   * @private
   */ siftUp_(index) {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const count = elements.length;
        const element = elements[index];
        const priority = priorities[index];
        const startIndex = index;
        while(index < count >> 1){
            const lIndex = this.getLeftChildIndex_(index);
            const rIndex = this.getRightChildIndex_(index);
            const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
            elements[index] = elements[smallerChildIndex];
            priorities[index] = priorities[smallerChildIndex];
            index = smallerChildIndex;
        }
        elements[index] = element;
        priorities[index] = priority;
        this.siftDown_(startIndex, index);
    }
    /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */ siftDown_(startIndex, index) {
        const elements = this.elements_;
        const priorities = this.priorities_;
        const element = elements[index];
        const priority = priorities[index];
        while(index > startIndex){
            const parentIndex = this.getParentIndex_(index);
            if (priorities[parentIndex] > priority) {
                elements[index] = elements[parentIndex];
                priorities[index] = priorities[parentIndex];
                index = parentIndex;
            } else break;
        }
        elements[index] = element;
        priorities[index] = priority;
    }
    /**
   * FIXME empty description for jsdoc
   */ reprioritize() {
        const priorityFunction = this.priorityFunction_;
        const elements = this.elements_;
        const priorities = this.priorities_;
        let index = 0;
        const n = elements.length;
        let element, i, priority;
        for(i = 0; i < n; ++i){
            element = elements[i];
            priority = priorityFunction(element);
            if (priority == DROP) delete this.queuedElements_[this.keyFunction_(element)];
            else {
                priorities[index] = priority;
                elements[index++] = element;
            }
        }
        elements.length = index;
        priorities.length = index;
        this.heapify_();
    }
}
exports.default = PriorityQueue;

},{"../asserts.js":"k0OL6","../obj.js":"7RZD4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2J5J5":[function(require,module,exports,__globalThis) {
/**
 * @module ol/TileState
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    /**
   * Indicates that tile loading failed
   * @type {number}
   */ ERROR: 3,
    EMPTY: 4
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d6ZU0":[function(require,module,exports,__globalThis) {
/**
 * @module ol/control/defaults
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 */ /**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions} [options] Options for the default controls.
 * @return {Collection<import("./Control.js").default>} A collection of controls
 * to be used with the {@link module:ol/Map~Map} constructor's `controls` option.
 * @api
 */ parcelHelpers.export(exports, "defaults", ()=>defaults);
var _attributionJs = require("./Attribution.js");
var _attributionJsDefault = parcelHelpers.interopDefault(_attributionJs);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _rotateJs = require("./Rotate.js");
var _rotateJsDefault = parcelHelpers.interopDefault(_rotateJs);
var _zoomJs = require("./Zoom.js");
var _zoomJsDefault = parcelHelpers.interopDefault(_zoomJs);
function defaults(options) {
    options = options ? options : {};
    /** @type {Collection<import("./Control.js").default>} */ const controls = new (0, _collectionJsDefault.default)();
    const zoomControl = options.zoom !== undefined ? options.zoom : true;
    if (zoomControl) controls.push(new (0, _zoomJsDefault.default)(options.zoomOptions));
    const rotateControl = options.rotate !== undefined ? options.rotate : true;
    if (rotateControl) controls.push(new (0, _rotateJsDefault.default)(options.rotateOptions));
    const attributionControl = options.attribution !== undefined ? options.attribution : true;
    if (attributionControl) controls.push(new (0, _attributionJsDefault.default)(options.attributionOptions));
    return controls;
}

},{"./Attribution.js":"KR41C","../Collection.js":"hzcJw","./Rotate.js":"i8OvH","./Zoom.js":"2qYMW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"KR41C":[function(require,module,exports,__globalThis) {
/**
 * @module ol/control/Attribution
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _arrayJs = require("../array.js");
var _domJs = require("../dom.js");
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string|HTMLElement} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel='›'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */ /**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */ class Attribution extends (0, _controlJsDefault.default) {
    /**
   * @param {Options} [options] Attribution options.
   */ constructor(options){
        options = options ? options : {};
        super({
            element: document.createElement('div'),
            render: options.render,
            target: options.target
        });
        /**
     * @private
     * @type {HTMLElement}
     */ this.ulElement_ = document.createElement('ul');
        /**
     * @private
     * @type {boolean}
     */ this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
        /**
     * @private
     * @type {boolean}
     */ this.userCollapsed_ = this.collapsed_;
        /**
     * @private
     * @type {boolean}
     */ this.overrideCollapsible_ = options.collapsible !== undefined;
        /**
     * @private
     * @type {boolean}
     */ this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;
        if (!this.collapsible_) this.collapsed_ = false;
        const className = options.className !== undefined ? options.className : 'ol-attribution';
        const tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
        const expandClassName = options.expandClassName !== undefined ? options.expandClassName : className + '-expand';
        const collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u203A';
        const collapseClassName = options.collapseClassName !== undefined ? options.collapseClassName : className + '-collapse';
        if (typeof collapseLabel === 'string') {
            /**
       * @private
       * @type {HTMLElement}
       */ this.collapseLabel_ = document.createElement('span');
            this.collapseLabel_.textContent = collapseLabel;
            this.collapseLabel_.className = collapseClassName;
        } else this.collapseLabel_ = collapseLabel;
        const label = options.label !== undefined ? options.label : 'i';
        if (typeof label === 'string') {
            /**
       * @private
       * @type {HTMLElement}
       */ this.label_ = document.createElement('span');
            this.label_.textContent = label;
            this.label_.className = expandClassName;
        } else this.label_ = label;
        const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
        /**
     * @private
     * @type {HTMLElement}
     */ this.toggleButton_ = document.createElement('button');
        this.toggleButton_.setAttribute('type', 'button');
        this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
        this.toggleButton_.title = tipLabel;
        this.toggleButton_.appendChild(activeLabel);
        this.toggleButton_.addEventListener((0, _eventTypeJsDefault.default).CLICK, this.handleClick_.bind(this), false);
        const cssClasses = className + ' ' + (0, _cssJs.CLASS_UNSELECTABLE) + ' ' + (0, _cssJs.CLASS_CONTROL) + (this.collapsed_ && this.collapsible_ ? ' ' + (0, _cssJs.CLASS_COLLAPSED) : '') + (this.collapsible_ ? '' : ' ol-uncollapsible');
        const element = this.element;
        element.className = cssClasses;
        element.appendChild(this.toggleButton_);
        element.appendChild(this.ulElement_);
        /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */ this.renderedAttributions_ = [];
        /**
     * @private
     * @type {boolean}
     */ this.renderedVisible_ = true;
    }
    /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */ collectSourceAttributions_(frameState) {
        const visibleAttributions = Array.from(new Set(this.getMap().getAllLayers().flatMap((layer)=>layer.getAttributions(frameState))));
        const collapsible = !this.getMap().getAllLayers().some((layer)=>layer.getSource() && layer.getSource().getAttributionsCollapsible() === false);
        if (!this.overrideCollapsible_) this.setCollapsible(collapsible);
        return visibleAttributions;
    }
    /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */ updateElement_(frameState) {
        if (!frameState) {
            if (this.renderedVisible_) {
                this.element.style.display = 'none';
                this.renderedVisible_ = false;
            }
            return;
        }
        const attributions = this.collectSourceAttributions_(frameState);
        const visible = attributions.length > 0;
        if (this.renderedVisible_ != visible) {
            this.element.style.display = visible ? '' : 'none';
            this.renderedVisible_ = visible;
        }
        if ((0, _arrayJs.equals)(attributions, this.renderedAttributions_)) return;
        (0, _domJs.removeChildren)(this.ulElement_);
        // append the attributions
        for(let i = 0, ii = attributions.length; i < ii; ++i){
            const element = document.createElement('li');
            element.innerHTML = attributions[i];
            this.ulElement_.appendChild(element);
        }
        this.renderedAttributions_ = attributions;
    }
    /**
   * @param {MouseEvent} event The event to handle
   * @private
   */ handleClick_(event) {
        event.preventDefault();
        this.handleToggle_();
        this.userCollapsed_ = this.collapsed_;
    }
    /**
   * @private
   */ handleToggle_() {
        this.element.classList.toggle((0, _cssJs.CLASS_COLLAPSED));
        if (this.collapsed_) (0, _domJs.replaceNode)(this.collapseLabel_, this.label_);
        else (0, _domJs.replaceNode)(this.label_, this.collapseLabel_);
        this.collapsed_ = !this.collapsed_;
        this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
    }
    /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */ getCollapsible() {
        return this.collapsible_;
    }
    /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */ setCollapsible(collapsible) {
        if (this.collapsible_ === collapsible) return;
        this.collapsible_ = collapsible;
        this.element.classList.toggle('ol-uncollapsible');
        if (this.userCollapsed_) this.handleToggle_();
    }
    /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */ setCollapsed(collapsed) {
        this.userCollapsed_ = collapsed;
        if (!this.collapsible_ || this.collapsed_ === collapsed) return;
        this.handleToggle_();
    }
    /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */ getCollapsed() {
        return this.collapsed_;
    }
    /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */ render(mapEvent) {
        this.updateElement_(mapEvent.frameState);
    }
}
exports.default = Attribution;

},{"./Control.js":"84aaX","../events/EventType.js":"3uT2C","../css.js":"b247l","../array.js":"hyet5","../dom.js":"h98kD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"84aaX":[function(require,module,exports,__globalThis) {
/**
 * @module ol/control/Control
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _mapEventTypeJs = require("../MapEventType.js");
var _mapEventTypeJsDefault = parcelHelpers.interopDefault(_mapEventTypeJs);
var _functionsJs = require("../functions.js");
var _eventsJs = require("../events.js");
var _domJs = require("../dom.js");
/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * const myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */ class Control extends (0, _objectJsDefault.default) {
    /**
   * @param {Options} options Control options.
   */ constructor(options){
        super();
        const element = options.element;
        if (element && !options.target && !element.style.pointerEvents) element.style.pointerEvents = 'auto';
        /**
     * @protected
     * @type {HTMLElement}
     */ this.element = element ? element : null;
        /**
     * @private
     * @type {HTMLElement}
     */ this.target_ = null;
        /**
     * @private
     * @type {import("../Map.js").default|null}
     */ this.map_ = null;
        /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */ this.listenerKeys = [];
        if (options.render) this.render = options.render;
        if (options.target) this.setTarget(options.target);
    }
    /**
   * Clean up.
   */ disposeInternal() {
        (0, _domJs.removeNode)(this.element);
        super.disposeInternal();
    }
    /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */ getMap() {
        return this.map_;
    }
    /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */ setMap(map) {
        if (this.map_) (0, _domJs.removeNode)(this.element);
        for(let i = 0, ii = this.listenerKeys.length; i < ii; ++i)(0, _eventsJs.unlistenByKey)(this.listenerKeys[i]);
        this.listenerKeys.length = 0;
        this.map_ = map;
        if (map) {
            const target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
            target.appendChild(this.element);
            if (this.render !== (0, _functionsJs.VOID)) this.listenerKeys.push((0, _eventsJs.listen)(map, (0, _mapEventTypeJsDefault.default).POSTRENDER, this.render, this));
            map.render();
        }
    }
    /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */ render(mapEvent) {}
    /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */ setTarget(target) {
        this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
    }
}
exports.default = Control;

},{"../Object.js":"N6yIf","../MapEventType.js":"lytOT","../functions.js":"1QSsQ","../events.js":"lh4km","../dom.js":"h98kD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i8OvH":[function(require,module,exports,__globalThis) {
/**
 * @module ol/control/Rotate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _easingJs = require("../easing.js");
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */ class Rotate extends (0, _controlJsDefault.default) {
    /**
   * @param {Options} [options] Rotate options.
   */ constructor(options){
        options = options ? options : {};
        super({
            element: document.createElement('div'),
            render: options.render,
            target: options.target
        });
        const className = options.className !== undefined ? options.className : 'ol-rotate';
        const label = options.label !== undefined ? options.label : '\u21E7';
        const compassClassName = options.compassClassName !== undefined ? options.compassClassName : 'ol-compass';
        /**
     * @type {HTMLElement}
     * @private
     */ this.label_ = null;
        if (typeof label === 'string') {
            this.label_ = document.createElement('span');
            this.label_.className = compassClassName;
            this.label_.textContent = label;
        } else {
            this.label_ = label;
            this.label_.classList.add(compassClassName);
        }
        const tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
        const button = document.createElement('button');
        button.className = className + '-reset';
        button.setAttribute('type', 'button');
        button.title = tipLabel;
        button.appendChild(this.label_);
        button.addEventListener((0, _eventTypeJsDefault.default).CLICK, this.handleClick_.bind(this), false);
        const cssClasses = className + ' ' + (0, _cssJs.CLASS_UNSELECTABLE) + ' ' + (0, _cssJs.CLASS_CONTROL);
        const element = this.element;
        element.className = cssClasses;
        element.appendChild(button);
        this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
        /**
     * @type {number}
     * @private
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
        /**
     * @type {boolean}
     * @private
     */ this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
        /**
     * @private
     * @type {number|undefined}
     */ this.rotation_ = undefined;
        if (this.autoHide_) this.element.classList.add((0, _cssJs.CLASS_HIDDEN));
    }
    /**
   * @param {MouseEvent} event The event to handle
   * @private
   */ handleClick_(event) {
        event.preventDefault();
        if (this.callResetNorth_ !== undefined) this.callResetNorth_();
        else this.resetNorth_();
    }
    /**
   * @private
   */ resetNorth_() {
        const map = this.getMap();
        const view = map.getView();
        if (!view) // the map does not have a view, so we can't act
        // upon it
        return;
        const rotation = view.getRotation();
        if (rotation !== undefined) {
            if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) view.animate({
                rotation: 0,
                duration: this.duration_,
                easing: (0, _easingJs.easeOut)
            });
            else view.setRotation(0);
        }
    }
    /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */ render(mapEvent) {
        const frameState = mapEvent.frameState;
        if (!frameState) return;
        const rotation = frameState.viewState.rotation;
        if (rotation != this.rotation_) {
            const transform = 'rotate(' + rotation + 'rad)';
            if (this.autoHide_) {
                const contains = this.element.classList.contains((0, _cssJs.CLASS_HIDDEN));
                if (!contains && rotation === 0) this.element.classList.add((0, _cssJs.CLASS_HIDDEN));
                else if (contains && rotation !== 0) this.element.classList.remove((0, _cssJs.CLASS_HIDDEN));
            }
            this.label_.style.transform = transform;
        }
        this.rotation_ = rotation;
    }
}
exports.default = Rotate;

},{"./Control.js":"84aaX","../events/EventType.js":"3uT2C","../css.js":"b247l","../easing.js":"jskwM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2qYMW":[function(require,module,exports,__globalThis) {
/**
 * @module ol/control/Zoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _easingJs = require("../easing.js");
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='–'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */ class Zoom extends (0, _controlJsDefault.default) {
    /**
   * @param {Options} [options] Zoom options.
   */ constructor(options){
        options = options ? options : {};
        super({
            element: document.createElement('div'),
            target: options.target
        });
        const className = options.className !== undefined ? options.className : 'ol-zoom';
        const delta = options.delta !== undefined ? options.delta : 1;
        const zoomInClassName = options.zoomInClassName !== undefined ? options.zoomInClassName : className + '-in';
        const zoomOutClassName = options.zoomOutClassName !== undefined ? options.zoomOutClassName : className + '-out';
        const zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
        const zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2013';
        const zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
        const zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
        const inElement = document.createElement('button');
        inElement.className = zoomInClassName;
        inElement.setAttribute('type', 'button');
        inElement.title = zoomInTipLabel;
        inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);
        inElement.addEventListener((0, _eventTypeJsDefault.default).CLICK, this.handleClick_.bind(this, delta), false);
        const outElement = document.createElement('button');
        outElement.className = zoomOutClassName;
        outElement.setAttribute('type', 'button');
        outElement.title = zoomOutTipLabel;
        outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
        outElement.addEventListener((0, _eventTypeJsDefault.default).CLICK, this.handleClick_.bind(this, -delta), false);
        const cssClasses = className + ' ' + (0, _cssJs.CLASS_UNSELECTABLE) + ' ' + (0, _cssJs.CLASS_CONTROL);
        const element = this.element;
        element.className = cssClasses;
        element.appendChild(inElement);
        element.appendChild(outElement);
        /**
     * @type {number}
     * @private
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */ handleClick_(delta, event) {
        event.preventDefault();
        this.zoomByDelta_(delta);
    }
    /**
   * @param {number} delta Zoom delta.
   * @private
   */ zoomByDelta_(delta) {
        const map = this.getMap();
        const view = map.getView();
        if (!view) // the map does not have a view, so we can't act
        // upon it
        return;
        const currentZoom = view.getZoom();
        if (currentZoom !== undefined) {
            const newZoom = view.getConstrainedZoom(currentZoom + delta);
            if (this.duration_ > 0) {
                if (view.getAnimating()) view.cancelAnimations();
                view.animate({
                    zoom: newZoom,
                    duration: this.duration_,
                    easing: (0, _easingJs.easeOut)
                });
            } else view.setZoom(newZoom);
        }
    }
}
exports.default = Zoom;

},{"./Control.js":"84aaX","../events/EventType.js":"3uT2C","../css.js":"b247l","../easing.js":"jskwM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fwCpz":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/defaults
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */ /**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction~Interaction} instances and insert
 * them into a {@link module:ol/Collection~Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions} [options] Defaults options.
 * @return {Collection<import("./Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */ parcelHelpers.export(exports, "defaults", ()=>defaults);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _doubleClickZoomJs = require("./DoubleClickZoom.js");
var _doubleClickZoomJsDefault = parcelHelpers.interopDefault(_doubleClickZoomJs);
var _dragPanJs = require("./DragPan.js");
var _dragPanJsDefault = parcelHelpers.interopDefault(_dragPanJs);
var _dragRotateJs = require("./DragRotate.js");
var _dragRotateJsDefault = parcelHelpers.interopDefault(_dragRotateJs);
var _dragZoomJs = require("./DragZoom.js");
var _dragZoomJsDefault = parcelHelpers.interopDefault(_dragZoomJs);
var _keyboardPanJs = require("./KeyboardPan.js");
var _keyboardPanJsDefault = parcelHelpers.interopDefault(_keyboardPanJs);
var _keyboardZoomJs = require("./KeyboardZoom.js");
var _keyboardZoomJsDefault = parcelHelpers.interopDefault(_keyboardZoomJs);
var _kineticJs = require("../Kinetic.js");
var _kineticJsDefault = parcelHelpers.interopDefault(_kineticJs);
var _mouseWheelZoomJs = require("./MouseWheelZoom.js");
var _mouseWheelZoomJsDefault = parcelHelpers.interopDefault(_mouseWheelZoomJs);
var _pinchRotateJs = require("./PinchRotate.js");
var _pinchRotateJsDefault = parcelHelpers.interopDefault(_pinchRotateJs);
var _pinchZoomJs = require("./PinchZoom.js");
var _pinchZoomJsDefault = parcelHelpers.interopDefault(_pinchZoomJs);
function defaults(options) {
    options = options ? options : {};
    /** @type {Collection<import("./Interaction.js").default>} */ const interactions = new (0, _collectionJsDefault.default)();
    const kinetic = new (0, _kineticJsDefault.default)(-0.005, 0.05, 100);
    const altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;
    if (altShiftDragRotate) interactions.push(new (0, _dragRotateJsDefault.default)());
    const doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
    if (doubleClickZoom) interactions.push(new (0, _doubleClickZoomJsDefault.default)({
        delta: options.zoomDelta,
        duration: options.zoomDuration
    }));
    const dragPan = options.dragPan !== undefined ? options.dragPan : true;
    if (dragPan) interactions.push(new (0, _dragPanJsDefault.default)({
        onFocusOnly: options.onFocusOnly,
        kinetic: kinetic
    }));
    const pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
    if (pinchRotate) interactions.push(new (0, _pinchRotateJsDefault.default)());
    const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
    if (pinchZoom) interactions.push(new (0, _pinchZoomJsDefault.default)({
        duration: options.zoomDuration
    }));
    const keyboard = options.keyboard !== undefined ? options.keyboard : true;
    if (keyboard) {
        interactions.push(new (0, _keyboardPanJsDefault.default)());
        interactions.push(new (0, _keyboardZoomJsDefault.default)({
            delta: options.zoomDelta,
            duration: options.zoomDuration
        }));
    }
    const mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
    if (mouseWheelZoom) interactions.push(new (0, _mouseWheelZoomJsDefault.default)({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
    }));
    const shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
    if (shiftDragZoom) interactions.push(new (0, _dragZoomJsDefault.default)({
        duration: options.zoomDuration
    }));
    return interactions;
}

},{"../Collection.js":"hzcJw","./DoubleClickZoom.js":"45Zop","./DragPan.js":"5c75C","./DragRotate.js":"aSZKM","./DragZoom.js":"5Bp8x","./KeyboardPan.js":"dlW1h","./KeyboardZoom.js":"6uteB","../Kinetic.js":"2jYtz","./MouseWheelZoom.js":"wSFgD","./PinchRotate.js":"aW88o","./PinchZoom.js":"kKE3X","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"45Zop":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/DoubleClickZoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */ /**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */ class DoubleClickZoom extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @private
     * @type {number}
     */ this.delta_ = options.delta ? options.delta : 1;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */ handleEvent(mapBrowserEvent) {
        let stopEvent = false;
        if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).DBLCLICK) {
            const browserEvent = /** @type {MouseEvent} */ mapBrowserEvent.originalEvent;
            const map = mapBrowserEvent.map;
            const anchor = mapBrowserEvent.coordinate;
            const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
            const view = map.getView();
            (0, _interactionJs.zoomByDelta)(view, delta, anchor, this.duration_);
            browserEvent.preventDefault();
            stopEvent = true;
        }
        return !stopEvent;
    }
}
exports.default = DoubleClickZoom;

},{"./Interaction.js":"kcjGH","../MapBrowserEventType.js":"2Xhyu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kcjGH":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Interaction
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number} [duration] Duration.
 */ parcelHelpers.export(exports, "pan", ()=>pan);
/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate} [anchor] Anchor coordinate in the user projection.
 * @param {number} [duration] Duration.
 */ parcelHelpers.export(exports, "zoomByDelta", ()=>zoomByDelta);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _easingJs = require("../easing.js");
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */ /**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */ class Interaction extends (0, _objectJsDefault.default) {
    /**
   * @param {InteractionOptions} [options] Options.
   */ constructor(options){
        super();
        /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {InteractionOnSignature<void>}
     */ this.un;
        if (options && options.handleEvent) this.handleEvent = options.handleEvent;
        /**
     * @private
     * @type {import("../Map.js").default|null}
     */ this.map_ = null;
        this.setActive(true);
    }
    /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */ getActive() {
        return /** @type {boolean} */ this.get((0, _propertyJsDefault.default).ACTIVE);
    }
    /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */ getMap() {
        return this.map_;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(mapBrowserEvent) {
        return true;
    }
    /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */ setActive(active) {
        this.set((0, _propertyJsDefault.default).ACTIVE, active);
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */ setMap(map) {
        this.map_ = map;
    }
}
function pan(view, delta, duration) {
    const currentCenter = view.getCenterInternal();
    if (currentCenter) {
        const center = [
            currentCenter[0] + delta[0],
            currentCenter[1] + delta[1]
        ];
        view.animateInternal({
            duration: duration !== undefined ? duration : 250,
            easing: (0, _easingJs.linear),
            center: view.getConstrainedCenter(center)
        });
    }
}
function zoomByDelta(view, delta, anchor, duration) {
    const currentZoom = view.getZoom();
    if (currentZoom === undefined) return;
    const newZoom = view.getConstrainedZoom(currentZoom + delta);
    const newResolution = view.getResolutionForZoom(newZoom);
    if (view.getAnimating()) view.cancelAnimations();
    view.animate({
        resolution: newResolution,
        anchor: anchor,
        duration: duration !== undefined ? duration : 250,
        easing: (0, _easingJs.easeOut)
    });
}
exports.default = Interaction;

},{"../Object.js":"N6yIf","./Property.js":"7pgVi","../easing.js":"jskwM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7pgVi":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Property
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    ACTIVE: 'active'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5c75C":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/DragPan
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var _conditionJs = require("../events/condition.js");
var _easingJs = require("../easing.js");
var _coordinateJs = require("../coordinate.js");
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */ /**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */ class DragPan extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super({
            stopDown: (0, _functionsJs.FALSE)
        });
        options = options ? options : {};
        /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */ this.kinetic_ = options.kinetic;
        /**
     * @type {import("../pixel.js").Pixel}
     */ this.lastCentroid = null;
        /**
     * @type {number}
     */ this.lastPointersCount_;
        /**
     * @type {boolean}
     */ this.panning_ = false;
        const condition = options.condition ? options.condition : (0, _conditionJs.all)((0, _conditionJs.noModifierKeys), (0, _conditionJs.primaryAction));
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.onFocusOnly ? (0, _conditionJs.all)((0, _conditionJs.focusWithTabindex), condition) : condition;
        /**
     * @private
     * @type {boolean}
     */ this.noKinetic_ = false;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */ handleDragEvent(mapBrowserEvent) {
        const map = mapBrowserEvent.map;
        if (!this.panning_) {
            this.panning_ = true;
            map.getView().beginInteraction();
        }
        const targetPointers = this.targetPointers;
        const centroid = map.getEventPixel((0, _pointerJs.centroid)(targetPointers));
        if (targetPointers.length == this.lastPointersCount_) {
            if (this.kinetic_) this.kinetic_.update(centroid[0], centroid[1]);
            if (this.lastCentroid) {
                const delta = [
                    this.lastCentroid[0] - centroid[0],
                    centroid[1] - this.lastCentroid[1]
                ];
                const map = mapBrowserEvent.map;
                const view = map.getView();
                (0, _coordinateJs.scale)(delta, view.getResolution());
                (0, _coordinateJs.rotate)(delta, view.getRotation());
                view.adjustCenterInternal(delta);
            }
        } else if (this.kinetic_) // reset so we don't overestimate the kinetic energy after
        // after one finger down, tiny drag, second finger down
        this.kinetic_.begin();
        this.lastCentroid = centroid;
        this.lastPointersCount_ = targetPointers.length;
        mapBrowserEvent.originalEvent.preventDefault();
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(mapBrowserEvent) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (this.targetPointers.length === 0) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                const distance = this.kinetic_.getDistance();
                const angle = this.kinetic_.getAngle();
                const center = view.getCenterInternal();
                const centerpx = map.getPixelFromCoordinateInternal(center);
                const dest = map.getCoordinateFromPixelInternal([
                    centerpx[0] - distance * Math.cos(angle),
                    centerpx[1] - distance * Math.sin(angle)
                ]);
                view.animateInternal({
                    center: view.getConstrainedCenter(dest),
                    duration: 500,
                    easing: (0, _easingJs.easeOut)
                });
            }
            if (this.panning_) {
                this.panning_ = false;
                view.endInteraction();
            }
            return false;
        }
        if (this.kinetic_) // reset so we don't overestimate the kinetic energy after
        // after one finger up, tiny drag, second finger up
        this.kinetic_.begin();
        this.lastCentroid = null;
        return true;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
            const map = mapBrowserEvent.map;
            const view = map.getView();
            this.lastCentroid = null;
            // stop any current animation
            if (view.getAnimating()) view.cancelAnimations();
            if (this.kinetic_) this.kinetic_.begin();
            // No kinetic as soon as more than one pointer on the screen is
            // detected. This is to prevent nasty pans after pinch.
            this.noKinetic_ = this.targetPointers.length > 1;
            return true;
        }
        return false;
    }
}
exports.default = DragPan;

},{"./Pointer.js":"a39IA","../functions.js":"1QSsQ","../events/condition.js":"gm0iA","../easing.js":"jskwM","../coordinate.js":"fqHXJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a39IA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Pointer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {{clientX: number, clientY: number}} Centroid pixel.
 */ parcelHelpers.export(exports, "centroid", ()=>centroid);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */ /**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */ class PointerInteraction extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super(/** @type {import("./Interaction.js").InteractionOptions} */ options);
        if (options.handleDownEvent) this.handleDownEvent = options.handleDownEvent;
        if (options.handleDragEvent) this.handleDragEvent = options.handleDragEvent;
        if (options.handleMoveEvent) this.handleMoveEvent = options.handleMoveEvent;
        if (options.handleUpEvent) this.handleUpEvent = options.handleUpEvent;
        if (options.stopDown) this.stopDown = options.stopDown;
        /**
     * @type {boolean}
     * @protected
     */ this.handlingDownUpSequence = false;
        /**
     * @type {Array<PointerEvent>}
     * @protected
     */ this.targetPointers = [];
    }
    /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */ getPointerCount() {
        return this.targetPointers.length;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */ handleDownEvent(mapBrowserEvent) {
        return false;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */ handleDragEvent(mapBrowserEvent) {}
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) return true;
        let stopEvent = false;
        this.updateTrackedPointers_(mapBrowserEvent);
        if (this.handlingDownUpSequence) {
            if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG) {
                this.handleDragEvent(mapBrowserEvent);
                // prevent page scrolling during dragging
                mapBrowserEvent.originalEvent.preventDefault();
            } else if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERUP) {
                const handledUp = this.handleUpEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
            }
        } else {
            if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERDOWN) {
                const handled = this.handleDownEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handled;
                stopEvent = this.stopDown(handled);
            } else if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE) this.handleMoveEvent(mapBrowserEvent);
        }
        return !stopEvent;
    }
    /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */ handleMoveEvent(mapBrowserEvent) {}
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */ handleUpEvent(mapBrowserEvent) {
        return false;
    }
    /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */ stopDown(handled) {
        return handled;
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */ updateTrackedPointers_(mapBrowserEvent) {
        if (mapBrowserEvent.activePointers) this.targetPointers = mapBrowserEvent.activePointers;
    }
}
function centroid(pointerEvents) {
    const length = pointerEvents.length;
    let clientX = 0;
    let clientY = 0;
    for(let i = 0; i < length; i++){
        clientX += pointerEvents[i].clientX;
        clientY += pointerEvents[i].clientY;
    }
    return {
        clientX: clientX / length,
        clientY: clientY / length
    };
}
exports.default = PointerInteraction;

},{"./Interaction.js":"kcjGH","../MapBrowserEventType.js":"2Xhyu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gm0iA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/condition
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */ /**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */ parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "altKeyOnly", ()=>altKeyOnly);
parcelHelpers.export(exports, "altShiftKeysOnly", ()=>altShiftKeysOnly);
parcelHelpers.export(exports, "focus", ()=>focus);
parcelHelpers.export(exports, "focusWithTabindex", ()=>focusWithTabindex);
parcelHelpers.export(exports, "always", ()=>always);
parcelHelpers.export(exports, "click", ()=>click);
parcelHelpers.export(exports, "mouseActionButton", ()=>mouseActionButton);
parcelHelpers.export(exports, "never", ()=>never);
parcelHelpers.export(exports, "pointerMove", ()=>pointerMove);
parcelHelpers.export(exports, "singleClick", ()=>singleClick);
parcelHelpers.export(exports, "doubleClick", ()=>doubleClick);
parcelHelpers.export(exports, "noModifierKeys", ()=>noModifierKeys);
parcelHelpers.export(exports, "platformModifierKeyOnly", ()=>platformModifierKeyOnly);
parcelHelpers.export(exports, "platformModifierKey", ()=>platformModifierKey);
parcelHelpers.export(exports, "shiftKeyOnly", ()=>shiftKeyOnly);
parcelHelpers.export(exports, "targetNotEditable", ()=>targetNotEditable);
parcelHelpers.export(exports, "mouseOnly", ()=>mouseOnly);
parcelHelpers.export(exports, "touchOnly", ()=>touchOnly);
parcelHelpers.export(exports, "penOnly", ()=>penOnly);
parcelHelpers.export(exports, "primaryAction", ()=>primaryAction);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _functionsJs = require("../functions.js");
var _hasJs = require("../has.js");
var _assertsJs = require("../asserts.js");
function all(var_args) {
    const conditions = arguments;
    /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} All conditions passed.
   */ return function(event) {
        let pass = true;
        for(let i = 0, ii = conditions.length; i < ii; ++i){
            pass = pass && conditions[i](event);
            if (!pass) break;
        }
        return pass;
    };
}
const altKeyOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const altShiftKeysOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const focus = function(event) {
    const targetElement = event.map.getTargetElement();
    const activeElement = event.map.getOwnerDocument().activeElement;
    return targetElement.contains(activeElement);
};
const focusWithTabindex = function(event) {
    return event.map.getTargetElement().hasAttribute('tabindex') ? focus(event) : true;
};
const always = (0, _functionsJs.TRUE);
const click = function(mapBrowserEvent) {
    return mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).CLICK;
};
const mouseActionButton = function(mapBrowserEvent) {
    const originalEvent = /** @type {MouseEvent} */ mapBrowserEvent.originalEvent;
    return originalEvent.button == 0 && !((0, _hasJs.WEBKIT) && (0, _hasJs.MAC) && originalEvent.ctrlKey);
};
const never = (0, _functionsJs.FALSE);
const pointerMove = function(mapBrowserEvent) {
    return mapBrowserEvent.type == 'pointermove';
};
const singleClick = function(mapBrowserEvent) {
    return mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).SINGLECLICK;
};
const doubleClick = function(mapBrowserEvent) {
    return mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).DBLCLICK;
};
const noModifierKeys = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const platformModifierKeyOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && ((0, _hasJs.MAC) ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const platformModifierKey = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return (0, _hasJs.MAC) ? originalEvent.metaKey : originalEvent.ctrlKey;
};
const shiftKeyOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const targetNotEditable = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    const tagName = /** @type {Element} */ originalEvent.target.tagName;
    return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA' && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !originalEvent.target.isContentEditable;
};
const mouseOnly = function(mapBrowserEvent) {
    const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvent !== undefined, 'mapBrowserEvent must originate from a pointer event');
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvent.pointerType == 'mouse';
};
const touchOnly = function(mapBrowserEvent) {
    const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvt !== undefined, 'mapBrowserEvent must originate from a pointer event');
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === 'touch';
};
const penOnly = function(mapBrowserEvent) {
    const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvt !== undefined, 'mapBrowserEvent must originate from a pointer event');
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === 'pen';
};
const primaryAction = function(mapBrowserEvent) {
    const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvent !== undefined, 'mapBrowserEvent must originate from a pointer event');
    return pointerEvent.isPrimary && pointerEvent.button === 0;
};

},{"../MapBrowserEventType.js":"2Xhyu","../functions.js":"1QSsQ","../has.js":"i07p3","../asserts.js":"k0OL6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aSZKM":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/DragRotate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var _conditionJs = require("../events/condition.js");
var _rotationconstraintJs = require("../rotationconstraint.js");
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */ /**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */ class DragRotate extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super({
            stopDown: (0, _functionsJs.FALSE)
        });
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : (0, _conditionJs.altShiftKeysOnly);
        /**
     * @private
     * @type {number|undefined}
     */ this.lastAngle_ = undefined;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */ handleDragEvent(mapBrowserEvent) {
        if (!(0, _conditionJs.mouseOnly)(mapBrowserEvent)) return;
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (view.getConstraints().rotation === (0, _rotationconstraintJs.disable)) return;
        const size = map.getSize();
        const offset = mapBrowserEvent.pixel;
        const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
        if (this.lastAngle_ !== undefined) {
            const delta = theta - this.lastAngle_;
            view.adjustRotationInternal(-delta);
        }
        this.lastAngle_ = theta;
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(mapBrowserEvent) {
        if (!(0, _conditionJs.mouseOnly)(mapBrowserEvent)) return true;
        const map = mapBrowserEvent.map;
        const view = map.getView();
        view.endInteraction(this.duration_);
        return false;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(mapBrowserEvent) {
        if (!(0, _conditionJs.mouseOnly)(mapBrowserEvent)) return false;
        if ((0, _conditionJs.mouseActionButton)(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
            const map = mapBrowserEvent.map;
            map.getView().beginInteraction();
            this.lastAngle_ = undefined;
            return true;
        }
        return false;
    }
}
exports.default = DragRotate;

},{"./Pointer.js":"a39IA","../functions.js":"1QSsQ","../events/condition.js":"gm0iA","../rotationconstraint.js":"6TPbY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5Bp8x":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/DragZoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dragBoxJs = require("./DragBox.js");
var _dragBoxJsDefault = parcelHelpers.interopDefault(_dragBoxJs);
var _easingJs = require("../easing.js");
var _conditionJs = require("../events/condition.js");
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */ class DragZoom extends (0, _dragBoxJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const condition = options.condition ? options.condition : (0, _conditionJs.shiftKeyOnly);
        super({
            condition: condition,
            className: options.className || 'ol-dragzoom',
            minArea: options.minArea
        });
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 200;
        /**
     * @private
     * @type {boolean}
     */ this.out_ = options.out !== undefined ? options.out : false;
    }
    /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */ onBoxEnd(event) {
        const map = this.getMap();
        const view = /** @type {!import("../View.js").default} */ map.getView();
        let geometry = this.getGeometry();
        if (this.out_) {
            const rotatedExtent = view.rotatedExtentForGeometry(geometry);
            const resolution = view.getResolutionForExtentInternal(rotatedExtent);
            const factor = view.getResolution() / resolution;
            geometry = geometry.clone();
            geometry.scale(factor * factor);
        }
        view.fitInternal(geometry, {
            duration: this.duration_,
            easing: (0, _easingJs.easeOut)
        });
    }
}
exports.default = DragZoom;

},{"./DragBox.js":"jYVho","../easing.js":"jskwM","../events/condition.js":"gm0iA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jYVho":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/DragBox
 */ // FIXME draw drag box
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */ parcelHelpers.export(exports, "DragBoxEvent", ()=>DragBoxEvent);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _boxJs = require("../render/Box.js");
var _boxJsDefault = parcelHelpers.interopDefault(_boxJs);
var _conditionJs = require("../events/condition.js");
/**
 * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */ /**
 * @enum {string}
 */ const DragBoxEventType = {
    /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */ BOXSTART: 'boxstart',
    /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */ BOXDRAG: 'boxdrag',
    /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */ BOXEND: 'boxend',
    /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */ BOXCANCEL: 'boxcancel'
};
class DragBoxEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */ constructor(type, coordinate, mapBrowserEvent){
        super(type);
        /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */ this.coordinate = coordinate;
        /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */ this.mapBrowserEvent = mapBrowserEvent;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */ /**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */ class DragBox extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {DragBoxOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {DragBoxOnSignature<void>}
     */ this.un;
        options = options ? options : {};
        /**
     * @type {import("../render/Box.js").default}
     * @private
     */ this.box_ = new (0, _boxJsDefault.default)(options.className || 'ol-dragbox');
        /**
     * @type {number}
     * @private
     */ this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
        if (options.onBoxEnd) this.onBoxEnd = options.onBoxEnd;
        /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */ this.startPixel_ = null;
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : (0, _conditionJs.mouseActionButton);
        /**
     * @private
     * @type {EndCondition}
     */ this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : this.defaultBoxEndCondition;
    }
    /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */ defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
        const width = endPixel[0] - startPixel[0];
        const height = endPixel[1] - startPixel[1];
        return width * width + height * height >= this.minArea_;
    }
    /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */ getGeometry() {
        return this.box_.getGeometry();
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */ handleDragEvent(mapBrowserEvent) {
        this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(mapBrowserEvent) {
        this.box_.setMap(null);
        const completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
        if (completeBox) this.onBoxEnd(mapBrowserEvent);
        this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
        return false;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(mapBrowserEvent) {
        if (this.condition_(mapBrowserEvent)) {
            this.startPixel_ = mapBrowserEvent.pixel;
            this.box_.setMap(mapBrowserEvent.map);
            this.box_.setPixels(this.startPixel_, this.startPixel_);
            this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
            return true;
        }
        return false;
    }
    /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */ onBoxEnd(event) {}
}
exports.default = DragBox;

},{"../events/Event.js":"kooRA","./Pointer.js":"a39IA","../render/Box.js":"fkHEp","../events/condition.js":"gm0iA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fkHEp":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/Box
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
class RenderBox extends (0, _disposableJsDefault.default) {
    /**
   * @param {string} className CSS class name.
   */ constructor(className){
        super();
        /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */ this.geometry_ = null;
        /**
     * @type {HTMLDivElement}
     * @private
     */ this.element_ = document.createElement('div');
        this.element_.style.position = 'absolute';
        this.element_.style.pointerEvents = 'auto';
        this.element_.className = 'ol-box ' + className;
        /**
     * @private
     * @type {import("../Map.js").default|null}
     */ this.map_ = null;
        /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */ this.startPixel_ = null;
        /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */ this.endPixel_ = null;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        this.setMap(null);
    }
    /**
   * @private
   */ render_() {
        const startPixel = this.startPixel_;
        const endPixel = this.endPixel_;
        const px = 'px';
        const style = this.element_.style;
        style.left = Math.min(startPixel[0], endPixel[0]) + px;
        style.top = Math.min(startPixel[1], endPixel[1]) + px;
        style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
        style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
    }
    /**
   * @param {import("../Map.js").default|null} map Map.
   */ setMap(map) {
        if (this.map_) {
            this.map_.getOverlayContainer().removeChild(this.element_);
            const style = this.element_.style;
            style.left = 'inherit';
            style.top = 'inherit';
            style.width = 'inherit';
            style.height = 'inherit';
        }
        this.map_ = map;
        if (this.map_) this.map_.getOverlayContainer().appendChild(this.element_);
    }
    /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */ setPixels(startPixel, endPixel) {
        this.startPixel_ = startPixel;
        this.endPixel_ = endPixel;
        this.createOrUpdateGeometry();
        this.render_();
    }
    /**
   * Creates or updates the cached geometry.
   */ createOrUpdateGeometry() {
        const startPixel = this.startPixel_;
        const endPixel = this.endPixel_;
        const pixels = [
            startPixel,
            [
                startPixel[0],
                endPixel[1]
            ],
            endPixel,
            [
                endPixel[0],
                startPixel[1]
            ]
        ];
        const coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
        // close the polygon
        coordinates[4] = coordinates[0].slice();
        if (!this.geometry_) this.geometry_ = new (0, _polygonJsDefault.default)([
            coordinates
        ]);
        else this.geometry_.setCoordinates([
            coordinates
        ]);
    }
    /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */ getGeometry() {
        return this.geometry_;
    }
}
exports.default = RenderBox;

},{"../Disposable.js":"7pfJR","../geom/Polygon.js":"8Vwps","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dlW1h":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/KeyboardPan
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _keyJs = require("../events/Key.js");
var _keyJsDefault = parcelHelpers.interopDefault(_keyJs);
var _conditionJs = require("../events/condition.js");
var _coordinateJs = require("../coordinate.js");
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.noModifierKeys} and
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */ /**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */ class KeyboardPan extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options || {};
        /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */ this.defaultCondition_ = function(mapBrowserEvent) {
            return (0, _conditionJs.noModifierKeys)(mapBrowserEvent) && (0, _conditionJs.targetNotEditable)(mapBrowserEvent);
        };
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 100;
        /**
     * @private
     * @type {number}
     */ this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */ handleEvent(mapBrowserEvent) {
        let stopEvent = false;
        if (mapBrowserEvent.type == (0, _eventTypeJsDefault.default).KEYDOWN) {
            const keyEvent = /** @type {KeyboardEvent} */ mapBrowserEvent.originalEvent;
            const key = keyEvent.key;
            if (this.condition_(mapBrowserEvent) && (key == (0, _keyJsDefault.default).DOWN || key == (0, _keyJsDefault.default).LEFT || key == (0, _keyJsDefault.default).RIGHT || key == (0, _keyJsDefault.default).UP)) {
                const map = mapBrowserEvent.map;
                const view = map.getView();
                const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                let deltaX = 0, deltaY = 0;
                if (key == (0, _keyJsDefault.default).DOWN) deltaY = -mapUnitsDelta;
                else if (key == (0, _keyJsDefault.default).LEFT) deltaX = -mapUnitsDelta;
                else if (key == (0, _keyJsDefault.default).RIGHT) deltaX = mapUnitsDelta;
                else deltaY = mapUnitsDelta;
                const delta = [
                    deltaX,
                    deltaY
                ];
                (0, _coordinateJs.rotate)(delta, view.getRotation());
                (0, _interactionJs.pan)(view, delta, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
            }
        }
        return !stopEvent;
    }
}
exports.default = KeyboardPan;

},{"../events/EventType.js":"3uT2C","./Interaction.js":"kcjGH","../events/Key.js":"hD8Un","../events/condition.js":"gm0iA","../coordinate.js":"fqHXJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hD8Un":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/Key
 */ /**
 * @enum {string}
 * @const
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    LEFT: 'ArrowLeft',
    UP: 'ArrowUp',
    RIGHT: 'ArrowRight',
    DOWN: 'ArrowDown'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6uteB":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/KeyboardZoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _conditionJs = require("../events/condition.js");
/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. The default condition is
 * that {@link module:ol/events/condition.targetNotEditable} is fulfilled and that
 * the platform modifier key isn't pressed
 * (!{@link module:ol/events/condition.platformModifierKey}).
 * @property {number} [delta=1] The zoom level delta on each key press.
 */ /**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */ class KeyboardZoom extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : function(mapBrowserEvent) {
            return !(0, _conditionJs.platformModifierKey)(mapBrowserEvent) && (0, _conditionJs.targetNotEditable)(mapBrowserEvent);
        };
        /**
     * @private
     * @type {number}
     */ this.delta_ = options.delta ? options.delta : 1;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 100;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */ handleEvent(mapBrowserEvent) {
        let stopEvent = false;
        if (mapBrowserEvent.type == (0, _eventTypeJsDefault.default).KEYDOWN || mapBrowserEvent.type == (0, _eventTypeJsDefault.default).KEYPRESS) {
            const keyEvent = /** @type {KeyboardEvent} */ mapBrowserEvent.originalEvent;
            const key = keyEvent.key;
            if (this.condition_(mapBrowserEvent) && (key === '+' || key === '-')) {
                const map = mapBrowserEvent.map;
                const delta = key === '+' ? this.delta_ : -this.delta_;
                const view = map.getView();
                (0, _interactionJs.zoomByDelta)(view, delta, undefined, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
            }
        }
        return !stopEvent;
    }
}
exports.default = KeyboardZoom;

},{"../events/EventType.js":"3uT2C","./Interaction.js":"kcjGH","../events/condition.js":"gm0iA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2jYtz":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Kinetic
 */ /**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Kinetic {
    /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */ constructor(decay, minVelocity, delay){
        /**
     * @private
     * @type {number}
     */ this.decay_ = decay;
        /**
     * @private
     * @type {number}
     */ this.minVelocity_ = minVelocity;
        /**
     * @private
     * @type {number}
     */ this.delay_ = delay;
        /**
     * @private
     * @type {Array<number>}
     */ this.points_ = [];
        /**
     * @private
     * @type {number}
     */ this.angle_ = 0;
        /**
     * @private
     * @type {number}
     */ this.initialVelocity_ = 0;
    }
    /**
   * FIXME empty description for jsdoc
   */ begin() {
        this.points_.length = 0;
        this.angle_ = 0;
        this.initialVelocity_ = 0;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   */ update(x, y) {
        this.points_.push(x, y, Date.now());
    }
    /**
   * @return {boolean} Whether we should do kinetic animation.
   */ end() {
        if (this.points_.length < 6) // at least 2 points are required (i.e. there must be at least 6 elements
        // in the array)
        return false;
        const delay = Date.now() - this.delay_;
        const lastIndex = this.points_.length - 3;
        if (this.points_[lastIndex + 2] < delay) // the last tracked point is too old, which means that the user stopped
        // panning before releasing the map
        return false;
        // get the first point which still falls into the delay time
        let firstIndex = lastIndex - 3;
        while(firstIndex > 0 && this.points_[firstIndex + 2] > delay)firstIndex -= 3;
        const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
        // we don't want a duration of 0 (divide by zero)
        // we also make sure the user panned for a duration of at least one frame
        // (1/60s) to compute sane displacement values
        if (duration < 1000 / 60) return false;
        const dx = this.points_[lastIndex] - this.points_[firstIndex];
        const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
        this.angle_ = Math.atan2(dy, dx);
        this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
        return this.initialVelocity_ > this.minVelocity_;
    }
    /**
   * @return {number} Total distance travelled (pixels).
   */ getDistance() {
        return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }
    /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */ getAngle() {
        return this.angle_;
    }
}
exports.default = Kinetic;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"wSFgD":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/MouseWheelZoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _hasJs = require("../has.js");
var _conditionJs = require("../events/condition.js");
var _mathJs = require("../math.js");
/**
 * @typedef {'trackpad' | 'wheel'} Mode
 */ /**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */ class MouseWheelZoom extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super(/** @type {import("./Interaction.js").InteractionOptions} */ options);
        /**
     * @private
     * @type {number}
     */ this.totalDelta_ = 0;
        /**
     * @private
     * @type {number}
     */ this.lastDelta_ = 0;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
        /**
     * @private
     * @type {number}
     */ this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
        /**
     * @private
     * @type {boolean}
     */ this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
        /**
     * @private
     * @type {boolean}
     */ this.constrainResolution_ = options.constrainResolution !== undefined ? options.constrainResolution : false;
        const condition = options.condition ? options.condition : (0, _conditionJs.always);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.onFocusOnly ? (0, _conditionJs.all)((0, _conditionJs.focusWithTabindex), condition) : condition;
        /**
     * @private
     * @type {?import("../coordinate.js").Coordinate}
     */ this.lastAnchor_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.startTime_ = undefined;
        /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */ this.timeoutId_;
        /**
     * @private
     * @type {Mode|undefined}
     */ this.mode_ = undefined;
        /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @private
     * @type {number}
     */ this.trackpadEventGap_ = 400;
        /**
     * @private
     * @type {ReturnType<typeof setTimeout>}
     */ this.trackpadTimeoutId_;
        /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */ this.deltaPerZoom_ = 300;
    }
    /**
   * @private
   */ endInteraction_() {
        this.trackpadTimeoutId_ = undefined;
        const map = this.getMap();
        if (!map) return;
        const view = map.getView();
        view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */ handleEvent(mapBrowserEvent) {
        if (!this.condition_(mapBrowserEvent)) return true;
        const type = mapBrowserEvent.type;
        if (type !== (0, _eventTypeJsDefault.default).WHEEL) return true;
        const map = mapBrowserEvent.map;
        const wheelEvent = /** @type {WheelEvent} */ mapBrowserEvent.originalEvent;
        wheelEvent.preventDefault();
        if (this.useAnchor_) this.lastAnchor_ = mapBrowserEvent.coordinate;
        // Delta normalisation inspired by
        // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
        let delta;
        if (mapBrowserEvent.type == (0, _eventTypeJsDefault.default).WHEEL) {
            delta = wheelEvent.deltaY;
            if ((0, _hasJs.FIREFOX) && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) delta /= (0, _hasJs.DEVICE_PIXEL_RATIO);
            if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) delta *= 40;
        }
        if (delta === 0) return false;
        this.lastDelta_ = delta;
        const now = Date.now();
        if (this.startTime_ === undefined) this.startTime_ = now;
        if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';
        const view = map.getView();
        if (this.mode_ === 'trackpad' && !(view.getConstrainResolution() || this.constrainResolution_)) {
            if (this.trackpadTimeoutId_) clearTimeout(this.trackpadTimeoutId_);
            else {
                if (view.getAnimating()) view.cancelAnimations();
                view.beginInteraction();
            }
            this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
            view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
            this.startTime_ = now;
            return false;
        }
        this.totalDelta_ += delta;
        const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
        clearTimeout(this.timeoutId_);
        this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
        return false;
    }
    /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */ handleWheelZoom_(map) {
        const view = map.getView();
        if (view.getAnimating()) view.cancelAnimations();
        let delta = -(0, _mathJs.clamp)(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
        if (view.getConstrainResolution() || this.constrainResolution_) // view has a zoom constraint, zoom by 1
        delta = delta ? delta > 0 ? 1 : -1 : 0;
        (0, _interactionJs.zoomByDelta)(view, delta, this.lastAnchor_, this.duration_);
        this.mode_ = undefined;
        this.totalDelta_ = 0;
        this.lastAnchor_ = null;
        this.startTime_ = undefined;
        this.timeoutId_ = undefined;
    }
    /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */ setMouseAnchor(useAnchor) {
        this.useAnchor_ = useAnchor;
        if (!useAnchor) this.lastAnchor_ = null;
    }
}
exports.default = MouseWheelZoom;

},{"../events/EventType.js":"3uT2C","./Interaction.js":"kcjGH","../has.js":"i07p3","../events/condition.js":"gm0iA","../math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aW88o":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/PinchRotate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var _rotationconstraintJs = require("../rotationconstraint.js");
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */ /**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */ class PinchRotate extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const pointerOptions = /** @type {import("./Pointer.js").Options} */ options;
        if (!pointerOptions.stopDown) pointerOptions.stopDown = (0, _functionsJs.FALSE);
        super(pointerOptions);
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */ this.anchor_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.lastAngle_ = undefined;
        /**
     * @private
     * @type {boolean}
     */ this.rotating_ = false;
        /**
     * @private
     * @type {number}
     */ this.rotationDelta_ = 0.0;
        /**
     * @private
     * @type {number}
     */ this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 250;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */ handleDragEvent(mapBrowserEvent) {
        let rotationDelta = 0.0;
        const touch0 = this.targetPointers[0];
        const touch1 = this.targetPointers[1];
        // angle between touches
        const angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
        if (this.lastAngle_ !== undefined) {
            const delta = angle - this.lastAngle_;
            this.rotationDelta_ += delta;
            if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) this.rotating_ = true;
            rotationDelta = delta;
        }
        this.lastAngle_ = angle;
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (view.getConstraints().rotation === (0, _rotationconstraintJs.disable)) return;
        // rotate anchor point.
        // FIXME: should be the intersection point between the lines:
        //     touch0,touch1 and previousTouch0,previousTouch1
        this.anchor_ = map.getCoordinateFromPixelInternal(map.getEventPixel((0, _pointerJs.centroid)(this.targetPointers)));
        // rotate
        if (this.rotating_) {
            map.render();
            view.adjustRotationInternal(rotationDelta, this.anchor_);
        }
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
            const map = mapBrowserEvent.map;
            const view = map.getView();
            view.endInteraction(this.duration_);
            return false;
        }
        return true;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
            const map = mapBrowserEvent.map;
            this.anchor_ = null;
            this.lastAngle_ = undefined;
            this.rotating_ = false;
            this.rotationDelta_ = 0.0;
            if (!this.handlingDownUpSequence) map.getView().beginInteraction();
            return true;
        }
        return false;
    }
}
exports.default = PinchRotate;

},{"./Pointer.js":"a39IA","../functions.js":"1QSsQ","../rotationconstraint.js":"6TPbY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kKE3X":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/PinchZoom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */ class PinchZoom extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const pointerOptions = /** @type {import("./Pointer.js").Options} */ options;
        if (!pointerOptions.stopDown) pointerOptions.stopDown = (0, _functionsJs.FALSE);
        super(pointerOptions);
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */ this.anchor_ = null;
        /**
     * @private
     * @type {number}
     */ this.duration_ = options.duration !== undefined ? options.duration : 400;
        /**
     * @private
     * @type {number|undefined}
     */ this.lastDistance_ = undefined;
        /**
     * @private
     * @type {number}
     */ this.lastScaleDelta_ = 1;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */ handleDragEvent(mapBrowserEvent) {
        let scaleDelta = 1.0;
        const touch0 = this.targetPointers[0];
        const touch1 = this.targetPointers[1];
        const dx = touch0.clientX - touch1.clientX;
        const dy = touch0.clientY - touch1.clientY;
        // distance between touches
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (this.lastDistance_ !== undefined) scaleDelta = this.lastDistance_ / distance;
        this.lastDistance_ = distance;
        const map = mapBrowserEvent.map;
        const view = map.getView();
        if (scaleDelta != 1.0) this.lastScaleDelta_ = scaleDelta;
        // scale anchor point.
        this.anchor_ = map.getCoordinateFromPixelInternal(map.getEventPixel((0, _pointerJs.centroid)(this.targetPointers)));
        // scale, bypass the resolution constraint
        map.render();
        view.adjustResolutionInternal(scaleDelta, this.anchor_);
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
            const map = mapBrowserEvent.map;
            const view = map.getView();
            const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
            view.endInteraction(this.duration_, direction);
            return false;
        }
        return true;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
            const map = mapBrowserEvent.map;
            this.anchor_ = null;
            this.lastDistance_ = undefined;
            this.lastScaleDelta_ = 1;
            if (!this.handlingDownUpSequence) map.getView().beginInteraction();
            return true;
        }
        return false;
    }
}
exports.default = PinchZoom;

},{"./Pointer.js":"a39IA","../functions.js":"1QSsQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fXEON":[function(require,module,exports,__globalThis) {
/**
 * @module ol/size
 */ /**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */ /**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The buffered size.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buffer", ()=>buffer);
/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */ parcelHelpers.export(exports, "hasArea", ()=>hasArea);
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The scaled size.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */ parcelHelpers.export(exports, "toSize", ()=>toSize);
function buffer(size, num, dest) {
    if (dest === undefined) dest = [
        0,
        0
    ];
    dest[0] = size[0] + 2 * num;
    dest[1] = size[1] + 2 * num;
    return dest;
}
function hasArea(size) {
    return size[0] > 0 && size[1] > 0;
}
function scale(size, ratio, dest) {
    if (dest === undefined) dest = [
        0,
        0
    ];
    dest[0] = size[0] * ratio + 0.5 | 0;
    dest[1] = size[1] * ratio + 0.5 | 0;
    return dest;
}
function toSize(size, dest) {
    if (Array.isArray(size)) return size;
    if (dest === undefined) dest = [
        size,
        size
    ];
    else {
        dest[0] = size;
        dest[1] = size;
    }
    return dest;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8sJWw":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/Tile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseTileJs = require("./BaseTile.js");
var _baseTileJsDefault = parcelHelpers.interopDefault(_baseTileJs);
var _tileLayerJs = require("../renderer/canvas/TileLayer.js");
var _tileLayerJsDefault = parcelHelpers.interopDefault(_tileLayerJs);
/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
 * @api
 */ class TileLayer extends (0, _baseTileJsDefault.default) {
    /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */ constructor(options){
        super(options);
    }
    createRenderer() {
        return new (0, _tileLayerJsDefault.default)(this);
    }
}
exports.default = TileLayer;

},{"./BaseTile.js":"7ay52","../renderer/canvas/TileLayer.js":"3Vwvc","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7ay52":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/BaseTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _tilePropertyJs = require("./TileProperty.js");
var _tilePropertyJsDefault = parcelHelpers.interopDefault(_tilePropertyJs);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   import("./Layer.js").LayerEventType|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */ /**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../Map.js").default#addLayer map.addLayer()}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @template {import("../renderer/Layer.js").default} RendererType
 * @extends {Layer<TileSourceType, RendererType>}
 * @api
 */ class BaseTileLayer extends (0, _layerJsDefault.default) {
    /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */ constructor(options){
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.preload;
        delete baseOptions.useInterimTilesOnError;
        super(baseOptions);
        /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {BaseTileLayerOnSignature<void>}
     */ this.un;
        this.setPreload(options.preload !== undefined ? options.preload : 0);
        this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);
    }
    /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */ getPreload() {
        return /** @type {number} */ this.get((0, _tilePropertyJsDefault.default).PRELOAD);
    }
    /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */ setPreload(preload) {
        this.set((0, _tilePropertyJsDefault.default).PRELOAD, preload);
    }
    /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */ getUseInterimTilesOnError() {
        return /** @type {boolean} */ this.get((0, _tilePropertyJsDefault.default).USE_INTERIM_TILES_ON_ERROR);
    }
    /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */ setUseInterimTilesOnError(useInterimTilesOnError) {
        this.set((0, _tilePropertyJsDefault.default).USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
    }
    /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */ getData(pixel) {
        return super.getData(pixel);
    }
}
exports.default = BaseTileLayer;

},{"./Layer.js":"ixGac","./TileProperty.js":"aGUPT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aGUPT":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/TileProperty
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    PRELOAD: 'preload',
    USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Vwvc":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/canvas/TileLayer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _imageTileJs = require("../../ImageTile.js");
var _imageTileJsDefault = parcelHelpers.interopDefault(_imageTileJs);
var _tileJs = require("../../reproj/Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileRangeJs = require("../../TileRange.js");
var _tileRangeJsDefault = parcelHelpers.interopDefault(_tileRangeJs);
var _tileStateJs = require("../../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _transformJs = require("../../transform.js");
var _arrayJs = require("../../array.js");
var _extentJs = require("../../extent.js");
var _projJs = require("../../proj.js");
var _utilJs = require("../../util.js");
var _sizeJs = require("../../size.js");
/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 * @template {import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
 * @extends {CanvasLayerRenderer<LayerType>}
 */ class CanvasTileLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {LayerType} tileLayer Tile layer.
   */ constructor(tileLayer){
        super(tileLayer);
        /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */ this.extentChanged = true;
        /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */ this.renderedExtent_ = null;
        /**
     * @protected
     * @type {number}
     */ this.renderedPixelRatio;
        /**
     * @protected
     * @type {import("../../proj/Projection.js").default}
     */ this.renderedProjection = null;
        /**
     * @protected
     * @type {number}
     */ this.renderedRevision;
        /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */ this.renderedTiles = [];
        /**
     * @private
     * @type {boolean}
     */ this.newTiles_ = false;
        /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */ this.tmpExtent = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {import("../../TileRange.js").default}
     */ this.tmpTileRange_ = new (0, _tileRangeJsDefault.default)(0, 0, 0, 0);
    }
    /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */ isDrawableTile(tile) {
        const tileLayer = this.getLayer();
        const tileState = tile.getState();
        const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
        return tileState == (0, _tileStateJsDefault.default).LOADED || tileState == (0, _tileStateJsDefault.default).EMPTY || tileState == (0, _tileStateJsDefault.default).ERROR && !useInterimTilesOnError;
    }
    /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */ getTile(z, x, y, frameState) {
        const pixelRatio = frameState.pixelRatio;
        const projection = frameState.viewState.projection;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getSource();
        let tile = tileSource.getTile(z, x, y, pixelRatio, projection);
        if (tile.getState() == (0, _tileStateJsDefault.default).ERROR) {
            if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) // Preloaded tiles for lower resolutions might have finished loading.
            this.newTiles_ = true;
        }
        if (!this.isDrawableTile(tile)) tile = tile.getInterimTile();
        return tile;
    }
    /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */ getData(pixel) {
        const frameState = this.frameState;
        if (!frameState) return null;
        const layer = this.getLayer();
        const coordinate = (0, _transformJs.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
        const layerExtent = layer.getExtent();
        if (layerExtent) {
            if (!(0, _extentJs.containsCoordinate)(layerExtent, coordinate)) return null;
        }
        const pixelRatio = frameState.pixelRatio;
        const projection = frameState.viewState.projection;
        const viewState = frameState.viewState;
        const source = layer.getRenderSource();
        const tileGrid = source.getTileGridForProjection(viewState.projection);
        const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
        for(let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z){
            const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
            const tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);
            if (!(tile instanceof (0, _imageTileJsDefault.default) || tile instanceof (0, _tileJsDefault.default)) || tile instanceof (0, _tileJsDefault.default) && tile.getState() === (0, _tileStateJsDefault.default).EMPTY) return null;
            if (tile.getState() !== (0, _tileStateJsDefault.default).LOADED) continue;
            const tileOrigin = tileGrid.getOrigin(z);
            const tileSize = (0, _sizeJs.toSize)(tileGrid.getTileSize(z));
            const tileResolution = tileGrid.getResolution(z);
            const col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));
            const row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));
            const gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));
            return this.getImageData(tile.getImage(), col + gutter, row + gutter);
        }
        return null;
    }
    /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */ loadedTileCallback(tiles, zoom, tile) {
        if (this.isDrawableTile(tile)) return super.loadedTileCallback(tiles, zoom, tile);
        return false;
    }
    /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        return !!this.getLayer().getSource();
    }
    /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */ renderFrame(frameState, target) {
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const viewResolution = viewState.resolution;
        const viewCenter = viewState.center;
        const rotation = viewState.rotation;
        const pixelRatio = frameState.pixelRatio;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getSource();
        const sourceRevision = tileSource.getRevision();
        const tileGrid = tileSource.getTileGridForProjection(projection);
        const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
        const tileResolution = tileGrid.getResolution(z);
        let extent = frameState.extent;
        const resolution = frameState.viewState.resolution;
        const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
        // desired dimensions of the canvas in pixels
        const width = Math.round((0, _extentJs.getWidth)(extent) / resolution * pixelRatio);
        const height = Math.round((0, _extentJs.getHeight)(extent) / resolution * pixelRatio);
        const layerExtent = layerState.extent && (0, _projJs.fromUserExtent)(layerState.extent, projection);
        if (layerExtent) extent = (0, _extentJs.getIntersection)(extent, (0, _projJs.fromUserExtent)(layerState.extent, projection));
        const dx = tileResolution * width / 2 / tilePixelRatio;
        const dy = tileResolution * height / 2 / tilePixelRatio;
        const canvasExtent = [
            viewCenter[0] - dx,
            viewCenter[1] - dy,
            viewCenter[0] + dx,
            viewCenter[1] + dy
        ];
        const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
        /**
     * @type {Object<number, Object<string, import("../../Tile.js").default>>}
     */ const tilesToDrawByZ = {};
        tilesToDrawByZ[z] = {};
        const findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
        const tmpExtent = this.tmpExtent;
        const tmpTileRange = this.tmpTileRange_;
        this.newTiles_ = false;
        const viewport = rotation ? (0, _extentJs.getRotatedViewport)(viewState.center, resolution, rotation, frameState.size) : undefined;
        for(let x = tileRange.minX; x <= tileRange.maxX; ++x)for(let y = tileRange.minY; y <= tileRange.maxY; ++y){
            if (rotation && !tileGrid.tileCoordIntersectsViewport([
                z,
                x,
                y
            ], viewport)) continue;
            const tile = this.getTile(z, x, y, frameState);
            if (this.isDrawableTile(tile)) {
                const uid = (0, _utilJs.getUid)(this);
                if (tile.getState() == (0, _tileStateJsDefault.default).LOADED) {
                    tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
                    let inTransition = tile.inTransition(uid);
                    if (inTransition && layerState.opacity !== 1) {
                        // Skipping transition when layer is not fully opaque avoids visual artifacts.
                        tile.endTransition(uid);
                        inTransition = false;
                    }
                    if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) this.newTiles_ = true;
                }
                if (tile.getAlpha(uid, frameState.time) === 1) continue;
            }
            const childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
            let covered = false;
            if (childTileRange) covered = findLoadedTiles(z + 1, childTileRange);
            if (!covered) tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
        }
        const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
        // set forward and inverse pixel transforms
        (0, _transformJs.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
        const canvasTransform = (0, _transformJs.toString)(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        const context = this.context;
        const canvas = context.canvas;
        (0, _transformJs.makeInverse)(this.inversePixelTransform, this.pixelTransform);
        // set scale transform for calculating tile positions on the canvas
        (0, _transformJs.compose)(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
        } else if (!this.containerReused) context.clearRect(0, 0, width, height);
        if (layerExtent) this.clipUnrotated(context, frameState, layerExtent);
        if (!tileSource.getInterpolate()) context.imageSmoothingEnabled = false;
        this.preRender(context, frameState);
        this.renderedTiles.length = 0;
        /** @type {Array<number>} */ let zs = Object.keys(tilesToDrawByZ).map(Number);
        zs.sort((0, _arrayJs.ascending));
        let clips, clipZs, currentClip;
        if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) zs = zs.reverse();
        else {
            clips = [];
            clipZs = [];
        }
        for(let i = zs.length - 1; i >= 0; --i){
            const currentZ = zs[i];
            const currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
            const currentResolution = tileGrid.getResolution(currentZ);
            const currentScale = currentResolution / tileResolution;
            const dx = currentTilePixelSize[0] * currentScale * canvasScale;
            const dy = currentTilePixelSize[1] * currentScale * canvasScale;
            const originTileCoord = tileGrid.getTileCoordForCoordAndZ((0, _extentJs.getTopLeft)(canvasExtent), currentZ);
            const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
            const origin = (0, _transformJs.apply)(this.tempTransform, [
                tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
                tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
            ]);
            const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
            const tilesToDraw = tilesToDrawByZ[currentZ];
            for(const tileCoordKey in tilesToDraw){
                const tile = /** @type {import("../../ImageTile.js").default} */ tilesToDraw[tileCoordKey];
                const tileCoord = tile.tileCoord;
                // Calculate integer positions and sizes so that tiles align
                const xIndex = originTileCoord[1] - tileCoord[1];
                const nextX = Math.round(origin[0] - (xIndex - 1) * dx);
                const yIndex = originTileCoord[2] - tileCoord[2];
                const nextY = Math.round(origin[1] - (yIndex - 1) * dy);
                const x = Math.round(origin[0] - xIndex * dx);
                const y = Math.round(origin[1] - yIndex * dy);
                const w = nextX - x;
                const h = nextY - y;
                const transition = z === currentZ;
                const inTransition = transition && tile.getAlpha((0, _utilJs.getUid)(this), frameState.time) !== 1;
                let contextSaved = false;
                if (!inTransition) {
                    if (clips) {
                        // Clip mask for regions in this tile that already filled by a higher z tile
                        currentClip = [
                            x,
                            y,
                            x + w,
                            y,
                            x + w,
                            y + h,
                            x,
                            y + h
                        ];
                        for(let i = 0, ii = clips.length; i < ii; ++i)if (z !== currentZ && currentZ < clipZs[i]) {
                            const clip = clips[i];
                            if ((0, _extentJs.intersects)([
                                x,
                                y,
                                x + w,
                                y + h
                            ], [
                                clip[0],
                                clip[3],
                                clip[4],
                                clip[7]
                            ])) {
                                if (!contextSaved) {
                                    context.save();
                                    contextSaved = true;
                                }
                                context.beginPath();
                                // counter-clockwise (outer ring) for current tile
                                context.moveTo(currentClip[0], currentClip[1]);
                                context.lineTo(currentClip[2], currentClip[3]);
                                context.lineTo(currentClip[4], currentClip[5]);
                                context.lineTo(currentClip[6], currentClip[7]);
                                // clockwise (inner ring) for higher z tile
                                context.moveTo(clip[6], clip[7]);
                                context.lineTo(clip[4], clip[5]);
                                context.lineTo(clip[2], clip[3]);
                                context.lineTo(clip[0], clip[1]);
                                context.clip();
                            }
                        }
                        clips.push(currentClip);
                        clipZs.push(currentZ);
                    } else context.clearRect(x, y, w, h);
                }
                this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);
                if (clips && !inTransition) {
                    if (contextSaved) context.restore();
                    this.renderedTiles.unshift(tile);
                } else this.renderedTiles.push(tile);
                this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
            }
        }
        this.renderedRevision = sourceRevision;
        this.renderedResolution = tileResolution;
        this.extentChanged = !this.renderedExtent_ || !(0, _extentJs.equals)(this.renderedExtent_, canvasExtent);
        this.renderedExtent_ = canvasExtent;
        this.renderedPixelRatio = pixelRatio;
        this.renderedProjection = projection;
        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
        this.scheduleExpireCache(frameState, tileSource);
        this.postRender(context, frameState);
        if (layerState.extent) context.restore();
        context.imageSmoothingEnabled = true;
        if (canvasTransform !== canvas.style.transform) canvas.style.transform = canvasTransform;
        return this.container;
    }
    /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */ drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {
        const image = this.getTileImage(tile);
        if (!image) return;
        const uid = (0, _utilJs.getUid)(this);
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
        const alphaChanged = alpha !== this.context.globalAlpha;
        if (alphaChanged) {
            this.context.save();
            this.context.globalAlpha = alpha;
        }
        this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
        if (alphaChanged) this.context.restore();
        if (alpha !== layerState.opacity) frameState.animate = true;
        else if (transition) tile.endTransition(uid);
    }
    /**
   * @return {HTMLCanvasElement} Image
   */ getImage() {
        const context = this.context;
        return context ? context.canvas : null;
    }
    /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */ getTileImage(tile) {
        return tile.getImage();
    }
    /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */ scheduleExpireCache(frameState, tileSource) {
        if (tileSource.canExpireCache()) {
            /**
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import("../../Map.js").default} map Map.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */ const postRenderFunction = (function(tileSource, map, frameState) {
                const tileSourceKey = (0, _utilJs.getUid)(tileSource);
                if (tileSourceKey in frameState.usedTiles) tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
            }).bind(null, tileSource);
            frameState.postRenderFunctions.push(/** @type {import("../../Map.js").PostRenderFunction} */ postRenderFunction);
        }
    }
    /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */ updateUsedTiles(usedTiles, tileSource, tile) {
        // FIXME should we use tilesToDrawByZ instead?
        const tileSourceKey = (0, _utilJs.getUid)(tileSource);
        if (!(tileSourceKey in usedTiles)) usedTiles[tileSourceKey] = {};
        usedTiles[tileSourceKey][tile.getKey()] = true;
    }
    /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */ manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {
        const tileSourceKey = (0, _utilJs.getUid)(tileSource);
        if (!(tileSourceKey in frameState.wantedTiles)) frameState.wantedTiles[tileSourceKey] = {};
        const wantedTiles = frameState.wantedTiles[tileSourceKey];
        const tileQueue = frameState.tileQueue;
        const minZoom = tileGrid.getMinZoom();
        const rotation = frameState.viewState.rotation;
        const viewport = rotation ? (0, _extentJs.getRotatedViewport)(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;
        let tileCount = 0;
        let tile, tileRange, tileResolution, x, y, z;
        for(z = minZoom; z <= currentZ; ++z){
            tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
            tileResolution = tileGrid.getResolution(z);
            for(x = tileRange.minX; x <= tileRange.maxX; ++x)for(y = tileRange.minY; y <= tileRange.maxY; ++y){
                if (rotation && !tileGrid.tileCoordIntersectsViewport([
                    z,
                    x,
                    y
                ], viewport)) continue;
                if (currentZ - z <= preload) {
                    ++tileCount;
                    tile = tileSource.getTile(z, x, y, pixelRatio, projection);
                    if (tile.getState() == (0, _tileStateJsDefault.default).IDLE) {
                        wantedTiles[tile.getKey()] = true;
                        if (!tileQueue.isKeyQueued(tile.getKey())) tileQueue.enqueue([
                            tile,
                            tileSourceKey,
                            tileGrid.getTileCoordCenter(tile.tileCoord),
                            tileResolution
                        ]);
                    }
                    if (tileCallback !== undefined) tileCallback(tile);
                } else tileSource.useTile(z, x, y, projection);
            }
        }
        tileSource.updateCacheSize(tileCount, projection);
    }
}
exports.default = CanvasTileLayerRenderer;

},{"./Layer.js":"9fzi4","../../ImageTile.js":"3IBrO","../../reproj/Tile.js":"dqATW","../../TileRange.js":"gx7Pm","../../TileState.js":"2J5J5","../../transform.js":"9LrRk","../../array.js":"hyet5","../../extent.js":"bGUel","../../proj.js":"8OK47","../../util.js":"l1iPW","../../size.js":"fXEON","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9fzi4":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/canvas/Layer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "canvasPool", ()=>canvasPool);
var _layerJs = require("../Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _eventJs = require("../../render/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _transformJs = require("../../transform.js");
var _colorJs = require("../../color.js");
var _domJs = require("../../dom.js");
var _arrayJs = require("../../array.js");
var _extentJs = require("../../extent.js");
const canvasPool = [];
/**
 * @type {CanvasRenderingContext2D}
 */ let pixelContext = null;
function createPixelContext() {
    pixelContext = (0, _domJs.createCanvasContext2D)(1, 1, undefined, {
        willReadFrequently: true
    });
}
/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */ class CanvasLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {LayerType} layer Layer.
   */ constructor(layer){
        super(layer);
        /**
     * @protected
     * @type {HTMLElement}
     */ this.container = null;
        /**
     * @protected
     * @type {number}
     */ this.renderedResolution;
        /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.tempTransform = (0, _transformJs.create)();
        /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.pixelTransform = (0, _transformJs.create)();
        /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.inversePixelTransform = (0, _transformJs.create)();
        /**
     * @type {CanvasRenderingContext2D}
     */ this.context = null;
        /**
     * @type {boolean}
     */ this.containerReused = false;
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.pixelContext_ = null;
        /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */ this.frameState = null;
    }
    /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */ getImageData(image, col, row) {
        if (!pixelContext) createPixelContext();
        pixelContext.clearRect(0, 0, 1, 1);
        let data;
        try {
            pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
            data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch (err) {
            pixelContext = null;
            return null;
        }
        return data;
    }
    /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */ getBackground(frameState) {
        const layer = this.getLayer();
        let background = layer.getBackground();
        if (typeof background === 'function') background = background(frameState.viewState.resolution);
        return background || undefined;
    }
    /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */ useContainer(target, transform, backgroundColor) {
        const layerClassName = this.getLayer().getClassName();
        let container, context;
        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && (0, _arrayJs.equals)((0, _colorJs.asArray)(target.style.backgroundColor), (0, _colorJs.asArray)(backgroundColor)))) {
            const canvas = target.firstElementChild;
            if (canvas instanceof HTMLCanvasElement) context = canvas.getContext('2d');
        }
        if (context && context.canvas.style.transform === transform) {
            // Container of the previous layer renderer can be used.
            this.container = target;
            this.context = context;
            this.containerReused = true;
        } else if (this.containerReused) {
            // Previously reused container cannot be used any more.
            this.container = null;
            this.context = null;
            this.containerReused = false;
        } else if (this.container) this.container.style.backgroundColor = null;
        if (!this.container) {
            container = document.createElement('div');
            container.className = layerClassName;
            let style = container.style;
            style.position = 'absolute';
            style.width = '100%';
            style.height = '100%';
            context = (0, _domJs.createCanvasContext2D)();
            const canvas = context.canvas;
            container.appendChild(canvas);
            style = canvas.style;
            style.position = 'absolute';
            style.left = '0';
            style.transformOrigin = 'top left';
            this.container = container;
            this.context = context;
        }
        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) this.container.style.backgroundColor = backgroundColor;
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */ clipUnrotated(context, frameState, extent) {
        const topLeft = (0, _extentJs.getTopLeft)(extent);
        const topRight = (0, _extentJs.getTopRight)(extent);
        const bottomRight = (0, _extentJs.getBottomRight)(extent);
        const bottomLeft = (0, _extentJs.getBottomLeft)(extent);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, topLeft);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, topRight);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, bottomRight);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, bottomLeft);
        const inverted = this.inversePixelTransform;
        (0, _transformJs.apply)(inverted, topLeft);
        (0, _transformJs.apply)(inverted, topRight);
        (0, _transformJs.apply)(inverted, bottomRight);
        (0, _transformJs.apply)(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
    }
    /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */ dispatchRenderEvent_(type, context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
            const event = new (0, _eventJsDefault.default)(type, this.inversePixelTransform, frameState, context);
            layer.dispatchEvent(event);
        }
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ preRender(context, frameState) {
        this.frameState = frameState;
        this.dispatchRenderEvent_((0, _eventTypeJsDefault.default).PRERENDER, context, frameState);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ postRender(context, frameState) {
        this.dispatchRenderEvent_((0, _eventTypeJsDefault.default).POSTRENDER, context, frameState);
    }
    /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */ getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        const dx1 = width / 2;
        const dy1 = height / 2;
        const sx = pixelRatio / resolution;
        const sy = -sx;
        const dx2 = -center[0] + offsetX;
        const dy2 = -center[1];
        return (0, _transformJs.compose)(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
    }
    /**
   * Clean up.
   */ disposeInternal() {
        delete this.frameState;
        super.disposeInternal();
    }
}
exports.default = CanvasLayerRenderer;

},{"../Layer.js":"90Wfg","../../render/Event.js":"e6ARE","../../render/EventType.js":"1ajEk","../../transform.js":"9LrRk","../../color.js":"h6hAX","../../dom.js":"h98kD","../../array.js":"hyet5","../../extent.js":"bGUel","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"90Wfg":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/Layer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _observableJs = require("../Observable.js");
var _observableJsDefault = parcelHelpers.interopDefault(_observableJs);
var _utilJs = require("../util.js");
/**
 * @template {import("../layer/Layer.js").default} LayerType
 */ class LayerRenderer extends (0, _observableJsDefault.default) {
    /**
   * @param {LayerType} layer Layer.
   */ constructor(layer){
        super();
        /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */ this.ready = true;
        /** @private */ this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
        /**
     * @protected
     * @type {LayerType}
     */ this.layer_ = layer;
        /**
     * @type {import("../render/canvas/ExecutorGroup").default}
     */ this.declutterExecutorGroup = null;
    }
    /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */ getFeatures(pixel) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */ getData(pixel) {
        return null;
    }
    /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */ renderFrame(frameState, target) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */ loadedTileCallback(tiles, zoom, tile) {
        if (!tiles[zoom]) tiles[zoom] = {};
        tiles[zoom][tile.tileCoord.toString()] = tile;
        return undefined;
    }
    /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */ createLoadedTileFinder(source, projection, tiles) {
        return(/**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */ (zoom, tileRange)=>{
            const callback = this.loadedTileCallback.bind(this, tiles, zoom);
            return source.forEachLoadedTile(projection, zoom, tileRange, callback);
        });
    }
    /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return undefined;
    }
    /**
   * @return {LayerType} Layer.
   */ getLayer() {
        return this.layer_;
    }
    /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */ handleFontsChanged() {}
    /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */ handleImageChange_(event) {
        const image = /** @type {import("../Image.js").default} */ event.target;
        if (image.getState() === (0, _imageStateJsDefault.default).LOADED || image.getState() === (0, _imageStateJsDefault.default).ERROR) this.renderIfReadyAndVisible();
    }
    /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */ loadImage(image) {
        let imageState = image.getState();
        if (imageState != (0, _imageStateJsDefault.default).LOADED && imageState != (0, _imageStateJsDefault.default).ERROR) image.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleImageChange_);
        if (imageState == (0, _imageStateJsDefault.default).IDLE) {
            image.load();
            imageState = image.getState();
        }
        return imageState == (0, _imageStateJsDefault.default).LOADED;
    }
    /**
   * @protected
   */ renderIfReadyAndVisible() {
        const layer = this.getLayer();
        if (layer && layer.getVisible() && layer.getSourceState() === 'ready') layer.changed();
    }
    /**
   * Clean up.
   */ disposeInternal() {
        delete this.layer_;
        super.disposeInternal();
    }
}
exports.default = LayerRenderer;

},{"../events/EventType.js":"3uT2C","../ImageState.js":"jCrEd","../Observable.js":"eKbGA","../util.js":"l1iPW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jCrEd":[function(require,module,exports,__globalThis) {
/**
 * @module ol/ImageState
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3IBrO":[function(require,module,exports,__globalThis) {
/**
 * @module ol/ImageTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _domJs = require("./dom.js");
var _imageJs = require("./Image.js");
class ImageTile extends (0, _tileJsDefault.default) {
    /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */ constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options){
        super(tileCoord, state, options);
        /**
     * @private
     * @type {?string}
     */ this.crossOrigin_ = crossOrigin;
        /**
     * Image URI
     *
     * @private
     * @type {string}
     */ this.src_ = src;
        this.key = src;
        /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */ this.image_ = new Image();
        if (crossOrigin !== null) this.image_.crossOrigin = crossOrigin;
        /**
     * @private
     * @type {?function():void}
     */ this.unlisten_ = null;
        /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */ this.tileLoadFunction_ = tileLoadFunction;
    }
    /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */ getImage() {
        return this.image_;
    }
    /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */ setImage(element) {
        this.image_ = element;
        this.state = (0, _tileStateJsDefault.default).LOADED;
        this.unlistenImage_();
        this.changed();
    }
    /**
   * Tracks loading or read errors.
   *
   * @private
   */ handleImageError_() {
        this.state = (0, _tileStateJsDefault.default).ERROR;
        this.unlistenImage_();
        this.image_ = getBlankImage();
        this.changed();
    }
    /**
   * Tracks successful image load.
   *
   * @private
   */ handleImageLoad_() {
        const image = /** @type {HTMLImageElement} */ this.image_;
        if (image.naturalWidth && image.naturalHeight) this.state = (0, _tileStateJsDefault.default).LOADED;
        else this.state = (0, _tileStateJsDefault.default).EMPTY;
        this.unlistenImage_();
        this.changed();
    }
    /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */ load() {
        if (this.state == (0, _tileStateJsDefault.default).ERROR) {
            this.state = (0, _tileStateJsDefault.default).IDLE;
            this.image_ = new Image();
            if (this.crossOrigin_ !== null) this.image_.crossOrigin = this.crossOrigin_;
        }
        if (this.state == (0, _tileStateJsDefault.default).IDLE) {
            this.state = (0, _tileStateJsDefault.default).LOADING;
            this.changed();
            this.tileLoadFunction_(this, this.src_);
            this.unlisten_ = (0, _imageJs.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
        }
    }
    /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */ unlistenImage_() {
        if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
        }
    }
}
/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */ function getBlankImage() {
    const ctx = (0, _domJs.createCanvasContext2D)(1, 1);
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0, 0, 1, 1);
    return ctx.canvas;
}
exports.default = ImageTile;

},{"./Tile.js":"eTFB8","./TileState.js":"2J5J5","./dom.js":"h98kD","./Image.js":"7I8uM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eTFB8":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Tile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _utilJs = require("./util.js");
var _easingJs = require("./easing.js");
/**
 * A function that takes an {@link module:ol/Tile~Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState.js';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   const xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     const data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */ /**
 * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection~Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */ /**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @api
 */ /**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */ class Tile extends (0, _targetJsDefault.default) {
    /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */ constructor(tileCoord, state, options){
        super();
        options = options ? options : {};
        /**
     * @type {import("./tilecoord.js").TileCoord}
     */ this.tileCoord = tileCoord;
        /**
     * @protected
     * @type {import("./TileState.js").default}
     */ this.state = state;
        /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile|null}
     */ this.interimTile = null;
        /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */ this.key = '';
        /**
     * The duration for the opacity transition.
     * @type {number}
     */ this.transition_ = options.transition === undefined ? 250 : options.transition;
        /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */ this.transitionStarts_ = {};
        /**
     * @type {boolean}
     */ this.interpolate = !!options.interpolate;
    }
    /**
   * @protected
   */ changed() {
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */ release() {
        if (this.state === (0, _tileStateJsDefault.default).ERROR) // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`
        this.setState((0, _tileStateJsDefault.default).EMPTY);
    }
    /**
   * @return {string} Key.
   */ getKey() {
        return this.key + '/' + this.tileCoord;
    }
    /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */ getInterimTile() {
        let tile = this.interimTile;
        if (!tile) //empty chain
        return this;
        // find the first loaded tile and return it. Since the chain is sorted in
        // decreasing order of creation time, there is no need to search the remainder
        // of the list (all those tiles correspond to older requests and will be
        // cleaned up by refreshInterimChain)
        do {
            if (tile.getState() == (0, _tileStateJsDefault.default).LOADED) {
                // Show tile immediately instead of fading it in after loading, because
                // the interim tile is in place already
                this.transition_ = 0;
                return tile;
            }
            tile = tile.interimTile;
        }while (tile);
        // we can not find a better tile
        return this;
    }
    /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */ refreshInterimChain() {
        let tile = this.interimTile;
        if (!tile) return;
        /** @type {Tile} */ let prev = this;
        do {
            if (tile.getState() == (0, _tileStateJsDefault.default).LOADED) {
                //we have a loaded tile, we can discard the rest of the list
                //we would could abort any LOADING tile request
                //older than this tile (i.e. any LOADING tile following this entry in the chain)
                tile.interimTile = null;
                break;
            }
            if (tile.getState() == (0, _tileStateJsDefault.default).LOADING) //keep this LOADING tile any loaded tiles later in the chain are
            //older than this tile, so we're still interested in the request
            prev = tile;
            else if (tile.getState() == (0, _tileStateJsDefault.default).IDLE) //the head of the list is the most current tile, we don't need
            //to start any other requests for this chain
            prev.interimTile = tile.interimTile;
            else prev = tile;
            tile = prev.interimTile;
        }while (tile);
    }
    /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */ getTileCoord() {
        return this.tileCoord;
    }
    /**
   * @return {import("./TileState.js").default} State.
   */ getState() {
        return this.state;
    }
    /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */ setState(state) {
        if (this.state !== (0, _tileStateJsDefault.default).ERROR && this.state > state) throw new Error('Tile load sequence violation');
        this.state = state;
        this.changed();
    }
    /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */ load() {
        (0, _utilJs.abstract)();
    }
    /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */ getAlpha(id, time) {
        if (!this.transition_) return 1;
        let start = this.transitionStarts_[id];
        if (!start) {
            start = time;
            this.transitionStarts_[id] = start;
        } else if (start === -1) return 1;
        const delta = time - start + 1000 / 60; // avoid rendering at 0
        if (delta >= this.transition_) return 1;
        return (0, _easingJs.easeIn)(delta / this.transition_);
    }
    /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */ inTransition(id) {
        if (!this.transition_) return false;
        return this.transitionStarts_[id] !== -1;
    }
    /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */ endTransition(id) {
        if (this.transition_) this.transitionStarts_[id] = -1;
    }
}
exports.default = Tile;

},{"./events/Target.js":"dZel6","./events/EventType.js":"3uT2C","./TileState.js":"2J5J5","./util.js":"l1iPW","./easing.js":"jskwM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7I8uM":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import('./DataTile.js').ImageLike} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */ parcelHelpers.export(exports, "listenImage", ()=>listenImage);
/**
 * Loads an image.
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.
 * @api
 */ parcelHelpers.export(exports, "load", ()=>load);
/**
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.
 */ parcelHelpers.export(exports, "decodeFallback", ()=>decodeFallback);
/**
 * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns
 * the loaded image otherwise.
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an
 * `HTMLImageElement` if `createImageBitmap()` is not supported.
 * @api
 */ parcelHelpers.export(exports, "decode", ()=>decode);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("./ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _hasJs = require("./has.js");
var _eventsJs = require("./events.js");
var _functionsJs = require("./functions.js");
/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(import("./Image.js").default, string): void} LoadFunction
 * @api
 */ /**
 * @typedef {Object} ImageObject
 * @property {import("./extent.js").Extent} [extent] Extent, if different from the requested one.
 * @property {import("./resolution.js").ResolutionLike} [resolution] Resolution, if different from the requested one.
 * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).
 * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */ /**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * For images that cover any extent and resolution (static images), the loader function should not accept
 * any arguments. The function returns an {@link import("./DataTile.js").ImageLike image}, an
 * {@link import("./Image.js").ImageObject image object}, or a promise for the same.
 * For loaders that generate images, the promise should not resolve until the image is loaded.
 * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,
 * it has to return an {@link import("./Image.js").ImageObject image object} with the `image` and the
 * correct `extent`, `resolution` and `pixelRatio`.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} Loader
 * @api
 */ /**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * The function returns a promise for an  {@link import("./Image.js").ImageObject image object}.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} ImageObjectPromiseLoader
 */ class ImageWrapper extends (0, _targetJsDefault.default) {
    /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
   */ constructor(extent, resolution, pixelRatio, stateOrLoader){
        super();
        /**
     * @protected
     * @type {import("./extent.js").Extent}
     */ this.extent = extent;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @protected
     * @type {number|Array<number>|undefined}
     */ this.resolution = resolution;
        /**
     * @protected
     * @type {import("./ImageState.js").default}
     */ this.state = typeof stateOrLoader === 'function' ? (0, _imageStateJsDefault.default).IDLE : stateOrLoader;
        /**
     * @private
     * @type {import('./DataTile.js').ImageLike|null}
     */ this.image_ = null;
        /**
     * @protected
     * @type {import("./Image.js").Loader}
     */ this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;
    }
    /**
   * @protected
   */ changed() {
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * @return {import("./extent.js").Extent} Extent.
   */ getExtent() {
        return this.extent;
    }
    /**
   * @return {import('./DataTile.js').ImageLike} Image.
   */ getImage() {
        return this.image_;
    }
    /**
   * @return {number} PixelRatio.
   */ getPixelRatio() {
        return this.pixelRatio_;
    }
    /**
   * @return {number|Array<number>} Resolution.
   */ getResolution() {
        return /** @type {number} */ this.resolution;
    }
    /**
   * @return {import("./ImageState.js").default} State.
   */ getState() {
        return this.state;
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.state == (0, _imageStateJsDefault.default).IDLE) {
            if (this.loader) {
                this.state = (0, _imageStateJsDefault.default).LOADING;
                this.changed();
                const resolution = this.getResolution();
                const requestResolution = Array.isArray(resolution) ? resolution[0] : resolution;
                (0, _functionsJs.toPromise)(()=>this.loader(this.getExtent(), requestResolution, this.getPixelRatio())).then((image)=>{
                    if ('image' in image) this.image_ = image.image;
                    if ('extent' in image) this.extent = image.extent;
                    if ('resolution' in image) this.resolution = image.resolution;
                    if ('pixelRatio' in image) this.pixelRatio_ = image.pixelRatio;
                    if (image instanceof HTMLImageElement || image instanceof ImageBitmap || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement) this.image_ = image;
                    this.state = (0, _imageStateJsDefault.default).LOADED;
                }).catch((error)=>{
                    this.state = (0, _imageStateJsDefault.default).ERROR;
                    console.error(error); // eslint-disable-line no-console
                }).finally(()=>this.changed());
            }
        }
    }
    /**
   * @param {import('./DataTile.js').ImageLike} image The image.
   */ setImage(image) {
        this.image_ = image;
    }
    /**
   * @param {number|Array<number>} resolution Resolution.
   */ setResolution(resolution) {
        this.resolution = resolution;
    }
}
function listenImage(image, loadHandler, errorHandler) {
    const img = /** @type {HTMLImageElement} */ image;
    let listening = true;
    let decoding = false;
    let loaded = false;
    const listenerKeys = [
        (0, _eventsJs.listenOnce)(img, (0, _eventTypeJsDefault.default).LOAD, function() {
            loaded = true;
            if (!decoding) loadHandler();
        })
    ];
    if (img.src && (0, _hasJs.IMAGE_DECODE)) {
        decoding = true;
        img.decode().then(function() {
            if (listening) loadHandler();
        }).catch(function(error) {
            if (listening) {
                if (loaded) loadHandler();
                else errorHandler();
            }
        });
    } else listenerKeys.push((0, _eventsJs.listenOnce)(img, (0, _eventTypeJsDefault.default).ERROR, errorHandler));
    return function unlisten() {
        listening = false;
        listenerKeys.forEach((0, _eventsJs.unlistenByKey));
    };
}
function load(image, src) {
    return new Promise((resolve, reject)=>{
        function handleLoad() {
            unlisten();
            resolve(image);
        }
        function handleError() {
            unlisten();
            reject(new Error('Image load error'));
        }
        function unlisten() {
            image.removeEventListener('load', handleLoad);
            image.removeEventListener('error', handleError);
        }
        image.addEventListener('load', handleLoad);
        image.addEventListener('error', handleError);
        if (src) image.src = src;
    });
}
function decodeFallback(image, src) {
    if (src) image.src = src;
    return image.src && (0, _hasJs.IMAGE_DECODE) ? new Promise((resolve, reject)=>image.decode().then(()=>resolve(image)).catch((e)=>image.complete && image.width ? resolve(image) : reject(e))) : load(image);
}
function decode(image, src) {
    if (src) image.src = src;
    return image.src && (0, _hasJs.IMAGE_DECODE) && (0, _hasJs.CREATE_IMAGE_BITMAP) ? image.decode().then(()=>createImageBitmap(image)).catch((e)=>{
        if (image.complete && image.width) return image;
        throw e;
    }) : decodeFallback(image);
}
exports.default = ImageWrapper;

},{"./events/Target.js":"dZel6","./events/EventType.js":"3uT2C","./ImageState.js":"jCrEd","./has.js":"i07p3","./events.js":"lh4km","./functions.js":"1QSsQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dqATW":[function(require,module,exports,__globalThis) {
/**
 * @module ol/reproj/Tile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _commonJs = require("./common.js");
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _tileJs = require("../Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _triangulationJs = require("./Triangulation.js");
var _triangulationJsDefault = parcelHelpers.interopDefault(_triangulationJs);
var _reprojJs = require("../reproj.js");
var _mathJs = require("../math.js");
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
var _domJs = require("../dom.js");
/**
 * @typedef {function(number, number, number, number) : (import("../ImageTile.js").default)} FunctionType
 */ /**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */ class ReprojTile extends (0, _tileJsDefault.default) {
    /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */ constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options){
        super(tileCoord, (0, _tileStateJsDefault.default).IDLE, options);
        /**
     * @private
     * @type {boolean}
     */ this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {number}
     */ this.gutter_ = gutter;
        /**
     * @private
     * @type {HTMLCanvasElement}
     */ this.canvas_ = null;
        /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */ this.sourceTileGrid_ = sourceTileGrid;
        /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */ this.targetTileGrid_ = targetTileGrid;
        /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */ this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
        /**
     * @private
     * @type {!Array<import("../ImageTile.js").default>}
     */ this.sourceTiles_ = [];
        /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */ this.sourcesListenerKeys_ = null;
        /**
     * @private
     * @type {number}
     */ this.sourceZ_ = 0;
        const targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
        const maxTargetExtent = this.targetTileGrid_.getExtent();
        let maxSourceExtent = this.sourceTileGrid_.getExtent();
        const limitedTargetExtent = maxTargetExtent ? (0, _extentJs.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;
        if ((0, _extentJs.getArea)(limitedTargetExtent) === 0) {
            // Tile is completely outside range -> EMPTY
            // TODO: is it actually correct that the source even creates the tile ?
            this.state = (0, _tileStateJsDefault.default).EMPTY;
            return;
        }
        const sourceProjExtent = sourceProj.getExtent();
        if (sourceProjExtent) {
            if (!maxSourceExtent) maxSourceExtent = sourceProjExtent;
            else maxSourceExtent = (0, _extentJs.getIntersection)(maxSourceExtent, sourceProjExtent);
        }
        const targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);
        const sourceResolution = (0, _reprojJs.calculateSourceExtentResolution)(sourceProj, targetProj, limitedTargetExtent, targetResolution);
        if (!isFinite(sourceResolution) || sourceResolution <= 0) {
            // invalid sourceResolution -> EMPTY
            // probably edges of the projections when no extent is defined
            this.state = (0, _tileStateJsDefault.default).EMPTY;
            return;
        }
        const errorThresholdInPixels = errorThreshold !== undefined ? errorThreshold : (0, _commonJs.ERROR_THRESHOLD);
        /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */ this.triangulation_ = new (0, _triangulationJsDefault.default)(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
        if (this.triangulation_.getTriangles().length === 0) {
            // no valid triangles -> EMPTY
            this.state = (0, _tileStateJsDefault.default).EMPTY;
            return;
        }
        this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
        let sourceExtent = this.triangulation_.calculateSourceExtent();
        if (maxSourceExtent) {
            if (sourceProj.canWrapX()) {
                sourceExtent[1] = (0, _mathJs.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
                sourceExtent[3] = (0, _mathJs.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
            } else sourceExtent = (0, _extentJs.getIntersection)(sourceExtent, maxSourceExtent);
        }
        if (!(0, _extentJs.getArea)(sourceExtent)) this.state = (0, _tileStateJsDefault.default).EMPTY;
        else {
            const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);
            for(let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++)for(let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++){
                const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
                if (tile) this.sourceTiles_.push(tile);
            }
            if (this.sourceTiles_.length === 0) this.state = (0, _tileStateJsDefault.default).EMPTY;
        }
    }
    /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */ getImage() {
        return this.canvas_;
    }
    /**
   * @private
   */ reproject_() {
        const sources = [];
        this.sourceTiles_.forEach((tile)=>{
            if (tile && tile.getState() == (0, _tileStateJsDefault.default).LOADED) sources.push({
                extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
                image: tile.getImage()
            });
        });
        this.sourceTiles_.length = 0;
        if (sources.length === 0) this.state = (0, _tileStateJsDefault.default).ERROR;
        else {
            const z = this.wrappedTileCoord_[0];
            const size = this.targetTileGrid_.getTileSize(z);
            const width = typeof size === 'number' ? size : size[0];
            const height = typeof size === 'number' ? size : size[1];
            const targetResolution = this.targetTileGrid_.getResolution(z);
            const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
            const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
            this.canvas_ = (0, _reprojJs.render)(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
            this.state = (0, _tileStateJsDefault.default).LOADED;
        }
        this.changed();
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.state == (0, _tileStateJsDefault.default).IDLE) {
            this.state = (0, _tileStateJsDefault.default).LOADING;
            this.changed();
            let leftToLoad = 0;
            this.sourcesListenerKeys_ = [];
            this.sourceTiles_.forEach((tile)=>{
                const state = tile.getState();
                if (state == (0, _tileStateJsDefault.default).IDLE || state == (0, _tileStateJsDefault.default).LOADING) {
                    leftToLoad++;
                    const sourceListenKey = (0, _eventsJs.listen)(tile, (0, _eventTypeJsDefault.default).CHANGE, function(e) {
                        const state = tile.getState();
                        if (state == (0, _tileStateJsDefault.default).LOADED || state == (0, _tileStateJsDefault.default).ERROR || state == (0, _tileStateJsDefault.default).EMPTY) {
                            (0, _eventsJs.unlistenByKey)(sourceListenKey);
                            leftToLoad--;
                            if (leftToLoad === 0) {
                                this.unlistenSources_();
                                this.reproject_();
                            }
                        }
                    }, this);
                    this.sourcesListenerKeys_.push(sourceListenKey);
                }
            });
            if (leftToLoad === 0) setTimeout(this.reproject_.bind(this), 0);
            else this.sourceTiles_.forEach(function(tile, i, arr) {
                const state = tile.getState();
                if (state == (0, _tileStateJsDefault.default).IDLE) tile.load();
            });
        }
    }
    /**
   * @private
   */ unlistenSources_() {
        this.sourcesListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
        this.sourcesListenerKeys_ = null;
    }
    /**
   * Remove from the cache due to expiry
   */ release() {
        if (this.canvas_) {
            (0, _domJs.releaseCanvas)(this.canvas_.getContext('2d'));
            (0, _reprojJs.canvasPool).push(this.canvas_);
            this.canvas_ = null;
        }
        super.release();
    }
}
exports.default = ReprojTile;

},{"./common.js":"aQ4PW","../events/EventType.js":"3uT2C","../Tile.js":"eTFB8","../TileState.js":"2J5J5","./Triangulation.js":"eWboV","../reproj.js":"i3wKe","../math.js":"d8zSj","../extent.js":"bGUel","../events.js":"lh4km","../dom.js":"h98kD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aQ4PW":[function(require,module,exports,__globalThis) {
/**
 * @module ol/reproj/common
 */ /**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ERROR_THRESHOLD", ()=>ERROR_THRESHOLD);
const ERROR_THRESHOLD = 0.5;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eWboV":[function(require,module,exports,__globalThis) {
/**
 * @module ol/reproj/Triangulation
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _mathJs = require("../math.js");
/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source Source.
 * @property {Array<import("../coordinate.js").Coordinate>} target Target.
 */ /**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */ const MAX_SUBDIVISION = 10;
/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */ const MAX_TRIANGLE_WIDTH = 0.25;
/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */ class Triangulation {
    /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */ constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution){
        /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */ this.sourceProj_ = sourceProj;
        /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */ this.targetProj_ = targetProj;
        /** @type {!Object<string, import("../coordinate.js").Coordinate>} */ let transformInvCache = {};
        const transformInv = (0, _projJs.getTransform)(this.targetProj_, this.sourceProj_);
        /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */ this.transformInv_ = function(c) {
            const key = c[0] + '/' + c[1];
            if (!transformInvCache[key]) transformInvCache[key] = transformInv(c);
            return transformInvCache[key];
        };
        /**
     * @type {import("../extent.js").Extent}
     * @private
     */ this.maxSourceExtent_ = maxSourceExtent;
        /**
     * @type {number}
     * @private
     */ this.errorThresholdSquared_ = errorThreshold * errorThreshold;
        /**
     * @type {Array<Triangle>}
     * @private
     */ this.triangles_ = [];
        /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */ this.wrapsXInSource_ = false;
        /**
     * @type {boolean}
     * @private
     */ this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && (0, _extentJs.getWidth)(maxSourceExtent) >= (0, _extentJs.getWidth)(this.sourceProj_.getExtent());
        /**
     * @type {?number}
     * @private
     */ this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? (0, _extentJs.getWidth)(this.sourceProj_.getExtent()) : null;
        /**
     * @type {?number}
     * @private
     */ this.targetWorldWidth_ = this.targetProj_.getExtent() ? (0, _extentJs.getWidth)(this.targetProj_.getExtent()) : null;
        const destinationTopLeft = (0, _extentJs.getTopLeft)(targetExtent);
        const destinationTopRight = (0, _extentJs.getTopRight)(targetExtent);
        const destinationBottomRight = (0, _extentJs.getBottomRight)(targetExtent);
        const destinationBottomLeft = (0, _extentJs.getBottomLeft)(targetExtent);
        const sourceTopLeft = this.transformInv_(destinationTopLeft);
        const sourceTopRight = this.transformInv_(destinationTopRight);
        const sourceBottomRight = this.transformInv_(destinationBottomRight);
        const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
        /*
     * The maxSubdivision controls how many splittings of the target area can
     * be done. The idea here is to do a linear mapping of the target areas
     * but the actual overall reprojection (can be) extremely non-linear. The
     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
     * tile size. However this function is also called to remap canvas rendered
     * layers which can be much larger. This calculation increases the maxSubdivision
     * value by the right factor so that each 256x256 pixel area has
     * MAX_SUBDIVISION divisions.
     */ const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2((0, _extentJs.getArea)(targetExtent) / (destinationResolution * destinationResolution * 65536)))) : 0);
        this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
        if (this.wrapsXInSource_) {
            let leftBound = Infinity;
            this.triangles_.forEach(function(triangle, i, arr) {
                leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
            });
            // Shift triangles to be as close to `leftBound` as possible
            // (if the distance is more than `worldWidth / 2` it can be closer.
            this.triangles_.forEach((triangle)=>{
                if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
                    const newTriangle = [
                        [
                            triangle.source[0][0],
                            triangle.source[0][1]
                        ],
                        [
                            triangle.source[1][0],
                            triangle.source[1][1]
                        ],
                        [
                            triangle.source[2][0],
                            triangle.source[2][1]
                        ]
                    ];
                    if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) newTriangle[0][0] -= this.sourceWorldWidth_;
                    if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) newTriangle[1][0] -= this.sourceWorldWidth_;
                    if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) newTriangle[2][0] -= this.sourceWorldWidth_;
                    // Rarely (if the extent contains both the dateline and prime meridian)
                    // the shift can in turn break some triangles.
                    // Detect this here and don't shift in such cases.
                    const minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                    const maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                    if (maxX - minX < this.sourceWorldWidth_ / 2) triangle.source = newTriangle;
                }
            });
        }
        transformInvCache = {};
    }
    /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */ addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
        this.triangles_.push({
            source: [
                aSrc,
                bSrc,
                cSrc
            ],
            target: [
                a,
                b,
                c
            ]
        });
    }
    /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */ addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
        const sourceQuadExtent = (0, _extentJs.boundingExtent)([
            aSrc,
            bSrc,
            cSrc,
            dSrc
        ]);
        const sourceCoverageX = this.sourceWorldWidth_ ? (0, _extentJs.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_ : null;
        const sourceWorldWidth = /** @type {number} */ this.sourceWorldWidth_;
        // when the quad is wrapped in the source projection
        // it covers most of the projection extent, but not fully
        const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
        let needsSubdivision = false;
        if (maxSubdivision > 0) {
            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
                const targetQuadExtent = (0, _extentJs.boundingExtent)([
                    a,
                    b,
                    c,
                    d
                ]);
                const targetCoverageX = (0, _extentJs.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
                needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
            }
            if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
        }
        if (!needsSubdivision && this.maxSourceExtent_) {
            if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
                if (!(0, _extentJs.intersects)(sourceQuadExtent, this.maxSourceExtent_)) // whole quad outside source projection extent -> ignore
                return;
            }
        }
        let isNotFinite = 0;
        if (!needsSubdivision) {
            if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
                if (maxSubdivision > 0) needsSubdivision = true;
                else {
                    // It might be the case that only 1 of the points is infinite. In this case
                    // we can draw a single triangle with the other three points
                    isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
                    if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) return;
                }
            }
        }
        if (maxSubdivision > 0) {
            if (!needsSubdivision) {
                const center = [
                    (a[0] + c[0]) / 2,
                    (a[1] + c[1]) / 2
                ];
                const centerSrc = this.transformInv_(center);
                let dx;
                if (wrapsX) {
                    const centerSrcEstimX = ((0, _mathJs.modulo)(aSrc[0], sourceWorldWidth) + (0, _mathJs.modulo)(cSrc[0], sourceWorldWidth)) / 2;
                    dx = centerSrcEstimX - (0, _mathJs.modulo)(centerSrc[0], sourceWorldWidth);
                } else dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
                const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
                const centerSrcErrorSquared = dx * dx + dy * dy;
                needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
            }
            if (needsSubdivision) {
                if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
                    // split horizontally (top & bottom)
                    const bc = [
                        (b[0] + c[0]) / 2,
                        (b[1] + c[1]) / 2
                    ];
                    const bcSrc = this.transformInv_(bc);
                    const da = [
                        (d[0] + a[0]) / 2,
                        (d[1] + a[1]) / 2
                    ];
                    const daSrc = this.transformInv_(da);
                    this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
                    this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
                } else {
                    // split vertically (left & right)
                    const ab = [
                        (a[0] + b[0]) / 2,
                        (a[1] + b[1]) / 2
                    ];
                    const abSrc = this.transformInv_(ab);
                    const cd = [
                        (c[0] + d[0]) / 2,
                        (c[1] + d[1]) / 2
                    ];
                    const cdSrc = this.transformInv_(cd);
                    this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
                    this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
                }
                return;
            }
        }
        if (wrapsX) {
            if (!this.canWrapXInSource_) return;
            this.wrapsXInSource_ = true;
        }
        // Exactly zero or one of *Src is not finite
        // The triangles must have the diagonal line as the first side
        // This is to allow easy code in reproj.s to make it straight for broken
        // browsers that can't handle diagonal clipping
        if ((isNotFinite & 0xb) == 0) this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
        if ((isNotFinite & 0xe) == 0) this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
        if (isNotFinite) {
            // Try the other two triangles
            if ((isNotFinite & 0xd) == 0) this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
            if ((isNotFinite & 0x7) == 0) this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
        }
    }
    /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */ calculateSourceExtent() {
        const extent = (0, _extentJs.createEmpty)();
        this.triangles_.forEach(function(triangle, i, arr) {
            const src = triangle.source;
            (0, _extentJs.extendCoordinate)(extent, src[0]);
            (0, _extentJs.extendCoordinate)(extent, src[1]);
            (0, _extentJs.extendCoordinate)(extent, src[2]);
        });
        return extent;
    }
    /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */ getTriangles() {
        return this.triangles_;
    }
}
exports.default = Triangulation;

},{"../extent.js":"bGUel","../proj.js":"8OK47","../math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i3wKe":[function(require,module,exports,__globalThis) {
/**
 * @module ol/reproj
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "canvasPool", ()=>canvasPool);
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */ parcelHelpers.export(exports, "calculateSourceResolution", ()=>calculateSourceResolution);
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */ parcelHelpers.export(exports, "calculateSourceExtentResolution", ()=>calculateSourceExtentResolution);
/**
 * @typedef {Object} ImageExtent
 * @property {import("./extent.js").Extent} extent Extent.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */ /**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
 * @param {Array<ImageExtent>} sources Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean} [renderEdges] Render reprojection edges.
 * @param {boolean} [interpolate] Use linear interpolation when resampling.
 * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */ parcelHelpers.export(exports, "render", ()=>render);
var _extentJs = require("./extent.js");
var _domJs = require("./dom.js");
var _projJs = require("./proj.js");
var _mathJs = require("./math.js");
let brokenDiagonalRendering_;
const canvasPool = [];
/**
 * This draws a small triangle into a canvas by setting the triangle as the clip region
 * and then drawing a (too large) rectangle
 *
 * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
 * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
 * @param {number} v1 The y-coordinate of the second point.
 * @param {number} u2 The x-coordinate of the third point.
 * @param {number} v2 The y-coordinate of the third point.
 */ function drawTestTriangle(ctx, u1, v1, u2, v2) {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(u1, v1);
    ctx.lineTo(u2, v2);
    ctx.closePath();
    ctx.save();
    ctx.clip();
    ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
    ctx.restore();
}
/**
 * Given the data from getImageData, see if the right values appear at the provided offset.
 * Returns true if either the color or transparency is off
 *
 * @param {Uint8ClampedArray} data The data returned from getImageData
 * @param {number} offset The pixel offset from the start of data.
 * @return {boolean} true if the diagonal rendering is broken
 */ function verifyBrokenDiagonalRendering(data, offset) {
    // the values ought to be close to the rgba(210, 0, 0, 0.75)
    return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 191.25) > 2;
}
/**
 * Determines if the current browser configuration can render triangular clip regions correctly.
 * This value is cached so the function is only expensive the first time called.
 * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
 * Chrome works, and everything seems to work on OSX and Android. This function caches the
 * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
 * running, but lets hope not.
 *
 * @return {boolean} true if the Diagonal Rendering is broken.
 */ function isBrokenDiagonalRendering() {
    if (brokenDiagonalRendering_ === undefined) {
        const ctx = (0, _domJs.createCanvasContext2D)(6, 6, canvasPool);
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
        drawTestTriangle(ctx, 4, 5, 4, 0);
        drawTestTriangle(ctx, 4, 5, 0, 5);
        const data = ctx.getImageData(0, 0, 3, 3).data;
        brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
        (0, _domJs.releaseCanvas)(ctx);
        canvasPool.push(ctx.canvas);
    }
    return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
    const sourceCenter = (0, _projJs.transform)(targetCenter, targetProj, sourceProj);
    // calculate the ideal resolution of the source data
    let sourceResolution = (0, _projJs.getPointResolution)(targetProj, targetResolution, targetCenter);
    const targetMetersPerUnit = targetProj.getMetersPerUnit();
    if (targetMetersPerUnit !== undefined) sourceResolution *= targetMetersPerUnit;
    const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
    if (sourceMetersPerUnit !== undefined) sourceResolution /= sourceMetersPerUnit;
    // Based on the projection properties, the point resolution at the specified
    // coordinates may be slightly different. We need to reverse-compensate this
    // in order to achieve optimal results.
    const sourceExtent = sourceProj.getExtent();
    if (!sourceExtent || (0, _extentJs.containsCoordinate)(sourceExtent, sourceCenter)) {
        const compensationFactor = (0, _projJs.getPointResolution)(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
        if (isFinite(compensationFactor) && compensationFactor > 0) sourceResolution /= compensationFactor;
    }
    return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
    const targetCenter = (0, _extentJs.getCenter)(targetExtent);
    let sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
    if (!isFinite(sourceResolution) || sourceResolution <= 0) (0, _extentJs.forEachCorner)(targetExtent, function(corner) {
        sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
        return isFinite(sourceResolution) && sourceResolution > 0;
    });
    return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle) {
    const context = (0, _domJs.createCanvasContext2D)(Math.round(pixelRatio * width), Math.round(pixelRatio * height), canvasPool);
    if (!interpolate) context.imageSmoothingEnabled = false;
    if (sources.length === 0) return context.canvas;
    context.scale(pixelRatio, pixelRatio);
    function pixelRound(value) {
        return Math.round(value * pixelRatio) / pixelRatio;
    }
    context.globalCompositeOperation = 'lighter';
    const sourceDataExtent = (0, _extentJs.createEmpty)();
    sources.forEach(function(src, i, arr) {
        (0, _extentJs.extend)(sourceDataExtent, src.extent);
    });
    let stitchContext;
    if (!drawSingle || sources.length !== 1 || gutter !== 0) {
        const canvasWidthInUnits = (0, _extentJs.getWidth)(sourceDataExtent);
        const canvasHeightInUnits = (0, _extentJs.getHeight)(sourceDataExtent);
        stitchContext = (0, _domJs.createCanvasContext2D)(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution), canvasPool);
        if (!interpolate) stitchContext.imageSmoothingEnabled = false;
        const stitchScale = pixelRatio / sourceResolution;
        sources.forEach(function(src, i, arr) {
            const xPos = src.extent[0] - sourceDataExtent[0];
            const yPos = -(src.extent[3] - sourceDataExtent[3]);
            const srcWidth = (0, _extentJs.getWidth)(src.extent);
            const srcHeight = (0, _extentJs.getHeight)(src.extent);
            // This test should never fail -- but it does. Need to find a fix the upstream condition
            if (src.image.width > 0 && src.image.height > 0) stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
        });
    }
    const targetTopLeft = (0, _extentJs.getTopLeft)(targetExtent);
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
        /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */ const source = triangle.source;
        const target = triangle.target;
        let x0 = source[0][0], y0 = source[0][1];
        let x1 = source[1][0], y1 = source[1][1];
        let x2 = source[2][0], y2 = source[2][1];
        // Make sure that everything is on pixel boundaries
        const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
        const v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
        const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
        const v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
        const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
        const v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
        // Shift all the source points to improve numerical stability
        // of all the subsequent calculations. The [x0, y0] is used here.
        // This is also used to simplify the linear system.
        const sourceNumericalShiftX = x0;
        const sourceNumericalShiftY = y0;
        x0 = 0;
        y0 = 0;
        x1 -= sourceNumericalShiftX;
        y1 -= sourceNumericalShiftY;
        x2 -= sourceNumericalShiftX;
        y2 -= sourceNumericalShiftY;
        const augmentedMatrix = [
            [
                x1,
                y1,
                0,
                0,
                u1 - u0
            ],
            [
                x2,
                y2,
                0,
                0,
                u2 - u0
            ],
            [
                0,
                0,
                x1,
                y1,
                v1 - v0
            ],
            [
                0,
                0,
                x2,
                y2,
                v2 - v0
            ]
        ];
        const affineCoefs = (0, _mathJs.solveLinearSystem)(augmentedMatrix);
        if (!affineCoefs) return;
        context.save();
        context.beginPath();
        if (isBrokenDiagonalRendering() || !interpolate) {
            // Make sure that all lines are horizontal or vertical
            context.moveTo(u1, v1);
            // This is the diagonal line. Do it in 4 steps
            const steps = 4;
            const ud = u0 - u1;
            const vd = v0 - v1;
            for(let step = 0; step < steps; step++){
                // Go horizontally
                context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1)));
                // Go vertically
                if (step != steps - 1) context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
            }
            // We are almost at u0r, v0r
            context.lineTo(u2, v2);
        } else {
            context.moveTo(u1, v1);
            context.lineTo(u0, v0);
            context.lineTo(u2, v2);
        }
        context.clip();
        context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
        context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
        let image;
        if (stitchContext) {
            image = stitchContext.canvas;
            context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
        } else {
            const source = sources[0];
            const extent = source.extent;
            image = source.image;
            context.scale((0, _extentJs.getWidth)(extent) / image.width, -(0, _extentJs.getHeight)(extent) / image.height);
        }
        context.drawImage(image, 0, 0);
        context.restore();
    });
    if (stitchContext) {
        (0, _domJs.releaseCanvas)(stitchContext);
        canvasPool.push(stitchContext.canvas);
    }
    if (renderEdges) {
        context.save();
        context.globalCompositeOperation = 'source-over';
        context.strokeStyle = 'black';
        context.lineWidth = 1;
        triangulation.getTriangles().forEach(function(triangle, i, arr) {
            const target = triangle.target;
            const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
            const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
            const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
            const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
            const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
            const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
            context.beginPath();
            context.moveTo(u1, v1);
            context.lineTo(u0, v0);
            context.lineTo(u2, v2);
            context.closePath();
            context.stroke();
        });
        context.restore();
    }
    return context.canvas;
}

},{"./extent.js":"bGUel","./dom.js":"h98kD","./proj.js":"8OK47","./math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gx7Pm":[function(require,module,exports,__globalThis) {
/**
 * @module ol/TileRange
 */ /**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange} [tileRange] TileRange.
 * @return {TileRange} Tile range.
 */ parcelHelpers.export(exports, "createOrUpdate", ()=>createOrUpdate);
class TileRange {
    /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */ constructor(minX, maxX, minY, maxY){
        /**
     * @type {number}
     */ this.minX = minX;
        /**
     * @type {number}
     */ this.maxX = maxX;
        /**
     * @type {number}
     */ this.minY = minY;
        /**
     * @type {number}
     */ this.maxY = maxY;
    }
    /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */ contains(tileCoord) {
        return this.containsXY(tileCoord[1], tileCoord[2]);
    }
    /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */ containsTileRange(tileRange) {
        return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
    }
    /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */ containsXY(x, y) {
        return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    }
    /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */ equals(tileRange) {
        return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
    }
    /**
   * @param {TileRange} tileRange Tile range.
   */ extend(tileRange) {
        if (tileRange.minX < this.minX) this.minX = tileRange.minX;
        if (tileRange.maxX > this.maxX) this.maxX = tileRange.maxX;
        if (tileRange.minY < this.minY) this.minY = tileRange.minY;
        if (tileRange.maxY > this.maxY) this.maxY = tileRange.maxY;
    }
    /**
   * @return {number} Height.
   */ getHeight() {
        return this.maxY - this.minY + 1;
    }
    /**
   * @return {import("./size.js").Size} Size.
   */ getSize() {
        return [
            this.getWidth(),
            this.getHeight()
        ];
    }
    /**
   * @return {number} Width.
   */ getWidth() {
        return this.maxX - this.minX + 1;
    }
    /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */ intersects(tileRange) {
        return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
    }
}
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
    if (tileRange !== undefined) {
        tileRange.minX = minX;
        tileRange.maxX = maxX;
        tileRange.minY = minY;
        tileRange.maxY = maxY;
        return tileRange;
    }
    return new TileRange(minX, maxX, minY, maxY);
}
exports.default = TileRange;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"90vGx":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/OSM
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ATTRIBUTION", ()=>ATTRIBUTION);
var _xyzJs = require("./XYZ.js");
var _xyzJsDefault = parcelHelpers.interopDefault(_xyzJs);
const ATTRIBUTION = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */ /**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */ class OSM extends (0, _xyzJsDefault.default) {
    /**
   * @param {Options} [options] Open Street Map options.
   */ constructor(options){
        options = options || {};
        let attributions;
        if (options.attributions !== undefined) attributions = options.attributions;
        else attributions = [
            ATTRIBUTION
        ];
        const crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
        const url = options.url !== undefined ? options.url : 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
        super({
            attributions: attributions,
            attributionsCollapsible: false,
            cacheSize: options.cacheSize,
            crossOrigin: crossOrigin,
            interpolate: options.interpolate,
            maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
            opaque: options.opaque !== undefined ? options.opaque : true,
            reprojectionErrorThreshold: options.reprojectionErrorThreshold,
            tileLoadFunction: options.tileLoadFunction,
            transition: options.transition,
            url: url,
            wrapX: options.wrapX,
            zDirection: options.zDirection
        });
    }
}
exports.default = OSM;

},{"./XYZ.js":"15CIn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"15CIn":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/XYZ
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileImageJs = require("./TileImage.js");
var _tileImageJsDefault = parcelHelpers.interopDefault(_tileImageJs);
var _tilegridJs = require("../tilegrid.js");
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Not used if `tileGrid` is provided.
 * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
 * This allows artifacts of rendering at tile edges to be ignored.
 * Supported images should be wider and taller than the tile size by a value of `2 x gutter`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if `url` or `urls` are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */ /**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case
 * a `tileUrlFunction` can be used, such as:
 * ```js
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
 *  }
 * ```
 * @api
 */ class XYZ extends (0, _tileImageJsDefault.default) {
    /**
   * @param {Options} [options] XYZ options.
   */ constructor(options){
        options = options || {};
        const projection = options.projection !== undefined ? options.projection : 'EPSG:3857';
        const tileGrid = options.tileGrid !== undefined ? options.tileGrid : (0, _tilegridJs.createXYZ)({
            extent: (0, _tilegridJs.extentFromProjection)(projection),
            maxResolution: options.maxResolution,
            maxZoom: options.maxZoom,
            minZoom: options.minZoom,
            tileSize: options.tileSize
        });
        super({
            attributions: options.attributions,
            cacheSize: options.cacheSize,
            crossOrigin: options.crossOrigin,
            interpolate: options.interpolate,
            opaque: options.opaque,
            projection: projection,
            reprojectionErrorThreshold: options.reprojectionErrorThreshold,
            tileGrid: tileGrid,
            tileLoadFunction: options.tileLoadFunction,
            tilePixelRatio: options.tilePixelRatio,
            tileUrlFunction: options.tileUrlFunction,
            url: options.url,
            urls: options.urls,
            wrapX: options.wrapX !== undefined ? options.wrapX : true,
            transition: options.transition,
            attributionsCollapsible: options.attributionsCollapsible,
            zDirection: options.zDirection
        });
        /**
     * @private
     * @type {number}
     */ this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
    }
    /**
   * @return {number} Gutter.
   */ getGutter() {
        return this.gutter_;
    }
}
exports.default = XYZ;

},{"./TileImage.js":"kLfUI","../tilegrid.js":"54iDu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kLfUI":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/TileImage
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageTileJs = require("../ImageTile.js");
var _imageTileJsDefault = parcelHelpers.interopDefault(_imageTileJs);
var _tileJs = require("../reproj/Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileCacheJs = require("../TileCache.js");
var _tileCacheJsDefault = parcelHelpers.interopDefault(_tileCacheJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _urlTileJs = require("./UrlTile.js");
var _urlTileJsDefault = parcelHelpers.interopDefault(_urlTileJs);
var _projJs = require("../proj.js");
var _tilecoordJs = require("../tilecoord.js");
var _tilegridJs = require("../tilegrid.js");
var _utilJs = require("../util.js");
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./Source.js").State} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */ /**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */ class TileImage extends (0, _urlTileJsDefault.default) {
    /**
   * @param {!Options} options Image tile options.
   */ constructor(options){
        super({
            attributions: options.attributions,
            cacheSize: options.cacheSize,
            opaque: options.opaque,
            projection: options.projection,
            state: options.state,
            tileGrid: options.tileGrid,
            tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
            tilePixelRatio: options.tilePixelRatio,
            tileUrlFunction: options.tileUrlFunction,
            url: options.url,
            urls: options.urls,
            wrapX: options.wrapX,
            transition: options.transition,
            interpolate: options.interpolate !== undefined ? options.interpolate : true,
            key: options.key,
            attributionsCollapsible: options.attributionsCollapsible,
            zDirection: options.zDirection
        });
        /**
     * @protected
     * @type {?string}
     */ this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
        /**
     * @protected
     * @type {typeof ImageTile}
     */ this.tileClass = options.tileClass !== undefined ? options.tileClass : (0, _imageTileJsDefault.default);
        /**
     * @protected
     * @type {!Object<string, TileCache>}
     */ this.tileCacheForProjection = {};
        /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */ this.tileGridForProjection = {};
        /**
     * @private
     * @type {number|undefined}
     */ this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
        /**
     * @private
     * @type {boolean}
     */ this.renderReprojectionEdges_ = false;
    }
    /**
   * @return {boolean} Can expire cache.
   */ canExpireCache() {
        if (this.tileCache.canExpireCache()) return true;
        for(const key in this.tileCacheForProjection){
            if (this.tileCacheForProjection[key].canExpireCache()) return true;
        }
        return false;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */ expireCache(projection, usedTiles) {
        const usedTileCache = this.getTileCacheForProjection(projection);
        this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
        for(const id in this.tileCacheForProjection){
            const tileCache = this.tileCacheForProjection[id];
            tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
        }
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */ getGutterForProjection(projection) {
        if (this.getProjection() && projection && !(0, _projJs.equivalent)(this.getProjection(), projection)) return 0;
        return this.getGutter();
    }
    /**
   * @return {number} Gutter.
   */ getGutter() {
        return 0;
    }
    /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */ getKey() {
        let key = super.getKey();
        if (!this.getInterpolate()) key += ':disable-interpolation';
        return key;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */ getOpaque(projection) {
        if (this.getProjection() && projection && !(0, _projJs.equivalent)(this.getProjection(), projection)) return false;
        return super.getOpaque(projection);
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */ getTileGridForProjection(projection) {
        const thisProj = this.getProjection();
        if (this.tileGrid && (!thisProj || (0, _projJs.equivalent)(thisProj, projection))) return this.tileGrid;
        const projKey = (0, _utilJs.getUid)(projection);
        if (!(projKey in this.tileGridForProjection)) this.tileGridForProjection[projKey] = (0, _tilegridJs.getForProjection)(projection);
        return this.tileGridForProjection[projKey];
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */ getTileCacheForProjection(projection) {
        const thisProj = this.getProjection();
        if (!thisProj || (0, _projJs.equivalent)(thisProj, projection)) return this.tileCache;
        const projKey = (0, _utilJs.getUid)(projection);
        if (!(projKey in this.tileCacheForProjection)) this.tileCacheForProjection[projKey] = new (0, _tileCacheJsDefault.default)(this.tileCache.highWaterMark);
        return this.tileCacheForProjection[projKey];
    }
    /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */ createTile_(z, x, y, pixelRatio, projection, key) {
        const tileCoord = [
            z,
            x,
            y
        ];
        const urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
        const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
        const tile = new this.tileClass(tileCoord, tileUrl !== undefined ? (0, _tileStateJsDefault.default).IDLE : (0, _tileStateJsDefault.default).EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
        tile.key = key;
        tile.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.handleTileChange.bind(this));
        return tile;
    }
    /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */ getTile(z, x, y, pixelRatio, projection) {
        const sourceProjection = this.getProjection();
        if (!sourceProjection || !projection || (0, _projJs.equivalent)(sourceProjection, projection)) return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
        const cache = this.getTileCacheForProjection(projection);
        const tileCoord = [
            z,
            x,
            y
        ];
        let tile;
        const tileCoordKey = (0, _tilecoordJs.getKey)(tileCoord);
        if (cache.containsKey(tileCoordKey)) tile = cache.get(tileCoordKey);
        const key = this.getKey();
        if (tile && tile.key == key) return tile;
        const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        const targetTileGrid = this.getTileGridForProjection(projection);
        const wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
        const newTile = new (0, _tileJsDefault.default)(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), (z, x, y, pixelRatio)=>this.getTileInternal(z, x, y, pixelRatio, sourceProjection), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.tileOptions);
        newTile.key = key;
        if (tile) {
            newTile.interimTile = tile;
            newTile.refreshInterimChain();
            cache.replace(tileCoordKey, newTile);
        } else cache.set(tileCoordKey, newTile);
        return newTile;
    }
    /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */ getTileInternal(z, x, y, pixelRatio, projection) {
        let tile = null;
        const tileCoordKey = (0, _tilecoordJs.getKeyZXY)(z, x, y);
        const key = this.getKey();
        if (!this.tileCache.containsKey(tileCoordKey)) {
            tile = this.createTile_(z, x, y, pixelRatio, projection, key);
            this.tileCache.set(tileCoordKey, tile);
        } else {
            tile = this.tileCache.get(tileCoordKey);
            if (tile.key != key) {
                // The source's params changed. If the tile has an interim tile and if we
                // can use it then we use it. Otherwise we create a new tile.  In both
                // cases we attempt to assign an interim tile to the new tile.
                const interimTile = tile;
                tile = this.createTile_(z, x, y, pixelRatio, projection, key);
                //make the new tile the head of the list,
                if (interimTile.getState() == (0, _tileStateJsDefault.default).IDLE) //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
                tile.interimTile = interimTile.interimTile;
                else tile.interimTile = interimTile;
                tile.refreshInterimChain();
                this.tileCache.replace(tileCoordKey, tile);
            }
        }
        return tile;
    }
    /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */ setRenderReprojectionEdges(render) {
        if (this.renderReprojectionEdges_ == render) return;
        this.renderReprojectionEdges_ = render;
        for(const id in this.tileCacheForProjection)this.tileCacheForProjection[id].clear();
        this.changed();
    }
    /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */ setTileGridForProjection(projection, tilegrid) {
        const proj = (0, _projJs.get)(projection);
        if (proj) {
            const projKey = (0, _utilJs.getUid)(proj);
            if (!(projKey in this.tileGridForProjection)) this.tileGridForProjection[projKey] = tilegrid;
        }
    }
    clear() {
        super.clear();
        for(const id in this.tileCacheForProjection)this.tileCacheForProjection[id].clear();
    }
}
/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */ function defaultTileLoadFunction(imageTile, src) {
    /** @type {HTMLImageElement|HTMLVideoElement} */ imageTile.getImage().src = src;
}
exports.default = TileImage;

},{"../events/EventType.js":"3uT2C","../ImageTile.js":"3IBrO","../reproj/Tile.js":"dqATW","../TileCache.js":"fcMW2","../TileState.js":"2J5J5","./UrlTile.js":"lVoU8","../proj.js":"8OK47","../tilecoord.js":"ksONy","../tilegrid.js":"54iDu","../util.js":"l1iPW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fcMW2":[function(require,module,exports,__globalThis) {
/**
 * @module ol/TileCache
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lrucacheJs = require("./structs/LRUCache.js");
var _lrucacheJsDefault = parcelHelpers.interopDefault(_lrucacheJs);
var _tilecoordJs = require("./tilecoord.js");
class TileCache extends (0, _lrucacheJsDefault.default) {
    clear() {
        while(this.getCount() > 0)this.pop().release();
        super.clear();
    }
    /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */ expireCache(usedTiles) {
        while(this.canExpireCache()){
            const tile = this.peekLast();
            if (tile.getKey() in usedTiles) break;
            else this.pop().release();
        }
    }
    /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */ pruneExceptNewestZ() {
        if (this.getCount() === 0) return;
        const key = this.peekFirstKey();
        const tileCoord = (0, _tilecoordJs.fromKey)(key);
        const z = tileCoord[0];
        this.forEach((tile)=>{
            if (tile.tileCoord[0] !== z) {
                this.remove((0, _tilecoordJs.getKey)(tile.tileCoord));
                tile.release();
            }
        });
    }
}
exports.default = TileCache;

},{"./structs/LRUCache.js":"cdXrp","./tilecoord.js":"ksONy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cdXrp":[function(require,module,exports,__globalThis) {
/**
 * @module ol/structs/LRUCache
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assertsJs = require("../asserts.js");
/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Entry|null} newer Newer.
 * @property {Entry|null} older Older.
 * @property {*} value_ Value.
 */ /**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */ class LRUCache {
    /**
   * @param {number} [highWaterMark] High water mark.
   */ constructor(highWaterMark){
        /**
     * Desired max cache size after expireCache(). If set to 0, no cache entries
     * will be pruned at all.
     * @type {number}
     */ this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;
        /**
     * @private
     * @type {number}
     */ this.count_ = 0;
        /**
     * @private
     * @type {!Object<string, Entry>}
     */ this.entries_ = {};
        /**
     * @private
     * @type {?Entry}
     */ this.oldest_ = null;
        /**
     * @private
     * @type {?Entry}
     */ this.newest_ = null;
    }
    /**
   * @return {boolean} Can expire cache.
   */ canExpireCache() {
        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    }
    /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */ expireCache(keep) {
        while(this.canExpireCache())this.pop();
    }
    /**
   * FIXME empty description for jsdoc
   */ clear() {
        this.count_ = 0;
        this.entries_ = {};
        this.oldest_ = null;
        this.newest_ = null;
    }
    /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */ containsKey(key) {
        return this.entries_.hasOwnProperty(key);
    }
    /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */ forEach(f) {
        let entry = this.oldest_;
        while(entry){
            f(entry.value_, entry.key_, this);
            entry = entry.newer;
        }
    }
    /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */ get(key, options) {
        const entry = this.entries_[key];
        (0, _assertsJs.assert)(entry !== undefined, 'Tried to get a value for a key that does not exist in the cache');
        if (entry === this.newest_) return entry.value_;
        if (entry === this.oldest_) {
            this.oldest_ = /** @type {Entry} */ this.oldest_.newer;
            this.oldest_.older = null;
        } else {
            entry.newer.older = entry.older;
            entry.older.newer = entry.newer;
        }
        entry.newer = null;
        entry.older = this.newest_;
        this.newest_.newer = entry;
        this.newest_ = entry;
        return entry.value_;
    }
    /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */ remove(key) {
        const entry = this.entries_[key];
        (0, _assertsJs.assert)(entry !== undefined, 'Tried to get a value for a key that does not exist in the cache');
        if (entry === this.newest_) {
            this.newest_ = /** @type {Entry} */ entry.older;
            if (this.newest_) this.newest_.newer = null;
        } else if (entry === this.oldest_) {
            this.oldest_ = /** @type {Entry} */ entry.newer;
            if (this.oldest_) this.oldest_.older = null;
        } else {
            entry.newer.older = entry.older;
            entry.older.newer = entry.newer;
        }
        delete this.entries_[key];
        --this.count_;
        return entry.value_;
    }
    /**
   * @return {number} Count.
   */ getCount() {
        return this.count_;
    }
    /**
   * @return {Array<string>} Keys.
   */ getKeys() {
        const keys = new Array(this.count_);
        let i = 0;
        let entry;
        for(entry = this.newest_; entry; entry = entry.older)keys[i++] = entry.key_;
        return keys;
    }
    /**
   * @return {Array<T>} Values.
   */ getValues() {
        const values = new Array(this.count_);
        let i = 0;
        let entry;
        for(entry = this.newest_; entry; entry = entry.older)values[i++] = entry.value_;
        return values;
    }
    /**
   * @return {T} Last value.
   */ peekLast() {
        return this.oldest_.value_;
    }
    /**
   * @return {string} Last key.
   */ peekLastKey() {
        return this.oldest_.key_;
    }
    /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */ peekFirstKey() {
        return this.newest_.key_;
    }
    /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */ peek(key) {
        return this.entries_[key]?.value_;
    }
    /**
   * @return {T} value Value.
   */ pop() {
        const entry = this.oldest_;
        delete this.entries_[entry.key_];
        if (entry.newer) entry.newer.older = null;
        this.oldest_ = /** @type {Entry} */ entry.newer;
        if (!this.oldest_) this.newest_ = null;
        --this.count_;
        return entry.value_;
    }
    /**
   * @param {string} key Key.
   * @param {T} value Value.
   */ replace(key, value) {
        this.get(key); // update `newest_`
        this.entries_[key].value_ = value;
    }
    /**
   * @param {string} key Key.
   * @param {T} value Value.
   */ set(key, value) {
        (0, _assertsJs.assert)(!(key in this.entries_), 'Tried to set a value for a key that is used already');
        const entry = {
            key_: key,
            newer: null,
            older: this.newest_,
            value_: value
        };
        if (!this.newest_) this.oldest_ = entry;
        else this.newest_.newer = entry;
        this.newest_ = entry;
        this.entries_[key] = entry;
        ++this.count_;
    }
    /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */ setSize(size) {
        this.highWaterMark = size;
    }
}
exports.default = LRUCache;

},{"../asserts.js":"k0OL6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ksONy":[function(require,module,exports,__globalThis) {
/**
 * @module ol/tilecoord
 */ /**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */ /**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createOrUpdate", ()=>createOrUpdate);
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */ parcelHelpers.export(exports, "getKeyZXY", ()=>getKeyZXY);
/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */ parcelHelpers.export(exports, "getKey", ()=>getKey);
/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */ parcelHelpers.export(exports, "getCacheKeyForTileKey", ()=>getCacheKeyForTileKey);
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */ parcelHelpers.export(exports, "fromKey", ()=>fromKey);
/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */ parcelHelpers.export(exports, "hash", ()=>hash);
/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */ parcelHelpers.export(exports, "withinExtentAndZ", ()=>withinExtentAndZ);
function createOrUpdate(z, x, y, tileCoord) {
    if (tileCoord !== undefined) {
        tileCoord[0] = z;
        tileCoord[1] = x;
        tileCoord[2] = y;
        return tileCoord;
    }
    return [
        z,
        x,
        y
    ];
}
function getKeyZXY(z, x, y) {
    return z + '/' + x + '/' + y;
}
function getKey(tileCoord) {
    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function getCacheKeyForTileKey(tileKey) {
    const [z, x, y] = tileKey.substring(tileKey.lastIndexOf('/') + 1, tileKey.length).split(',').map(Number);
    return getKeyZXY(z, x, y);
}
function fromKey(key) {
    return key.split('/').map(Number);
}
function hash(tileCoord) {
    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
function withinExtentAndZ(tileCoord, tileGrid) {
    const z = tileCoord[0];
    const x = tileCoord[1];
    const y = tileCoord[2];
    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) return false;
    const tileRange = tileGrid.getFullTileRange(z);
    if (!tileRange) return true;
    return tileRange.containsXY(x, y);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lVoU8":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/UrlTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileEventTypeJs = require("./TileEventType.js");
var _tileEventTypeJsDefault = parcelHelpers.interopDefault(_tileEventTypeJs);
var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _tileurlfunctionJs = require("../tileurlfunction.js");
var _tilecoordJs = require("../tilecoord.js");
var _utilJs = require("../util.js");
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Cache size.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] TileUrlFunction.
 * @property {string} [url] Url.
 * @property {Array<string>} [urls] Urls.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */ /**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */ class UrlTile extends (0, _tileJsDefault.default) {
    /**
   * @param {Options} options Image tile options.
   */ constructor(options){
        super({
            attributions: options.attributions,
            cacheSize: options.cacheSize,
            opaque: options.opaque,
            projection: options.projection,
            state: options.state,
            tileGrid: options.tileGrid,
            tilePixelRatio: options.tilePixelRatio,
            wrapX: options.wrapX,
            transition: options.transition,
            interpolate: options.interpolate,
            key: options.key,
            attributionsCollapsible: options.attributionsCollapsible,
            zDirection: options.zDirection
        });
        /**
     * @private
     * @type {boolean}
     */ this.generateTileUrlFunction_ = this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
        /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */ this.tileLoadFunction = options.tileLoadFunction;
        if (options.tileUrlFunction) this.tileUrlFunction = options.tileUrlFunction;
        /**
     * @protected
     * @type {!Array<string>|null}
     */ this.urls = null;
        if (options.urls) this.setUrls(options.urls);
        else if (options.url) this.setUrl(options.url);
        /**
     * @private
     * @type {!Object<string, boolean>}
     */ this.tileLoadingKeys_ = {};
    }
    /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */ getTileLoadFunction() {
        return this.tileLoadFunction;
    }
    /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */ getTileUrlFunction() {
        return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
    }
    /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */ getUrls() {
        return this.urls;
    }
    /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */ handleTileChange(event) {
        const tile = /** @type {import("../Tile.js").default} */ event.target;
        const uid = (0, _utilJs.getUid)(tile);
        const tileState = tile.getState();
        let type;
        if (tileState == (0, _tileStateJsDefault.default).LOADING) {
            this.tileLoadingKeys_[uid] = true;
            type = (0, _tileEventTypeJsDefault.default).TILELOADSTART;
        } else if (uid in this.tileLoadingKeys_) {
            delete this.tileLoadingKeys_[uid];
            type = tileState == (0, _tileStateJsDefault.default).ERROR ? (0, _tileEventTypeJsDefault.default).TILELOADERROR : tileState == (0, _tileStateJsDefault.default).LOADED ? (0, _tileEventTypeJsDefault.default).TILELOADEND : undefined;
        }
        if (type != undefined) this.dispatchEvent(new (0, _tileJs.TileSourceEvent)(type, tile));
    }
    /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */ setTileLoadFunction(tileLoadFunction) {
        this.tileCache.clear();
        this.tileLoadFunction = tileLoadFunction;
        this.changed();
    }
    /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */ setTileUrlFunction(tileUrlFunction, key) {
        this.tileUrlFunction = tileUrlFunction;
        this.tileCache.pruneExceptNewestZ();
        if (typeof key !== 'undefined') this.setKey(key);
        else this.changed();
    }
    /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */ setUrl(url) {
        const urls = (0, _tileurlfunctionJs.expandUrl)(url);
        this.urls = urls;
        this.setUrls(urls);
    }
    /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */ setUrls(urls) {
        this.urls = urls;
        const key = urls.join('\n');
        if (this.generateTileUrlFunction_) this.setTileUrlFunction((0, _tileurlfunctionJs.createFromTemplates)(urls, this.tileGrid), key);
        else this.setKey(key);
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */ tileUrlFunction(tileCoord, pixelRatio, projection) {
        return undefined;
    }
    /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */ useTile(z, x, y) {
        const tileCoordKey = (0, _tilecoordJs.getKeyZXY)(z, x, y);
        if (this.tileCache.containsKey(tileCoordKey)) this.tileCache.get(tileCoordKey);
    }
}
exports.default = UrlTile;

},{"./TileEventType.js":"g6wnu","./Tile.js":"cjQw9","../TileState.js":"2J5J5","../tileurlfunction.js":"7hwWE","../tilecoord.js":"ksONy","../util.js":"l1iPW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g6wnu":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/TileEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */ TILELOADSTART: 'tileloadstart',
    /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */ TILELOADEND: 'tileloadend',
    /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */ TILELOADERROR: 'tileloaderror'
}; /**
 * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cjQw9":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/Tile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */ parcelHelpers.export(exports, "TileSourceEvent", ()=>TileSourceEvent);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _sourceJs = require("./Source.js");
var _sourceJsDefault = parcelHelpers.interopDefault(_sourceJs);
var _tileCacheJs = require("../TileCache.js");
var _tileCacheJsDefault = parcelHelpers.interopDefault(_tileCacheJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _utilJs = require("../util.js");
var _assertsJs = require("../asserts.js");
var _projJs = require("../proj.js");
var _tilecoordJs = require("../tilecoord.js");
var _tilegridJs = require("../tilegrid.js");
var _sizeJs = require("../size.js");
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] CacheSize.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./Source.js").State} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */ class TileSource extends (0, _sourceJsDefault.default) {
    /**
   * @param {Options} options SourceTile source options.
   */ constructor(options){
        super({
            attributions: options.attributions,
            attributionsCollapsible: options.attributionsCollapsible,
            projection: options.projection,
            state: options.state,
            wrapX: options.wrapX,
            interpolate: options.interpolate
        });
        /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {TileSourceOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {TileSourceOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {boolean}
     */ this.opaque_ = options.opaque !== undefined ? options.opaque : false;
        /**
     * @private
     * @type {number}
     */ this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
        /**
     * @type {import("../tilegrid/TileGrid.js").default|null}
     */ this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
        const tileSize = [
            256,
            256
        ];
        if (this.tileGrid) (0, _sizeJs.toSize)(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
        /**
     * @protected
     * @type {import("../TileCache.js").default}
     */ this.tileCache = new (0, _tileCacheJsDefault.default)(options.cacheSize || 0);
        /**
     * @protected
     * @type {import("../size.js").Size}
     */ this.tmpSize = [
            0,
            0
        ];
        /**
     * @private
     * @type {string}
     */ this.key_ = options.key || '';
        /**
     * @protected
     * @type {import("../Tile.js").Options}
     */ this.tileOptions = {
            transition: options.transition,
            interpolate: options.interpolate
        };
        /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number|import("../array.js").NearestDirectionFunction}
     */ this.zDirection = options.zDirection ? options.zDirection : 0;
    }
    /**
   * @return {boolean} Can expire cache.
   */ canExpireCache() {
        return this.tileCache.canExpireCache();
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */ expireCache(projection, usedTiles) {
        const tileCache = this.getTileCacheForProjection(projection);
        if (tileCache) tileCache.expireCache(usedTiles);
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */ forEachLoadedTile(projection, z, tileRange, callback) {
        const tileCache = this.getTileCacheForProjection(projection);
        if (!tileCache) return false;
        let covered = true;
        let tile, tileCoordKey, loaded;
        for(let x = tileRange.minX; x <= tileRange.maxX; ++x)for(let y = tileRange.minY; y <= tileRange.maxY; ++y){
            tileCoordKey = (0, _tilecoordJs.getKeyZXY)(z, x, y);
            loaded = false;
            if (tileCache.containsKey(tileCoordKey)) {
                tile = /** @type {!import("../Tile.js").default} */ tileCache.get(tileCoordKey);
                loaded = tile.getState() === (0, _tileStateJsDefault.default).LOADED;
                if (loaded) loaded = callback(tile) !== false;
            }
            if (!loaded) covered = false;
        }
        return covered;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */ getGutterForProjection(projection) {
        return 0;
    }
    /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */ getKey() {
        return this.key_;
    }
    /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */ setKey(key) {
        if (this.key_ !== key) {
            this.key_ = key;
            this.changed();
        }
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */ getOpaque(projection) {
        return this.opaque_;
    }
    /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */ getResolutions(projection) {
        const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
        if (!tileGrid) return null;
        return tileGrid.getResolutions();
    }
    /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */ getTile(z, x, y, pixelRatio, projection) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */ getTileGrid() {
        return this.tileGrid;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */ getTileGridForProjection(projection) {
        if (!this.tileGrid) return (0, _tilegridJs.getForProjection)(projection);
        return this.tileGrid;
    }
    /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */ getTileCacheForProjection(projection) {
        const sourceProjection = this.getProjection();
        (0, _assertsJs.assert)(sourceProjection === null || (0, _projJs.equivalent)(sourceProjection, projection), 'A VectorTile source can only be rendered if it has a projection compatible with the view projection.');
        return this.tileCache;
    }
    /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */ getTilePixelRatio(pixelRatio) {
        return this.tilePixelRatio_;
    }
    /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */ getTilePixelSize(z, pixelRatio, projection) {
        const tileGrid = this.getTileGridForProjection(projection);
        const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
        const tileSize = (0, _sizeJs.toSize)(tileGrid.getTileSize(z), this.tmpSize);
        if (tilePixelRatio == 1) return tileSize;
        return (0, _sizeJs.scale)(tileSize, tilePixelRatio, this.tmpSize);
    }
    /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */ getTileCoordForTileUrlFunction(tileCoord, projection) {
        projection = projection !== undefined ? projection : this.getProjection();
        const tileGrid = this.getTileGridForProjection(projection);
        if (this.getWrapX() && projection.isGlobal()) tileCoord = (0, _tilegridJs.wrapX)(tileGrid, tileCoord, projection);
        return (0, _tilecoordJs.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
    }
    /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */ clear() {
        this.tileCache.clear();
    }
    refresh() {
        this.clear();
        super.refresh();
    }
    /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */ updateCacheSize(tileCount, projection) {
        const tileCache = this.getTileCacheForProjection(projection);
        if (tileCount > tileCache.highWaterMark) tileCache.highWaterMark = tileCount;
    }
    /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */ useTile(z, x, y, projection) {}
}
class TileSourceEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */ constructor(type, tile){
        super(type);
        /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */ this.tile = tile;
    }
}
exports.default = TileSource;

},{"../events/Event.js":"kooRA","./Source.js":"bjb1h","../TileCache.js":"fcMW2","../TileState.js":"2J5J5","../util.js":"l1iPW","../asserts.js":"k0OL6","../proj.js":"8OK47","../tilecoord.js":"ksONy","../tilegrid.js":"54iDu","../size.js":"fXEON","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bjb1h":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/Source
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _projJs = require("../proj.js");
/**
 * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */ /**
 * A function that takes a {@link import("../View.js").ViewStateLayerStateExtent} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../View.js").ViewStateLayerStateExtent): (string|Array<string>)} Attribution
 */ /**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */ /**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./Source.js").State} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */ class Source extends (0, _objectJsDefault.default) {
    /**
   * @param {Options} options Source options.
   */ constructor(options){
        super();
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|null}
     */ this.projection = (0, _projJs.get)(options.projection);
        /**
     * @private
     * @type {?Attribution}
     */ this.attributions_ = adaptAttributions(options.attributions);
        /**
     * @private
     * @type {boolean}
     */ this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;
        /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */ this.loading = false;
        /**
     * @private
     * @type {import("./Source.js").State}
     */ this.state_ = options.state !== undefined ? options.state : 'ready';
        /**
     * @private
     * @type {boolean}
     */ this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
        /**
     * @private
     * @type {boolean}
     */ this.interpolate_ = !!options.interpolate;
        /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */ this.viewResolver = null;
        /**
     * @protected
     * @type {function(Error):void}
     */ this.viewRejector = null;
        const self = this;
        /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */ this.viewPromise_ = new Promise(function(resolve, reject) {
            self.viewResolver = resolve;
            self.viewRejector = reject;
        });
    }
    /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */ getAttributions() {
        return this.attributions_;
    }
    /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */ getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
    }
    /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */ getProjection() {
        return this.projection;
    }
    /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */ getResolutions(projection) {
        return null;
    }
    /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */ getView() {
        return this.viewPromise_;
    }
    /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */ getState() {
        return this.state_;
    }
    /**
   * @return {boolean|undefined} Wrap X.
   */ getWrapX() {
        return this.wrapX_;
    }
    /**
   * @return {boolean} Use linear interpolation when resampling.
   */ getInterpolate() {
        return this.interpolate_;
    }
    /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */ refresh() {
        this.changed();
    }
    /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */ setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
    }
    /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */ setState(state) {
        this.state_ = state;
        this.changed();
    }
}
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */ function adaptAttributions(attributionLike) {
    if (!attributionLike) return null;
    if (Array.isArray(attributionLike)) return function(frameState) {
        return attributionLike;
    };
    if (typeof attributionLike === 'function') return attributionLike;
    return function(frameState) {
        return [
            attributionLike
        ];
    };
}
exports.default = Source;

},{"../Object.js":"N6yIf","../proj.js":"8OK47","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"54iDu":[function(require,module,exports,__globalThis) {
/**
 * @module ol/tilegrid
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WMTS", ()=>(0, _wmtsJsDefault.default));
parcelHelpers.export(exports, "TileGrid", ()=>(0, _tileGridJsDefault.default));
/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */ parcelHelpers.export(exports, "getForProjection", ()=>getForProjection);
/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX);
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */ parcelHelpers.export(exports, "createForExtent", ()=>createForExtent);
/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */ /**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */ parcelHelpers.export(exports, "createXYZ", ()=>createXYZ);
/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */ parcelHelpers.export(exports, "createForProjection", ()=>createForProjection);
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */ parcelHelpers.export(exports, "extentFromProjection", ()=>extentFromProjection);
var _tileGridJs = require("./tilegrid/TileGrid.js");
var _tileGridJsDefault = parcelHelpers.interopDefault(_tileGridJs);
var _commonJs = require("./tilegrid/common.js");
var _projJs = require("./proj.js");
var _extentJs = require("./extent.js");
var _sizeJs = require("./size.js");
var _wmtsJs = require("./tilegrid/WMTS.js");
var _wmtsJsDefault = parcelHelpers.interopDefault(_wmtsJs);
function getForProjection(projection) {
    let tileGrid = projection.getDefaultTileGrid();
    if (!tileGrid) {
        tileGrid = createForProjection(projection);
        projection.setDefaultTileGrid(tileGrid);
    }
    return tileGrid;
}
function wrapX(tileGrid, tileCoord, projection) {
    const z = tileCoord[0];
    const center = tileGrid.getTileCoordCenter(tileCoord);
    const projectionExtent = extentFromProjection(projection);
    if (!(0, _extentJs.containsCoordinate)(projectionExtent, center)) {
        const worldWidth = (0, _extentJs.getWidth)(projectionExtent);
        const worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
        center[0] += worldWidth * worldsAway;
        return tileGrid.getTileCoordForCoordAndZ(center, z);
    }
    return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
    corner = corner !== undefined ? corner : 'top-left';
    const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
    return new (0, _tileGridJsDefault.default)({
        extent: extent,
        origin: (0, _extentJs.getCorner)(extent, corner),
        resolutions: resolutions,
        tileSize: tileSize
    });
}
function createXYZ(options) {
    const xyzOptions = options || {};
    const extent = xyzOptions.extent || (0, _projJs.get)('EPSG:3857').getExtent();
    const gridOptions = {
        extent: extent,
        minZoom: xyzOptions.minZoom,
        tileSize: xyzOptions.tileSize,
        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
    };
    return new (0, _tileGridJsDefault.default)(gridOptions);
}
/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number} [maxResolution] Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */ function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
    maxZoom = maxZoom !== undefined ? maxZoom : (0, _commonJs.DEFAULT_MAX_ZOOM);
    tileSize = (0, _sizeJs.toSize)(tileSize !== undefined ? tileSize : (0, _commonJs.DEFAULT_TILE_SIZE));
    const height = (0, _extentJs.getHeight)(extent);
    const width = (0, _extentJs.getWidth)(extent);
    maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
    const length = maxZoom + 1;
    const resolutions = new Array(length);
    for(let z = 0; z < length; ++z)resolutions[z] = maxResolution / Math.pow(2, z);
    return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
    const extent = extentFromProjection(projection);
    return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
    projection = (0, _projJs.get)(projection);
    let extent = projection.getExtent();
    if (!extent) {
        const half = 180 * (0, _projJs.METERS_PER_UNIT).degrees / projection.getMetersPerUnit();
        extent = (0, _extentJs.createOrUpdate)(-half, -half, half, half);
    }
    return extent;
}

},{"./tilegrid/TileGrid.js":"1y9y0","./tilegrid/common.js":"bQNAJ","./proj.js":"8OK47","./extent.js":"bGUel","./size.js":"fXEON","./tilegrid/WMTS.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1y9y0":[function(require,module,exports,__globalThis) {
/**
 * @module ol/tilegrid/TileGrid
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileRangeJs = require("../TileRange.js");
var _tileRangeJsDefault = parcelHelpers.interopDefault(_tileRangeJs);
var _commonJs = require("./common.js");
var _assertsJs = require("../asserts.js");
var _mathJs = require("../math.js");
var _extentJs = require("../extent.js");
var _tilecoordJs = require("../tilecoord.js");
var _intersectsextentJs = require("../geom/flat/intersectsextent.js");
var _arrayJs = require("../array.js");
var _sizeJs = require("../size.js");
/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */ const tmpTileCoord = [
    0,
    0,
    0
];
/**
 * Number of decimal digits to consider in integer values when rounding.
 * @type {number}
 */ const DECIMALS = 5;
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */ /**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */ class TileGrid {
    /**
   * @param {Options} options Tile grid options.
   */ constructor(options){
        /**
     * @protected
     * @type {number}
     */ this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
        /**
     * @private
     * @type {!Array<number>}
     */ this.resolutions_ = options.resolutions;
        (0, _assertsJs.assert)((0, _arrayJs.isSorted)(this.resolutions_, /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */ (a, b)=>b - a, true), '`resolutions` must be sorted in descending order');
        // check if we've got a consistent zoom factor and origin
        let zoomFactor;
        if (!options.origins) for(let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i){
            if (!zoomFactor) zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
            else if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
                zoomFactor = undefined;
                break;
            }
        }
        /**
     * @private
     * @type {number|undefined}
     */ this.zoomFactor_ = zoomFactor;
        /**
     * @protected
     * @type {number}
     */ this.maxZoom = this.resolutions_.length - 1;
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */ this.origin_ = options.origin !== undefined ? options.origin : null;
        /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */ this.origins_ = null;
        if (options.origins !== undefined) {
            this.origins_ = options.origins;
            (0, _assertsJs.assert)(this.origins_.length == this.resolutions_.length, 'Number of `origins` and `resolutions` must be equal');
        }
        const extent = options.extent;
        if (extent !== undefined && !this.origin_ && !this.origins_) this.origin_ = (0, _extentJs.getTopLeft)(extent);
        (0, _assertsJs.assert)(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 'Either `origin` or `origins` must be configured, never both');
        /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */ this.tileSizes_ = null;
        if (options.tileSizes !== undefined) {
            this.tileSizes_ = options.tileSizes;
            (0, _assertsJs.assert)(this.tileSizes_.length == this.resolutions_.length, 'Number of `tileSizes` and `resolutions` must be equal');
        }
        /**
     * @private
     * @type {number|import("../size.js").Size}
     */ this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? (0, _commonJs.DEFAULT_TILE_SIZE) : null;
        (0, _assertsJs.assert)(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 'Either `tileSize` or `tileSizes` must be configured, never both');
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.extent_ = extent !== undefined ? extent : null;
        /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */ this.fullTileRanges_ = null;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.tmpSize_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.tmpExtent_ = [
            0,
            0,
            0,
            0
        ];
        if (options.sizes !== undefined) this.fullTileRanges_ = options.sizes.map((size, z)=>{
            const tileRange = new (0, _tileRangeJsDefault.default)(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
            if (extent) {
                const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
                tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
                tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
                tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
                tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
            }
            return tileRange;
        });
        else if (extent) this.calculateTileRanges_(extent);
    }
    /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */ forEachTileCoord(extent, zoom, callback) {
        const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
        for(let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i)for(let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j)callback([
            zoom,
            i,
            j
        ]);
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */ forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
        let tileRange, x, y;
        let tileCoordExtent = null;
        let z = tileCoord[0] - 1;
        if (this.zoomFactor_ === 2) {
            x = tileCoord[1];
            y = tileCoord[2];
        } else tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
        while(z >= this.minZoom){
            if (x !== undefined && y !== undefined) {
                x = Math.floor(x / 2);
                y = Math.floor(y / 2);
                tileRange = (0, _tileRangeJs.createOrUpdate)(x, x, y, y, tempTileRange);
            } else tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
            if (callback(z, tileRange)) return true;
            --z;
        }
        return false;
    }
    /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent() {
        return this.extent_;
    }
    /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */ getMaxZoom() {
        return this.maxZoom;
    }
    /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */ getMinZoom() {
        return this.minZoom;
    }
    /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */ getOrigin(z) {
        if (this.origin_) return this.origin_;
        return this.origins_[z];
    }
    /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */ getResolution(z) {
        return this.resolutions_[z];
    }
    /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */ getResolutions() {
        return this.resolutions_;
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */ getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
        if (tileCoord[0] < this.maxZoom) {
            if (this.zoomFactor_ === 2) {
                const minX = tileCoord[1] * 2;
                const minY = tileCoord[2] * 2;
                return (0, _tileRangeJs.createOrUpdate)(minX, minX + 1, minY, minY + 1, tempTileRange);
            }
            const tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent || this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, tempTileRange);
        }
        return null;
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */ getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
        if (z > this.maxZoom || z < this.minZoom) return null;
        const tileCoordZ = tileCoord[0];
        const tileCoordX = tileCoord[1];
        const tileCoordY = tileCoord[2];
        if (z === tileCoordZ) return (0, _tileRangeJs.createOrUpdate)(tileCoordX, tileCoordY, tileCoordX, tileCoordY, tempTileRange);
        if (this.zoomFactor_) {
            const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
            const minX = Math.floor(tileCoordX * factor);
            const minY = Math.floor(tileCoordY * factor);
            if (z < tileCoordZ) return (0, _tileRangeJs.createOrUpdate)(minX, minX, minY, minY, tempTileRange);
            const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
            const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
            return (0, _tileRangeJs.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
        }
        const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
    }
    /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */ getTileRangeForExtentAndZ(extent, z, tempTileRange) {
        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
        const minX = tmpTileCoord[1];
        const minY = tmpTileCoord[2];
        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
        const maxX = tmpTileCoord[1];
        const maxY = tmpTileCoord[2];
        return (0, _tileRangeJs.createOrUpdate)(minX, maxX, minY, maxY, tempTileRange);
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */ getTileCoordCenter(tileCoord) {
        const origin = this.getOrigin(tileCoord[0]);
        const resolution = this.getResolution(tileCoord[0]);
        const tileSize = (0, _sizeJs.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
        return [
            origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
            origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
        ];
    }
    /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getTileCoordExtent(tileCoord, tempExtent) {
        const origin = this.getOrigin(tileCoord[0]);
        const resolution = this.getResolution(tileCoord[0]);
        const tileSize = (0, _sizeJs.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
        const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
        const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
        const maxX = minX + tileSize[0] * resolution;
        const maxY = minY + tileSize[1] * resolution;
        return (0, _extentJs.createOrUpdate)(minX, minY, maxX, maxY, tempExtent);
    }
    /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */ getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
    }
    /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */ getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
        const z = this.getZForResolution(resolution);
        const scale = resolution / this.getResolution(z);
        const origin = this.getOrigin(z);
        const tileSize = (0, _sizeJs.toSize)(this.getTileSize(z), this.tmpSize_);
        let tileCoordX = scale * (x - origin[0]) / resolution / tileSize[0];
        let tileCoordY = scale * (origin[1] - y) / resolution / tileSize[1];
        if (reverseIntersectionPolicy) {
            tileCoordX = (0, _mathJs.ceil)(tileCoordX, DECIMALS) - 1;
            tileCoordY = (0, _mathJs.ceil)(tileCoordY, DECIMALS) - 1;
        } else {
            tileCoordX = (0, _mathJs.floor)(tileCoordX, DECIMALS);
            tileCoordY = (0, _mathJs.floor)(tileCoordY, DECIMALS);
        }
        return (0, _tilecoordJs.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
    }
    /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */ getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
        const origin = this.getOrigin(z);
        const resolution = this.getResolution(z);
        const tileSize = (0, _sizeJs.toSize)(this.getTileSize(z), this.tmpSize_);
        let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
        let tileCoordY = (origin[1] - y) / resolution / tileSize[1];
        if (reverseIntersectionPolicy) {
            tileCoordX = (0, _mathJs.ceil)(tileCoordX, DECIMALS) - 1;
            tileCoordY = (0, _mathJs.ceil)(tileCoordY, DECIMALS) - 1;
        } else {
            tileCoordX = (0, _mathJs.floor)(tileCoordX, DECIMALS);
            tileCoordY = (0, _mathJs.floor)(tileCoordY, DECIMALS);
        }
        return (0, _tilecoordJs.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
    }
    /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */ getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */ getTileCoordResolution(tileCoord) {
        return this.resolutions_[tileCoord[0]];
    }
    /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */ getTileSize(z) {
        if (this.tileSize_) return this.tileSize_;
        return this.tileSizes_[z];
    }
    /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */ getFullTileRange(z) {
        if (!this.fullTileRanges_) return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
        return this.fullTileRanges_[z];
    }
    /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */ getZForResolution(resolution, opt_direction) {
        const z = (0, _arrayJs.linearFindNearest)(this.resolutions_, resolution, opt_direction || 0);
        return (0, _mathJs.clamp)(z, this.minZoom, this.maxZoom);
    }
    /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */ tileCoordIntersectsViewport(tileCoord, viewport) {
        return (0, _intersectsextentJs.intersectsLinearRing)(viewport, 0, viewport.length, 2, this.getTileCoordExtent(tileCoord));
    }
    /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */ calculateTileRanges_(extent) {
        const length = this.resolutions_.length;
        const fullTileRanges = new Array(length);
        for(let z = this.minZoom; z < length; ++z)fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
        this.fullTileRanges_ = fullTileRanges;
    }
}
exports.default = TileGrid;

},{"../TileRange.js":"gx7Pm","./common.js":"bQNAJ","../asserts.js":"k0OL6","../math.js":"d8zSj","../extent.js":"bGUel","../tilecoord.js":"ksONy","../geom/flat/intersectsextent.js":"empkw","../array.js":"hyet5","../size.js":"fXEON","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cas0X":[function(require,module,exports,__globalThis) {
/**
 * @module ol/tilegrid/WMTS
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a tile grid from a WMTS capabilities matrix set and an
 * optional TileMatrixSetLimits.
 * @param {Object} matrixSet An object representing a matrixSet in the
 *     capabilities document.
 * @param {import("../extent.js").Extent} [extent] An optional extent to restrict the tile
 *     ranges the server provides.
 * @param {Array<Object>} [matrixLimits] An optional object representing
 *     the available matrices for tileGrid.
 * @return {WMTSTileGrid} WMTS tileGrid instance.
 * @api
 */ parcelHelpers.export(exports, "createFromCapabilitiesMatrixSet", ()=>createFromCapabilitiesMatrixSet);
var _tileGridJs = require("./TileGrid.js");
var _tileGridJsDefault = parcelHelpers.interopDefault(_tileGridJs);
var _projJs = require("../proj.js");
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles
 * outside this extent will be requested by {@link module:ol/source/Tile~TileSource} sources.
 * When no `origin` or `origins` are configured, the `origin` will be set to the
 * top-left corner of the extent.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e.
 * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left
 * to right and downwards. If not specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins,
 * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If
 * given, the array length should match the length of the `resolutions` array, i.e.
 * each resolution can have a different origin. Tile coordinates increase left to
 * right and downwards. If not specified, `extent` or `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each
 * resolution needs to match the zoom level. This means that even if a `minZoom`
 * is configured, the resolutions array will have a length of `maxZoom + 1`
 * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs
 * to match the length of the `resolutions` array.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. The values here are the `TileMatrixWidth` and
 * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent for
 * which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. The length of
 * this array needs to match the length of the `resolutions` array.
 */ /**
 * @classdesc
 * Set the grid pattern for sources accessing WMTS tiled-image servers.
 * @api
 */ class WMTSTileGrid extends (0, _tileGridJsDefault.default) {
    /**
   * @param {Options} options WMTS options.
   */ constructor(options){
        super({
            extent: options.extent,
            origin: options.origin,
            origins: options.origins,
            resolutions: options.resolutions,
            tileSize: options.tileSize,
            tileSizes: options.tileSizes,
            sizes: options.sizes
        });
        /**
     * @private
     * @type {!Array<string>}
     */ this.matrixIds_ = options.matrixIds;
    }
    /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */ getMatrixId(z) {
        return this.matrixIds_[z];
    }
    /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */ getMatrixIds() {
        return this.matrixIds_;
    }
}
exports.default = WMTSTileGrid;
function createFromCapabilitiesMatrixSet(matrixSet, extent, matrixLimits) {
    /** @type {!Array<number>} */ const resolutions = [];
    /** @type {!Array<string>} */ const matrixIds = [];
    /** @type {!Array<import("../coordinate.js").Coordinate>} */ const origins = [];
    /** @type {!Array<number|import("../size.js").Size>} */ const tileSizes = [];
    /** @type {!Array<import("../size.js").Size>} */ const sizes = [];
    matrixLimits = matrixLimits !== undefined ? matrixLimits : [];
    const supportedCRSPropName = 'SupportedCRS';
    const matrixIdsPropName = 'TileMatrix';
    const identifierPropName = 'Identifier';
    const scaleDenominatorPropName = 'ScaleDenominator';
    const topLeftCornerPropName = 'TopLeftCorner';
    const tileWidthPropName = 'TileWidth';
    const tileHeightPropName = 'TileHeight';
    const code = matrixSet[supportedCRSPropName];
    const projection = (0, _projJs.get)(code);
    const metersPerUnit = projection.getMetersPerUnit();
    // swap origin x and y coordinates if axis orientation is lat/long
    const switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
    matrixSet[matrixIdsPropName].sort(function(a, b) {
        return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
    });
    matrixSet[matrixIdsPropName].forEach(function(elt) {
        let matrixAvailable;
        // use of matrixLimits to filter TileMatrices from GetCapabilities
        // TileMatrixSet from unavailable matrix levels.
        if (matrixLimits.length > 0) matrixAvailable = matrixLimits.find(function(elt_ml) {
            if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) return true;
            // Fallback for tileMatrix identifiers that don't get prefixed
            // by their tileMatrixSet identifiers.
            if (!elt[identifierPropName].includes(':')) return matrixSet[identifierPropName] + ':' + elt[identifierPropName] === elt_ml[matrixIdsPropName];
            return false;
        });
        else matrixAvailable = true;
        if (matrixAvailable) {
            matrixIds.push(elt[identifierPropName]);
            const resolution = elt[scaleDenominatorPropName] * 0.28e-3 / metersPerUnit;
            const tileWidth = elt[tileWidthPropName];
            const tileHeight = elt[tileHeightPropName];
            if (switchOriginXY) origins.push([
                elt[topLeftCornerPropName][1],
                elt[topLeftCornerPropName][0]
            ]);
            else origins.push(elt[topLeftCornerPropName]);
            resolutions.push(resolution);
            tileSizes.push(tileWidth == tileHeight ? tileWidth : [
                tileWidth,
                tileHeight
            ]);
            sizes.push([
                elt['MatrixWidth'],
                elt['MatrixHeight']
            ]);
        }
    });
    return new WMTSTileGrid({
        extent: extent,
        origins: origins,
        resolutions: resolutions,
        matrixIds: matrixIds,
        tileSizes: tileSizes,
        sizes: sizes
    });
}

},{"./TileGrid.js":"1y9y0","../proj.js":"8OK47","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7hwWE":[function(require,module,exports,__globalThis) {
/**
 * @module ol/tileurlfunction
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */ parcelHelpers.export(exports, "createFromTemplate", ()=>createFromTemplate);
/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */ parcelHelpers.export(exports, "createFromTemplates", ()=>createFromTemplates);
/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */ parcelHelpers.export(exports, "createFromTileUrlFunctions", ()=>createFromTileUrlFunctions);
/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */ parcelHelpers.export(exports, "nullTileUrlFunction", ()=>nullTileUrlFunction);
/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */ parcelHelpers.export(exports, "expandUrl", ()=>expandUrl);
var _mathJs = require("./math.js");
var _tilecoordJs = require("./tilecoord.js");
function createFromTemplate(template, tileGrid) {
    const zRegEx = /\{z\}/g;
    const xRegEx = /\{x\}/g;
    const yRegEx = /\{y\}/g;
    const dashYRegEx = /\{-y\}/g;
    return(/**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */ function(tileCoord, pixelRatio, projection) {
        if (!tileCoord) return undefined;
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
            const z = tileCoord[0];
            const range = tileGrid.getFullTileRange(z);
            if (!range) throw new Error('The {-y} placeholder requires a tile grid with extent');
            const y = range.getHeight() - tileCoord[2] - 1;
            return y.toString();
        });
    });
}
function createFromTemplates(templates, tileGrid) {
    const len = templates.length;
    const tileUrlFunctions = new Array(len);
    for(let i = 0; i < len; ++i)tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
    return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
    if (tileUrlFunctions.length === 1) return tileUrlFunctions[0];
    return(/**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */ function(tileCoord, pixelRatio, projection) {
        if (!tileCoord) return undefined;
        const h = (0, _tilecoordJs.hash)(tileCoord);
        const index = (0, _mathJs.modulo)(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    });
}
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
    return undefined;
}
function expandUrl(url) {
    const urls = [];
    let match = /\{([a-z])-([a-z])\}/.exec(url);
    if (match) {
        // char range
        const startCharCode = match[1].charCodeAt(0);
        const stopCharCode = match[2].charCodeAt(0);
        let charCode;
        for(charCode = startCharCode; charCode <= stopCharCode; ++charCode)urls.push(url.replace(match[0], String.fromCharCode(charCode)));
        return urls;
    }
    match = /\{(\d+)-(\d+)\}/.exec(url);
    if (match) {
        // number range
        const stop = parseInt(match[2], 10);
        for(let i = parseInt(match[1], 10); i <= stop; i++)urls.push(url.replace(match[0], i.toString()));
        return urls;
    }
    urls.push(url);
    return urls;
}

},{"./math.js":"d8zSj","./tilecoord.js":"ksONy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6bOIK":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/Vector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseVectorJs = require("./BaseVector.js");
var _baseVectorJsDefault = parcelHelpers.interopDefault(_baseVectorJs);
var _vectorLayerJs = require("../renderer/canvas/VectorLayer.js");
var _vectorLayerJsDefault = parcelHelpers.interopDefault(_vectorLayerJs);
/**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:ol/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */ class VectorLayer extends (0, _baseVectorJsDefault.default) {
    /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */ constructor(options){
        super(options);
    }
    createRenderer() {
        return new (0, _vectorLayerJsDefault.default)(this);
    }
}
exports.default = VectorLayer;

},{"./BaseVector.js":"jHTXH","../renderer/canvas/VectorLayer.js":"cwWLB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jHTXH":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/BaseVector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _rbush = require("rbush");
var _rbushDefault = parcelHelpers.interopDefault(_rbush);
var _styleJs = require("../style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _styleJs1 = require("../render/canvas/style.js");
/**
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @enum {string}
 * @private
 */ const Property = {
    RENDER_ORDER: 'renderOrder'
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @extends {Layer<VectorSourceType, RendererType>}
 * @api
 */ class BaseVectorLayer extends (0, _layerJsDefault.default) {
    /**
   * @param {Options<VectorSourceType>} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        super(baseOptions);
        /**
     * @private
     * @type {boolean}
     */ this.declutter_ = options.declutter !== undefined ? options.declutter : false;
        /**
     * @type {number}
     * @private
     */ this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
        /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike}
     * @private
     */ this.style_ = null;
        /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */ this.styleFunction_ = undefined;
        this.setStyle(options.style);
        /**
     * @type {boolean}
     * @private
     */ this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
        /**
     * @type {boolean}
     * @private
     */ this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
    }
    /**
   * @return {boolean} Declutter.
   */ getDeclutter() {
        return this.declutter_;
    }
    /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */ getFeatures(pixel) {
        return super.getFeatures(pixel);
    }
    /**
   * @return {number|undefined} Render buffer.
   */ getRenderBuffer() {
        return this.renderBuffer_;
    }
    /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */ getRenderOrder() {
        return /** @type {import("../render.js").OrderFunction|null|undefined} */ this.get(Property.RENDER_ORDER);
    }
    /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */ getStyle() {
        return this.style_;
    }
    /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */ getStyleFunction() {
        return this.styleFunction_;
    }
    /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */ getUpdateWhileAnimating() {
        return this.updateWhileAnimating_;
    }
    /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */ getUpdateWhileInteracting() {
        return this.updateWhileInteracting_;
    }
    /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ renderDeclutter(frameState) {
        if (!frameState.declutterTree) frameState.declutterTree = new (0, _rbushDefault.default)(9);
        /** @type {*} */ this.getRenderer().renderDeclutter(frameState);
    }
    /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */ setRenderOrder(renderOrder) {
        this.set(Property.RENDER_ORDER, renderOrder);
    }
    /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */ setStyle(style) {
        this.style_ = toStyleLike(style);
        this.styleFunction_ = style === null ? undefined : (0, _styleJs.toFunction)(this.style_);
        this.changed();
    }
}
/**
 * Coerce the allowed style types into a shorter list of types.  Flat styles, arrays of flat
 * styles, and arrays of rules are converted into style functions.
 *
 * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
 * @return {import("../style/Style.js").StyleLike|null} The style.
 */ function toStyleLike(style) {
    if (style === undefined) return 0, _styleJs.createDefaultStyle;
    if (!style) return null;
    if (typeof style === 'function') return style;
    if (style instanceof (0, _styleJsDefault.default)) return style;
    if (!Array.isArray(style)) return (0, _styleJs1.flatStylesToStyleFunction)([
        style
    ]);
    if (style.length === 0) return [];
    const length = style.length;
    const first = style[0];
    if (first instanceof (0, _styleJsDefault.default)) {
        /**
     * @type {Array<Style>}
     */ const styles = new Array(length);
        for(let i = 0; i < length; ++i){
            const candidate = style[i];
            if (!(candidate instanceof (0, _styleJsDefault.default))) throw new Error('Expected a list of style instances');
            styles[i] = candidate;
        }
        return styles;
    }
    if ('style' in first) {
        /**
     * @type Array<import("../style/flat.js").Rule>
     */ const rules = new Array(length);
        for(let i = 0; i < length; ++i){
            const candidate = style[i];
            if (!('style' in candidate)) throw new Error('Expected a list of rules with a style property');
            rules[i] = candidate;
        }
        return (0, _styleJs1.rulesToStyleFunction)(rules);
    }
    const flatStyles = /** @type {Array<import("../style/flat.js").FlatStyle>} */ style;
    return (0, _styleJs1.flatStylesToStyleFunction)(flatStyles);
}
exports.default = BaseVectorLayer;

},{"./Layer.js":"ixGac","rbush":"dgmWo","../style/Style.js":"8opjn","../render/canvas/style.js":"emx1h","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dgmWo":[function(require,module,exports,__globalThis) {
!function(t, i) {
    module.exports = i();
}(this, function() {
    "use strict";
    function t(t, r, e, a, h) {
        !function t(n, r, e, a, h) {
            for(; a > e;){
                if (a - e > 600) {
                    var o = a - e + 1, s = r - e + 1, l = Math.log(o), f = .5 * Math.exp(2 * l / 3), u = .5 * Math.sqrt(l * f * (o - f) / o) * (s - o / 2 < 0 ? -1 : 1), m = Math.max(e, Math.floor(r - s * f / o + u)), c = Math.min(a, Math.floor(r + (o - s) * f / o + u));
                    t(n, r, m, c, h);
                }
                var p = n[r], d = e, x = a;
                for(i(n, e, r), h(n[a], p) > 0 && i(n, e, a); d < x;){
                    for(i(n, d, x), d++, x--; h(n[d], p) < 0;)d++;
                    for(; h(n[x], p) > 0;)x--;
                }
                0 === h(n[e], p) ? i(n, e, x) : i(n, ++x, a), x <= r && (e = x + 1), r <= x && (a = x - 1);
            }
        }(t, r, e || 0, a || t.length - 1, h || n);
    }
    function i(t, i, n) {
        var r = t[i];
        t[i] = t[n], t[n] = r;
    }
    function n(t, i) {
        return t < i ? -1 : t > i ? 1 : 0;
    }
    var r = function(t) {
        void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear();
    };
    function e(t, i, n) {
        if (!n) return i.indexOf(t);
        for(var r = 0; r < i.length; r++)if (n(t, i[r])) return r;
        return -1;
    }
    function a(t, i) {
        h(t, 0, t.children.length, i, t);
    }
    function h(t, i, n, r, e) {
        e || (e = p(null)), e.minX = 1 / 0, e.minY = 1 / 0, e.maxX = -1 / 0, e.maxY = -1 / 0;
        for(var a = i; a < n; a++){
            var h = t.children[a];
            o(e, t.leaf ? r(h) : h);
        }
        return e;
    }
    function o(t, i) {
        return t.minX = Math.min(t.minX, i.minX), t.minY = Math.min(t.minY, i.minY), t.maxX = Math.max(t.maxX, i.maxX), t.maxY = Math.max(t.maxY, i.maxY), t;
    }
    function s(t, i) {
        return t.minX - i.minX;
    }
    function l(t, i) {
        return t.minY - i.minY;
    }
    function f(t) {
        return (t.maxX - t.minX) * (t.maxY - t.minY);
    }
    function u(t) {
        return t.maxX - t.minX + (t.maxY - t.minY);
    }
    function m(t, i) {
        return t.minX <= i.minX && t.minY <= i.minY && i.maxX <= t.maxX && i.maxY <= t.maxY;
    }
    function c(t, i) {
        return i.minX <= t.maxX && i.minY <= t.maxY && i.maxX >= t.minX && i.maxY >= t.minY;
    }
    function p(t) {
        return {
            children: t,
            height: 1,
            leaf: !0,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
        };
    }
    function d(i, n, r, e, a) {
        for(var h = [
            n,
            r
        ]; h.length;)if (!((r = h.pop()) - (n = h.pop()) <= e)) {
            var o = n + Math.ceil((r - n) / e / 2) * e;
            t(i, o, n, r, a), h.push(n, o, o, r);
        }
    }
    return r.prototype.all = function() {
        return this._all(this.data, []);
    }, r.prototype.search = function(t) {
        var i = this.data, n = [];
        if (!c(t, i)) return n;
        for(var r = this.toBBox, e = []; i;){
            for(var a = 0; a < i.children.length; a++){
                var h = i.children[a], o = i.leaf ? r(h) : h;
                c(t, o) && (i.leaf ? n.push(h) : m(t, o) ? this._all(h, n) : e.push(h));
            }
            i = e.pop();
        }
        return n;
    }, r.prototype.collides = function(t) {
        var i = this.data;
        if (!c(t, i)) return !1;
        for(var n = []; i;){
            for(var r = 0; r < i.children.length; r++){
                var e = i.children[r], a = i.leaf ? this.toBBox(e) : e;
                if (c(t, a)) {
                    if (i.leaf || m(t, a)) return !0;
                    n.push(e);
                }
            }
            i = n.pop();
        }
        return !1;
    }, r.prototype.load = function(t) {
        if (!t || !t.length) return this;
        if (t.length < this._minEntries) {
            for(var i = 0; i < t.length; i++)this.insert(t[i]);
            return this;
        }
        var n = this._build(t.slice(), 0, t.length - 1, 0);
        if (this.data.children.length) {
            if (this.data.height === n.height) this._splitRoot(this.data, n);
            else {
                if (this.data.height < n.height) {
                    var r = this.data;
                    this.data = n, n = r;
                }
                this._insert(n, this.data.height - n.height - 1, !0);
            }
        } else this.data = n;
        return this;
    }, r.prototype.insert = function(t) {
        return t && this._insert(t, this.data.height - 1), this;
    }, r.prototype.clear = function() {
        return this.data = p([]), this;
    }, r.prototype.remove = function(t, i) {
        if (!t) return this;
        for(var n, r, a, h = this.data, o = this.toBBox(t), s = [], l = []; h || s.length;){
            if (h || (h = s.pop(), r = s[s.length - 1], n = l.pop(), a = !0), h.leaf) {
                var f = e(t, h.children, i);
                if (-1 !== f) return h.children.splice(f, 1), s.push(h), this._condense(s), this;
            }
            a || h.leaf || !m(h, o) ? r ? (n++, h = r.children[n], a = !1) : h = null : (s.push(h), l.push(n), n = 0, r = h, h = h.children[0]);
        }
        return this;
    }, r.prototype.toBBox = function(t) {
        return t;
    }, r.prototype.compareMinX = function(t, i) {
        return t.minX - i.minX;
    }, r.prototype.compareMinY = function(t, i) {
        return t.minY - i.minY;
    }, r.prototype.toJSON = function() {
        return this.data;
    }, r.prototype.fromJSON = function(t) {
        return this.data = t, this;
    }, r.prototype._all = function(t, i) {
        for(var n = []; t;)t.leaf ? i.push.apply(i, t.children) : n.push.apply(n, t.children), t = n.pop();
        return i;
    }, r.prototype._build = function(t, i, n, r) {
        var e, h = n - i + 1, o = this._maxEntries;
        if (h <= o) return a(e = p(t.slice(i, n + 1)), this.toBBox), e;
        r || (r = Math.ceil(Math.log(h) / Math.log(o)), o = Math.ceil(h / Math.pow(o, r - 1))), (e = p([])).leaf = !1, e.height = r;
        var s = Math.ceil(h / o), l = s * Math.ceil(Math.sqrt(o));
        d(t, i, n, l, this.compareMinX);
        for(var f = i; f <= n; f += l){
            var u = Math.min(f + l - 1, n);
            d(t, f, u, s, this.compareMinY);
            for(var m = f; m <= u; m += s){
                var c = Math.min(m + s - 1, u);
                e.children.push(this._build(t, m, c, r - 1));
            }
        }
        return a(e, this.toBBox), e;
    }, r.prototype._chooseSubtree = function(t, i, n, r) {
        for(; r.push(i), !i.leaf && r.length - 1 !== n;){
            for(var e = 1 / 0, a = 1 / 0, h = void 0, o = 0; o < i.children.length; o++){
                var s = i.children[o], l = f(s), u = (m = t, c = s, (Math.max(c.maxX, m.maxX) - Math.min(c.minX, m.minX)) * (Math.max(c.maxY, m.maxY) - Math.min(c.minY, m.minY)) - l);
                u < a ? (a = u, e = l < e ? l : e, h = s) : u === a && l < e && (e = l, h = s);
            }
            i = h || i.children[0];
        }
        var m, c;
        return i;
    }, r.prototype._insert = function(t, i, n) {
        var r = n ? t : this.toBBox(t), e = [], a = this._chooseSubtree(r, this.data, i, e);
        for(a.children.push(t), o(a, r); i >= 0 && e[i].children.length > this._maxEntries;)this._split(e, i), i--;
        this._adjustParentBBoxes(r, e, i);
    }, r.prototype._split = function(t, i) {
        var n = t[i], r = n.children.length, e = this._minEntries;
        this._chooseSplitAxis(n, e, r);
        var h = this._chooseSplitIndex(n, e, r), o = p(n.children.splice(h, n.children.length - h));
        o.height = n.height, o.leaf = n.leaf, a(n, this.toBBox), a(o, this.toBBox), i ? t[i - 1].children.push(o) : this._splitRoot(n, o);
    }, r.prototype._splitRoot = function(t, i) {
        this.data = p([
            t,
            i
        ]), this.data.height = t.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);
    }, r.prototype._chooseSplitIndex = function(t, i, n) {
        for(var r, e, a, o, s, l, u, m = 1 / 0, c = 1 / 0, p = i; p <= n - i; p++){
            var d = h(t, 0, p, this.toBBox), x = h(t, p, n, this.toBBox), v = (e = d, a = x, o = void 0, s = void 0, l = void 0, u = void 0, o = Math.max(e.minX, a.minX), s = Math.max(e.minY, a.minY), l = Math.min(e.maxX, a.maxX), u = Math.min(e.maxY, a.maxY), Math.max(0, l - o) * Math.max(0, u - s)), M = f(d) + f(x);
            v < m ? (m = v, r = p, c = M < c ? M : c) : v === m && M < c && (c = M, r = p);
        }
        return r || n - i;
    }, r.prototype._chooseSplitAxis = function(t, i, n) {
        var r = t.leaf ? this.compareMinX : s, e = t.leaf ? this.compareMinY : l;
        this._allDistMargin(t, i, n, r) < this._allDistMargin(t, i, n, e) && t.children.sort(r);
    }, r.prototype._allDistMargin = function(t, i, n, r) {
        t.children.sort(r);
        for(var e = this.toBBox, a = h(t, 0, i, e), s = h(t, n - i, n, e), l = u(a) + u(s), f = i; f < n - i; f++){
            var m = t.children[f];
            o(a, t.leaf ? e(m) : m), l += u(a);
        }
        for(var c = n - i - 1; c >= i; c--){
            var p = t.children[c];
            o(s, t.leaf ? e(p) : p), l += u(s);
        }
        return l;
    }, r.prototype._adjustParentBBoxes = function(t, i, n) {
        for(var r = n; r >= 0; r--)o(i[r], t);
    }, r.prototype._condense = function(t) {
        for(var i = t.length - 1, n = void 0; i >= 0; i--)0 === t[i].children.length ? i > 0 ? (n = t[i - 1].children).splice(n.indexOf(t[i]), 1) : this.clear() : a(t[i], this.toBBox);
    }, r;
});

},{}],"8opjn":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Style
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */ parcelHelpers.export(exports, "toFunction", ()=>toFunction);
/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */ parcelHelpers.export(exports, "createDefaultStyle", ()=>createDefaultStyle);
/**
 * Default styles for editing features.
 * @return {Object<import("../geom/Geometry.js").Type, Array<Style>>} Styles
 */ parcelHelpers.export(exports, "createEditingStyle", ()=>createEditingStyle);
var _circleJs = require("./Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("./Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _strokeJs = require("./Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _assertsJs = require("../asserts.js");
/**
 * A function that takes an {@link module:ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */ /**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */ /**
 * A function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */ /**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>|Array<Array<Array<import("../coordinate.js").Coordinate>>>),import("../render.js").State): void} RenderFunction
 */ /**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */ /**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles['Polygon'] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles['MultiPolygon'] =
 *      styles['Polygon'];
 *  styles['LineString'] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles['MultiLineString'] = styles['LineString'];
 *
 *  styles['Circle'] = styles['Polygon'].concat(
 *    styles['LineString']
 *  );
 *
 *  styles['Point'] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles['MultiPoint'] =
 *      styles['Point'];
 *  styles['GeometryCollection'] =
 *      styles['Polygon'].concat(
 *          styles['LineString'],
 *          styles['Point']
 *      );
 * ```
 *
 * @api
 */ class Style {
    /**
   * @param {Options} [options] Style options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction|null}
     */ this.geometry_ = null;
        /**
     * @private
     * @type {!GeometryFunction}
     */ this.geometryFunction_ = defaultGeometryFunction;
        if (options.geometry !== undefined) this.setGeometry(options.geometry);
        /**
     * @private
     * @type {import("./Fill.js").default|null}
     */ this.fill_ = options.fill !== undefined ? options.fill : null;
        /**
     * @private
     * @type {import("./Image.js").default|null}
     */ this.image_ = options.image !== undefined ? options.image : null;
        /**
     * @private
     * @type {RenderFunction|null}
     */ this.renderer_ = options.renderer !== undefined ? options.renderer : null;
        /**
     * @private
     * @type {RenderFunction|null}
     */ this.hitDetectionRenderer_ = options.hitDetectionRenderer !== undefined ? options.hitDetectionRenderer : null;
        /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
     * @private
     * @type {import("./Text.js").default|null}
     */ this.text_ = options.text !== undefined ? options.text : null;
        /**
     * @private
     * @type {number|undefined}
     */ this.zIndex_ = options.zIndex;
    }
    /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */ clone() {
        let geometry = this.getGeometry();
        if (geometry && typeof geometry === 'object') geometry = /** @type {import("../geom/Geometry.js").default} */ geometry.clone();
        return new Style({
            geometry: geometry ?? undefined,
            fill: this.getFill() ? this.getFill().clone() : undefined,
            image: this.getImage() ? this.getImage().clone() : undefined,
            renderer: this.getRenderer() ?? undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            text: this.getText() ? this.getText().clone() : undefined,
            zIndex: this.getZIndex()
        });
    }
    /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */ getRenderer() {
        return this.renderer_;
    }
    /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */ setRenderer(renderer) {
        this.renderer_ = renderer;
    }
    /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */ setHitDetectionRenderer(renderer) {
        this.hitDetectionRenderer_ = renderer;
    }
    /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */ getHitDetectionRenderer() {
        return this.hitDetectionRenderer_;
    }
    /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */ getGeometry() {
        return this.geometry_;
    }
    /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */ getGeometryFunction() {
        return this.geometryFunction_;
    }
    /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */ getFill() {
        return this.fill_;
    }
    /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */ setFill(fill) {
        this.fill_ = fill;
    }
    /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */ getImage() {
        return this.image_;
    }
    /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */ setImage(image) {
        this.image_ = image;
    }
    /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */ getStroke() {
        return this.stroke_;
    }
    /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */ setStroke(stroke) {
        this.stroke_ = stroke;
    }
    /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */ getText() {
        return this.text_;
    }
    /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */ setText(text) {
        this.text_ = text;
    }
    /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */ getZIndex() {
        return this.zIndex_;
    }
    /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */ setGeometry(geometry) {
        if (typeof geometry === 'function') this.geometryFunction_ = geometry;
        else if (typeof geometry === 'string') this.geometryFunction_ = function(feature) {
            return /** @type {import("../geom/Geometry.js").default} */ feature.get(geometry);
        };
        else if (!geometry) this.geometryFunction_ = defaultGeometryFunction;
        else if (geometry !== undefined) this.geometryFunction_ = function() {
            return /** @type {import("../geom/Geometry.js").default} */ geometry;
        };
        this.geometry_ = geometry;
    }
    /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */ setZIndex(zIndex) {
        this.zIndex_ = zIndex;
    }
}
function toFunction(obj) {
    let styleFunction;
    if (typeof obj === 'function') styleFunction = obj;
    else {
        /**
     * @type {Array<Style>}
     */ let styles;
        if (Array.isArray(obj)) styles = obj;
        else {
            (0, _assertsJs.assert)(typeof /** @type {?} */ obj.getZIndex === 'function', 'Expected an `Style` or an array of `Style`');
            const style = /** @type {Style} */ obj;
            styles = [
                style
            ];
        }
        styleFunction = function() {
            return styles;
        };
    }
    return styleFunction;
}
/**
 * @type {Array<Style>|null}
 */ let defaultStyles = null;
function createDefaultStyle(feature, resolution) {
    // We don't use an immediately-invoked function
    // and a closure so we don't get an error at script evaluation time in
    // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
    // canvas.getContext('2d') at construction time, which will cause an.error
    // in such browsers.)
    if (!defaultStyles) {
        const fill = new (0, _fillJsDefault.default)({
            color: 'rgba(255,255,255,0.4)'
        });
        const stroke = new (0, _strokeJsDefault.default)({
            color: '#3399CC',
            width: 1.25
        });
        defaultStyles = [
            new Style({
                image: new (0, _circleJsDefault.default)({
                    fill: fill,
                    stroke: stroke,
                    radius: 5
                }),
                fill: fill,
                stroke: stroke
            })
        ];
    }
    return defaultStyles;
}
function createEditingStyle() {
    /** @type {Object<import("../geom/Geometry.js").Type, Array<Style>>} */ const styles = {};
    const white = [
        255,
        255,
        255,
        1
    ];
    const blue = [
        0,
        153,
        255,
        1
    ];
    const width = 3;
    styles['Polygon'] = [
        new Style({
            fill: new (0, _fillJsDefault.default)({
                color: [
                    255,
                    255,
                    255,
                    0.5
                ]
            })
        })
    ];
    styles['MultiPolygon'] = styles['Polygon'];
    styles['LineString'] = [
        new Style({
            stroke: new (0, _strokeJsDefault.default)({
                color: white,
                width: width + 2
            })
        }),
        new Style({
            stroke: new (0, _strokeJsDefault.default)({
                color: blue,
                width: width
            })
        })
    ];
    styles['MultiLineString'] = styles['LineString'];
    styles['Circle'] = styles['Polygon'].concat(styles['LineString']);
    styles['Point'] = [
        new Style({
            image: new (0, _circleJsDefault.default)({
                radius: width * 2,
                fill: new (0, _fillJsDefault.default)({
                    color: blue
                }),
                stroke: new (0, _strokeJsDefault.default)({
                    color: white,
                    width: width / 2
                })
            }),
            zIndex: Infinity
        })
    ];
    styles['MultiPoint'] = styles['Point'];
    styles['GeometryCollection'] = styles['Polygon'].concat(styles['LineString'], styles['Point']);
    return styles;
}
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */ function defaultGeometryFunction(feature) {
    return feature.getGeometry();
}
exports.default = Style;

},{"./Circle.js":"3LBvw","./Fill.js":"cHc7U","./Stroke.js":"1uQwy","../asserts.js":"k0OL6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3LBvw":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Circle
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regularShapeJs = require("./RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode
 */ /**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */ class CircleStyle extends (0, _regularShapeJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {
            radius: 5
        };
        super({
            points: Infinity,
            fill: options.fill,
            radius: options.radius,
            stroke: options.stroke,
            scale: options.scale !== undefined ? options.scale : 1,
            rotation: options.rotation !== undefined ? options.rotation : 0,
            rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ],
            declutterMode: options.declutterMode
        });
    }
    /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        const style = new CircleStyle({
            fill: this.getFill() ? this.getFill().clone() : undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            radius: this.getRadius(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
    }
    /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */ setRadius(radius) {
        this.radius_ = radius;
        this.render();
    }
}
exports.default = CircleStyle;

},{"./RegularShape.js":"fLUBU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fLUBU":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/RegularShape
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("./Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _colorJs = require("../color.js");
var _colorlikeJs = require("../colorlike.js");
var _domJs = require("../dom.js");
var _canvasJs = require("../render/canvas.js");
/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [radius2] Second radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.
 * Positive values will shift the shape right and up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */ /**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike|undefined} strokeStyle StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>|null} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */ /**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */ class RegularShape extends (0, _imageJsDefault.default) {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        /**
     * @type {boolean}
     */ const rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
        super({
            opacity: 1,
            rotateWithView: rotateWithView,
            rotation: options.rotation !== undefined ? options.rotation : 0,
            scale: options.scale !== undefined ? options.scale : 1,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ],
            declutterMode: options.declutterMode
        });
        /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */ this.canvases_;
        /**
     * @private
     * @type {HTMLCanvasElement|null}
     */ this.hitDetectionCanvas_ = null;
        /**
     * @private
     * @type {import("./Fill.js").default|null}
     */ this.fill_ = options.fill !== undefined ? options.fill : null;
        /**
     * @private
     * @type {Array<number>}
     */ this.origin_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {number}
     */ this.points_ = options.points;
        /**
     * @protected
     * @type {number}
     */ this.radius_ = options.radius !== undefined ? options.radius : options.radius1;
        /**
     * @private
     * @type {number|undefined}
     */ this.radius2_ = options.radius2;
        /**
     * @private
     * @type {number}
     */ this.angle_ = options.angle !== undefined ? options.angle : 0;
        /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.size_;
        /**
     * @private
     * @type {RenderOptions}
     */ this.renderOptions_;
        this.render();
    }
    /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        const style = new RegularShape({
            fill: this.getFill() ? this.getFill().clone() : undefined,
            points: this.getPoints(),
            radius: this.getRadius(),
            radius2: this.getRadius2(),
            angle: this.getAngle(),
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
    }
    /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */ getAnchor() {
        const size = this.size_;
        const displacement = this.getDisplacement();
        const scale = this.getScaleArray();
        // anchor is scaled by renderer but displacement should not be scaled
        // so divide by scale here
        return [
            size[0] / 2 - displacement[0] / scale[0],
            size[1] / 2 + displacement[1] / scale[1]
        ];
    }
    /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */ getAngle() {
        return this.angle_;
    }
    /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */ getFill() {
        return this.fill_;
    }
    /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */ setFill(fill) {
        this.fill_ = fill;
        this.render();
    }
    /**
   * @return {HTMLCanvasElement} Image element.
   */ getHitDetectionImage() {
        if (!this.hitDetectionCanvas_) this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(this.renderOptions_);
        return this.hitDetectionCanvas_;
    }
    /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */ getImage(pixelRatio) {
        let image = this.canvases_[pixelRatio];
        if (!image) {
            const renderOptions = this.renderOptions_;
            const context = (0, _domJs.createCanvasContext2D)(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
            this.draw_(renderOptions, context, pixelRatio);
            image = context.canvas;
            this.canvases_[pixelRatio] = image;
        }
        return image;
    }
    /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */ getPixelRatio(pixelRatio) {
        return pixelRatio;
    }
    /**
   * @return {import("../size.js").Size} Image size.
   */ getImageSize() {
        return this.size_;
    }
    /**
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return (0, _imageStateJsDefault.default).LOADED;
    }
    /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */ getOrigin() {
        return this.origin_;
    }
    /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */ getPoints() {
        return this.points_;
    }
    /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */ getRadius() {
        return this.radius_;
    }
    /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */ getRadius2() {
        return this.radius2_;
    }
    /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */ getSize() {
        return this.size_;
    }
    /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */ getStroke() {
        return this.stroke_;
    }
    /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */ setStroke(stroke) {
        this.stroke_ = stroke;
        this.render();
    }
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ listenImageChange(listener) {}
    /**
   * Load not yet loaded URI.
   */ load() {}
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ unlistenImageChange(listener) {}
    /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */ calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== 'bevel' && lineJoin !== 'miter') return strokeWidth;
        // m  | ^
        // i  | |\                  .
        // t >|  #\
        // e  | |\ \              .
        // r      \s\
        //      |  \t\          .                 .
        //          \r\                      .   .
        //      |    \o\      .          .  . . .
        //          e \k\            .  .    . .
        //      |      \e\  .    .  .       . .
        //       d      \ \  .  .          . .
        //      | _ _a_ _\#  .            . .
        //   r1          / `             . .
        //      |                       . .
        //       b     /               . .
        //      |                     . .
        //           / r2            . .
        //      |                        .   .
        //         /                           .   .
        //      |α                                   .   .
        //       /                                         .   .
        //      ° center
        let r1 = this.radius_;
        let r2 = this.radius2_ === undefined ? r1 : this.radius2_;
        if (r1 < r2) {
            const tmp = r1;
            r1 = r2;
            r2 = tmp;
        }
        const points = this.radius2_ === undefined ? this.points_ : this.points_ * 2;
        const alpha = 2 * Math.PI / points;
        const a = r2 * Math.sin(alpha);
        const b = Math.sqrt(r2 * r2 - a * a);
        const d = r1 - b;
        const e = Math.sqrt(a * a + d * d);
        const miterRatio = e / a;
        if (lineJoin === 'miter' && miterRatio <= miterLimit) return miterRatio * strokeWidth;
        // Calculate the distance from center to the stroke corner where
        // it was cut short because of the miter limit.
        //              l
        //        ----+---- <= distance from center to here is maxr
        //       /####|k ##\
        //      /#####^#####\
        //     /#### /+\# s #\
        //    /### h/+++\# t #\
        //   /### t/+++++\# r #\
        //  /### a/+++++++\# o #\
        // /### p/++ fill +\# k #\
        ///#### /+++++^+++++\# e #\
        //#####/+++++/+\+++++\#####\
        const k = strokeWidth / 2 / miterRatio;
        const l = strokeWidth / 2 * (d / e);
        const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
        const bevelAdd = maxr - r1;
        if (this.radius2_ === undefined || lineJoin === 'bevel') return bevelAdd * 2;
        // If outer miter is over the miter limit the inner miter may reach through the
        // center and be longer than the bevel, same calculation as above but swap r1 / r2.
        const aa = r1 * Math.sin(alpha);
        const bb = Math.sqrt(r1 * r1 - aa * aa);
        const dd = r2 - bb;
        const ee = Math.sqrt(aa * aa + dd * dd);
        const innerMiterRatio = ee / aa;
        if (innerMiterRatio <= miterLimit) {
            const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
            return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
    }
    /**
   * @return {RenderOptions}  The render options
   * @protected
   */ createRenderOptions() {
        let lineCap = (0, _canvasJs.defaultLineCap);
        let lineJoin = (0, _canvasJs.defaultLineJoin);
        let miterLimit = 0;
        let lineDash = null;
        let lineDashOffset = 0;
        let strokeStyle;
        let strokeWidth = 0;
        if (this.stroke_) {
            strokeStyle = (0, _colorlikeJs.asColorLike)(this.stroke_.getColor() ?? (0, _canvasJs.defaultStrokeStyle));
            strokeWidth = this.stroke_.getWidth() ?? (0, _canvasJs.defaultLineWidth);
            lineDash = this.stroke_.getLineDash();
            lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
            lineJoin = this.stroke_.getLineJoin() ?? (0, _canvasJs.defaultLineJoin);
            lineCap = this.stroke_.getLineCap() ?? (0, _canvasJs.defaultLineCap);
            miterLimit = this.stroke_.getMiterLimit() ?? (0, _canvasJs.defaultMiterLimit);
        }
        const add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
        const size = Math.ceil(2 * maxRadius + add);
        return {
            strokeStyle: strokeStyle,
            strokeWidth: strokeWidth,
            size: size,
            lineCap: lineCap,
            lineDash: lineDash,
            lineDashOffset: lineDashOffset,
            lineJoin: lineJoin,
            miterLimit: miterLimit
        };
    }
    /**
   * @protected
   */ render() {
        this.renderOptions_ = this.createRenderOptions();
        const size = this.renderOptions_.size;
        this.canvases_ = {};
        this.hitDetectionCanvas_ = null;
        this.size_ = [
            size,
            size
        ];
    }
    /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */ draw_(renderOptions, context, pixelRatio) {
        context.scale(pixelRatio, pixelRatio);
        // set origin to canvas center
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        if (this.fill_) {
            let color = this.fill_.getColor();
            if (color === null) color = (0, _canvasJs.defaultFillStyle);
            context.fillStyle = (0, _colorlikeJs.asColorLike)(color);
            context.fill();
        }
        if (renderOptions.strokeStyle) {
            context.strokeStyle = renderOptions.strokeStyle;
            context.lineWidth = renderOptions.strokeWidth;
            if (renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
            }
            context.lineCap = renderOptions.lineCap;
            context.lineJoin = renderOptions.lineJoin;
            context.miterLimit = renderOptions.miterLimit;
            context.stroke();
        }
    }
    /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */ createHitDetectionCanvas_(renderOptions) {
        let context;
        if (this.fill_) {
            let color = this.fill_.getColor();
            // determine if fill is transparent (or pattern or gradient)
            let opacity = 0;
            if (typeof color === 'string') color = (0, _colorJs.asArray)(color);
            if (color === null) opacity = 1;
            else if (Array.isArray(color)) opacity = color.length === 4 ? color[3] : 1;
            if (opacity === 0) {
                // if a transparent fill style is set, create an extra hit-detection image
                // with a default fill style
                context = (0, _domJs.createCanvasContext2D)(renderOptions.size, renderOptions.size);
                this.drawHitDetectionCanvas_(renderOptions, context);
            }
        }
        return context ? context.canvas : this.getImage(1);
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */ createPath_(context) {
        let points = this.points_;
        const radius = this.radius_;
        if (points === Infinity) context.arc(0, 0, radius, 0, 2 * Math.PI);
        else {
            const radius2 = this.radius2_ === undefined ? radius : this.radius2_;
            if (this.radius2_ !== undefined) points *= 2;
            const startAngle = this.angle_ - Math.PI / 2;
            const step = 2 * Math.PI / points;
            for(let i = 0; i < points; i++){
                const angle0 = startAngle + i * step;
                const radiusC = i % 2 === 0 ? radius : radius2;
                context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
            }
            context.closePath();
        }
    }
    /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */ drawHitDetectionCanvas_(renderOptions, context) {
        // set origin to canvas center
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        context.fillStyle = (0, _canvasJs.defaultFillStyle);
        context.fill();
        if (renderOptions.strokeStyle) {
            context.strokeStyle = renderOptions.strokeStyle;
            context.lineWidth = renderOptions.strokeWidth;
            if (renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
            }
            context.lineJoin = renderOptions.lineJoin;
            context.miterLimit = renderOptions.miterLimit;
            context.stroke();
        }
    }
}
exports.default = RegularShape;

},{"../ImageState.js":"jCrEd","./Image.js":"4PQUx","../color.js":"h6hAX","../colorlike.js":"36IFz","../dom.js":"h98kD","../render/canvas.js":"6S9WQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4PQUx":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilJs = require("../util.js");
var _sizeJs = require("../size.js");
/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 * @property {"declutter"|"obstacle"|"none"|undefined} declutterMode Declutter mode: `declutter`, `obstacle`, 'none */ /**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */ class ImageStyle {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        /**
     * @private
     * @type {number}
     */ this.opacity_ = options.opacity;
        /**
     * @private
     * @type {boolean}
     */ this.rotateWithView_ = options.rotateWithView;
        /**
     * @private
     * @type {number}
     */ this.rotation_ = options.rotation;
        /**
     * @private
     * @type {number|import("../size.js").Size}
     */ this.scale_ = options.scale;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.scaleArray_ = (0, _sizeJs.toSize)(options.scale);
        /**
     * @private
     * @type {Array<number>}
     */ this.displacement_ = options.displacement;
        /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */ this.declutterMode_ = options.declutterMode;
    }
    /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        return new ImageStyle({
            opacity: this.getOpacity(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
    }
    /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */ getOpacity() {
        return this.opacity_;
    }
    /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */ getRotateWithView() {
        return this.rotateWithView_;
    }
    /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */ getRotation() {
        return this.rotation_;
    }
    /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */ getScale() {
        return this.scale_;
    }
    /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */ getScaleArray() {
        return this.scaleArray_;
    }
    /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */ getDisplacement() {
        return this.displacement_;
    }
    /**
   * Get the declutter mode of the shape
   * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
   * @api
   */ getDeclutterMode() {
        return this.declutterMode_;
    }
    /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */ getAnchor() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */ getImage(pixelRatio) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */ getHitDetectionImage() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */ getPixelRatio(pixelRatio) {
        return 1;
    }
    /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */ getImageSize() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */ getOrigin() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */ getSize() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */ setDisplacement(displacement) {
        this.displacement_ = displacement;
    }
    /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */ setOpacity(opacity) {
        this.opacity_ = opacity;
    }
    /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */ setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
    }
    /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */ setRotation(rotation) {
        this.rotation_ = rotation;
    }
    /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */ setScale(scale) {
        this.scale_ = scale;
        this.scaleArray_ = (0, _sizeJs.toSize)(scale);
    }
    /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ listenImageChange(listener) {
        (0, _utilJs.abstract)();
    }
    /**
   * Load not yet loaded URI.
   * @abstract
   */ load() {
        (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ unlistenImageChange(listener) {
        (0, _utilJs.abstract)();
    }
}
exports.default = ImageStyle;

},{"../util.js":"l1iPW","../size.js":"fXEON","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"36IFz":[function(require,module,exports,__globalThis) {
/**
 * @module ol/colorlike
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */ /**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */ parcelHelpers.export(exports, "asColorLike", ()=>asColorLike);
var _colorJs = require("./color.js");
function asColorLike(color) {
    if (Array.isArray(color)) return (0, _colorJs.toString)(color);
    return color;
}

},{"./color.js":"h6hAX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cHc7U":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Fill
 */ /**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|null} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */ /**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Fill {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|null}
     */ this.color_ = options.color !== undefined ? options.color : null;
    }
    /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */ clone() {
        const color = this.getColor();
        return new Fill({
            color: Array.isArray(color) ? color.slice() : color || undefined
        });
    }
    /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
   * @api
   */ getColor() {
        return this.color_;
    }
    /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
   * @api
   */ setColor(color) {
        this.color_ = color;
    }
}
exports.default = Fill;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1uQwy":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Stroke
 */ /**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */ /**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Stroke {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */ this.color_ = options.color !== undefined ? options.color : null;
        /**
     * @private
     * @type {CanvasLineCap|undefined}
     */ this.lineCap_ = options.lineCap;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
        /**
     * @private
     * @type {number|undefined}
     */ this.lineDashOffset_ = options.lineDashOffset;
        /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */ this.lineJoin_ = options.lineJoin;
        /**
     * @private
     * @type {number|undefined}
     */ this.miterLimit_ = options.miterLimit;
        /**
     * @private
     * @type {number|undefined}
     */ this.width_ = options.width;
    }
    /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */ clone() {
        const color = this.getColor();
        return new Stroke({
            color: Array.isArray(color) ? color.slice() : color || undefined,
            lineCap: this.getLineCap(),
            lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
            lineDashOffset: this.getLineDashOffset(),
            lineJoin: this.getLineJoin(),
            miterLimit: this.getMiterLimit(),
            width: this.getWidth()
        });
    }
    /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */ getColor() {
        return this.color_;
    }
    /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */ getLineCap() {
        return this.lineCap_;
    }
    /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */ getLineDash() {
        return this.lineDash_;
    }
    /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */ getLineDashOffset() {
        return this.lineDashOffset_;
    }
    /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */ getLineJoin() {
        return this.lineJoin_;
    }
    /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */ getMiterLimit() {
        return this.miterLimit_;
    }
    /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */ getWidth() {
        return this.width_;
    }
    /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */ setColor(color) {
        this.color_ = color;
    }
    /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */ setLineCap(lineCap) {
        this.lineCap_ = lineCap;
    }
    /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */ setLineDash(lineDash) {
        this.lineDash_ = lineDash;
    }
    /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */ setLineDashOffset(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
    }
    /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */ setLineJoin(lineJoin) {
        this.lineJoin_ = lineJoin;
    }
    /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */ setMiterLimit(miterLimit) {
        this.miterLimit_ = miterLimit;
    }
    /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */ setWidth(width) {
        this.width_ = width;
    }
}
exports.default = Stroke;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"emx1h":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/style
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This function adapts a rule evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */ parcelHelpers.export(exports, "rulesToStyleFunction", ()=>rulesToStyleFunction);
/**
 * This function adapts a style evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */ parcelHelpers.export(exports, "flatStylesToStyleFunction", ()=>flatStylesToStyleFunction);
/**
 * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator
 */ /**
 * @typedef {Object} CompiledRule
 * @property {ExpressionEvaluator} filter The compiled filter evaluator.
 * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.
 */ /**
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @param {ParsingContext} context The parsing context.
 * @return {RuleSetEvaluator} The evaluator function.
 */ parcelHelpers.export(exports, "buildRuleSet", ()=>buildRuleSet);
/**
 * @typedef {function(EvaluationContext):Style|null} StyleEvaluator
 */ /**
 * @param {FlatStyle} flatStyle A flat style literal.
 * @param {ParsingContext} context The parsing context.
 * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by
 * this function will be reused between invocations.
 */ parcelHelpers.export(exports, "buildStyle", ()=>buildStyle);
var _circleJs = require("../../style/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("../../style/Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _iconJs = require("../../style/Icon.js");
var _iconJsDefault = parcelHelpers.interopDefault(_iconJs);
var _regularShapeJs = require("../../style/RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
var _strokeJs = require("../../style/Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _styleJs = require("../../style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _textJs = require("../../style/Text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);
var _expressionJs = require("../../expr/expression.js");
var _cpuJs = require("../../expr/cpu.js");
var _objJs = require("../../obj.js");
var _sizeJs = require("../../size.js");
/**
 * @fileoverview This module includes functions to build styles for the canvas renderer.  Building
 * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression
 * and returns an instance of one of the expression classes.  The compiling step takes the
 * expression instance and returns a function that can be evaluated to return a literal value.  The
 * evaluator function should do as little allocation and work as possible.
 */ /**
 * @typedef {import("../../style/flat.js").FlatStyle} FlatStyle
 */ /**
 * @typedef {import("../../expr/expression.js").EncodedExpression} EncodedExpression
 */ /**
 * @typedef {import("../../expr/expression.js").ParsingContext} ParsingContext
 */ /**
 * @typedef {import("../../expr/expression.js").CallExpression} CallExpression
 */ /**
 * @typedef {import("../../expr/cpu.js").EvaluationContext} EvaluationContext
 */ /**
 * @typedef {import("../../expr/cpu.js").ExpressionEvaluator} ExpressionEvaluator
 */ /**
 * @param {EvaluationContext} context The evaluation context.
 * @return {boolean} Always true.
 */ function always(context) {
    return true;
}
function rulesToStyleFunction(rules) {
    const parsingContext = (0, _expressionJs.newParsingContext)();
    const evaluator = buildRuleSet(rules, parsingContext);
    const evaluationContext = (0, _cpuJs.newEvaluationContext)();
    return function(feature, resolution) {
        evaluationContext.properties = feature.getPropertiesInternal();
        evaluationContext.resolution = resolution;
        if (parsingContext.featureId) {
            const id = feature.getId();
            if (id !== undefined) evaluationContext.featureId = id;
            else evaluationContext.featureId = null;
        }
        return evaluator(evaluationContext);
    };
}
function flatStylesToStyleFunction(flatStyles) {
    const parsingContext = (0, _expressionJs.newParsingContext)();
    const length = flatStyles.length;
    /**
   * @type {Array<StyleEvaluator>}
   */ const evaluators = new Array(length);
    for(let i = 0; i < length; ++i)evaluators[i] = buildStyle(flatStyles[i], parsingContext);
    const evaluationContext = (0, _cpuJs.newEvaluationContext)();
    /**
   * @type {Array<Style>}
   */ const styles = new Array(length);
    return function(feature, resolution) {
        evaluationContext.properties = feature.getPropertiesInternal();
        evaluationContext.resolution = resolution;
        if (parsingContext.featureId) {
            const id = feature.getId();
            if (id !== undefined) evaluationContext.featureId = id;
            else evaluationContext.featureId = null;
        }
        let nonNullCount = 0;
        for(let i = 0; i < length; ++i){
            const style = evaluators[i](evaluationContext);
            if (style) {
                styles[nonNullCount] = style;
                nonNullCount += 1;
            }
        }
        styles.length = nonNullCount;
        return styles;
    };
}
function buildRuleSet(rules, context) {
    const length = rules.length;
    /**
   * @type {Array<CompiledRule>}
   */ const compiledRules = new Array(length);
    for(let i = 0; i < length; ++i){
        const rule = rules[i];
        const filter = 'filter' in rule ? (0, _cpuJs.buildExpression)(rule.filter, (0, _expressionJs.BooleanType), context) : always;
        /**
     * @type {Array<StyleEvaluator>}
     */ let styles;
        if (Array.isArray(rule.style)) {
            const styleLength = rule.style.length;
            styles = new Array(styleLength);
            for(let j = 0; j < styleLength; ++j)styles[j] = buildStyle(rule.style[j], context);
        } else styles = [
            buildStyle(rule.style, context)
        ];
        compiledRules[i] = {
            filter,
            styles
        };
    }
    return function(context) {
        /**
     * @type {Array<Style>}
     */ const styles = [];
        let someMatched = false;
        for(let i = 0; i < length; ++i){
            const filterEvaluator = compiledRules[i].filter;
            if (!filterEvaluator(context)) continue;
            if (rules[i].else && someMatched) continue;
            someMatched = true;
            for (const styleEvaluator of compiledRules[i].styles){
                const style = styleEvaluator(context);
                if (!style) continue;
                styles.push(style);
            }
        }
        return styles;
    };
}
function buildStyle(flatStyle, context) {
    const evaluateFill = buildFill(flatStyle, '', context);
    const evaluateStroke = buildStroke(flatStyle, '', context);
    const evaluateText = buildText(flatStyle, context);
    const evaluateImage = buildImage(flatStyle, context);
    const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);
    if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !(0, _objJs.isEmpty)(flatStyle)) // assume this is a user error
    // would be nice to check the properties and suggest "did you mean..."
    throw new Error('No fill, stroke, point, or text symbolizer properties in style: ' + JSON.stringify(flatStyle));
    const style = new (0, _styleJsDefault.default)();
    return function(context) {
        let empty = true;
        if (evaluateFill) {
            const fill = evaluateFill(context);
            if (fill) empty = false;
            style.setFill(fill);
        }
        if (evaluateStroke) {
            const stroke = evaluateStroke(context);
            if (stroke) empty = false;
            style.setStroke(stroke);
        }
        if (evaluateText) {
            const text = evaluateText(context);
            if (text) empty = false;
            style.setText(text);
        }
        if (evaluateImage) {
            const image = evaluateImage(context);
            if (image) empty = false;
            style.setImage(image);
        }
        if (evaluateZIndex) style.setZIndex(evaluateZIndex(context));
        if (empty) return null;
        return style;
    };
}
/**
 * @typedef {function(EvaluationContext):Fill|null} FillEvaluator
 */ /**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @param {ParsingContext} context The parsing context.
 * @return {FillEvaluator?} A function that evaluates to a fill.
 */ function buildFill(flatStyle, prefix, context) {
    const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'fill-color', context);
    if (!evaluateColor) return null;
    const fill = new (0, _fillJsDefault.default)();
    return function(context) {
        const color = evaluateColor(context);
        if (color === 'none') return null;
        fill.setColor(color);
        return fill;
    };
}
/**
 * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator
 */ /**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @param {ParsingContext} context The parsing context.
 * @return {StrokeEvaluator?} A function the evaluates to a stroke.
 */ function buildStroke(flatStyle, prefix, context) {
    const evaluateWidth = numberEvaluator(flatStyle, prefix + 'stroke-width', context);
    const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'stroke-color', context);
    if (!evaluateWidth && !evaluateColor) return null;
    const evaluateLineCap = stringEvaluator(flatStyle, prefix + 'stroke-line-cap', context);
    const evaluateLineJoin = stringEvaluator(flatStyle, prefix + 'stroke-line-join', context);
    const evaluateLineDash = numberArrayEvaluator(flatStyle, prefix + 'stroke-line-dash', context);
    const evaluateLineDashOffset = numberEvaluator(flatStyle, prefix + 'stroke-line-dash-offset', context);
    const evaluateMiterLimit = numberEvaluator(flatStyle, prefix + 'stroke-miter-limit', context);
    const stroke = new (0, _strokeJsDefault.default)();
    return function(context) {
        if (evaluateColor) {
            const color = evaluateColor(context);
            if (color === 'none') return null;
            stroke.setColor(color);
        }
        if (evaluateWidth) stroke.setWidth(evaluateWidth(context));
        if (evaluateLineCap) {
            const lineCap = evaluateLineCap(context);
            if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') throw new Error('Expected butt, round, or square line cap');
            stroke.setLineCap(lineCap);
        }
        if (evaluateLineJoin) {
            const lineJoin = evaluateLineJoin(context);
            if (lineJoin !== 'bevel' && lineJoin !== 'round' && lineJoin !== 'miter') throw new Error('Expected bevel, round, or miter line join');
            stroke.setLineJoin(lineJoin);
        }
        if (evaluateLineDash) stroke.setLineDash(evaluateLineDash(context));
        if (evaluateLineDashOffset) stroke.setLineDashOffset(evaluateLineDashOffset(context));
        if (evaluateMiterLimit) stroke.setMiterLimit(evaluateMiterLimit(context));
        return stroke;
    };
}
/**
 * @typedef {function(EvaluationContext):Text} TextEvaluator
 */ /**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {TextEvaluator?} A function that evaluates to a text symbolizer.
 */ function buildText(flatStyle, context) {
    const prefix = 'text-';
    // Currently, an Array<string> may be used for rich text support.  This doesn't
    // work with our expression syntax where arrays of strings are interpreted as
    // call expressions.  To support rich text, we could add a 'strings' operator
    // where all the following arguments would be string values.
    const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);
    if (!evaluateValue) return null;
    const evaluateFill = buildFill(flatStyle, prefix, context);
    const evaluateBackgroundFill = buildFill(flatStyle, prefix + 'background-', context);
    const evaluateStroke = buildStroke(flatStyle, prefix, context);
    const evaluateBackgroundStroke = buildStroke(flatStyle, prefix + 'background-', context);
    const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);
    const evaluateMaxAngle = numberEvaluator(flatStyle, prefix + 'max-angle', context);
    const evaluateOffsetX = numberEvaluator(flatStyle, prefix + 'offset-x', context);
    const evaluateOffsetY = numberEvaluator(flatStyle, prefix + 'offset-y', context);
    const evaluateOverflow = booleanEvaluator(flatStyle, prefix + 'overflow', context);
    const evaluatePlacement = stringEvaluator(flatStyle, prefix + 'placement', context);
    const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
    const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);
    const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
    const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);
    const evaluateJustify = stringEvaluator(flatStyle, prefix + 'justify', context);
    const evaluateBaseline = stringEvaluator(flatStyle, prefix + 'baseline', context);
    const evaluatePadding = numberArrayEvaluator(flatStyle, prefix + 'padding', context);
    const text = new (0, _textJsDefault.default)({});
    return function(context) {
        text.setText(evaluateValue(context));
        if (evaluateFill) text.setFill(evaluateFill(context));
        if (evaluateBackgroundFill) text.setBackgroundFill(evaluateBackgroundFill(context));
        if (evaluateStroke) text.setStroke(evaluateStroke(context));
        if (evaluateBackgroundStroke) text.setBackgroundStroke(evaluateBackgroundStroke(context));
        if (evaluateFont) text.setFont(evaluateFont(context));
        if (evaluateMaxAngle) text.setMaxAngle(evaluateMaxAngle(context));
        if (evaluateOffsetX) text.setOffsetX(evaluateOffsetX(context));
        if (evaluateOffsetY) text.setOffsetY(evaluateOffsetY(context));
        if (evaluateOverflow) text.setOverflow(evaluateOverflow(context));
        if (evaluatePlacement) {
            const placement = evaluatePlacement(context);
            if (placement !== 'point' && placement !== 'line') throw new Error('Expected point or line for text-placement');
            text.setPlacement(placement);
        }
        if (evaluateRepeat) text.setRepeat(evaluateRepeat(context));
        if (evaluateScale) text.setScale(evaluateScale(context));
        if (evaluateRotateWithView) text.setRotateWithView(evaluateRotateWithView(context));
        if (evaluateRotation) text.setRotation(evaluateRotation(context));
        if (evaluateAlign) {
            const textAlign = evaluateAlign(context);
            if (textAlign !== 'left' && textAlign !== 'center' && textAlign !== 'right' && textAlign !== 'end' && textAlign !== 'start') throw new Error('Expected left, right, center, start, or end for text-align');
            text.setTextAlign(textAlign);
        }
        if (evaluateJustify) {
            const justify = evaluateJustify(context);
            if (justify !== 'left' && justify !== 'right' && justify !== 'center') throw new Error('Expected left, right, or center for text-justify');
            text.setJustify(justify);
        }
        if (evaluateBaseline) {
            const textBaseline = evaluateBaseline(context);
            if (textBaseline !== 'bottom' && textBaseline !== 'top' && textBaseline !== 'middle' && textBaseline !== 'alphabetic' && textBaseline !== 'hanging') throw new Error('Expected bottom, top, middle, alphabetic, or hanging for text-baseline');
            text.setTextBaseline(textBaseline);
        }
        if (evaluatePadding) text.setPadding(evaluatePadding(context));
        return text;
    };
}
/**
 * @typedef {function(EvaluationContext):import("../../style/Image.js").default} ImageEvaluator
 */ /**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.
 */ function buildImage(flatStyle, context) {
    if ('icon-src' in flatStyle) return buildIcon(flatStyle, context);
    if ('shape-points' in flatStyle) return buildShape(flatStyle, context);
    if ('circle-radius' in flatStyle) return buildCircle(flatStyle, context);
    return null;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to an image symbolizer.
 */ function buildIcon(flatStyle, context) {
    const prefix = 'icon-';
    // required property
    const srcName = prefix + 'src';
    const src = requireString(flatStyle[srcName], srcName);
    // settable properties
    const evaluateAnchor = coordinateEvaluator(flatStyle, prefix + 'anchor', context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
    const evaluateOpacity = numberEvaluator(flatStyle, prefix + 'opacity', context);
    const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);
    const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
    const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);
    // the remaining symbolizer properties are not currently settable
    const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');
    const anchorXUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-x-units');
    const anchorYUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-y-units');
    const color = optionalColorLike(flatStyle, prefix + 'color');
    const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');
    const offset = optionalNumberArray(flatStyle, prefix + 'offset');
    const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');
    const width = optionalNumber(flatStyle, prefix + 'width');
    const height = optionalNumber(flatStyle, prefix + 'height');
    const size = optionalSize(flatStyle, prefix + 'size');
    const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter');
    const icon = new (0, _iconJsDefault.default)({
        src,
        anchorOrigin,
        anchorXUnits,
        anchorYUnits,
        color,
        crossOrigin,
        offset,
        offsetOrigin,
        height,
        width,
        size,
        declutterMode
    });
    return function(context) {
        if (evaluateOpacity) icon.setOpacity(evaluateOpacity(context));
        if (evaluateDisplacement) icon.setDisplacement(evaluateDisplacement(context));
        if (evaluateRotation) icon.setRotation(evaluateRotation(context));
        if (evaluateRotateWithView) icon.setRotateWithView(evaluateRotateWithView(context));
        if (evaluateScale) icon.setScale(evaluateScale(context));
        if (evaluateAnchor) icon.setAnchor(evaluateAnchor(context));
        return icon;
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.
 */ function buildShape(flatStyle, context) {
    const prefix = 'shape-';
    // required property
    const pointsName = prefix + 'points';
    const points = requireNumber(flatStyle[pointsName], pointsName);
    // settable properties
    const evaluateFill = buildFill(flatStyle, prefix, context);
    const evaluateStroke = buildStroke(flatStyle, prefix, context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
    const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);
    const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
    const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);
    // the remaining properties are not currently settable
    const radius = optionalNumber(flatStyle, prefix + 'radius');
    const radius1 = optionalNumber(flatStyle, prefix + 'radius1');
    const radius2 = optionalNumber(flatStyle, prefix + 'radius2');
    const angle = optionalNumber(flatStyle, prefix + 'angle');
    const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');
    const shape = new (0, _regularShapeJsDefault.default)({
        points,
        radius,
        radius1,
        radius2,
        angle,
        declutterMode
    });
    return function(context) {
        if (evaluateFill) shape.setFill(evaluateFill(context));
        if (evaluateStroke) shape.setStroke(evaluateStroke(context));
        if (evaluateDisplacement) shape.setDisplacement(evaluateDisplacement(context));
        if (evaluateRotation) shape.setRotation(evaluateRotation(context));
        if (evaluateRotateWithView) shape.setRotateWithView(evaluateRotateWithView(context));
        if (evaluateScale) shape.setScale(evaluateScale(context));
        return shape;
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.
 */ function buildCircle(flatStyle, context) {
    const prefix = 'circle-';
    // settable properties
    const evaluateFill = buildFill(flatStyle, prefix, context);
    const evaluateStroke = buildStroke(flatStyle, prefix, context);
    const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
    const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);
    const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
    const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);
    // the remaining properties are not currently settable
    const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');
    const circle = new (0, _circleJsDefault.default)({
        radius: 5,
        declutterMode
    });
    return function(context) {
        if (evaluateRadius) circle.setRadius(evaluateRadius(context));
        if (evaluateFill) circle.setFill(evaluateFill(context));
        if (evaluateStroke) circle.setStroke(evaluateStroke(context));
        if (evaluateDisplacement) circle.setDisplacement(evaluateDisplacement(context));
        if (evaluateRotation) circle.setRotation(evaluateRotation(context));
        if (evaluateRotateWithView) circle.setRotateWithView(evaluateRotateWithView(context));
        if (evaluateScale) circle.setScale(evaluateScale(context));
        return circle;
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.
 */ function numberEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return undefined;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.NumberType), context);
    return function(context) {
        return requireNumber(evaluator(context), name);
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.
 */ function stringEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.StringType), context);
    return function(context) {
        return requireString(evaluator(context), name);
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.
 */ function booleanEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.BooleanType), context);
    return function(context) {
        const value = evaluator(context);
        if (typeof value !== 'boolean') throw new Error(`Expected a boolean for ${name}`);
        return value;
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.
 */ function colorLikeEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.ColorType) | (0, _expressionJs.StringType), context);
    return function(context) {
        return requireColorLike(evaluator(context), name);
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.
 */ function numberArrayEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.NumberArrayType), context);
    return function(context) {
        return requireNumberArray(evaluator(context), name);
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.
 */ function coordinateEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.NumberArrayType), context);
    return function(context) {
        const array = requireNumberArray(evaluator(context), name);
        if (array.length !== 2) throw new Error(`Expected two numbers for ${name}`);
        return array;
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.
 */ function sizeLikeEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.NumberArrayType) | (0, _expressionJs.NumberType), context);
    return function(context) {
        return requireSizeLike(evaluator(context), name);
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {number|undefined} A number or undefined.
 */ function optionalNumber(flatStyle, property) {
    const value = flatStyle[property];
    if (value === undefined) return undefined;
    if (typeof value !== 'number') throw new Error(`Expected a number for ${property}`);
    return value;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../size.js").Size|undefined} A size or undefined.
 */ function optionalSize(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    if (typeof encoded === 'number') return (0, _sizeJs.toSize)(encoded);
    if (!Array.isArray(encoded)) throw new Error(`Expected a number or size array for ${property}`);
    if (encoded.length !== 2 || typeof encoded[0] !== 'number' || typeof encoded[1] !== 'number') throw new Error(`Expected a number or size array for ${property}`);
    return encoded;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {string|undefined} A string or undefined.
 */ function optionalString(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    if (typeof encoded !== 'string') throw new Error(`Expected a string for ${property}`);
    return encoded;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../style/Icon.js").IconOrigin|undefined} An icon origin or undefined.
 */ function optionalIconOrigin(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    if (encoded !== 'bottom-left' && encoded !== 'bottom-right' && encoded !== 'top-left' && encoded !== 'top-right') throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${property}`);
    return encoded;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../style/Icon.js").IconAnchorUnits|undefined} Icon anchor units or undefined.
 */ function optionalIconAnchorUnits(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    if (encoded !== 'pixels' && encoded !== 'fraction') throw new Error(`Expected pixels or fraction for ${property}`);
    return encoded;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {Array<number>|undefined} An array of numbers or undefined.
 */ function optionalNumberArray(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    return requireNumberArray(encoded, property);
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {"declutter"|"obstacle"|"none"|undefined} Icon declutter mode.
 */ function optionalDeclutterMode(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    if (typeof encoded !== 'string') throw new Error(`Expected a string for ${property}`);
    if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') throw new Error(`Expected declutter, obstacle, or none for ${property}`);
    return encoded;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {string|Array<number>|undefined} A string or an array of color values or undefined.
 */ function optionalColorLike(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    return requireColorLike(encoded, property);
}
/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>} An array of numbers.
 */ function requireNumberArray(value, property) {
    if (!Array.isArray(value)) throw new Error(`Expected an array for ${property}`);
    const length = value.length;
    for(let i = 0; i < length; ++i){
        if (typeof value[i] !== 'number') throw new Error(`Expected an array of numbers for ${property}`);
    }
    return value;
}
/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {string} A string.
 */ function requireString(value, property) {
    if (typeof value !== 'string') throw new Error(`Expected a string for ${property}`);
    return value;
}
/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {number} A number.
 */ function requireNumber(value, property) {
    if (typeof value !== 'number') throw new Error(`Expected a number for ${property}`);
    return value;
}
/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>|string} A color.
 */ function requireColorLike(value, property) {
    if (typeof value === 'string') return value;
    const array = requireNumberArray(value, property);
    const length = array.length;
    if (length < 3 || length > 4) throw new Error(`Expected a color with 3 or 4 values for ${property}`);
    return array;
}
/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {number|Array<number>} A number or an array of two numbers.
 */ function requireSizeLike(value, property) {
    if (typeof value === 'number') return value;
    const size = requireNumberArray(value, property);
    if (size.length !== 2) throw new Error(`Expected an array of two numbers for ${property}`);
    return size;
}

},{"../../style/Circle.js":"3LBvw","../../style/Fill.js":"cHc7U","../../style/Icon.js":"1mjWl","../../style/RegularShape.js":"fLUBU","../../style/Stroke.js":"1uQwy","../../style/Style.js":"8opjn","../../style/Text.js":"iy7JB","../../expr/expression.js":"8u0Bf","../../expr/cpu.js":"9xcYD","../../obj.js":"7RZD4","../../size.js":"fXEON","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1mjWl":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Icon
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("./Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _colorJs = require("../color.js");
var _assertsJs = require("../asserts.js");
var _iconImageJs = require("./IconImage.js");
var _utilJs = require("../util.js");
/**
 * @typedef {'fraction' | 'pixels'} IconAnchorUnits
 * Anchor unit can be either a fraction of the icon size or in pixels.
 */ /**
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} IconOrigin
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 */ /**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {IconOrigin} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {IconAnchorUnits} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {IconAnchorUnits} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement|ImageBitmap} [img] Image object for the icon.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the icon in pixels.
 * Positive values will shift the icon right and up.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number} [width] The width of the icon in pixels. This can't be used together with `scale`.
 * @property {number} [height] The height of the icon in pixels. This can't be used together with `scale`.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {Array<number>} [offset=[0, 0]] Offset which, together with `size` and `offsetOrigin`, defines the
 * sub-rectangle to use from the original (sprite) image.
 * @property {IconOrigin} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("../size.js").Size} [size] Icon size in pixels. Used together with `offset` to define the
 * sub-rectangle to use from the original (sprite) image.
 * @property {string} [src] Image source URI.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */ /**
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {number|undefined} wantedWidth The wanted width.
 * @param {number|undefined} wantedHeight The wanted height.
 * @return {number|Array<number>} The scale.
 */ function calculateScale(width, height, wantedWidth, wantedHeight) {
    if (wantedWidth !== undefined && wantedHeight !== undefined) return [
        wantedWidth / width,
        wantedHeight / height
    ];
    if (wantedWidth !== undefined) return wantedWidth / width;
    if (wantedHeight !== undefined) return wantedHeight / height;
    return 1;
}
/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */ class Icon extends (0, _imageJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @type {number}
     */ const opacity = options.opacity !== undefined ? options.opacity : 1;
        /**
     * @type {number}
     */ const rotation = options.rotation !== undefined ? options.rotation : 0;
        /**
     * @type {number|import("../size.js").Size}
     */ const scale = options.scale !== undefined ? options.scale : 1;
        /**
     * @type {boolean}
     */ const rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
        super({
            opacity: opacity,
            rotation: rotation,
            scale: scale,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ],
            rotateWithView: rotateWithView,
            declutterMode: options.declutterMode
        });
        /**
     * @private
     * @type {Array<number>}
     */ this.anchor_ = options.anchor !== undefined ? options.anchor : [
            0.5,
            0.5
        ];
        /**
     * @private
     * @type {Array<number>}
     */ this.normalizedAnchor_ = null;
        /**
     * @private
     * @type {IconOrigin}
     */ this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : 'top-left';
        /**
     * @private
     * @type {IconAnchorUnits}
     */ this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : 'fraction';
        /**
     * @private
     * @type {IconAnchorUnits}
     */ this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : 'fraction';
        /**
     * @private
     * @type {?string}
     */ this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
        const image = options.img !== undefined ? options.img : null;
        let cacheKey = options.src;
        (0, _assertsJs.assert)(!(cacheKey !== undefined && image), '`image` and `src` cannot be provided at the same time');
        if ((cacheKey === undefined || cacheKey.length === 0) && image) cacheKey = /** @type {HTMLImageElement} */ image.src || (0, _utilJs.getUid)(image);
        (0, _assertsJs.assert)(cacheKey !== undefined && cacheKey.length > 0, 'A defined and non-empty `src` or `image` must be provided');
        (0, _assertsJs.assert)(!((options.width !== undefined || options.height !== undefined) && options.scale !== undefined), '`width` or `height` cannot be provided together with `scale`');
        let imageState;
        if (options.src !== undefined) imageState = (0, _imageStateJsDefault.default).IDLE;
        else if (image !== undefined) {
            if (image instanceof HTMLImageElement) {
                if (image.complete) imageState = image.src ? (0, _imageStateJsDefault.default).LOADED : (0, _imageStateJsDefault.default).IDLE;
                else imageState = (0, _imageStateJsDefault.default).LOADING;
            } else imageState = (0, _imageStateJsDefault.default).LOADED;
        }
        /**
     * @private
     * @type {import("../color.js").Color}
     */ this.color_ = options.color !== undefined ? (0, _colorJs.asArray)(options.color) : null;
        /**
     * @private
     * @type {import("./IconImage.js").default}
     */ this.iconImage_ = (0, _iconImageJs.get)(image, /** @type {string} */ cacheKey, this.crossOrigin_, imageState, this.color_);
        /**
     * @private
     * @type {Array<number>}
     */ this.offset_ = options.offset !== undefined ? options.offset : [
            0,
            0
        ];
        /**
     * @private
     * @type {IconOrigin}
     */ this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : 'top-left';
        /**
     * @private
     * @type {Array<number>}
     */ this.origin_ = null;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.size_ = options.size !== undefined ? options.size : null;
        /**
     * Calculate the scale if width or height were given.
     */ if (options.width !== undefined || options.height !== undefined) {
            let width, height;
            if (options.size) [width, height] = options.size;
            else {
                const image = this.getImage(1);
                if (image.width && image.height) {
                    width = image.width;
                    height = image.height;
                } else if (image instanceof HTMLImageElement) {
                    this.initialOptions_ = options;
                    const onload = ()=>{
                        this.unlistenImageChange(onload);
                        if (!this.initialOptions_) return;
                        const imageSize = this.iconImage_.getSize();
                        this.setScale(calculateScale(imageSize[0], imageSize[1], options.width, options.height));
                    };
                    this.listenImageChange(onload);
                    return;
                }
            }
            if (width !== undefined) this.setScale(calculateScale(width, height, options.width, options.height));
        }
    }
    /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */ clone() {
        let scale, width, height;
        if (this.initialOptions_) {
            width = this.initialOptions_.width;
            height = this.initialOptions_.height;
        } else {
            scale = this.getScale();
            scale = Array.isArray(scale) ? scale.slice() : scale;
        }
        return new Icon({
            anchor: this.anchor_.slice(),
            anchorOrigin: this.anchorOrigin_,
            anchorXUnits: this.anchorXUnits_,
            anchorYUnits: this.anchorYUnits_,
            color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
            crossOrigin: this.crossOrigin_,
            offset: this.offset_.slice(),
            offsetOrigin: this.offsetOrigin_,
            opacity: this.getOpacity(),
            rotateWithView: this.getRotateWithView(),
            rotation: this.getRotation(),
            scale,
            width,
            height,
            size: this.size_ !== null ? this.size_.slice() : undefined,
            src: this.getSrc(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
    }
    /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */ getAnchor() {
        let anchor = this.normalizedAnchor_;
        if (!anchor) {
            anchor = this.anchor_;
            const size = this.getSize();
            if (this.anchorXUnits_ == 'fraction' || this.anchorYUnits_ == 'fraction') {
                if (!size) return null;
                anchor = this.anchor_.slice();
                if (this.anchorXUnits_ == 'fraction') anchor[0] *= size[0];
                if (this.anchorYUnits_ == 'fraction') anchor[1] *= size[1];
            }
            if (this.anchorOrigin_ != 'top-left') {
                if (!size) return null;
                if (anchor === this.anchor_) anchor = this.anchor_.slice();
                if (this.anchorOrigin_ == 'top-right' || this.anchorOrigin_ == 'bottom-right') anchor[0] = -anchor[0] + size[0];
                if (this.anchorOrigin_ == 'bottom-left' || this.anchorOrigin_ == 'bottom-right') anchor[1] = -anchor[1] + size[1];
            }
            this.normalizedAnchor_ = anchor;
        }
        const displacement = this.getDisplacement();
        const scale = this.getScaleArray();
        // anchor is scaled by renderer but displacement should not be scaled
        // so divide by scale here
        return [
            anchor[0] - displacement[0] / scale[0],
            anchor[1] + displacement[1] / scale[1]
        ];
    }
    /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */ setAnchor(anchor) {
        this.anchor_ = anchor;
        this.normalizedAnchor_ = null;
    }
    /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */ getColor() {
        return this.color_;
    }
    /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   */ getImage(pixelRatio) {
        return this.iconImage_.getImage(pixelRatio);
    }
    /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */ getPixelRatio(pixelRatio) {
        return this.iconImage_.getPixelRatio(pixelRatio);
    }
    /**
   * @return {import("../size.js").Size} Image size.
   */ getImageSize() {
        return this.iconImage_.getSize();
    }
    /**
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return this.iconImage_.getImageState();
    }
    /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */ getHitDetectionImage() {
        return this.iconImage_.getHitDetectionImage();
    }
    /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */ getOrigin() {
        if (this.origin_) return this.origin_;
        let offset = this.offset_;
        if (this.offsetOrigin_ != 'top-left') {
            const size = this.getSize();
            const iconImageSize = this.iconImage_.getSize();
            if (!size || !iconImageSize) return null;
            offset = offset.slice();
            if (this.offsetOrigin_ == 'top-right' || this.offsetOrigin_ == 'bottom-right') offset[0] = iconImageSize[0] - size[0] - offset[0];
            if (this.offsetOrigin_ == 'bottom-left' || this.offsetOrigin_ == 'bottom-right') offset[1] = iconImageSize[1] - size[1] - offset[1];
        }
        this.origin_ = offset;
        return this.origin_;
    }
    /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */ getSrc() {
        return this.iconImage_.getSrc();
    }
    /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */ getSize() {
        return !this.size_ ? this.iconImage_.getSize() : this.size_;
    }
    /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */ getWidth() {
        const scale = this.getScaleArray();
        if (this.size_) return this.size_[0] * scale[0];
        if (this.iconImage_.getImageState() == (0, _imageStateJsDefault.default).LOADED) return this.iconImage_.getSize()[0] * scale[0];
        return undefined;
    }
    /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */ getHeight() {
        const scale = this.getScaleArray();
        if (this.size_) return this.size_[1] * scale[1];
        if (this.iconImage_.getImageState() == (0, _imageStateJsDefault.default).LOADED) return this.iconImage_.getSize()[1] * scale[1];
        return undefined;
    }
    /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */ setScale(scale) {
        delete this.initialOptions_;
        super.setScale(scale);
    }
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ listenImageChange(listener) {
        this.iconImage_.addEventListener((0, _eventTypeJsDefault.default).CHANGE, listener);
    }
    /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */ load() {
        this.iconImage_.load();
    }
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ unlistenImageChange(listener) {
        this.iconImage_.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, listener);
    }
}
exports.default = Icon;

},{"../events/EventType.js":"3uT2C","../ImageState.js":"jCrEd","./Image.js":"4PQUx","../color.js":"h6hAX","../asserts.js":"k0OL6","./IconImage.js":"dGTgt","../util.js":"l1iPW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dGTgt":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/IconImage
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
 * @param {string} cacheKey Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */ parcelHelpers.export(exports, "get", ()=>get);
var _targetJs = require("../events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _colorJs = require("../color.js");
var _domJs = require("../dom.js");
var _imageJs = require("../Image.js");
var _iconImageCacheJs = require("./IconImageCache.js");
/**
 * @type {CanvasRenderingContext2D}
 */ let taintedTestContext = null;
class IconImage extends (0, _targetJsDefault.default) {
    /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */ constructor(image, src, crossOrigin, imageState, color){
        super();
        /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap}
     */ this.hitDetectionImage_ = null;
        /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap}
     */ this.image_ = image;
        /**
     * @private
     * @type {string|null}
     */ this.crossOrigin_ = crossOrigin;
        /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */ this.canvas_ = {};
        /**
     * @private
     * @type {import("../color.js").Color}
     */ this.color_ = color;
        /**
     * @private
     * @type {import("../ImageState.js").default}
     */ this.imageState_ = imageState === undefined ? (0, _imageStateJsDefault.default).IDLE : imageState;
        /**
     * @private
     * @type {import("../size.js").Size|null}
     */ this.size_ = image && image.width && image.height ? [
            image.width,
            image.height
        ] : null;
        /**
     * @private
     * @type {string|undefined}
     */ this.src_ = src;
        /**
     * @private
     */ this.tainted_;
    }
    /**
   * @private
   */ initializeImage_() {
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) this.image_.crossOrigin = this.crossOrigin_;
    }
    /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */ isTainted_() {
        if (this.tainted_ === undefined && this.imageState_ === (0, _imageStateJsDefault.default).LOADED) {
            if (!taintedTestContext) taintedTestContext = (0, _domJs.createCanvasContext2D)(1, 1, undefined, {
                willReadFrequently: true
            });
            taintedTestContext.drawImage(this.image_, 0, 0);
            try {
                taintedTestContext.getImageData(0, 0, 1, 1);
                this.tainted_ = false;
            } catch (e) {
                taintedTestContext = null;
                this.tainted_ = true;
            }
        }
        return this.tainted_ === true;
    }
    /**
   * @private
   */ dispatchChangeEvent_() {
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * @private
   */ handleImageError_() {
        this.imageState_ = (0, _imageStateJsDefault.default).ERROR;
        this.dispatchChangeEvent_();
    }
    /**
   * @private
   */ handleImageLoad_() {
        this.imageState_ = (0, _imageStateJsDefault.default).LOADED;
        this.size_ = [
            this.image_.width,
            this.image_.height
        ];
        this.dispatchChangeEvent_();
    }
    /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */ getImage(pixelRatio) {
        if (!this.image_) this.initializeImage_();
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
    }
    /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */ getPixelRatio(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
    }
    /**
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return this.imageState_;
    }
    /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */ getHitDetectionImage() {
        if (!this.image_) this.initializeImage_();
        if (!this.hitDetectionImage_) {
            if (this.isTainted_()) {
                const width = this.size_[0];
                const height = this.size_[1];
                const context = (0, _domJs.createCanvasContext2D)(width, height);
                context.fillRect(0, 0, width, height);
                this.hitDetectionImage_ = context.canvas;
            } else this.hitDetectionImage_ = this.image_;
        }
        return this.hitDetectionImage_;
    }
    /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */ getSize() {
        return this.size_;
    }
    /**
   * @return {string|undefined} Image src.
   */ getSrc() {
        return this.src_;
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.imageState_ !== (0, _imageStateJsDefault.default).IDLE) return;
        if (!this.image_) this.initializeImage_();
        this.imageState_ = (0, _imageStateJsDefault.default).LOADING;
        try {
            if (this.src_ !== undefined) /** @type {HTMLImageElement} */ this.image_.src = this.src_;
        } catch (e) {
            this.handleImageError_();
        }
        if (this.image_ instanceof HTMLImageElement) (0, _imageJs.decodeFallback)(this.image_, this.src_).then((image)=>{
            this.image_ = image;
            this.handleImageLoad_();
        }).catch(this.handleImageError_.bind(this));
    }
    /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */ replaceColor_(pixelRatio) {
        if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== (0, _imageStateJsDefault.default).LOADED) return;
        const image = this.image_;
        const canvas = document.createElement('canvas');
        canvas.width = Math.ceil(image.width * pixelRatio);
        canvas.height = Math.ceil(image.height * pixelRatio);
        const ctx = canvas.getContext('2d');
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(image, 0, 0);
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = (0, _colorJs.asString)(this.color_);
        ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
        ctx.globalCompositeOperation = 'destination-in';
        ctx.drawImage(image, 0, 0);
        this.canvas_[pixelRatio] = canvas;
    }
}
function get(image, cacheKey, crossOrigin, imageState, color) {
    let iconImage = cacheKey === undefined ? undefined : (0, _iconImageCacheJs.shared).get(cacheKey, crossOrigin, color);
    if (!iconImage) {
        iconImage = new IconImage(image, image instanceof HTMLImageElement ? image.src || undefined : cacheKey, crossOrigin, imageState, color);
        (0, _iconImageCacheJs.shared).set(cacheKey, crossOrigin, color, iconImage);
    }
    return iconImage;
}
exports.default = IconImage;

},{"../events/Target.js":"dZel6","../events/EventType.js":"3uT2C","../ImageState.js":"jCrEd","../color.js":"h6hAX","../dom.js":"h98kD","../Image.js":"7I8uM","./IconImageCache.js":"aj9Mo","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iy7JB":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Text
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fillJs = require("./Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _sizeJs = require("../size.js");
/**
 * @typedef {'point' | 'line'} TextPlacement
 * Default text placement is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 */ /**
 * @typedef {'left' | 'center' | 'right'} TextJustify
 */ /**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */ const DEFAULT_FILL_COLOR = '#333';
/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {TextPlacement} [placement='point'] Text placement.
 * @property {number} [repeat] Repeat interval. When set, the text will be repeated at this interval, which specifies
 * the distance between two text anchors in pixels. Only available when `placement` is set to `'line'`. Overrides 'textAlign'.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for `placement: 'line'` or the immediate rendering API.
 * @property {CanvasTextAlign} [textAlign] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {TextJustify} [justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.
 * @property {CanvasTextBaseline} [textBaseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {import("./Fill.js").default|null} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333). Specify `null` for no fill.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */ /**
 * @classdesc
 * Set text style for vector features.
 * @api
 */ class Text {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {string|undefined}
     */ this.font_ = options.font;
        /**
     * @private
     * @type {number|undefined}
     */ this.rotation_ = options.rotation;
        /**
     * @private
     * @type {boolean|undefined}
     */ this.rotateWithView_ = options.rotateWithView;
        /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */ this.scale_ = options.scale;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.scaleArray_ = (0, _sizeJs.toSize)(options.scale !== undefined ? options.scale : 1);
        /**
     * @private
     * @type {string|Array<string>|undefined}
     */ this.text_ = options.text;
        /**
     * @private
     * @type {CanvasTextAlign|undefined}
     */ this.textAlign_ = options.textAlign;
        /**
     * @private
     * @type {TextJustify|undefined}
     */ this.justify_ = options.justify;
        /**
     * @private
     * @type {number|undefined}
     */ this.repeat_ = options.repeat;
        /**
     * @private
     * @type {CanvasTextBaseline|undefined}
     */ this.textBaseline_ = options.textBaseline;
        /**
     * @private
     * @type {import("./Fill.js").default|null}
     */ this.fill_ = options.fill !== undefined ? options.fill : new (0, _fillJsDefault.default)({
            color: DEFAULT_FILL_COLOR
        });
        /**
     * @private
     * @type {number}
     */ this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
        /**
     * @private
     * @type {TextPlacement}
     */ this.placement_ = options.placement !== undefined ? options.placement : 'point';
        /**
     * @private
     * @type {boolean}
     */ this.overflow_ = !!options.overflow;
        /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
     * @private
     * @type {number}
     */ this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
        /**
     * @private
     * @type {number}
     */ this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
        /**
     * @private
     * @type {import("./Fill.js").default|null}
     */ this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
        /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */ this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.padding_ = options.padding === undefined ? null : options.padding;
    }
    /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        return new Text({
            font: this.getFont(),
            placement: this.getPlacement(),
            repeat: this.getRepeat(),
            maxAngle: this.getMaxAngle(),
            overflow: this.getOverflow(),
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            text: this.getText(),
            textAlign: this.getTextAlign(),
            justify: this.getJustify(),
            textBaseline: this.getTextBaseline(),
            fill: this.getFill() ? this.getFill().clone() : undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            offsetX: this.getOffsetX(),
            offsetY: this.getOffsetY(),
            backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,
            backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined,
            padding: this.getPadding() || undefined
        });
    }
    /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */ getOverflow() {
        return this.overflow_;
    }
    /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */ getFont() {
        return this.font_;
    }
    /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */ getMaxAngle() {
        return this.maxAngle_;
    }
    /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */ getPlacement() {
        return this.placement_;
    }
    /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */ getRepeat() {
        return this.repeat_;
    }
    /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */ getOffsetX() {
        return this.offsetX_;
    }
    /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */ getOffsetY() {
        return this.offsetY_;
    }
    /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */ getFill() {
        return this.fill_;
    }
    /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */ getRotateWithView() {
        return this.rotateWithView_;
    }
    /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */ getRotation() {
        return this.rotation_;
    }
    /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */ getScale() {
        return this.scale_;
    }
    /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */ getScaleArray() {
        return this.scaleArray_;
    }
    /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */ getStroke() {
        return this.stroke_;
    }
    /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */ getText() {
        return this.text_;
    }
    /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */ getTextAlign() {
        return this.textAlign_;
    }
    /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */ getJustify() {
        return this.justify_;
    }
    /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */ getTextBaseline() {
        return this.textBaseline_;
    }
    /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */ getBackgroundFill() {
        return this.backgroundFill_;
    }
    /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */ getBackgroundStroke() {
        return this.backgroundStroke_;
    }
    /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */ getPadding() {
        return this.padding_;
    }
    /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */ setOverflow(overflow) {
        this.overflow_ = overflow;
    }
    /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */ setFont(font) {
        this.font_ = font;
    }
    /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */ setMaxAngle(maxAngle) {
        this.maxAngle_ = maxAngle;
    }
    /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */ setOffsetX(offsetX) {
        this.offsetX_ = offsetX;
    }
    /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */ setOffsetY(offsetY) {
        this.offsetY_ = offsetY;
    }
    /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */ setPlacement(placement) {
        this.placement_ = placement;
    }
    /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */ setRepeat(repeat) {
        this.repeat_ = repeat;
    }
    /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */ setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
    }
    /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */ setFill(fill) {
        this.fill_ = fill;
    }
    /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */ setRotation(rotation) {
        this.rotation_ = rotation;
    }
    /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */ setScale(scale) {
        this.scale_ = scale;
        this.scaleArray_ = (0, _sizeJs.toSize)(scale !== undefined ? scale : 1);
    }
    /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */ setStroke(stroke) {
        this.stroke_ = stroke;
    }
    /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */ setText(text) {
        this.text_ = text;
    }
    /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */ setTextAlign(textAlign) {
        this.textAlign_ = textAlign;
    }
    /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */ setJustify(justify) {
        this.justify_ = justify;
    }
    /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */ setTextBaseline(textBaseline) {
        this.textBaseline_ = textBaseline;
    }
    /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */ setBackgroundFill(fill) {
        this.backgroundFill_ = fill;
    }
    /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */ setBackgroundStroke(stroke) {
        this.backgroundStroke_ = stroke;
    }
    /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */ setPadding(padding) {
        this.padding_ = padding;
    }
}
exports.default = Text;

},{"./Fill.js":"cHc7U","../size.js":"fXEON","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8u0Bf":[function(require,module,exports,__globalThis) {
/**
 * @module ol/expr/expression
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoneType", ()=>NoneType);
parcelHelpers.export(exports, "BooleanType", ()=>BooleanType);
parcelHelpers.export(exports, "NumberType", ()=>NumberType);
parcelHelpers.export(exports, "StringType", ()=>StringType);
parcelHelpers.export(exports, "ColorType", ()=>ColorType);
parcelHelpers.export(exports, "NumberArrayType", ()=>NumberArrayType);
parcelHelpers.export(exports, "AnyType", ()=>AnyType);
/**
 * Get a string representation for a type.
 * @param {number} type The type.
 * @return {string} The type name.
 */ parcelHelpers.export(exports, "typeName", ()=>typeName);
/**
 * @param {number} broad The broad type.
 * @param {number} specific The specific type.
 * @return {boolean} The broad type includes the specific type.
 */ parcelHelpers.export(exports, "includesType", ()=>includesType);
/**
 * @param {number} oneType One type.
 * @param {number} otherType Another type.
 * @return {boolean} The set of types overlap (share a common specific type)
 */ parcelHelpers.export(exports, "overlapsType", ()=>overlapsType);
/**
 * @param {number} type The type.
 * @param {number} expected The expected type.
 * @return {boolean} The given type is exactly the expected type.
 */ parcelHelpers.export(exports, "isType", ()=>isType);
/**
 * @typedef {boolean|number|string|Array<number>} LiteralValue
 */ parcelHelpers.export(exports, "LiteralExpression", ()=>LiteralExpression);
parcelHelpers.export(exports, "CallExpression", ()=>CallExpression);
/**
 * @typedef {LiteralExpression|CallExpression} Expression
 */ /**
 * @typedef {Object} ParsingContext
 * @property {Set<string>} variables Variables referenced with the 'var' operator.
 * @property {Set<string>} properties Properties referenced with the 'get' operator.
 * @property {boolean} featureId The style uses the feature id.
 * @property {import("../style/flat.js").FlatStyle|import("../style/webgl.js").WebGLStyle} style The style being parsed
 */ /**
 * @return {ParsingContext} A new parsing context.
 */ parcelHelpers.export(exports, "newParsingContext", ()=>newParsingContext);
/**
 * @typedef {LiteralValue|Array} EncodedExpression
 */ /**
 * @param {EncodedExpression} encoded The encoded expression.
 * @param {ParsingContext} context The parsing context.
 * @param {number} [typeHint] Optional type hint
 * @return {Expression} The parsed expression result.
 */ parcelHelpers.export(exports, "parse", ()=>parse);
parcelHelpers.export(exports, "Ops", ()=>Ops);
var _arrayJs = require("../array.js");
var _colorJs = require("../color.js");
/**
 * @fileoverview This module includes types and functions for parsing array encoded expressions.
 * The result of parsing an encoded expression is one of the specific expression classes.
 * During parsing, information is added to the parsing context about the data accessed by the
 * expression.
 */ /**
 * Base type used for literal style parameters; can be a number literal or the output of an operator,
 * which in turns takes {@link import("./expression.js").ExpressionValue} arguments.
 *
 * The following operators can be used:
 *
 * * Reading operators:
 *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band
 *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values
 *     are in the 0..1 range. {@link import("../source/TileImage.js").default} sources have 4 bands: red,
 *     green, blue and alpha. {@link import("../source/DataTile.js").default} sources can have any number
 *     of bands, depending on the underlying data source and
 *     {@link import("../source/GeoTIFF.js").Options configuration}. `xOffset` and `yOffset` are optional
 *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.
 *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`
 *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which
 *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'
 *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'
 *     `Multi*` values are returned as their singular equivalent
 *     `Circle` geometries are returned as 'Polygon'
 *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection
 *   * `['resolution']` returns the current resolution
 *   * `['time']` returns the time in seconds since the creation of the layer
 *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined
 *   * `['zoom']` returns the current zoom level
 *
 * * Math operators:
 *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)
 *   * `['/', value1, value2]` divides `value1` by `value2`
 *   * `['+', value1, value2, ...]` adds the values
 *   * `['-', value1, value2]` subtracts `value2` from `value1`
 *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`
 *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)
 *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power
 *   * `['abs', value1]` returns the absolute value of `value1`
 *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`
 *   * `['round', value1]` returns the nearest integer to `value1`
 *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`
 *   * `['sin', value1]` returns the sine of `value1`
 *   * `['cos', value1]` returns the cosine of `value1`
 *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`
 *   * `['sqrt', value1]` returns the square root of `value1`
 *
 * * Transform operators:
 *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding
 *     condition evaluates to `true`. If no match is found, returns the `fallback` value.
 *     All conditions should be `boolean`, output and fallback can be any kind.
 *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all
 *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,
 *     returns the `fallback` value.
 *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and
 *     `fallback` values must be of the same type, and can be of any kind.
 *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between
 *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is
 *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value
 *     of 1 is equivalent to `['linear']`.
 *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.
 *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised
 *     between `output1` and `outputN`.
 *
 * * Logical operators:
 *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.
 *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.
 *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.
 *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.
 *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.
 *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.
 *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.
 *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.
 *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.
 *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`
 *     (inclusively), or `false` otherwise.
 *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and
 *     `false` otherwise.
 *     This operator has the following limitations:
 *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)
 *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an
 *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:
 *     `['literal', ['abc', 'def', 'ghi']]`
 *
 * * Conversion operators:
 *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of
 *     values can currently only be 2, 3 or 4.
 *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is
 *     optional; if not specified, it will be set to 1.
 *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.
 *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`
 *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors
 *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),
 *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b
 *     in the 0-255 range and a in the 0-1 range).
 *
 * Values can either be literals or another operator, as they will be evaluated recursively.
 * Literal values can be of the following types:
 * * `boolean`
 * * `number`
 * * `number[]` (number arrays can only have a length of 2, 3 or 4)
 * * `string`
 * * {@link module:ol/color~Color}
 *
 * @typedef {Array<*>|import("../color.js").Color|string|number|boolean} ExpressionValue
 * @api
 */ let numTypes = 0;
const NoneType = 0;
const BooleanType = 1 << numTypes++;
const NumberType = 1 << numTypes++;
const StringType = 1 << numTypes++;
const ColorType = 1 << numTypes++;
const NumberArrayType = 1 << numTypes++;
const AnyType = Math.pow(2, numTypes) - 1;
const typeNames = {
    [BooleanType]: 'boolean',
    [NumberType]: 'number',
    [StringType]: 'string',
    [ColorType]: 'color',
    [NumberArrayType]: 'number[]'
};
const namedTypes = Object.keys(typeNames).map(Number).sort((0, _arrayJs.ascending));
function typeName(type) {
    const names = [];
    for (const namedType of namedTypes)if (includesType(type, namedType)) names.push(typeNames[namedType]);
    if (names.length === 0) return 'untyped';
    if (names.length < 3) return names.join(' or ');
    return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];
}
function includesType(broad, specific) {
    return (broad & specific) === specific;
}
function overlapsType(oneType, otherType) {
    return !!(oneType & otherType);
}
function isType(type, expected) {
    return type === expected;
}
class LiteralExpression {
    /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */ constructor(type, value){
        this.type = type;
        this.value = value;
    }
}
class CallExpression {
    /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */ constructor(type, operator, ...args){
        this.type = type;
        this.operator = operator;
        this.args = args;
    }
}
function newParsingContext() {
    return {
        variables: new Set(),
        properties: new Set(),
        featureId: false,
        style: {}
    };
}
/**
 * @param {string} typeHint Type hint
 * @return {number} Resulting value type (will be a single type)
 */ function getTypeFromHint(typeHint) {
    switch(typeHint){
        case 'string':
            return StringType;
        case 'color':
            return ColorType;
        case 'number':
            return NumberType;
        case 'boolean':
            return BooleanType;
        case 'number[]':
            return NumberArrayType;
        default:
            throw new Error(`Unrecognized type hint: ${typeHint}`);
    }
}
function parse(encoded, context, typeHint) {
    switch(typeof encoded){
        case 'boolean':
            return new LiteralExpression(BooleanType, encoded);
        case 'number':
            return new LiteralExpression(NumberType, encoded);
        case 'string':
            {
                let type = StringType;
                if ((0, _colorJs.isStringColor)(encoded)) type |= ColorType;
                // apply the given type hint only if it won't result in an empty type
                if (!isType(type & typeHint, NoneType)) type &= typeHint;
                return new LiteralExpression(type, encoded);
            }
        default:
    }
    if (!Array.isArray(encoded)) throw new Error('Expression must be an array or a primitive value');
    if (encoded.length === 0) throw new Error('Empty expression');
    if (typeof encoded[0] === 'string') return parseCallExpression(encoded, context, typeHint);
    for (const item of encoded){
        if (typeof item !== 'number') throw new Error('Expected an array of numbers');
    }
    let type = NumberArrayType;
    if (encoded.length === 3 || encoded.length === 4) type |= ColorType;
    if (typeHint) type &= typeHint;
    return new LiteralExpression(type, encoded);
}
const Ops = {
    Get: 'get',
    Var: 'var',
    Concat: 'concat',
    GeometryType: 'geometry-type',
    Any: 'any',
    All: 'all',
    Not: '!',
    Resolution: 'resolution',
    Zoom: 'zoom',
    Time: 'time',
    Equal: '==',
    NotEqual: '!=',
    GreaterThan: '>',
    GreaterThanOrEqualTo: '>=',
    LessThan: '<',
    LessThanOrEqualTo: '<=',
    Multiply: '*',
    Divide: '/',
    Add: '+',
    Subtract: '-',
    Clamp: 'clamp',
    Mod: '%',
    Pow: '^',
    Abs: 'abs',
    Floor: 'floor',
    Ceil: 'ceil',
    Round: 'round',
    Sin: 'sin',
    Cos: 'cos',
    Atan: 'atan',
    Sqrt: 'sqrt',
    Match: 'match',
    Between: 'between',
    Interpolate: 'interpolate',
    Case: 'case',
    In: 'in',
    Number: 'number',
    String: 'string',
    Array: 'array',
    Color: 'color',
    Id: 'id',
    Band: 'band',
    Palette: 'palette'
};
/**
 * @typedef {function(Array, ParsingContext, number):Expression} Parser
 * Third argument is a type hint
 */ /**
 * @type {Object<string, Parser>}
 */ const parsers = {
    [Ops.Get]: createParser(([_, typeHint])=>{
        if (typeHint !== undefined) return getTypeFromHint(/** @type {string} */ /** @type {LiteralExpression} */ typeHint.value);
        return AnyType;
    }, withArgsCount(1, 2), withGetArgs),
    [Ops.Var]: createParser(([firstArg])=>firstArg.type, withArgsCount(1, 1), withVarArgs),
    [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),
    [Ops.Concat]: createParser(StringType, withArgsCount(2, Infinity), parseArgsOfType(AnyType)),
    [Ops.GeometryType]: createParser(StringType, withNoArgs),
    [Ops.Resolution]: createParser(NumberType, withNoArgs),
    [Ops.Zoom]: createParser(NumberType, withNoArgs),
    [Ops.Time]: createParser(NumberType, withNoArgs),
    [Ops.Any]: createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType)),
    [Ops.All]: createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType)),
    [Ops.Not]: createParser(BooleanType, withArgsCount(1, 1), parseArgsOfType(BooleanType)),
    [Ops.Equal]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.NotEqual]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.GreaterThan]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.GreaterThanOrEqualTo]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.LessThan]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.LessThanOrEqualTo]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.Multiply]: createParser((parsedArgs)=>{
        let outputType = NumberType | ColorType;
        for(let i = 0; i < parsedArgs.length; i++)outputType &= parsedArgs[i].type;
        return outputType;
    }, withArgsCount(2, Infinity), parseArgsOfType(NumberType | ColorType), narrowArgsType),
    [Ops.Divide]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),
    [Ops.Add]: createParser(NumberType, withArgsCount(2, Infinity), parseArgsOfType(NumberType)),
    [Ops.Subtract]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),
    [Ops.Clamp]: createParser(NumberType, withArgsCount(3, 3), parseArgsOfType(NumberType)),
    [Ops.Mod]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),
    [Ops.Pow]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),
    [Ops.Abs]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Floor]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Ceil]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Round]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Sin]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Cos]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Atan]: createParser(NumberType, withArgsCount(1, 2), parseArgsOfType(NumberType)),
    [Ops.Sqrt]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Match]: createParser((parsedArgs)=>{
        let type = AnyType;
        for(let i = 2; i < parsedArgs.length; i += 2)type &= parsedArgs[i].type;
        type &= parsedArgs[parsedArgs.length - 1].type;
        return type;
    }, withArgsCount(4, Infinity), withEvenArgs, parseMatchArgs),
    [Ops.Between]: createParser(BooleanType, withArgsCount(3, 3), parseArgsOfType(NumberType)),
    [Ops.Interpolate]: createParser((parsedArgs)=>{
        let type = ColorType | NumberType;
        for(let i = 3; i < parsedArgs.length; i += 2)type &= parsedArgs[i].type;
        return type;
    }, withArgsCount(6, Infinity), withEvenArgs, parseInterpolateArgs),
    [Ops.Case]: createParser((parsedArgs)=>{
        let type = AnyType;
        for(let i = 1; i < parsedArgs.length; i += 2)type &= parsedArgs[i].type;
        type &= parsedArgs[parsedArgs.length - 1].type;
        return type;
    }, withArgsCount(3, Infinity), withOddArgs, parseCaseArgs),
    [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),
    [Ops.Number]: createParser(NumberType, withArgsCount(1, Infinity), parseArgsOfType(AnyType)),
    [Ops.String]: createParser(StringType, withArgsCount(1, Infinity), parseArgsOfType(AnyType)),
    [Ops.Array]: createParser((parsedArgs)=>{
        return parsedArgs.length === 3 || parsedArgs.length === 4 ? NumberArrayType | ColorType : NumberArrayType;
    }, withArgsCount(1, Infinity), parseArgsOfType(NumberType)),
    [Ops.Color]: createParser(ColorType, withArgsCount(3, 4), parseArgsOfType(NumberType)),
    [Ops.Band]: createParser(NumberType, withArgsCount(1, 3), parseArgsOfType(NumberType)),
    [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs)
};
/**
 * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator
 * An argument validator applies various checks to an encoded expression arguments
 * Returns the parsed arguments if any.
 * Third argument is the array of parsed arguments from previous validators
 * Fourth argument is an optional type hint
 */ /**
 * @type ArgValidator
 */ function withGetArgs(encoded, context) {
    const arg = parse(encoded[1], context);
    if (!(arg instanceof LiteralExpression)) throw new Error('Expected a literal argument for get operation');
    if (typeof arg.value !== 'string') throw new Error('Expected a string argument for get operation');
    context.properties.add(arg.value);
    if (encoded.length === 3) {
        const hint = parse(encoded[2], context);
        return [
            arg,
            hint
        ];
    }
    return [
        arg
    ];
}
/**
 * @type ArgValidator
 */ function withVarArgs(encoded, context, parsedArgs, typeHint) {
    const varName = encoded[1];
    if (typeof varName !== 'string') throw new Error('Expected a string argument for var operation');
    context.variables.add(varName);
    if (!('variables' in context.style) || context.style.variables[varName] === undefined) return [
        new LiteralExpression(AnyType, varName)
    ];
    const initialValue = context.style.variables[varName];
    const arg = /** @type {LiteralExpression} */ parse(initialValue, context);
    arg.value = varName;
    if (typeHint && !overlapsType(typeHint, arg.type)) throw new Error(`The variable ${varName} has type ${typeName(arg.type)} but the following type was expected: ${typeName(typeHint)}`);
    return [
        arg
    ];
}
/**
 * @type ArgValidator
 */ function usesFeatureId(encoded, context) {
    context.featureId = true;
}
/**
 * @type ArgValidator
 */ function withNoArgs(encoded, context) {
    const operation = encoded[0];
    if (encoded.length !== 1) throw new Error(`Expected no arguments for ${operation} operation`);
    return [];
}
/**
 * @param {number} minArgs The minimum number of arguments.
 * @param {number} maxArgs The maximum number of arguments.
 * @return {ArgValidator} The argument validator
 */ function withArgsCount(minArgs, maxArgs) {
    return function(encoded, context) {
        const operation = encoded[0];
        const argCount = encoded.length - 1;
        if (minArgs === maxArgs) {
            if (argCount !== minArgs) {
                const plural = minArgs === 1 ? '' : 's';
                throw new Error(`Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`);
            }
        } else if (argCount < minArgs || argCount > maxArgs) {
            const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;
            throw new Error(`Expected ${range} arguments for ${operation}, got ${argCount}`);
        }
    };
}
/**
 * @param {number} argType The argument type.
 * @return {ArgValidator} The argument validator
 */ function parseArgsOfType(argType) {
    return function(encoded, context) {
        const operation = encoded[0];
        const argCount = encoded.length - 1;
        /**
     * @type {Array<Expression>}
     */ const args = new Array(argCount);
        for(let i = 0; i < argCount; ++i){
            const expression = parse(encoded[i + 1], context);
            if (!overlapsType(argType, expression.type)) {
                const gotType = typeName(argType);
                const expectedType = typeName(expression.type);
                throw new Error(`Unexpected type for argument ${i} of ${operation} operation` + `, got ${gotType} but expected ${expectedType}`);
            }
            expression.type &= argType;
            args[i] = expression;
        }
        return args;
    };
}
/**
 * @type {ArgValidator}
 */ function narrowArgsType(encoded, context, parsedArgs) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    // first pass to determine a narrowed down type
    let sameType = AnyType;
    for(let i = 0; i < parsedArgs.length; ++i)sameType &= parsedArgs[i].type;
    if (sameType === NoneType) throw new Error(`No common type could be found for arguments of ${operation} operation`);
    // re-parse args
    const args = new Array(argCount);
    for(let i = 0; i < argCount; ++i)args[i] = parse(encoded[i + 1], context, sameType);
    return args;
}
/**
 * @type {ArgValidator}
 */ function withOddArgs(encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (argCount % 2 === 0) throw new Error(`An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(argCount)} instead`);
}
/**
 * @type {ArgValidator}
 */ function withEvenArgs(encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (argCount % 2 === 1) throw new Error(`An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(argCount)} instead`);
}
/**
 * @type ArgValidator
 */ function parseMatchArgs(encoded, context, parsedArgs, typeHint) {
    const argsCount = encoded.length - 1;
    const input = parse(encoded[1], context);
    let inputType = input.type;
    const fallback = parse(encoded[encoded.length - 1], context);
    let outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;
    // first parse args to figure out possible types
    const args = new Array(argsCount - 2);
    for(let i = 0; i < argsCount - 2; i += 2){
        const match = parse(encoded[i + 2], context);
        const output = parse(encoded[i + 3], context);
        inputType &= match.type;
        outputType &= output.type;
        args[i] = match;
        args[i + 1] = output;
    }
    // check input and output types validity
    const expectedInputType = StringType | NumberType | BooleanType;
    if (!overlapsType(expectedInputType, inputType)) throw new Error(`Expected an input of type ${typeName(expectedInputType)} for the interpolate operation` + `, got ${typeName(inputType)} instead`);
    if (isType(outputType, NoneType)) throw new Error(`Could not find a common output type for the following match operation: ` + JSON.stringify(encoded));
    // parse again inputs and outputs with common type
    for(let i = 0; i < argsCount - 2; i += 2){
        const match = parse(encoded[i + 2], context, inputType);
        const output = parse(encoded[i + 3], context, outputType);
        args[i] = match;
        args[i + 1] = output;
    }
    return [
        parse(encoded[1], context, inputType),
        ...args,
        parse(encoded[encoded.length - 1], context, outputType)
    ];
}
/**
 * @type ArgValidator
 */ function parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {
    const interpolationType = encoded[1];
    let interpolation;
    switch(interpolationType[0]){
        case 'linear':
            interpolation = 1;
            break;
        case 'exponential':
            interpolation = interpolationType[1];
            if (typeof interpolation !== 'number') throw new Error(`Expected a number base for exponential interpolation` + `, got ${JSON.stringify(interpolation)} instead`);
            break;
        default:
            interpolation = null;
    }
    if (!interpolation) throw new Error(`Invalid interpolation type: ${JSON.stringify(interpolationType)}`);
    interpolation = parse(interpolation, context);
    // check input types
    let input = parse(encoded[2], context);
    if (!overlapsType(NumberType, input.type)) throw new Error(`Expected an input of type number for the interpolate operation` + `, got ${typeName(input.type)} instead`);
    input = parse(encoded[2], context, NumberType); // parse again with narrower output
    const args = new Array(encoded.length - 3);
    for(let i = 0; i < args.length; i += 2){
        let stop = parse(encoded[i + 3], context);
        if (!overlapsType(NumberType, stop.type)) throw new Error(`Expected all stop input values in the interpolate operation to be of type number` + `, got ${typeName(stop.type)} at position ${i + 2} instead`);
        let output = parse(encoded[i + 4], context);
        if (!overlapsType(NumberType | ColorType, output.type)) throw new Error(`Expected all stop output values in the interpolate operation to be a number or color` + `, got ${typeName(output.type)} at position ${i + 3} instead`);
        // parse again with narrower types
        stop = parse(encoded[i + 3], context, NumberType);
        output = parse(encoded[i + 4], context, NumberType | ColorType);
        args[i] = stop;
        args[i + 1] = output;
    }
    return [
        interpolation,
        input,
        ...args
    ];
}
/**
 * @type ArgValidator
 */ function parseCaseArgs(encoded, context, parsedArgs, typeHint) {
    const fallback = parse(encoded[encoded.length - 1], context);
    let outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;
    // first parse args to figure out possible types
    const args = new Array(encoded.length - 1);
    for(let i = 0; i < args.length - 1; i += 2){
        const condition = parse(encoded[i + 1], context);
        const output = parse(encoded[i + 2], context);
        if (!overlapsType(BooleanType, condition.type)) throw new Error(`Expected all conditions in the case operation to be of type boolean` + `, got ${typeName(condition.type)} at position ${i} instead`);
        outputType &= output.type;
        args[i] = condition;
        args[i + 1] = output;
    }
    if (isType(outputType, NoneType)) throw new Error(`Could not find a common output type for the following case operation: ` + JSON.stringify(encoded));
    // parse again args with common output type
    for(let i = 0; i < args.length - 1; i += 2)args[i + 1] = parse(encoded[i + 2], context, outputType);
    args[args.length - 1] = parse(encoded[encoded.length - 1], context, outputType);
    return args;
}
/**
 * @type ArgValidator
 */ function parseInArgs(encoded, context) {
    /** @type {Array<number|string>} */ let haystack = /** @type {any} */ encoded[2];
    if (!Array.isArray(haystack)) throw new Error(`The "in" operator was provided a literal value which was not an array as second argument.`);
    if (typeof haystack[0] === 'string') {
        if (haystack[0] !== 'literal') throw new Error(`For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.`);
        if (!Array.isArray(haystack[1])) throw new Error(`The "in" operator was provided a literal value which was not an array as second argument.`);
        haystack = haystack[1];
    }
    let needleType = StringType | NumberType;
    const args = new Array(haystack.length);
    for(let i = 0; i < args.length; i++){
        const arg = parse(haystack[i], context);
        needleType &= arg.type;
        args[i] = arg;
    }
    if (isType(needleType, NoneType)) throw new Error(`Could not find a common type for the following in operation: ` + JSON.stringify(encoded));
    const needle = parse(encoded[1], context, needleType);
    return [
        needle,
        ...args
    ];
}
/**
 * @type ArgValidator
 */ function parsePaletteArgs(encoded, context) {
    const index = parse(encoded[1], context, NumberType);
    if (index.type !== NumberType) throw new Error(`The first argument of palette must be an number, got ${typeName(index.type)} instead`);
    const colors = encoded[2];
    if (!Array.isArray(colors)) throw new Error('The second argument of palette must be an array');
    const parsedColors = new Array(colors.length);
    for(let i = 0; i < parsedColors.length; i++){
        const color = parse(colors[i], context, ColorType);
        if (!(color instanceof LiteralExpression)) throw new Error(`The palette color at index ${i} must be a literal value`);
        if (!overlapsType(color.type, ColorType)) throw new Error(`The palette color at index ${i} should be of type color, got ${typeName(color.type)} instead`);
        parsedColors[i] = color;
    }
    return [
        index,
        ...parsedColors
    ];
}
/**
 * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed
 * arguments
 * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator
 * will be used as parsed arguments
 * @return {Parser} The parser.
 */ function createParser(returnType, ...argValidators) {
    return function(encoded, context, typeHint) {
        const operator = encoded[0];
        let parsedArgs = [];
        for(let i = 0; i < argValidators.length; i++)parsedArgs = argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;
        let actualType = typeof returnType === 'function' ? returnType(parsedArgs) : returnType;
        if (typeHint !== undefined) {
            if (!overlapsType(actualType, typeHint)) throw new Error(`The following expression was expected to return ${typeName(typeHint)}, but returns ${typeName(actualType)} instead: ${JSON.stringify(encoded)}`);
            actualType &= typeHint;
        }
        if (actualType === NoneType) throw new Error(`No matching type was found for the following expression: ${JSON.stringify(encoded)}`);
        return new CallExpression(actualType, operator, ...parsedArgs);
    };
}
/**
 * @param {Array} encoded The encoded expression.
 * @param {ParsingContext} context The parsing context.
 * @param {number} [typeHint] Optional type hint
 * @return {Expression} The parsed expression.
 */ function parseCallExpression(encoded, context, typeHint) {
    const operator = encoded[0];
    const parser = parsers[operator];
    if (!parser) throw new Error(`Unknown operator: ${operator}`);
    return parser(encoded, context, typeHint);
}

},{"../array.js":"hyet5","../color.js":"h6hAX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9xcYD":[function(require,module,exports,__globalThis) {
/**
 * @module ol/expr/cpu
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @fileoverview This module includes functions to build expressions for evaluation on the CPU.
 * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded
 * expression and returns an instance of one of the expression classes.  The compiling step takes
 * the expression instance and returns a function that can be evaluated in to return a literal
 * value.  The evaluator function should do as little allocation and work as possible.
 */ /**
 * @typedef {Object} EvaluationContext
 * @property {Object} properties The values for properties used in 'get' expressions.
 * @property {Object} variables The values for variables used in 'var' expressions.
 * @property {number} resolution The map resolution.
 * @property {string|number|null} featureId The feature id.
 */ /**
 * @return {EvaluationContext} A new evaluation context.
 */ parcelHelpers.export(exports, "newEvaluationContext", ()=>newEvaluationContext);
/**
 * @typedef {function(EvaluationContext):import("./expression.js").LiteralValue} ExpressionEvaluator
 */ /**
 * @typedef {function(EvaluationContext):boolean} BooleanEvaluator
 */ /**
 * @typedef {function(EvaluationContext):number} NumberEvaluator
 */ /**
 * @typedef {function(EvaluationContext):string} StringEvaluator
 */ /**
 * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator
 */ /**
 * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator
 */ /**
 * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator
 */ /**
 * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator
 */ /**
 * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.
 * @param {number} type The expected type.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The expression evaluator.
 */ parcelHelpers.export(exports, "buildExpression", ()=>buildExpression);
var _expressionJs = require("./expression.js");
var _colorJs = require("../color.js");
function newEvaluationContext() {
    return {
        variables: {},
        properties: {},
        resolution: NaN,
        featureId: null
    };
}
function buildExpression(encoded, type, context) {
    const expression = (0, _expressionJs.parse)(encoded, context);
    if (!(0, _expressionJs.overlapsType)(type, expression.type)) {
        const expected = (0, _expressionJs.typeName)(type);
        const actual = (0, _expressionJs.typeName)(expression.type);
        throw new Error(`Expected expression to be of type ${expected}, got ${actual}`);
    }
    return compileExpression(expression, context);
}
/**
 * @param {import("./expression.js").Expression} expression The expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileExpression(expression, context) {
    if (expression instanceof (0, _expressionJs.LiteralExpression)) {
        // convert colors to array if possible
        if (expression.type === (0, _expressionJs.ColorType) && typeof expression.value === 'string') {
            const colorValue = (0, _colorJs.fromString)(expression.value);
            return function() {
                return colorValue;
            };
        }
        return function() {
            return expression.value;
        };
    }
    const operator = expression.operator;
    switch(operator){
        case (0, _expressionJs.Ops).Number:
        case (0, _expressionJs.Ops).String:
            return compileAssertionExpression(expression, context);
        case (0, _expressionJs.Ops).Get:
        case (0, _expressionJs.Ops).Var:
            return compileAccessorExpression(expression, context);
        case (0, _expressionJs.Ops).Id:
            return (expression)=>expression.featureId;
        case (0, _expressionJs.Ops).Concat:
            {
                const args = expression.args.map((e)=>compileExpression(e, context));
                return (context)=>''.concat(...args.map((arg)=>arg(context).toString()));
            }
        case (0, _expressionJs.Ops).Resolution:
            return (context)=>context.resolution;
        case (0, _expressionJs.Ops).Any:
        case (0, _expressionJs.Ops).All:
        case (0, _expressionJs.Ops).Not:
            return compileLogicalExpression(expression, context);
        case (0, _expressionJs.Ops).Equal:
        case (0, _expressionJs.Ops).NotEqual:
        case (0, _expressionJs.Ops).LessThan:
        case (0, _expressionJs.Ops).LessThanOrEqualTo:
        case (0, _expressionJs.Ops).GreaterThan:
        case (0, _expressionJs.Ops).GreaterThanOrEqualTo:
            return compileComparisonExpression(expression, context);
        case (0, _expressionJs.Ops).Multiply:
        case (0, _expressionJs.Ops).Divide:
        case (0, _expressionJs.Ops).Add:
        case (0, _expressionJs.Ops).Subtract:
        case (0, _expressionJs.Ops).Clamp:
        case (0, _expressionJs.Ops).Mod:
        case (0, _expressionJs.Ops).Pow:
        case (0, _expressionJs.Ops).Abs:
        case (0, _expressionJs.Ops).Floor:
        case (0, _expressionJs.Ops).Ceil:
        case (0, _expressionJs.Ops).Round:
        case (0, _expressionJs.Ops).Sin:
        case (0, _expressionJs.Ops).Cos:
        case (0, _expressionJs.Ops).Atan:
        case (0, _expressionJs.Ops).Sqrt:
            return compileNumericExpression(expression, context);
        case (0, _expressionJs.Ops).Match:
            return compileMatchExpression(expression, context);
        case (0, _expressionJs.Ops).Interpolate:
            return compileInterpolateExpression(expression, context);
        default:
            throw new Error(`Unsupported operator ${operator}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileAssertionExpression(expression, context) {
    const type = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i)args[i] = compileExpression(expression.args[i], context);
    switch(type){
        case (0, _expressionJs.Ops).Number:
        case (0, _expressionJs.Ops).String:
            return (context)=>{
                for(let i = 0; i < length; ++i){
                    const value = args[i](context);
                    if (typeof value === type) return value;
                }
                throw new Error(`Expected one of the values to be a ${type}`);
            };
        default:
            throw new Error(`Unsupported assertion operator ${type}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileAccessorExpression(expression, context) {
    const nameExpression = /** @type {LiteralExpression} */ expression.args[0];
    const name = /** @type {string} */ nameExpression.value;
    switch(expression.operator){
        case (0, _expressionJs.Ops).Get:
            return (context)=>context.properties[name];
        case (0, _expressionJs.Ops).Var:
            return (context)=>context.variables[name];
        default:
            throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */ function compileComparisonExpression(expression, context) {
    const op = expression.operator;
    const left = compileExpression(expression.args[0], context);
    const right = compileExpression(expression.args[1], context);
    switch(op){
        case (0, _expressionJs.Ops).Equal:
            return (context)=>left(context) === right(context);
        case (0, _expressionJs.Ops).NotEqual:
            return (context)=>left(context) !== right(context);
        case (0, _expressionJs.Ops).LessThan:
            return (context)=>left(context) < right(context);
        case (0, _expressionJs.Ops).LessThanOrEqualTo:
            return (context)=>left(context) <= right(context);
        case (0, _expressionJs.Ops).GreaterThan:
            return (context)=>left(context) > right(context);
        case (0, _expressionJs.Ops).GreaterThanOrEqualTo:
            return (context)=>left(context) >= right(context);
        default:
            throw new Error(`Unsupported comparison operator ${op}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */ function compileLogicalExpression(expression, context) {
    const op = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i)args[i] = compileExpression(expression.args[i], context);
    switch(op){
        case (0, _expressionJs.Ops).Any:
            return (context)=>{
                for(let i = 0; i < length; ++i){
                    if (args[i](context)) return true;
                }
                return false;
            };
        case (0, _expressionJs.Ops).All:
            return (context)=>{
                for(let i = 0; i < length; ++i){
                    if (!args[i](context)) return false;
                }
                return true;
            };
        case (0, _expressionJs.Ops).Not:
            return (context)=>!args[0](context);
        default:
            throw new Error(`Unsupported logical operator ${op}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {NumberEvaluator} The evaluator function.
 */ function compileNumericExpression(expression, context) {
    const op = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i)args[i] = compileExpression(expression.args[i], context);
    switch(op){
        case (0, _expressionJs.Ops).Multiply:
            return (context)=>{
                let value = 1;
                for(let i = 0; i < length; ++i)value *= args[i](context);
                return value;
            };
        case (0, _expressionJs.Ops).Divide:
            return (context)=>args[0](context) / args[1](context);
        case (0, _expressionJs.Ops).Add:
            return (context)=>{
                let value = 0;
                for(let i = 0; i < length; ++i)value += args[i](context);
                return value;
            };
        case (0, _expressionJs.Ops).Subtract:
            return (context)=>args[0](context) - args[1](context);
        case (0, _expressionJs.Ops).Clamp:
            return (context)=>{
                const value = args[0](context);
                const min = args[1](context);
                if (value < min) return min;
                const max = args[2](context);
                if (value > max) return max;
                return value;
            };
        case (0, _expressionJs.Ops).Mod:
            return (context)=>args[0](context) % args[1](context);
        case (0, _expressionJs.Ops).Pow:
            return (context)=>Math.pow(args[0](context), args[1](context));
        case (0, _expressionJs.Ops).Abs:
            return (context)=>Math.abs(args[0](context));
        case (0, _expressionJs.Ops).Floor:
            return (context)=>Math.floor(args[0](context));
        case (0, _expressionJs.Ops).Ceil:
            return (context)=>Math.ceil(args[0](context));
        case (0, _expressionJs.Ops).Round:
            return (context)=>Math.round(args[0](context));
        case (0, _expressionJs.Ops).Sin:
            return (context)=>Math.sin(args[0](context));
        case (0, _expressionJs.Ops).Cos:
            return (context)=>Math.cos(args[0](context));
        case (0, _expressionJs.Ops).Atan:
            if (length === 2) return (context)=>Math.atan2(args[0](context), args[1](context));
            return (context)=>Math.atan(args[0](context));
        case (0, _expressionJs.Ops).Sqrt:
            return (context)=>Math.sqrt(args[0](context));
        default:
            throw new Error(`Unsupported numeric operator ${op}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileMatchExpression(expression, context) {
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i)args[i] = compileExpression(expression.args[i], context);
    return (context)=>{
        const value = args[0](context);
        for(let i = 1; i < length; i += 2){
            if (value === args[i](context)) return args[i + 1](context);
        }
        return args[length - 1](context);
    };
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileInterpolateExpression(expression, context) {
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i)args[i] = compileExpression(expression.args[i], context);
    return (context)=>{
        const base = args[0](context);
        const value = args[1](context);
        let previousInput;
        let previousOutput;
        for(let i = 2; i < length; i += 2){
            const input = args[i](context);
            let output = args[i + 1](context);
            const isColor = Array.isArray(output);
            if (isColor) output = (0, _colorJs.withAlpha)(output);
            if (input >= value) {
                if (i === 2) return output;
                if (isColor) return interpolateColor(base, value, previousInput, previousOutput, input, output);
                return interpolateNumber(base, value, previousInput, previousOutput, input, output);
            }
            previousInput = input;
            previousOutput = output;
        }
        return previousOutput;
    };
}
/**
 * @param {number} base The base.
 * @param {number} value The value.
 * @param {number} input1 The first input value.
 * @param {number} output1 The first output value.
 * @param {number} input2 The second input value.
 * @param {number} output2 The second output value.
 * @return {number} The interpolated value.
 */ function interpolateNumber(base, value, input1, output1, input2, output2) {
    const delta = input2 - input1;
    if (delta === 0) return output1;
    const along = value - input1;
    const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
    return output1 + factor * (output2 - output1);
}
/**
 * @param {number} base The base.
 * @param {number} value The value.
 * @param {number} input1 The first input value.
 * @param {import('../color.js').Color} rgba1 The first output value.
 * @param {number} input2 The second input value.
 * @param {import('../color.js').Color} rgba2 The second output value.
 * @return {import('../color.js').Color} The interpolated color.
 */ function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
    const delta = input2 - input1;
    if (delta === 0) return rgba1;
    const lcha1 = (0, _colorJs.rgbaToLcha)(rgba1);
    const lcha2 = (0, _colorJs.rgbaToLcha)(rgba2);
    let deltaHue = lcha2[2] - lcha1[2];
    if (deltaHue > 180) deltaHue -= 360;
    else if (deltaHue < -180) deltaHue += 360;
    const lcha = [
        interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
        interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
        lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
        interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])
    ];
    return (0, _colorJs.normalize)((0, _colorJs.lchaToRgba)(lcha));
}

},{"./expression.js":"8u0Bf","../color.js":"h6hAX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cwWLB":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/canvas/VectorLayer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderGroupJs = require("../../render/canvas/BuilderGroup.js");
var _builderGroupJsDefault = parcelHelpers.interopDefault(_builderGroupJs);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _executorGroupJs = require("../../render/canvas/ExecutorGroup.js");
var _executorGroupJsDefault = parcelHelpers.interopDefault(_executorGroupJs);
var _eventTypeJs = require("../../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _viewHintJs = require("../../ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _hitdetectJs = require("../../render/canvas/hitdetect.js");
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _domJs = require("../../dom.js");
var _vectorJs = require("../vector.js");
var _arrayJs = require("../../array.js");
var _projJs = require("../../proj.js");
var _utilJs = require("../../util.js");
var _coordinateJs = require("../../coordinate.js");
/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */ class CanvasVectorLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */ constructor(vectorLayer){
        super(vectorLayer);
        /** @private */ this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
        /**
     * @type {boolean}
     */ this.animatingOrInteracting_;
        /**
     * @type {ImageData|null}
     */ this.hitDetectionImageData_ = null;
        /**
     * @type {Array<import("../../Feature.js").default>}
     */ this.renderedFeatures_ = null;
        /**
     * @private
     * @type {number}
     */ this.renderedRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.renderedResolution_ = NaN;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.renderedExtent_ = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.wrappedRenderedExtent_ = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {number}
     */ this.renderedRotation_;
        /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */ this.renderedCenter_ = null;
        /**
     * @private
     * @type {import("../../proj/Projection").default}
     */ this.renderedProjection_ = null;
        /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */ this.renderedRenderOrder_ = null;
        /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */ this.replayGroup_ = null;
        /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */ this.replayGroupChanged = true;
        /**
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */ this.declutterExecutorGroup = null;
        /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */ this.clipping = true;
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.compositionContext_ = null;
        /**
     * @private
     * @type {number}
     */ this.opacity_ = 1;
    }
    /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */ renderWorlds(executorGroup, frameState, declutterTree) {
        const extent = frameState.extent;
        const viewState = frameState.viewState;
        const center = viewState.center;
        const resolution = viewState.resolution;
        const projection = viewState.projection;
        const rotation = viewState.rotation;
        const projectionExtent = projection.getExtent();
        const vectorSource = this.getLayer().getSource();
        const pixelRatio = frameState.pixelRatio;
        const viewHints = frameState.viewHints;
        const snapToPixel = !(viewHints[(0, _viewHintJsDefault.default).ANIMATING] || viewHints[(0, _viewHintJsDefault.default).INTERACTING]);
        const context = this.compositionContext_;
        const width = Math.round(frameState.size[0] * pixelRatio);
        const height = Math.round(frameState.size[1] * pixelRatio);
        const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
        const worldWidth = multiWorld ? (0, _extentJs.getWidth)(projectionExtent) : null;
        const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
        let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
        do {
            const transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
            executorGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, declutterTree);
        }while (++world < endWorld);
    }
    setupCompositionContext_() {
        if (this.opacity_ !== 1) {
            const compositionContext = (0, _domJs.createCanvasContext2D)(this.context.canvas.width, this.context.canvas.height, (0, _layerJs.canvasPool));
            this.compositionContext_ = compositionContext;
        } else this.compositionContext_ = this.context;
    }
    releaseCompositionContext_() {
        if (this.opacity_ !== 1) {
            const alpha = this.context.globalAlpha;
            this.context.globalAlpha = this.opacity_;
            this.context.drawImage(this.compositionContext_.canvas, 0, 0);
            this.context.globalAlpha = alpha;
            (0, _domJs.releaseCanvas)(this.compositionContext_);
            (0, _layerJs.canvasPool).push(this.compositionContext_.canvas);
            this.compositionContext_ = null;
        }
    }
    /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */ renderDeclutter(frameState) {
        if (this.declutterExecutorGroup) {
            this.setupCompositionContext_();
            this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
            this.releaseCompositionContext_();
        }
    }
    /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */ renderFrame(frameState, target) {
        const pixelRatio = frameState.pixelRatio;
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        // set forward and inverse pixel transforms
        (0, _transformJs.makeScale)(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
        (0, _transformJs.makeInverse)(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = (0, _transformJs.toString)(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        const context = this.context;
        const canvas = context.canvas;
        const replayGroup = this.replayGroup_;
        const declutterExecutorGroup = this.declutterExecutorGroup;
        let render = replayGroup && !replayGroup.isEmpty() || declutterExecutorGroup && !declutterExecutorGroup.isEmpty();
        if (!render) {
            const hasRenderListeners = this.getLayer().hasListener((0, _eventTypeJsDefault.default).PRERENDER) || this.getLayer().hasListener((0, _eventTypeJsDefault.default).POSTRENDER);
            if (!hasRenderListeners) return null;
        }
        // resize and clear
        const width = Math.round(frameState.size[0] * pixelRatio);
        const height = Math.round(frameState.size[1] * pixelRatio);
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
            if (canvas.style.transform !== canvasTransform) canvas.style.transform = canvasTransform;
        } else if (!this.containerReused) context.clearRect(0, 0, width, height);
        this.preRender(context, frameState);
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        this.opacity_ = layerState.opacity;
        this.setupCompositionContext_();
        // clipped rendering if layer extent is set
        let clipped = false;
        if (render && layerState.extent && this.clipping) {
            const layerExtent = (0, _projJs.fromUserExtent)(layerState.extent, projection);
            render = (0, _extentJs.intersects)(layerExtent, frameState.extent);
            clipped = render && !(0, _extentJs.containsExtent)(layerExtent, frameState.extent);
            if (clipped) this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
        }
        if (render) this.renderWorlds(replayGroup, frameState);
        if (clipped) this.compositionContext_.restore();
        this.releaseCompositionContext_();
        this.postRender(context, frameState);
        if (this.renderedRotation_ !== viewState.rotation) {
            this.renderedRotation_ = viewState.rotation;
            this.hitDetectionImageData_ = null;
        }
        return this.container;
    }
    /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */ getFeatures(pixel) {
        return new Promise((resolve)=>{
            if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                const size = [
                    this.context.canvas.width,
                    this.context.canvas.height
                ];
                (0, _transformJs.apply)(this.pixelTransform, size);
                const center = this.renderedCenter_;
                const resolution = this.renderedResolution_;
                const rotation = this.renderedRotation_;
                const projection = this.renderedProjection_;
                const extent = this.wrappedRenderedExtent_;
                const layer = this.getLayer();
                const transforms = [];
                const width = size[0] * (0, _hitdetectJs.HIT_DETECT_RESOLUTION);
                const height = size[1] * (0, _hitdetectJs.HIT_DETECT_RESOLUTION);
                transforms.push(this.getRenderTransform(center, resolution, rotation, (0, _hitdetectJs.HIT_DETECT_RESOLUTION), width, height, 0).slice());
                const source = layer.getSource();
                const projectionExtent = projection.getExtent();
                if (source.getWrapX() && projection.canWrapX() && !(0, _extentJs.containsExtent)(projectionExtent, extent)) {
                    let startX = extent[0];
                    const worldWidth = (0, _extentJs.getWidth)(projectionExtent);
                    let world = 0;
                    let offsetX;
                    while(startX < projectionExtent[0]){
                        --world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, (0, _hitdetectJs.HIT_DETECT_RESOLUTION), width, height, offsetX).slice());
                        startX += worldWidth;
                    }
                    world = 0;
                    startX = extent[2];
                    while(startX > projectionExtent[2]){
                        ++world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, (0, _hitdetectJs.HIT_DETECT_RESOLUTION), width, height, offsetX).slice());
                        startX -= worldWidth;
                    }
                }
                this.hitDetectionImageData_ = (0, _hitdetectJs.createHitDetectionImageData)(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
            }
            resolve((0, _hitdetectJs.hitDetect)(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
        });
    }
    /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        if (!this.replayGroup_) return undefined;
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const layer = this.getLayer();
        /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */ const features = {};
        /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position
     * @return {T|undefined} Callback result.
     */ const featureCallback = function(feature, geometry, distanceSq) {
            const key = (0, _utilJs.getUid)(feature);
            const match = features[key];
            if (!match) {
                if (distanceSq === 0) {
                    features[key] = true;
                    return callback(feature, layer, geometry);
                }
                matches.push(features[key] = {
                    feature: feature,
                    layer: layer,
                    geometry: geometry,
                    distanceSq: distanceSq,
                    callback: callback
                });
            } else if (match !== true && distanceSq < match.distanceSq) {
                if (distanceSq === 0) {
                    features[key] = true;
                    matches.splice(matches.lastIndexOf(match), 1);
                    return callback(feature, layer, geometry);
                }
                match.geometry = geometry;
                match.distanceSq = distanceSq;
            }
            return undefined;
        };
        let result;
        const executorGroups = [
            this.replayGroup_
        ];
        if (this.declutterExecutorGroup) executorGroups.push(this.declutterExecutorGroup);
        executorGroups.some((executorGroup)=>{
            return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map((item)=>item.value) : null);
        });
        return result;
    }
    /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */ handleFontsChanged() {
        const layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) layer.changed();
    }
    /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */ handleStyleImageChange_(event) {
        this.renderIfReadyAndVisible();
    }
    /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        const vectorLayer = this.getLayer();
        const vectorSource = vectorLayer.getSource();
        if (!vectorSource) return false;
        const animating = frameState.viewHints[(0, _viewHintJsDefault.default).ANIMATING];
        const interacting = frameState.viewHints[(0, _viewHintJsDefault.default).INTERACTING];
        const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
        if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
            this.animatingOrInteracting_ = true;
            return true;
        }
        this.animatingOrInteracting_ = false;
        const frameStateExtent = frameState.extent;
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const resolution = viewState.resolution;
        const pixelRatio = frameState.pixelRatio;
        const vectorLayerRevision = vectorLayer.getRevision();
        const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
        if (vectorLayerRenderOrder === undefined) vectorLayerRenderOrder = (0, _vectorJs.defaultOrder);
        const center = viewState.center.slice();
        const extent = (0, _extentJs.buffer)(frameStateExtent, vectorLayerRenderBuffer * resolution);
        const renderedExtent = extent.slice();
        const loadExtents = [
            extent.slice()
        ];
        const projectionExtent = projection.getExtent();
        if (vectorSource.getWrapX() && projection.canWrapX() && !(0, _extentJs.containsExtent)(projectionExtent, frameState.extent)) {
            // For the replay group, we need an extent that intersects the real world
            // (-180° to +180°). To support geometries in a coordinate range from -540°
            // to +540°, we add at least 1 world width on each side of the projection
            // extent. If the viewport is wider than the world, we need to add half of
            // the viewport width to make sure we cover the whole viewport.
            const worldWidth = (0, _extentJs.getWidth)(projectionExtent);
            const gutter = Math.max((0, _extentJs.getWidth)(extent) / 2, worldWidth);
            extent[0] = projectionExtent[0] - gutter;
            extent[2] = projectionExtent[2] + gutter;
            (0, _coordinateJs.wrapX)(center, projection);
            const loadExtent = (0, _extentJs.wrapX)(loadExtents[0], projection);
            // If the extent crosses the date line, we load data for both edges of the worlds
            if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) loadExtents.push([
                loadExtent[0] + worldWidth,
                loadExtent[1],
                loadExtent[2] + worldWidth,
                loadExtent[3]
            ]);
            else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) loadExtents.push([
                loadExtent[0] - worldWidth,
                loadExtent[1],
                loadExtent[2] - worldWidth,
                loadExtent[3]
            ]);
        }
        if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && (0, _extentJs.containsExtent)(this.wrappedRenderedExtent_, extent)) {
            if (!(0, _arrayJs.equals)(this.renderedExtent_, renderedExtent)) {
                this.hitDetectionImageData_ = null;
                this.renderedExtent_ = renderedExtent;
            }
            this.renderedCenter_ = center;
            this.replayGroupChanged = false;
            return true;
        }
        this.replayGroup_ = null;
        const replayGroup = new (0, _builderGroupJsDefault.default)((0, _vectorJs.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
        let declutterBuilderGroup;
        if (this.getLayer().getDeclutter()) declutterBuilderGroup = new (0, _builderGroupJsDefault.default)((0, _vectorJs.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
        const userProjection = (0, _projJs.getUserProjection)();
        let userTransform;
        if (userProjection) {
            for(let i = 0, ii = loadExtents.length; i < ii; ++i){
                const extent = loadExtents[i];
                const userExtent = (0, _projJs.toUserExtent)(extent, projection);
                vectorSource.loadFeatures(userExtent, (0, _projJs.toUserResolution)(resolution, projection), userProjection);
            }
            userTransform = (0, _projJs.getTransformFromProjections)(userProjection, projection);
        } else for(let i = 0, ii = loadExtents.length; i < ii; ++i)vectorSource.loadFeatures(loadExtents[i], resolution, projection);
        const squaredTolerance = (0, _vectorJs.getSquaredTolerance)(resolution, pixelRatio);
        let ready = true;
        const render = /**
       * @param {import("../../Feature.js").default} feature Feature.
       */ (feature)=>{
            let styles;
            const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
            if (styleFunction) styles = styleFunction(feature, resolution);
            if (styles) {
                const dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
                ready = ready && !dirty;
            }
        };
        const userExtent = (0, _projJs.toUserExtent)(extent, projection);
        /** @type {Array<import("../../Feature.js").default>} */ const features = vectorSource.getFeaturesInExtent(userExtent);
        if (vectorLayerRenderOrder) features.sort(vectorLayerRenderOrder);
        for(let i = 0, ii = features.length; i < ii; ++i)render(features[i]);
        this.renderedFeatures_ = features;
        this.ready = ready;
        const replayGroupInstructions = replayGroup.finish();
        const executorGroup = new (0, _executorGroupJsDefault.default)(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
        if (declutterBuilderGroup) this.declutterExecutorGroup = new (0, _executorGroupJsDefault.default)(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedExtent_ = renderedExtent;
        this.wrappedRenderedExtent_ = extent;
        this.renderedCenter_ = center;
        this.renderedProjection_ = projection;
        this.replayGroup_ = executorGroup;
        this.hitDetectionImageData_ = null;
        this.replayGroupChanged = true;
        return true;
    }
    /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */ renderFeature(feature, squaredTolerance, styles, builderGroup, transform, declutterBuilderGroup) {
        if (!styles) return false;
        let loading = false;
        if (Array.isArray(styles)) for(let i = 0, ii = styles.length; i < ii; ++i)loading = (0, _vectorJs.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, transform, declutterBuilderGroup) || loading;
        else loading = (0, _vectorJs.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, transform, declutterBuilderGroup);
        return loading;
    }
}
exports.default = CanvasVectorLayerRenderer;

},{"../../render/canvas/BuilderGroup.js":"f5Ix9","./Layer.js":"9fzi4","../../render/canvas/ExecutorGroup.js":"l1Ibd","../../render/EventType.js":"1ajEk","../../ViewHint.js":"9EJlo","../../render/canvas/hitdetect.js":"7dVZW","../../transform.js":"9LrRk","../../extent.js":"bGUel","../../dom.js":"h98kD","../vector.js":"1VLk4","../../array.js":"hyet5","../../proj.js":"8OK47","../../util.js":"l1iPW","../../coordinate.js":"fqHXJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f5Ix9":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/BuilderGroup
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _imageBuilderJs = require("./ImageBuilder.js");
var _imageBuilderJsDefault = parcelHelpers.interopDefault(_imageBuilderJs);
var _lineStringBuilderJs = require("./LineStringBuilder.js");
var _lineStringBuilderJsDefault = parcelHelpers.interopDefault(_lineStringBuilderJs);
var _polygonBuilderJs = require("./PolygonBuilder.js");
var _polygonBuilderJsDefault = parcelHelpers.interopDefault(_polygonBuilderJs);
var _textBuilderJs = require("./TextBuilder.js");
var _textBuilderJsDefault = parcelHelpers.interopDefault(_textBuilderJs);
/**
 * @type {Object<import("../canvas.js").BuilderType, typeof Builder>}
 */ const BATCH_CONSTRUCTORS = {
    'Circle': (0, _polygonBuilderJsDefault.default),
    'Default': (0, _builderJsDefault.default),
    'Image': (0, _imageBuilderJsDefault.default),
    'LineString': (0, _lineStringBuilderJsDefault.default),
    'Polygon': (0, _polygonBuilderJsDefault.default),
    'Text': (0, _textBuilderJsDefault.default)
};
class BuilderGroup {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        /**
     * @private
     * @type {number}
     */ this.tolerance_ = tolerance;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.maxExtent_ = maxExtent;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {number}
     */ this.resolution_ = resolution;
        /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, Builder>>}
     */ this.buildersByZIndex_ = {};
    }
    /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */ finish() {
        const builderInstructions = {};
        for(const zKey in this.buildersByZIndex_){
            builderInstructions[zKey] = builderInstructions[zKey] || {};
            const builders = this.buildersByZIndex_[zKey];
            for(const builderKey in builders){
                const builderInstruction = builders[builderKey].finish();
                builderInstructions[zKey][builderKey] = builderInstruction;
            }
        }
        return builderInstructions;
    }
    /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */ getBuilder(zIndex, builderType) {
        const zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
        let replays = this.buildersByZIndex_[zIndexKey];
        if (replays === undefined) {
            replays = {};
            this.buildersByZIndex_[zIndexKey] = replays;
        }
        let replay = replays[builderType];
        if (replay === undefined) {
            const Constructor = BATCH_CONSTRUCTORS[builderType];
            replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
            replays[builderType] = replay;
        }
        return replay;
    }
}
exports.default = BuilderGroup;

},{"./Builder.js":"5Yz7q","./ImageBuilder.js":"iZRVS","./LineStringBuilder.js":"hBKvU","./PolygonBuilder.js":"arlHY","./TextBuilder.js":"hSSq4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5Yz7q":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/Builder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _relationshipJs = require("../../extent/Relationship.js");
var _relationshipJsDefault = parcelHelpers.interopDefault(_relationshipJs);
var _vectorContextJs = require("../VectorContext.js");
var _vectorContextJsDefault = parcelHelpers.interopDefault(_vectorContextJs);
var _colorlikeJs = require("../../colorlike.js");
var _extentJs = require("../../extent.js");
var _canvasJs = require("../canvas.js");
var _arrayJs = require("../../array.js");
var _inflateJs = require("../../geom/flat/inflate.js");
class CanvasBuilder extends (0, _vectorContextJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super();
        /**
     * @protected
     * @type {number}
     */ this.tolerance = tolerance;
        /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */ this.maxExtent = maxExtent;
        /**
     * @protected
     * @type {number}
     */ this.pixelRatio = pixelRatio;
        /**
     * @protected
     * @type {number}
     */ this.maxLineWidth = 0;
        /**
     * @protected
     * @const
     * @type {number}
     */ this.resolution = resolution;
        /**
     * @private
     * @type {Array<*>}
     */ this.beginGeometryInstruction1_ = null;
        /**
     * @private
     * @type {Array<*>}
     */ this.beginGeometryInstruction2_ = null;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.bufferedMaxExtent_ = null;
        /**
     * @protected
     * @type {Array<*>}
     */ this.instructions = [];
        /**
     * @protected
     * @type {Array<number>}
     */ this.coordinates = [];
        /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */ this.tmpCoordinate_ = [];
        /**
     * @protected
     * @type {Array<*>}
     */ this.hitDetectionInstructions = [];
        /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */ this.state = /** @type {import("../canvas.js").FillStrokeState} */ {};
    }
    /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */ applyPixelRatio(dashArray) {
        const pixelRatio = this.pixelRatio;
        return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
            return dash * pixelRatio;
        });
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */ appendFlatPointCoordinates(flatCoordinates, stride) {
        const extent = this.getBufferedMaxExtent();
        const tmpCoord = this.tmpCoordinate_;
        const coordinates = this.coordinates;
        let myEnd = coordinates.length;
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            tmpCoord[0] = flatCoordinates[i];
            tmpCoord[1] = flatCoordinates[i + 1];
            if ((0, _extentJs.containsCoordinate)(extent, tmpCoord)) {
                coordinates[myEnd++] = tmpCoord[0];
                coordinates[myEnd++] = tmpCoord[1];
            }
        }
        return myEnd;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */ appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {
        const coordinates = this.coordinates;
        let myEnd = coordinates.length;
        const extent = this.getBufferedMaxExtent();
        if (skipFirst) offset += stride;
        let lastXCoord = flatCoordinates[offset];
        let lastYCoord = flatCoordinates[offset + 1];
        const nextCoord = this.tmpCoordinate_;
        let skipped = true;
        let i, lastRel, nextRel;
        for(i = offset + stride; i < end; i += stride){
            nextCoord[0] = flatCoordinates[i];
            nextCoord[1] = flatCoordinates[i + 1];
            nextRel = (0, _extentJs.coordinateRelationship)(extent, nextCoord);
            if (nextRel !== lastRel) {
                if (skipped) {
                    coordinates[myEnd++] = lastXCoord;
                    coordinates[myEnd++] = lastYCoord;
                    skipped = false;
                }
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
            } else if (nextRel === (0, _relationshipJsDefault.default).INTERSECTING) {
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
                skipped = false;
            } else skipped = true;
            lastXCoord = nextCoord[0];
            lastYCoord = nextCoord[1];
            lastRel = nextRel;
        }
        // Last coordinate equals first or only one point to append:
        if (closed && skipped || i === offset + stride) {
            coordinates[myEnd++] = lastXCoord;
            coordinates[myEnd++] = lastYCoord;
        }
        return myEnd;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */ drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
            builderEnds.push(builderEnd);
            offset = end;
        }
        return offset;
    }
    /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */ drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
        this.beginGeometry(geometry, feature);
        const type = geometry.getType();
        const stride = geometry.getStride();
        const builderBegin = this.coordinates.length;
        let flatCoordinates, builderEnd, builderEnds, builderEndss;
        let offset;
        switch(type){
            case 'MultiPolygon':
                flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getOrientedFlatCoordinates();
                builderEndss = [];
                const endss = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getEndss();
                offset = 0;
                for(let i = 0, ii = endss.length; i < ii; ++i){
                    const myEnds = [];
                    offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                    builderEndss.push(myEnds);
                }
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEndss,
                    geometry,
                    renderer,
                    (0, _inflateJs.inflateMultiCoordinatesArray)
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEndss,
                    geometry,
                    hitDetectionRenderer || renderer,
                    (0, _inflateJs.inflateMultiCoordinatesArray)
                ]);
                break;
            case 'Polygon':
            case 'MultiLineString':
                builderEnds = [];
                flatCoordinates = type == 'Polygon' ? /** @type {import("../../geom/Polygon.js").default} */ geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
                offset = this.drawCustomCoordinates_(flatCoordinates, 0, /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ geometry.getEnds(), stride, builderEnds);
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnds,
                    geometry,
                    renderer,
                    (0, _inflateJs.inflateCoordinatesArray)
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnds,
                    geometry,
                    hitDetectionRenderer || renderer,
                    (0, _inflateJs.inflateCoordinatesArray)
                ]);
                break;
            case 'LineString':
            case 'Circle':
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer,
                    (0, _inflateJs.inflateCoordinates)
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    hitDetectionRenderer || renderer,
                    (0, _inflateJs.inflateCoordinates)
                ]);
                break;
            case 'MultiPoint':
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
                if (builderEnd > builderBegin) {
                    this.instructions.push([
                        (0, _instructionJsDefault.default).CUSTOM,
                        builderBegin,
                        builderEnd,
                        geometry,
                        renderer,
                        (0, _inflateJs.inflateCoordinates)
                    ]);
                    this.hitDetectionInstructions.push([
                        (0, _instructionJsDefault.default).CUSTOM,
                        builderBegin,
                        builderEnd,
                        geometry,
                        hitDetectionRenderer || renderer,
                        (0, _inflateJs.inflateCoordinates)
                    ]);
                }
                break;
            case 'Point':
                flatCoordinates = geometry.getFlatCoordinates();
                this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
                builderEnd = this.coordinates.length;
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    hitDetectionRenderer || renderer
                ]);
                break;
            default:
        }
        this.endGeometry(feature);
    }
    /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ beginGeometry(geometry, feature) {
        this.beginGeometryInstruction1_ = [
            (0, _instructionJsDefault.default).BEGIN_GEOMETRY,
            feature,
            0,
            geometry
        ];
        this.instructions.push(this.beginGeometryInstruction1_);
        this.beginGeometryInstruction2_ = [
            (0, _instructionJsDefault.default).BEGIN_GEOMETRY,
            feature,
            0,
            geometry
        ];
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        return {
            instructions: this.instructions,
            hitDetectionInstructions: this.hitDetectionInstructions,
            coordinates: this.coordinates
        };
    }
    /**
   * Reverse the hit detection instructions.
   */ reverseHitDetectionInstructions() {
        const hitDetectionInstructions = this.hitDetectionInstructions;
        // step 1 - reverse array
        hitDetectionInstructions.reverse();
        // step 2 - reverse instructions within geometry blocks
        let i;
        const n = hitDetectionInstructions.length;
        let instruction;
        let type;
        let begin = -1;
        for(i = 0; i < n; ++i){
            instruction = hitDetectionInstructions[i];
            type = /** @type {import("./Instruction.js").default} */ instruction[0];
            if (type == (0, _instructionJsDefault.default).END_GEOMETRY) begin = i;
            else if (type == (0, _instructionJsDefault.default).BEGIN_GEOMETRY) {
                instruction[2] = i;
                (0, _arrayJs.reverseSubArray)(this.hitDetectionInstructions, begin, i);
                begin = -1;
            }
        }
    }
    /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */ setFillStrokeStyle(fillStyle, strokeStyle) {
        const state = this.state;
        if (fillStyle) {
            const fillStyleColor = fillStyle.getColor();
            state.fillStyle = (0, _colorlikeJs.asColorLike)(fillStyleColor ? fillStyleColor : (0, _canvasJs.defaultFillStyle));
        } else state.fillStyle = undefined;
        if (strokeStyle) {
            const strokeStyleColor = strokeStyle.getColor();
            state.strokeStyle = (0, _colorlikeJs.asColorLike)(strokeStyleColor ? strokeStyleColor : (0, _canvasJs.defaultStrokeStyle));
            const strokeStyleLineCap = strokeStyle.getLineCap();
            state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : (0, _canvasJs.defaultLineCap);
            const strokeStyleLineDash = strokeStyle.getLineDash();
            state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : (0, _canvasJs.defaultLineDash);
            const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
            state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : (0, _canvasJs.defaultLineDashOffset);
            const strokeStyleLineJoin = strokeStyle.getLineJoin();
            state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : (0, _canvasJs.defaultLineJoin);
            const strokeStyleWidth = strokeStyle.getWidth();
            state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : (0, _canvasJs.defaultLineWidth);
            const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : (0, _canvasJs.defaultMiterLimit);
            if (state.lineWidth > this.maxLineWidth) {
                this.maxLineWidth = state.lineWidth;
                // invalidate the buffered max extent cache
                this.bufferedMaxExtent_ = null;
            }
        } else {
            state.strokeStyle = undefined;
            state.lineCap = undefined;
            state.lineDash = null;
            state.lineDashOffset = undefined;
            state.lineJoin = undefined;
            state.lineWidth = undefined;
            state.miterLimit = undefined;
        }
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */ createFill(state) {
        const fillStyle = state.fillStyle;
        /** @type {Array<*>} */ const fillInstruction = [
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            fillStyle
        ];
        if (typeof fillStyle !== 'string') // Fill is a pattern or gradient - align it!
        fillInstruction.push(true);
        return fillInstruction;
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */ applyStroke(state) {
        this.instructions.push(this.createStroke(state));
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */ createStroke(state) {
        return [
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth * this.pixelRatio,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            this.applyPixelRatio(state.lineDash),
            state.lineDashOffset * this.pixelRatio
        ];
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */ updateFillStyle(state, createFill) {
        const fillStyle = state.fillStyle;
        if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
            if (fillStyle !== undefined) this.instructions.push(createFill.call(this, state));
            state.currentFillStyle = fillStyle;
        }
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */ updateStrokeStyle(state, applyStroke) {
        const strokeStyle = state.strokeStyle;
        const lineCap = state.lineCap;
        const lineDash = state.lineDash;
        const lineDashOffset = state.lineDashOffset;
        const lineJoin = state.lineJoin;
        const lineWidth = state.lineWidth;
        const miterLimit = state.miterLimit;
        if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !(0, _arrayJs.equals)(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
            if (strokeStyle !== undefined) applyStroke.call(this, state);
            state.currentStrokeStyle = strokeStyle;
            state.currentLineCap = lineCap;
            state.currentLineDash = lineDash;
            state.currentLineDashOffset = lineDashOffset;
            state.currentLineJoin = lineJoin;
            state.currentLineWidth = lineWidth;
            state.currentMiterLimit = miterLimit;
        }
    }
    /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ endGeometry(feature) {
        this.beginGeometryInstruction1_[2] = this.instructions.length;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
        this.beginGeometryInstruction2_ = null;
        const endGeometryInstruction = [
            (0, _instructionJsDefault.default).END_GEOMETRY,
            feature
        ];
        this.instructions.push(endGeometryInstruction);
        this.hitDetectionInstructions.push(endGeometryInstruction);
    }
    /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */ getBufferedMaxExtent() {
        if (!this.bufferedMaxExtent_) {
            this.bufferedMaxExtent_ = (0, _extentJs.clone)(this.maxExtent);
            if (this.maxLineWidth > 0) {
                const width = this.resolution * (this.maxLineWidth + 1) / 2;
                (0, _extentJs.buffer)(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
            }
        }
        return this.bufferedMaxExtent_;
    }
}
exports.default = CanvasBuilder;

},{"./Instruction.js":"aw1sl","../../extent/Relationship.js":"7qhKb","../VectorContext.js":"627sc","../../colorlike.js":"36IFz","../../extent.js":"bGUel","../canvas.js":"6S9WQ","../../array.js":"hyet5","../../geom/flat/inflate.js":"hm7Zu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aw1sl":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/Instruction
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fillInstruction", ()=>fillInstruction);
parcelHelpers.export(exports, "strokeInstruction", ()=>strokeInstruction);
parcelHelpers.export(exports, "beginPathInstruction", ()=>beginPathInstruction);
parcelHelpers.export(exports, "closePathInstruction", ()=>closePathInstruction);
const Instruction = {
    BEGIN_GEOMETRY: 0,
    BEGIN_PATH: 1,
    CIRCLE: 2,
    CLOSE_PATH: 3,
    CUSTOM: 4,
    DRAW_CHARS: 5,
    DRAW_IMAGE: 6,
    END_GEOMETRY: 7,
    FILL: 8,
    MOVE_TO_LINE_TO: 9,
    SET_FILL_STYLE: 10,
    SET_STROKE_STYLE: 11,
    STROKE: 12
};
const fillInstruction = [
    Instruction.FILL
];
const strokeInstruction = [
    Instruction.STROKE
];
const beginPathInstruction = [
    Instruction.BEGIN_PATH
];
const closePathInstruction = [
    Instruction.CLOSE_PATH
];
exports.default = Instruction;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"627sc":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/VectorContext
 */ /**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class VectorContext {
    /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */ drawCustom(geometry, feature, renderer, hitDetectionRenderer) {}
    /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */ drawGeometry(geometry) {}
    /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */ setStyle(style) {}
    /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */ drawCircle(circleGeometry, feature) {}
    /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */ drawFeature(feature, style) {}
    /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */ drawGeometryCollection(geometryCollectionGeometry, feature) {}
    /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawLineString(lineStringGeometry, feature) {}
    /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawMultiLineString(multiLineStringGeometry, feature) {}
    /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPoint(multiPointGeometry, feature) {}
    /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPolygon(multiPolygonGeometry, feature) {}
    /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawPoint(pointGeometry, feature) {}
    /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawPolygon(polygonGeometry, feature) {}
    /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawText(geometry, feature) {}
    /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */ setFillStrokeStyle(fillStyle, strokeStyle) {}
    /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */ setImageStyle(imageStyle, declutterImageWithText) {}
    /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */ setTextStyle(textStyle, declutterImageWithText) {}
}
exports.default = VectorContext;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iZRVS":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/ImageBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
class CanvasImageBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
        /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */ this.hitDetectionImage_ = null;
        /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */ this.image_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.imagePixelRatio_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.anchorX_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.anchorY_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.height_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.opacity_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.originX_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.originY_ = undefined;
        /**
     * @private
     * @type {boolean|undefined}
     */ this.rotateWithView_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.rotation_ = undefined;
        /**
     * @private
     * @type {import("../../size.js").Size|undefined}
     */ this.scale_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.width_ = undefined;
        /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */ this.declutterMode_ = undefined;
        /**
     * Data shared with a text builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */ this.declutterImageWithText_ = undefined;
    }
    /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawPoint(pointGeometry, feature) {
        if (!this.image_) return;
        this.beginGeometry(pointGeometry, feature);
        const flatCoordinates = pointGeometry.getFlatCoordinates();
        const stride = pointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_ * this.imagePixelRatio_,
            this.anchorY_ * this.imagePixelRatio_,
            Math.ceil(this.height_ * this.imagePixelRatio_),
            this.opacity_,
            this.originX_ * this.imagePixelRatio_,
            this.originY_ * this.imagePixelRatio_,
            this.rotateWithView_,
            this.rotation_,
            [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
            ],
            Math.ceil(this.width_ * this.imagePixelRatio_),
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_,
            this.anchorY_,
            this.height_,
            1,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            this.scale_,
            this.width_,
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPoint(multiPointGeometry, feature) {
        if (!this.image_) return;
        this.beginGeometry(multiPointGeometry, feature);
        const flatCoordinates = multiPointGeometry.getFlatCoordinates();
        const stride = multiPointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_ * this.imagePixelRatio_,
            this.anchorY_ * this.imagePixelRatio_,
            Math.ceil(this.height_ * this.imagePixelRatio_),
            this.opacity_,
            this.originX_ * this.imagePixelRatio_,
            this.originY_ * this.imagePixelRatio_,
            this.rotateWithView_,
            this.rotation_,
            [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
            ],
            Math.ceil(this.width_ * this.imagePixelRatio_),
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_,
            this.anchorY_,
            this.height_,
            1,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            this.scale_,
            this.width_,
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        this.reverseHitDetectionInstructions();
        // FIXME this doesn't really protect us against further calls to draw*Geometry
        this.anchorX_ = undefined;
        this.anchorY_ = undefined;
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = undefined;
        this.height_ = undefined;
        this.scale_ = undefined;
        this.opacity_ = undefined;
        this.originX_ = undefined;
        this.originY_ = undefined;
        this.rotateWithView_ = undefined;
        this.rotation_ = undefined;
        this.width_ = undefined;
        return super.finish();
    }
    /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */ setImageStyle(imageStyle, sharedData) {
        const anchor = imageStyle.getAnchor();
        const size = imageStyle.getSize();
        const origin = imageStyle.getOrigin();
        this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
        this.anchorX_ = anchor[0];
        this.anchorY_ = anchor[1];
        this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
        this.image_ = imageStyle.getImage(this.pixelRatio);
        this.height_ = size[1];
        this.opacity_ = imageStyle.getOpacity();
        this.originX_ = origin[0];
        this.originY_ = origin[1];
        this.rotateWithView_ = imageStyle.getRotateWithView();
        this.rotation_ = imageStyle.getRotation();
        this.scale_ = imageStyle.getScaleArray();
        this.width_ = size[0];
        this.declutterMode_ = imageStyle.getDeclutterMode();
        this.declutterImageWithText_ = sharedData;
    }
}
exports.default = CanvasImageBuilder;

},{"./Builder.js":"5Yz7q","./Instruction.js":"aw1sl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hBKvU":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/LineStringBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _canvasJs = require("../canvas.js");
class CanvasLineStringBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */ drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
        const moveToLineToInstruction = [
            (0, _instructionJsDefault.default).MOVE_TO_LINE_TO,
            myBegin,
            myEnd
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
    }
    /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawLineString(lineStringGeometry, feature) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) return;
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(lineStringGeometry, feature);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ], (0, _instructionJs.beginPathInstruction));
        const flatCoordinates = lineStringGeometry.getFlatCoordinates();
        const stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
        this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawMultiLineString(multiLineStringGeometry, feature) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) return;
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(multiLineStringGeometry, feature);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ], (0, _instructionJs.beginPathInstruction));
        const ends = multiLineStringGeometry.getEnds();
        const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        const stride = multiLineStringGeometry.getStride();
        let offset = 0;
        for(let i = 0, ii = ends.length; i < ii; ++i)offset = this.drawFlatCoordinates_(flatCoordinates, offset, /** @type {number} */ ends[i], stride);
        this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        this.endGeometry(feature);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        const state = this.state;
        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) this.instructions.push((0, _instructionJs.strokeInstruction));
        this.reverseHitDetectionInstructions();
        this.state = null;
        return super.finish();
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */ applyStroke(state) {
        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
            this.instructions.push((0, _instructionJs.strokeInstruction));
            state.lastStroke = this.coordinates.length;
        }
        state.lastStroke = 0;
        super.applyStroke(state);
        this.instructions.push((0, _instructionJs.beginPathInstruction));
    }
}
exports.default = CanvasLineStringBuilder;

},{"./Builder.js":"5Yz7q","./Instruction.js":"aw1sl","../canvas.js":"6S9WQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"arlHY":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/PolygonBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _canvasJs = require("../canvas.js");
var _simplifyJs = require("../../geom/flat/simplify.js");
class CanvasPolygonBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */ drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
        const state = this.state;
        const fill = state.fillStyle !== undefined;
        const stroke = state.strokeStyle !== undefined;
        const numEnds = ends.length;
        this.instructions.push((0, _instructionJs.beginPathInstruction));
        this.hitDetectionInstructions.push((0, _instructionJs.beginPathInstruction));
        for(let i = 0; i < numEnds; ++i){
            const end = ends[i];
            const myBegin = this.coordinates.length;
            const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
            const moveToLineToInstruction = [
                (0, _instructionJsDefault.default).MOVE_TO_LINE_TO,
                myBegin,
                myEnd
            ];
            this.instructions.push(moveToLineToInstruction);
            this.hitDetectionInstructions.push(moveToLineToInstruction);
            if (stroke) {
                // Performance optimization: only call closePath() when we have a stroke.
                // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
                this.instructions.push((0, _instructionJs.closePathInstruction));
                this.hitDetectionInstructions.push((0, _instructionJs.closePathInstruction));
            }
            offset = end;
        }
        if (fill) {
            this.instructions.push((0, _instructionJs.fillInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.fillInstruction));
        }
        if (stroke) {
            this.instructions.push((0, _instructionJs.strokeInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        }
        return offset;
    }
    /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */ drawCircle(circleGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(circleGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            (0, _canvasJs.defaultFillStyle)
        ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ]);
        const flatCoordinates = circleGeometry.getFlatCoordinates();
        const stride = circleGeometry.getStride();
        const myBegin = this.coordinates.length;
        this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
        const circleInstruction = [
            (0, _instructionJsDefault.default).CIRCLE,
            myBegin
        ];
        this.instructions.push((0, _instructionJs.beginPathInstruction), circleInstruction);
        this.hitDetectionInstructions.push((0, _instructionJs.beginPathInstruction), circleInstruction);
        if (state.fillStyle !== undefined) {
            this.instructions.push((0, _instructionJs.fillInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.fillInstruction));
        }
        if (state.strokeStyle !== undefined) {
            this.instructions.push((0, _instructionJs.strokeInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        }
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawPolygon(polygonGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(polygonGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            (0, _canvasJs.defaultFillStyle)
        ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ]);
        const ends = polygonGeometry.getEnds();
        const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        const stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(flatCoordinates, 0, /** @type {Array<number>} */ ends, stride);
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPolygon(multiPolygonGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            (0, _canvasJs.defaultFillStyle)
        ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ]);
        const endss = multiPolygonGeometry.getEndss();
        const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        const stride = multiPolygonGeometry.getStride();
        let offset = 0;
        for(let i = 0, ii = endss.length; i < ii; ++i)offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
        this.endGeometry(feature);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        this.reverseHitDetectionInstructions();
        this.state = null;
        // We want to preserve topology when drawing polygons.  Polygons are
        // simplified using quantization and point elimination. However, we might
        // have received a mix of quantized and non-quantized geometries, so ensure
        // that all are quantized by quantizing all coordinates in the batch.
        const tolerance = this.tolerance;
        if (tolerance !== 0) {
            const coordinates = this.coordinates;
            for(let i = 0, ii = coordinates.length; i < ii; ++i)coordinates[i] = (0, _simplifyJs.snap)(coordinates[i], tolerance);
        }
        return super.finish();
    }
    /**
   * @private
   */ setFillStrokeStyles_() {
        const state = this.state;
        const fillStyle = state.fillStyle;
        if (fillStyle !== undefined) this.updateFillStyle(state, this.createFill);
        if (state.strokeStyle !== undefined) this.updateStrokeStyle(state, this.applyStroke);
    }
}
exports.default = CanvasPolygonBuilder;

},{"./Builder.js":"5Yz7q","./Instruction.js":"aw1sl","../canvas.js":"6S9WQ","../../geom/flat/simplify.js":"gXvXA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hSSq4":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/TextBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TEXT_ALIGN", ()=>TEXT_ALIGN);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _colorlikeJs = require("../../colorlike.js");
var _canvasJs = require("../canvas.js");
var _utilJs = require("../../util.js");
var _extentJs = require("../../extent.js");
var _linechunkJs = require("../../geom/flat/linechunk.js");
var _straightchunkJs = require("../../geom/flat/straightchunk.js");
const TEXT_ALIGN = {
    'left': 0,
    'center': 0.5,
    'right': 1,
    'top': 0,
    'middle': 0.5,
    'hanging': 0.2,
    'alphabetic': 0.8,
    'ideographic': 0.8,
    'bottom': 1
};
class CanvasTextBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
        /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */ this.labels_ = null;
        /**
     * @private
     * @type {string|Array<string>}
     */ this.text_ = '';
        /**
     * @private
     * @type {number}
     */ this.textOffsetX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.textOffsetY_ = 0;
        /**
     * @private
     * @type {boolean|undefined}
     */ this.textRotateWithView_ = undefined;
        /**
     * @private
     * @type {number}
     */ this.textRotation_ = 0;
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.textFillState_ = null;
        /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */ this.fillStates = {};
        this.fillStates[0, _canvasJs.defaultFillStyle] = {
            fillStyle: (0, _canvasJs.defaultFillStyle)
        };
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.textStrokeState_ = null;
        /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */ this.strokeStates = {};
        /**
     * @private
     * @type {import("../canvas.js").TextState}
     */ this.textState_ = /** @type {import("../canvas.js").TextState} */ {};
        /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */ this.textStates = {};
        /**
     * @private
     * @type {string}
     */ this.textKey_ = '';
        /**
     * @private
     * @type {string}
     */ this.fillKey_ = '';
        /**
     * @private
     * @type {string}
     */ this.strokeKey_ = '';
        /**
     * Data shared with an image builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */ this.declutterImageWithText_ = undefined;
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        const instructions = super.finish();
        instructions.textStates = this.textStates;
        instructions.fillStates = this.fillStates;
        instructions.strokeStates = this.strokeStates;
        return instructions;
    }
    /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawText(geometry, feature) {
        const fillState = this.textFillState_;
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        if (this.text_ === '' || !textState || !fillState && !strokeState) return;
        const coordinates = this.coordinates;
        let begin = coordinates.length;
        const geometryType = geometry.getType();
        let flatCoordinates = null;
        let stride = geometry.getStride();
        if (textState.placement === 'line' && (geometryType == 'LineString' || geometryType == 'MultiLineString' || geometryType == 'Polygon' || geometryType == 'MultiPolygon')) {
            if (!(0, _extentJs.intersects)(this.getBufferedMaxExtent(), geometry.getExtent())) return;
            let ends;
            flatCoordinates = geometry.getFlatCoordinates();
            if (geometryType == 'LineString') ends = [
                flatCoordinates.length
            ];
            else if (geometryType == 'MultiLineString') ends = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.getEnds();
            else if (geometryType == 'Polygon') ends = /** @type {import("../../geom/Polygon.js").default} */ geometry.getEnds().slice(0, 1);
            else if (geometryType == 'MultiPolygon') {
                const endss = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getEndss();
                ends = [];
                for(let i = 0, ii = endss.length; i < ii; ++i)ends.push(endss[i][0]);
            }
            this.beginGeometry(geometry, feature);
            const repeat = textState.repeat;
            const textAlign = repeat ? undefined : textState.textAlign;
            // No `justify` support for line placement.
            let flatOffset = 0;
            for(let o = 0, oo = ends.length; o < oo; ++o){
                let chunks;
                if (repeat) chunks = (0, _linechunkJs.lineChunk)(repeat * this.resolution, flatCoordinates, flatOffset, ends[o], stride);
                else chunks = [
                    flatCoordinates.slice(flatOffset, ends[o])
                ];
                for(let c = 0, cc = chunks.length; c < cc; ++c){
                    const chunk = chunks[c];
                    let chunkBegin = 0;
                    let chunkEnd = chunk.length;
                    if (textAlign == undefined) {
                        const range = (0, _straightchunkJs.matchingChunk)(textState.maxAngle, chunk, 0, chunk.length, 2);
                        chunkBegin = range[0];
                        chunkEnd = range[1];
                    }
                    for(let i = chunkBegin; i < chunkEnd; i += stride)coordinates.push(chunk[i], chunk[i + 1]);
                    const end = coordinates.length;
                    flatOffset = ends[o];
                    this.drawChars_(begin, end);
                    begin = end;
                }
            }
            this.endGeometry(feature);
        } else {
            let geometryWidths = textState.overflow ? null : [];
            switch(geometryType){
                case 'Point':
                case 'MultiPoint':
                    flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */ geometry.getFlatCoordinates();
                    break;
                case 'LineString':
                    flatCoordinates = /** @type {import("../../geom/LineString.js").default} */ geometry.getFlatMidpoint();
                    break;
                case 'Circle':
                    flatCoordinates = /** @type {import("../../geom/Circle.js").default} */ geometry.getCenter();
                    break;
                case 'MultiLineString':
                    flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.getFlatMidpoints();
                    stride = 2;
                    break;
                case 'Polygon':
                    flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */ geometry.getFlatInteriorPoint();
                    if (!textState.overflow) geometryWidths.push(flatCoordinates[2] / this.resolution);
                    stride = 3;
                    break;
                case 'MultiPolygon':
                    const interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getFlatInteriorPoints();
                    flatCoordinates = [];
                    for(let i = 0, ii = interiorPoints.length; i < ii; i += 3){
                        if (!textState.overflow) geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                        flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                    }
                    if (flatCoordinates.length === 0) return;
                    stride = 2;
                    break;
                default:
            }
            const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
            if (end === begin) return;
            if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
                let beg = begin / 2;
                geometryWidths = geometryWidths.filter((w, i)=>{
                    const keep = coordinates[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
                    if (!keep) --beg;
                    return keep;
                });
            }
            this.saveTextStates_();
            if (textState.backgroundFill || textState.backgroundStroke) {
                this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                if (textState.backgroundFill) this.updateFillStyle(this.state, this.createFill);
                if (textState.backgroundStroke) {
                    this.updateStrokeStyle(this.state, this.applyStroke);
                    this.hitDetectionInstructions.push(this.createStroke(this.state));
                }
            }
            this.beginGeometry(geometry, feature);
            // adjust padding for negative scale
            let padding = textState.padding;
            if (padding != (0, _canvasJs.defaultPadding) && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                let p0 = textState.padding[0];
                let p1 = textState.padding[1];
                let p2 = textState.padding[2];
                let p3 = textState.padding[3];
                if (textState.scale[0] < 0) {
                    p1 = -p1;
                    p3 = -p3;
                }
                if (textState.scale[1] < 0) {
                    p0 = -p0;
                    p2 = -p2;
                }
                padding = [
                    p0,
                    p1,
                    p2,
                    p3
                ];
            }
            // The image is unknown at this stage so we pass null; it will be computed at render time.
            // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
            // render time.
            const pixelRatio = this.pixelRatio;
            this.instructions.push([
                (0, _instructionJsDefault.default).DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [
                    1,
                    1
                ],
                NaN,
                undefined,
                this.declutterImageWithText_,
                padding == (0, _canvasJs.defaultPadding) ? (0, _canvasJs.defaultPadding) : padding.map(function(p) {
                    return p * pixelRatio;
                }),
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths
            ]);
            const scale = 1 / pixelRatio;
            // Set default fill for hit detection background
            const currentFillStyle = this.state.fillStyle;
            if (textState.backgroundFill) {
                this.state.fillStyle = (0, _canvasJs.defaultFillStyle);
                this.hitDetectionInstructions.push(this.createFill(this.state));
            }
            this.hitDetectionInstructions.push([
                (0, _instructionJsDefault.default).DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [
                    scale,
                    scale
                ],
                NaN,
                undefined,
                this.declutterImageWithText_,
                padding,
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_ ? (0, _canvasJs.defaultFillStyle) : this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths
            ]);
            // Reset previous fill
            if (textState.backgroundFill) {
                this.state.fillStyle = currentFillStyle;
                this.hitDetectionInstructions.push(this.createFill(this.state));
            }
            this.endGeometry(feature);
        }
    }
    /**
   * @private
   */ saveTextStates_() {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const fillState = this.textFillState_;
        const strokeKey = this.strokeKey_;
        if (strokeState) {
            if (!(strokeKey in this.strokeStates)) this.strokeStates[strokeKey] = {
                strokeStyle: strokeState.strokeStyle,
                lineCap: strokeState.lineCap,
                lineDashOffset: strokeState.lineDashOffset,
                lineWidth: strokeState.lineWidth,
                lineJoin: strokeState.lineJoin,
                miterLimit: strokeState.miterLimit,
                lineDash: strokeState.lineDash
            };
        }
        const textKey = this.textKey_;
        if (!(textKey in this.textStates)) this.textStates[textKey] = {
            font: textState.font,
            textAlign: textState.textAlign || (0, _canvasJs.defaultTextAlign),
            justify: textState.justify,
            textBaseline: textState.textBaseline || (0, _canvasJs.defaultTextBaseline),
            scale: textState.scale
        };
        const fillKey = this.fillKey_;
        if (fillState) {
            if (!(fillKey in this.fillStates)) this.fillStates[fillKey] = {
                fillStyle: fillState.fillStyle
            };
        }
    }
    /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */ drawChars_(begin, end) {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const strokeKey = this.strokeKey_;
        const textKey = this.textKey_;
        const fillKey = this.fillKey_;
        this.saveTextStates_();
        const pixelRatio = this.pixelRatio;
        const baseline = TEXT_ALIGN[textState.textBaseline];
        const offsetY = this.textOffsetY_ * pixelRatio;
        const text = this.text_;
        const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
        this.instructions.push([
            (0, _instructionJsDefault.default).DRAW_CHARS,
            begin,
            end,
            baseline,
            textState.overflow,
            fillKey,
            textState.maxAngle,
            pixelRatio,
            offsetY,
            strokeKey,
            strokeWidth * pixelRatio,
            text,
            textKey,
            1
        ]);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).DRAW_CHARS,
            begin,
            end,
            baseline,
            textState.overflow,
            fillKey ? (0, _canvasJs.defaultFillStyle) : fillKey,
            textState.maxAngle,
            pixelRatio,
            offsetY,
            strokeKey,
            strokeWidth * pixelRatio,
            text,
            textKey,
            1 / pixelRatio
        ]);
    }
    /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */ setTextStyle(textStyle, sharedData) {
        let textState, fillState, strokeState;
        if (!textStyle) this.text_ = '';
        else {
            const textFillStyle = textStyle.getFill();
            if (!textFillStyle) {
                fillState = null;
                this.textFillState_ = fillState;
            } else {
                fillState = this.textFillState_;
                if (!fillState) {
                    fillState = /** @type {import("../canvas.js").FillState} */ {};
                    this.textFillState_ = fillState;
                }
                fillState.fillStyle = (0, _colorlikeJs.asColorLike)(textFillStyle.getColor() || (0, _canvasJs.defaultFillStyle));
            }
            const textStrokeStyle = textStyle.getStroke();
            if (!textStrokeStyle) {
                strokeState = null;
                this.textStrokeState_ = strokeState;
            } else {
                strokeState = this.textStrokeState_;
                if (!strokeState) {
                    strokeState = /** @type {import("../canvas.js").StrokeState} */ {};
                    this.textStrokeState_ = strokeState;
                }
                const lineDash = textStrokeStyle.getLineDash();
                const lineDashOffset = textStrokeStyle.getLineDashOffset();
                const lineWidth = textStrokeStyle.getWidth();
                const miterLimit = textStrokeStyle.getMiterLimit();
                strokeState.lineCap = textStrokeStyle.getLineCap() || (0, _canvasJs.defaultLineCap);
                strokeState.lineDash = lineDash ? lineDash.slice() : (0, _canvasJs.defaultLineDash);
                strokeState.lineDashOffset = lineDashOffset === undefined ? (0, _canvasJs.defaultLineDashOffset) : lineDashOffset;
                strokeState.lineJoin = textStrokeStyle.getLineJoin() || (0, _canvasJs.defaultLineJoin);
                strokeState.lineWidth = lineWidth === undefined ? (0, _canvasJs.defaultLineWidth) : lineWidth;
                strokeState.miterLimit = miterLimit === undefined ? (0, _canvasJs.defaultMiterLimit) : miterLimit;
                strokeState.strokeStyle = (0, _colorlikeJs.asColorLike)(textStrokeStyle.getColor() || (0, _canvasJs.defaultStrokeStyle));
            }
            textState = this.textState_;
            const font = textStyle.getFont() || (0, _canvasJs.defaultFont);
            (0, _canvasJs.registerFont)(font);
            const textScale = textStyle.getScaleArray();
            textState.overflow = textStyle.getOverflow();
            textState.font = font;
            textState.maxAngle = textStyle.getMaxAngle();
            textState.placement = textStyle.getPlacement();
            textState.textAlign = textStyle.getTextAlign();
            textState.repeat = textStyle.getRepeat();
            textState.justify = textStyle.getJustify();
            textState.textBaseline = textStyle.getTextBaseline() || (0, _canvasJs.defaultTextBaseline);
            textState.backgroundFill = textStyle.getBackgroundFill();
            textState.backgroundStroke = textStyle.getBackgroundStroke();
            textState.padding = textStyle.getPadding() || (0, _canvasJs.defaultPadding);
            textState.scale = textScale === undefined ? [
                1,
                1
            ] : textScale;
            const textOffsetX = textStyle.getOffsetX();
            const textOffsetY = textStyle.getOffsetY();
            const textRotateWithView = textStyle.getRotateWithView();
            const textRotation = textStyle.getRotation();
            this.text_ = textStyle.getText() || '';
            this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
            this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
            this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
            this.textRotation_ = textRotation === undefined ? 0 : textRotation;
            this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : (0, _utilJs.getUid)(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
            this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.repeat || '?') + (textState.justify || '?') + (textState.textBaseline || '?');
            this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + (0, _utilJs.getUid)(fillState.fillStyle) : '';
        }
        this.declutterImageWithText_ = sharedData;
    }
}
exports.default = CanvasTextBuilder;

},{"./Builder.js":"5Yz7q","./Instruction.js":"aw1sl","../../colorlike.js":"36IFz","../canvas.js":"6S9WQ","../../util.js":"l1iPW","../../extent.js":"bGUel","../../geom/flat/linechunk.js":"d7O6G","../../geom/flat/straightchunk.js":"kXkhP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d7O6G":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates chunks of equal length from a linestring
 * @param {number} chunkLength Length of each chunk.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @return {Array<Array<number>>} Chunks of linestrings with stride 2.
 */ parcelHelpers.export(exports, "lineChunk", ()=>lineChunk);
var _mathJs = require("../../math.js");
function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {
    const chunks = [];
    let cursor = offset;
    let chunkM = 0;
    let currentChunk = flatCoordinates.slice(offset, 2);
    while(chunkM < chunkLength && cursor + stride < end){
        const [x1, y1] = currentChunk.slice(-2);
        const x2 = flatCoordinates[cursor + stride];
        const y2 = flatCoordinates[cursor + stride + 1];
        const segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        chunkM += segmentLength;
        if (chunkM >= chunkLength) {
            const m = (chunkLength - chunkM + segmentLength) / segmentLength;
            const x = (0, _mathJs.lerp)(x1, x2, m);
            const y = (0, _mathJs.lerp)(y1, y2, m);
            currentChunk.push(x, y);
            chunks.push(currentChunk);
            currentChunk = [
                x,
                y
            ];
            if (chunkM == chunkLength) cursor += stride;
            chunkM = 0;
        } else if (chunkM < chunkLength) {
            currentChunk.push(flatCoordinates[cursor + stride], flatCoordinates[cursor + stride + 1]);
            cursor += stride;
        } else {
            const missing = segmentLength - chunkM;
            const x = (0, _mathJs.lerp)(x1, x2, missing / segmentLength);
            const y = (0, _mathJs.lerp)(y1, y2, missing / segmentLength);
            currentChunk.push(x, y);
            chunks.push(currentChunk);
            currentChunk = [
                x,
                y
            ];
            chunkM = 0;
            cursor += stride;
        }
    }
    if (chunkM > 0) chunks.push(currentChunk);
    return chunks;
}

},{"../../math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kXkhP":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/straightchunk
 */ /**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "matchingChunk", ()=>matchingChunk);
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
    let chunkStart = offset;
    let chunkEnd = offset;
    let chunkM = 0;
    let m = 0;
    let start = offset;
    let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
    for(i = offset; i < end; i += stride){
        const x2 = flatCoordinates[i];
        const y2 = flatCoordinates[i + 1];
        if (x1 !== undefined) {
            x23 = x2 - x1;
            y23 = y2 - y1;
            m23 = Math.sqrt(x23 * x23 + y23 * y23);
            if (x12 !== undefined) {
                m += m12;
                acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                if (acos > maxAngle) {
                    if (m > chunkM) {
                        chunkM = m;
                        chunkStart = start;
                        chunkEnd = i;
                    }
                    m = 0;
                    start = i - stride;
                }
            }
            m12 = m23;
            x12 = x23;
            y12 = y23;
        }
        x1 = x2;
        y1 = y2;
    }
    m += m23;
    return m > chunkM ? [
        start,
        i
    ] : [
        chunkStart,
        chunkEnd
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l1Ibd":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/ExecutorGroup
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @return {Array<number>} An array with indexes within a circle.
 */ parcelHelpers.export(exports, "getPixelIndexArray", ()=>getPixelIndexArray);
var _executorJs = require("./Executor.js");
var _executorJsDefault = parcelHelpers.interopDefault(_executorJs);
var _arrayJs = require("../../array.js");
var _extentJs = require("../../extent.js");
var _transformJs = require("../../transform.js");
var _domJs = require("../../dom.js");
var _objJs = require("../../obj.js");
var _transformJs1 = require("../../geom/flat/transform.js");
/**
 * @const
 * @type {Array<import("../canvas.js").BuilderType>}
 */ const ORDER = [
    'Polygon',
    'Circle',
    'LineString',
    'Image',
    'Text',
    'Default'
];
class ExecutorGroup {
    /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */ constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer){
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.maxExtent_ = maxExtent;
        /**
     * @private
     * @type {boolean}
     */ this.overlaps_ = overlaps;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {number}
     */ this.resolution_ = resolution;
        /**
     * @private
     * @type {number|undefined}
     */ this.renderBuffer_ = renderBuffer;
        /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Executor").default>>}
     */ this.executorsByZIndex_ = {};
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.hitDetectionContext_ = null;
        /**
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.hitDetectionTransform_ = (0, _transformJs.create)();
        this.createExecutors_(allInstructions);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */ clip(context, transform) {
        const flatClipCoords = this.getClipCoords(transform);
        context.beginPath();
        context.moveTo(flatClipCoords[0], flatClipCoords[1]);
        context.lineTo(flatClipCoords[2], flatClipCoords[3]);
        context.lineTo(flatClipCoords[4], flatClipCoords[5]);
        context.lineTo(flatClipCoords[6], flatClipCoords[7]);
        context.clip();
    }
    /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */ createExecutors_(allInstructions) {
        for(const zIndex in allInstructions){
            let executors = this.executorsByZIndex_[zIndex];
            if (executors === undefined) {
                executors = {};
                this.executorsByZIndex_[zIndex] = executors;
            }
            const instructionByZindex = allInstructions[zIndex];
            for(const builderType in instructionByZindex){
                const instructions = instructionByZindex[builderType];
                executors[builderType] = new (0, _executorJsDefault.default)(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
            }
        }
    }
    /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */ hasExecutors(executors) {
        for(const zIndex in this.executorsByZIndex_){
            const candidates = this.executorsByZIndex_[zIndex];
            for(let i = 0, ii = executors.length; i < ii; ++i){
                if (executors[i] in candidates) return true;
            }
        }
        return false;
    }
    /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
        hitTolerance = Math.round(hitTolerance);
        const contextSize = hitTolerance * 2 + 1;
        const transform = (0, _transformJs.compose)(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
        const newContext = !this.hitDetectionContext_;
        if (newContext) this.hitDetectionContext_ = (0, _domJs.createCanvasContext2D)(contextSize, contextSize, undefined, {
            willReadFrequently: true
        });
        const context = this.hitDetectionContext_;
        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
            context.canvas.width = contextSize;
            context.canvas.height = contextSize;
        } else if (!newContext) context.clearRect(0, 0, contextSize, contextSize);
        /**
     * @type {import("../../extent.js").Extent}
     */ let hitExtent;
        if (this.renderBuffer_ !== undefined) {
            hitExtent = (0, _extentJs.createEmpty)();
            (0, _extentJs.extendCoordinate)(hitExtent, coordinate);
            (0, _extentJs.buffer)(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
        }
        const indexes = getPixelIndexArray(hitTolerance);
        let builderType;
        /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */ function featureCallback(feature, geometry) {
            const imageData = context.getImageData(0, 0, contextSize, contextSize).data;
            for(let i = 0, ii = indexes.length; i < ii; i++)if (imageData[indexes[i]] > 0) {
                if (!declutteredFeatures || builderType !== 'Image' && builderType !== 'Text' || declutteredFeatures.includes(feature)) {
                    const idx = (indexes[i] - 3) / 4;
                    const x = hitTolerance - idx % contextSize;
                    const y = hitTolerance - (idx / contextSize | 0);
                    const result = callback(feature, geometry, x * x + y * y);
                    if (result) return result;
                }
                context.clearRect(0, 0, contextSize, contextSize);
                break;
            }
            return undefined;
        }
        /** @type {Array<number>} */ const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort((0, _arrayJs.ascending));
        let i, j, executors, executor, result;
        for(i = zs.length - 1; i >= 0; --i){
            const zIndexKey = zs[i].toString();
            executors = this.executorsByZIndex_[zIndexKey];
            for(j = ORDER.length - 1; j >= 0; --j){
                builderType = ORDER[j];
                executor = executors[builderType];
                if (executor !== undefined) {
                    result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);
                    if (result) return result;
                }
            }
        }
        return undefined;
    }
    /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */ getClipCoords(transform) {
        const maxExtent = this.maxExtent_;
        if (!maxExtent) return null;
        const minX = maxExtent[0];
        const minY = maxExtent[1];
        const maxX = maxExtent[2];
        const maxY = maxExtent[3];
        const flatClipCoords = [
            minX,
            minY,
            minX,
            maxY,
            maxX,
            maxY,
            maxX,
            minY
        ];
        (0, _transformJs1.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
        return flatClipCoords;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return (0, _objJs.isEmpty)(this.executorsByZIndex_);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */ execute(context, contextScale, transform, viewRotation, snapToPixel, builderTypes, declutterTree) {
        /** @type {Array<number>} */ const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort((0, _arrayJs.ascending));
        // setup clipping so that the parts of over-simplified geometries are not
        // visible outside the current extent when panning
        if (this.maxExtent_) {
            context.save();
            this.clip(context, transform);
        }
        builderTypes = builderTypes ? builderTypes : ORDER;
        let i, ii, j, jj, replays, replay;
        if (declutterTree) zs.reverse();
        for(i = 0, ii = zs.length; i < ii; ++i){
            const zIndexKey = zs[i].toString();
            replays = this.executorsByZIndex_[zIndexKey];
            for(j = 0, jj = builderTypes.length; j < jj; ++j){
                const builderType = builderTypes[j];
                replay = replays[builderType];
                if (replay !== undefined) replay.execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree);
            }
        }
        if (this.maxExtent_) context.restore();
    }
}
/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */ const circlePixelIndexArrayCache = {};
function getPixelIndexArray(radius) {
    if (circlePixelIndexArrayCache[radius] !== undefined) return circlePixelIndexArrayCache[radius];
    const size = radius * 2 + 1;
    const maxDistanceSq = radius * radius;
    const distances = new Array(maxDistanceSq + 1);
    for(let i = 0; i <= radius; ++i)for(let j = 0; j <= radius; ++j){
        const distanceSq = i * i + j * j;
        if (distanceSq > maxDistanceSq) break;
        let distance = distances[distanceSq];
        if (!distance) {
            distance = [];
            distances[distanceSq] = distance;
        }
        distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
        if (i > 0) distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
        if (j > 0) {
            distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
            if (i > 0) distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
    }
    const pixelIndex = [];
    for(let i = 0, ii = distances.length; i < ii; ++i)if (distances[i]) pixelIndex.push(...distances[i]);
    circlePixelIndexArrayCache[radius] = pixelIndex;
    return pixelIndex;
}
exports.default = ExecutorGroup;

},{"./Executor.js":"fBhUq","../../array.js":"hyet5","../../extent.js":"bGUel","../../transform.js":"9LrRk","../../dom.js":"h98kD","../../obj.js":"7RZD4","../../geom/flat/transform.js":"7FFJr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fBhUq":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/Executor
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _textBuilderJs = require("./TextBuilder.js");
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _canvasJs = require("../canvas.js");
var _textpathJs = require("../../geom/flat/textpath.js");
var _arrayJs = require("../../array.js");
var _lengthJs = require("../../geom/flat/length.js");
var _transformJs1 = require("../../geom/flat/transform.js");
/**
 * @typedef {Object} BBox
 * @property {number} minX Minimal x.
 * @property {number} minY Minimal y.
 * @property {number} maxX Maximal x.
 * @property {number} maxY Maximal y
 * @property {*} value Value.
 */ /**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX DrawImageX.
 * @property {number} drawImageY DrawImageY.
 * @property {number} drawImageW DrawImageW.
 * @property {number} drawImageH DrawImageH.
 * @property {number} originX OriginX.
 * @property {number} originY OriginY.
 * @property {Array<number>} scale Scale.
 * @property {BBox} declutterBox DeclutterBox.
 * @property {import("../../transform.js").Transform} canvasTransform CanvasTransform.
 */ /**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */ /**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */ /**
 * @type {import("../../extent.js").Extent}
 */ const tmpExtent = (0, _extentJs.createEmpty)();
/** @type {import("../../coordinate.js").Coordinate} */ const p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */ const p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */ const p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */ const p4 = [];
/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */ function getDeclutterBox(replayImageOrLabelArgs) {
    return replayImageOrLabelArgs[3].declutterBox;
}
const rtlRegEx = new RegExp(/* eslint-disable prettier/prettier */ '[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']');
/**
 * @param {string} text Text.
 * @param {CanvasTextAlign} align Alignment.
 * @return {number} Text alignment.
 */ function horizontalTextAlign(text, align) {
    if (align === 'start') align = rtlRegEx.test(text) ? 'right' : 'left';
    else if (align === 'end') align = rtlRegEx.test(text) ? 'left' : 'right';
    return (0, _textBuilderJs.TEXT_ALIGN)[align];
}
/**
 * @param {Array<string>} acc Accumulator.
 * @param {string} line Line of text.
 * @param {number} i Index
 * @return {Array<string>} Accumulator.
 */ function createTextChunks(acc, line, i) {
    if (i > 0) acc.push('\n', '');
    acc.push(line, '');
    return acc;
}
class Executor {
    /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */ constructor(resolution, pixelRatio, overlaps, instructions){
        /**
     * @protected
     * @type {boolean}
     */ this.overlaps = overlaps;
        /**
     * @protected
     * @type {number}
     */ this.pixelRatio = pixelRatio;
        /**
     * @protected
     * @const
     * @type {number}
     */ this.resolution = resolution;
        /**
     * @private
     * @type {boolean}
     */ this.alignFill_;
        /**
     * @protected
     * @type {Array<*>}
     */ this.instructions = instructions.instructions;
        /**
     * @protected
     * @type {Array<number>}
     */ this.coordinates = instructions.coordinates;
        /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */ this.coordinateCache_ = {};
        /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */ this.renderedTransform_ = (0, _transformJs.create)();
        /**
     * @protected
     * @type {Array<*>}
     */ this.hitDetectionInstructions = instructions.hitDetectionInstructions;
        /**
     * @private
     * @type {Array<number>}
     */ this.pixelCoordinates_ = null;
        /**
     * @private
     * @type {number}
     */ this.viewRotation_ = 0;
        /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */ this.fillStates = instructions.fillStates || {};
        /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */ this.strokeStates = instructions.strokeStates || {};
        /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */ this.textStates = instructions.textStates || {};
        /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */ this.widths_ = {};
        /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */ this.labels_ = {};
    }
    /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */ createLabel(text, textKey, fillKey, strokeKey) {
        const key = text + textKey + fillKey + strokeKey;
        if (this.labels_[key]) return this.labels_[key];
        const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
        const fillState = fillKey ? this.fillStates[fillKey] : null;
        const textState = this.textStates[textKey];
        const pixelRatio = this.pixelRatio;
        const scale = [
            textState.scale[0] * pixelRatio,
            textState.scale[1] * pixelRatio
        ];
        const textIsArray = Array.isArray(text);
        const align = textState.justify ? (0, _textBuilderJs.TEXT_ALIGN)[textState.justify] : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || (0, _canvasJs.defaultTextAlign));
        const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const chunks = textIsArray ? text : text.split('\n').reduce(createTextChunks, []);
        const { width, height, widths, heights, lineWidths } = (0, _canvasJs.getTextDimensions)(textState, chunks);
        const renderWidth = width + strokeWidth;
        const contextInstructions = [];
        // make canvas 2 pixels wider to account for italic text width measurement errors
        const w = (renderWidth + 2) * scale[0];
        const h = (height + strokeWidth) * scale[1];
        /** @type {import("../canvas.js").Label} */ const label = {
            width: w < 0 ? Math.floor(w) : Math.ceil(w),
            height: h < 0 ? Math.floor(h) : Math.ceil(h),
            contextInstructions: contextInstructions
        };
        if (scale[0] != 1 || scale[1] != 1) contextInstructions.push('scale', scale);
        if (strokeKey) {
            contextInstructions.push('strokeStyle', strokeState.strokeStyle);
            contextInstructions.push('lineWidth', strokeWidth);
            contextInstructions.push('lineCap', strokeState.lineCap);
            contextInstructions.push('lineJoin', strokeState.lineJoin);
            contextInstructions.push('miterLimit', strokeState.miterLimit);
            contextInstructions.push('setLineDash', [
                strokeState.lineDash
            ]);
            contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
        }
        if (fillKey) contextInstructions.push('fillStyle', fillState.fillStyle);
        contextInstructions.push('textBaseline', 'middle');
        contextInstructions.push('textAlign', 'center');
        const leftRight = 0.5 - align;
        let x = align * renderWidth + leftRight * strokeWidth;
        const strokeInstructions = [];
        const fillInstructions = [];
        let lineHeight = 0;
        let lineOffset = 0;
        let widthHeightIndex = 0;
        let lineWidthIndex = 0;
        let previousFont;
        for(let i = 0, ii = chunks.length; i < ii; i += 2){
            const text = chunks[i];
            if (text === '\n') {
                lineOffset += lineHeight;
                lineHeight = 0;
                x = align * renderWidth + leftRight * strokeWidth;
                ++lineWidthIndex;
                continue;
            }
            const font = chunks[i + 1] || textState.font;
            if (font !== previousFont) {
                if (strokeKey) strokeInstructions.push('font', font);
                if (fillKey) fillInstructions.push('font', font);
                previousFont = font;
            }
            lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
            const fillStrokeArgs = [
                text,
                x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
                0.5 * (strokeWidth + lineHeight) + lineOffset
            ];
            x += widths[widthHeightIndex];
            if (strokeKey) strokeInstructions.push('strokeText', fillStrokeArgs);
            if (fillKey) fillInstructions.push('fillText', fillStrokeArgs);
            ++widthHeightIndex;
        }
        Array.prototype.push.apply(contextInstructions, strokeInstructions);
        Array.prototype.push.apply(contextInstructions, fillInstructions);
        this.labels_[key] = label;
        return label;
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */ replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
        context.beginPath();
        context.moveTo.apply(context, p1);
        context.lineTo.apply(context, p2);
        context.lineTo.apply(context, p3);
        context.lineTo.apply(context, p4);
        context.lineTo.apply(context, p1);
        if (fillInstruction) {
            this.alignFill_ = /** @type {boolean} */ fillInstruction[2];
            this.fill_(context);
        }
        if (strokeInstruction) {
            this.setStrokeStyle_(context, /** @type {Array<*>} */ strokeInstruction);
            context.stroke();
        }
    }
    /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */ calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
        anchorX *= scale[0];
        anchorY *= scale[1];
        let x = centerX - anchorX;
        let y = centerY - anchorY;
        const w = width + originX > sheetWidth ? sheetWidth - originX : width;
        const h = height + originY > sheetHeight ? sheetHeight - originY : height;
        const boxW = padding[3] + w * scale[0] + padding[1];
        const boxH = padding[0] + h * scale[1] + padding[2];
        const boxX = x - padding[3];
        const boxY = y - padding[0];
        if (fillStroke || rotation !== 0) {
            p1[0] = boxX;
            p4[0] = boxX;
            p1[1] = boxY;
            p2[1] = boxY;
            p2[0] = boxX + boxW;
            p3[0] = p2[0];
            p3[1] = boxY + boxH;
            p4[1] = p3[1];
        }
        let transform;
        if (rotation !== 0) {
            transform = (0, _transformJs.compose)((0, _transformJs.create)(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
            (0, _transformJs.apply)(transform, p1);
            (0, _transformJs.apply)(transform, p2);
            (0, _transformJs.apply)(transform, p3);
            (0, _transformJs.apply)(transform, p4);
            (0, _extentJs.createOrUpdate)(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
        } else (0, _extentJs.createOrUpdate)(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
        if (snapToPixel) {
            x = Math.round(x);
            y = Math.round(y);
        }
        return {
            drawImageX: x,
            drawImageY: y,
            drawImageW: w,
            drawImageH: h,
            originX: originX,
            originY: originY,
            declutterBox: {
                minX: tmpExtent[0],
                minY: tmpExtent[1],
                maxX: tmpExtent[2],
                maxY: tmpExtent[3],
                value: feature
            },
            canvasTransform: transform,
            scale: scale
        };
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */ replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
        const fillStroke = !!(fillInstruction || strokeInstruction);
        const box = dimensions.declutterBox;
        const canvas = context.canvas;
        const strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
        const intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
        if (intersects) {
            if (fillStroke) this.replayTextBackground_(context, p1, p2, p3, p4, /** @type {Array<*>} */ fillInstruction, /** @type {Array<*>} */ strokeInstruction);
            (0, _canvasJs.drawImageOrLabel)(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
        }
        return true;
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */ fill_(context) {
        if (this.alignFill_) {
            const origin = (0, _transformJs.apply)(this.renderedTransform_, [
                0,
                0
            ]);
            const repeatSize = 512 * this.pixelRatio;
            context.save();
            context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
            context.rotate(this.viewRotation_);
        }
        context.fill();
        if (this.alignFill_) context.restore();
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */ setStrokeStyle_(context, instruction) {
        context['strokeStyle'] = /** @type {import("../../colorlike.js").ColorLike} */ instruction[1];
        context.lineWidth = /** @type {number} */ instruction[2];
        context.lineCap = /** @type {CanvasLineCap} */ instruction[3];
        context.lineJoin = /** @type {CanvasLineJoin} */ instruction[4];
        context.miterLimit = /** @type {number} */ instruction[5];
        context.lineDashOffset = /** @type {number} */ instruction[7];
        context.setLineDash(/** @type {Array<number>} */ instruction[6]);
    }
    /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */ drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
        const textState = this.textStates[textKey];
        const label = this.createLabel(text, textKey, fillKey, strokeKey);
        const strokeState = this.strokeStates[strokeKey];
        const pixelRatio = this.pixelRatio;
        const align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || (0, _canvasJs.defaultTextAlign));
        const baseline = (0, _textBuilderJs.TEXT_ALIGN)[textState.textBaseline || (0, _canvasJs.defaultTextBaseline)];
        const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
        // Remove the 2 pixels we added in createLabel() for the anchor
        const width = label.width / pixelRatio - 2 * textState.scale[0];
        const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
        const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
        return {
            label: label,
            anchorX: anchorX,
            anchorY: anchorY
        };
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */ execute_(context, contextScale, transform, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
        /** @type {Array<number>} */ let pixelCoordinates;
        if (this.pixelCoordinates_ && (0, _arrayJs.equals)(transform, this.renderedTransform_)) pixelCoordinates = this.pixelCoordinates_;
        else {
            if (!this.pixelCoordinates_) this.pixelCoordinates_ = [];
            pixelCoordinates = (0, _transformJs1.transform2D)(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
            (0, _transformJs.setFromArray)(this.renderedTransform_, transform);
        }
        let i = 0; // instruction index
        const ii = instructions.length; // end of instructions
        let d = 0; // data index
        let dd; // end of per-instruction data
        let anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
        let pendingFill = 0;
        let pendingStroke = 0;
        let lastFillInstruction = null;
        let lastStrokeInstruction = null;
        const coordinateCache = this.coordinateCache_;
        const viewRotation = this.viewRotation_;
        const viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
        const state = /** @type {import("../../render.js").State} */ {
            context: context,
            pixelRatio: this.pixelRatio,
            resolution: this.resolution,
            rotation: viewRotation
        };
        // When the batch size gets too big, performance decreases. 200 is a good
        // balance between batch size and number of fill/stroke instructions.
        const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
        let /** @type {import("../../Feature.js").FeatureLike} */ feature;
        let x, y, currentGeometry;
        while(i < ii){
            const instruction = instructions[i];
            const type = /** @type {import("./Instruction.js").default} */ instruction[0];
            switch(type){
                case (0, _instructionJsDefault.default).BEGIN_GEOMETRY:
                    feature = /** @type {import("../../Feature.js").FeatureLike} */ instruction[1];
                    currentGeometry = instruction[3];
                    if (!feature.getGeometry()) i = /** @type {number} */ instruction[2];
                    else if (hitExtent !== undefined && !(0, _extentJs.intersects)(hitExtent, currentGeometry.getExtent())) i = /** @type {number} */ instruction[2] + 1;
                    else ++i;
                    break;
                case (0, _instructionJsDefault.default).BEGIN_PATH:
                    if (pendingFill > batchSize) {
                        this.fill_(context);
                        pendingFill = 0;
                    }
                    if (pendingStroke > batchSize) {
                        context.stroke();
                        pendingStroke = 0;
                    }
                    if (!pendingFill && !pendingStroke) {
                        context.beginPath();
                        prevX = NaN;
                        prevY = NaN;
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).CIRCLE:
                    d = /** @type {number} */ instruction[1];
                    const x1 = pixelCoordinates[d];
                    const y1 = pixelCoordinates[d + 1];
                    const x2 = pixelCoordinates[d + 2];
                    const y2 = pixelCoordinates[d + 3];
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    context.moveTo(x1 + r, y1);
                    context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).CLOSE_PATH:
                    context.closePath();
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).CUSTOM:
                    d = /** @type {number} */ instruction[1];
                    dd = instruction[2];
                    const geometry = /** @type {import("../../geom/SimpleGeometry.js").default} */ instruction[3];
                    const renderer = instruction[4];
                    const fn = instruction.length == 6 ? instruction[5] : undefined;
                    state.geometry = geometry;
                    state.feature = feature;
                    if (!(i in coordinateCache)) coordinateCache[i] = [];
                    const coords = coordinateCache[i];
                    if (fn) fn(pixelCoordinates, d, dd, 2, coords);
                    else {
                        coords[0] = pixelCoordinates[d];
                        coords[1] = pixelCoordinates[d + 1];
                        coords.length = 2;
                    }
                    renderer(coords, state);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).DRAW_IMAGE:
                    d = /** @type {number} */ instruction[1];
                    dd = /** @type {number} */ instruction[2];
                    image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ instruction[3];
                    // Remaining arguments in DRAW_IMAGE are in alphabetical order
                    anchorX = /** @type {number} */ instruction[4];
                    anchorY = /** @type {number} */ instruction[5];
                    let height = /** @type {number} */ instruction[6];
                    const opacity = /** @type {number} */ instruction[7];
                    const originX = /** @type {number} */ instruction[8];
                    const originY = /** @type {number} */ instruction[9];
                    const rotateWithView = /** @type {boolean} */ instruction[10];
                    let rotation = /** @type {number} */ instruction[11];
                    const scale = /** @type {import("../../size.js").Size} */ instruction[12];
                    let width = /** @type {number} */ instruction[13];
                    const declutterMode = /** @type {"declutter"|"obstacle"|"none"|undefined} */ instruction[14];
                    const declutterImageWithText = /** @type {import("../canvas.js").DeclutterImageWithText} */ instruction[15];
                    if (!image && instruction.length >= 20) {
                        // create label images
                        text = /** @type {string} */ instruction[19];
                        textKey = /** @type {string} */ instruction[20];
                        strokeKey = /** @type {string} */ instruction[21];
                        fillKey = /** @type {string} */ instruction[22];
                        const labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                        image = labelWithAnchor.label;
                        instruction[3] = image;
                        const textOffsetX = /** @type {number} */ instruction[23];
                        anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                        instruction[4] = anchorX;
                        const textOffsetY = /** @type {number} */ instruction[24];
                        anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                        instruction[5] = anchorY;
                        height = image.height;
                        instruction[6] = height;
                        width = image.width;
                        instruction[13] = width;
                    }
                    let geometryWidths;
                    if (instruction.length > 25) geometryWidths = /** @type {number} */ instruction[25];
                    let padding, backgroundFill, backgroundStroke;
                    if (instruction.length > 17) {
                        padding = /** @type {Array<number>} */ instruction[16];
                        backgroundFill = /** @type {boolean} */ instruction[17];
                        backgroundStroke = /** @type {boolean} */ instruction[18];
                    } else {
                        padding = (0, _canvasJs.defaultPadding);
                        backgroundFill = false;
                        backgroundStroke = false;
                    }
                    if (rotateWithView && viewRotationFromTransform) // Canvas is expected to be rotated to reverse view rotation.
                    rotation += viewRotation;
                    else if (!rotateWithView && !viewRotationFromTransform) // Canvas is not rotated, images need to be rotated back to be north-up.
                    rotation -= viewRotation;
                    let widthIndex = 0;
                    for(; d < dd; d += 2){
                        if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) continue;
                        const dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
                        /** @type {ReplayImageOrLabelArgs} */ const args = [
                            context,
                            contextScale,
                            image,
                            dimensions,
                            opacity,
                            backgroundFill ? /** @type {Array<*>} */ lastFillInstruction : null,
                            backgroundStroke ? /** @type {Array<*>} */ lastStrokeInstruction : null
                        ];
                        if (declutterTree) {
                            if (declutterMode === 'none') continue;
                            else if (declutterMode === 'obstacle') {
                                // will always be drawn, thus no collision detection, but insert as obstacle
                                declutterTree.insert(dimensions.declutterBox);
                                continue;
                            } else {
                                let imageArgs;
                                let imageDeclutterBox;
                                if (declutterImageWithText) {
                                    const index = dd - d;
                                    if (!declutterImageWithText[index]) {
                                        // We now have the image for an image+text combination.
                                        declutterImageWithText[index] = args;
                                        continue;
                                    }
                                    imageArgs = declutterImageWithText[index];
                                    delete declutterImageWithText[index];
                                    imageDeclutterBox = getDeclutterBox(imageArgs);
                                    if (declutterTree.collides(imageDeclutterBox)) continue;
                                }
                                if (declutterTree.collides(dimensions.declutterBox)) continue;
                                if (imageArgs) {
                                    // We now have image and text for an image+text combination.
                                    declutterTree.insert(imageDeclutterBox);
                                    // Render the image before we render the text.
                                    this.replayImageOrLabel_.apply(this, imageArgs);
                                }
                                declutterTree.insert(dimensions.declutterBox);
                            }
                        }
                        this.replayImageOrLabel_.apply(this, args);
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).DRAW_CHARS:
                    const begin = /** @type {number} */ instruction[1];
                    const end = /** @type {number} */ instruction[2];
                    const baseline = /** @type {number} */ instruction[3];
                    const overflow = /** @type {number} */ instruction[4];
                    fillKey = /** @type {string} */ instruction[5];
                    const maxAngle = /** @type {number} */ instruction[6];
                    const measurePixelRatio = /** @type {number} */ instruction[7];
                    const offsetY = /** @type {number} */ instruction[8];
                    strokeKey = /** @type {string} */ instruction[9];
                    const strokeWidth = /** @type {number} */ instruction[10];
                    text = /** @type {string} */ instruction[11];
                    textKey = /** @type {string} */ instruction[12];
                    const pixelRatioScale = [
                        /** @type {number} */ instruction[13],
                        /** @type {number} */ instruction[13]
                    ];
                    const textState = this.textStates[textKey];
                    const font = textState.font;
                    const textScale = [
                        textState.scale[0] * measurePixelRatio,
                        textState.scale[1] * measurePixelRatio
                    ];
                    let cachedWidths;
                    if (font in this.widths_) cachedWidths = this.widths_[font];
                    else {
                        cachedWidths = {};
                        this.widths_[font] = cachedWidths;
                    }
                    const pathLength = (0, _lengthJs.lineStringLength)(pixelCoordinates, begin, end, 2);
                    const textLength = Math.abs(textScale[0]) * (0, _canvasJs.measureAndCacheTextWidth)(font, text, cachedWidths);
                    if (overflow || textLength <= pathLength) {
                        const textAlign = this.textStates[textKey].textAlign;
                        const startM = (pathLength - textLength) * horizontalTextAlign(text, textAlign);
                        const parts = (0, _textpathJs.drawTextOnPath)(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), (0, _canvasJs.measureAndCacheTextWidth), font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                        drawChars: if (parts) {
                            /** @type {Array<ReplayImageOrLabelArgs>} */ const replayImageOrLabelArgs = [];
                            let c, cc, chars, label, part;
                            if (strokeKey) for(c = 0, cc = parts.length; c < cc; ++c){
                                part = parts[c]; // x, y, anchorX, rotation, chunk
                                chars = /** @type {string} */ part[4];
                                label = this.createLabel(chars, textKey, '', strokeKey);
                                anchorX = /** @type {number} */ part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                                const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, (0, _canvasJs.defaultPadding), false, feature);
                                if (declutterTree && declutterTree.collides(dimensions.declutterBox)) break drawChars;
                                replayImageOrLabelArgs.push([
                                    context,
                                    contextScale,
                                    label,
                                    dimensions,
                                    1,
                                    null,
                                    null
                                ]);
                            }
                            if (fillKey) for(c = 0, cc = parts.length; c < cc; ++c){
                                part = parts[c]; // x, y, anchorX, rotation, chunk
                                chars = /** @type {string} */ part[4];
                                label = this.createLabel(chars, textKey, fillKey, '');
                                anchorX = /** @type {number} */ part[2];
                                anchorY = baseline * label.height - offsetY;
                                const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, (0, _canvasJs.defaultPadding), false, feature);
                                if (declutterTree && declutterTree.collides(dimensions.declutterBox)) break drawChars;
                                replayImageOrLabelArgs.push([
                                    context,
                                    contextScale,
                                    label,
                                    dimensions,
                                    1,
                                    null,
                                    null
                                ]);
                            }
                            if (declutterTree) declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                            for(let i = 0, ii = replayImageOrLabelArgs.length; i < ii; ++i)this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i]);
                        }
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).END_GEOMETRY:
                    if (featureCallback !== undefined) {
                        feature = /** @type {import("../../Feature.js").FeatureLike} */ instruction[1];
                        const result = featureCallback(feature, currentGeometry);
                        if (result) return result;
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).FILL:
                    if (batchSize) pendingFill++;
                    else this.fill_(context);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).MOVE_TO_LINE_TO:
                    d = /** @type {number} */ instruction[1];
                    dd = /** @type {number} */ instruction[2];
                    x = pixelCoordinates[d];
                    y = pixelCoordinates[d + 1];
                    roundX = x + 0.5 | 0;
                    roundY = y + 0.5 | 0;
                    if (roundX !== prevX || roundY !== prevY) {
                        context.moveTo(x, y);
                        prevX = roundX;
                        prevY = roundY;
                    }
                    for(d += 2; d < dd; d += 2){
                        x = pixelCoordinates[d];
                        y = pixelCoordinates[d + 1];
                        roundX = x + 0.5 | 0;
                        roundY = y + 0.5 | 0;
                        if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                            context.lineTo(x, y);
                            prevX = roundX;
                            prevY = roundY;
                        }
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).SET_FILL_STYLE:
                    lastFillInstruction = instruction;
                    this.alignFill_ = instruction[2];
                    if (pendingFill) {
                        this.fill_(context);
                        pendingFill = 0;
                        if (pendingStroke) {
                            context.stroke();
                            pendingStroke = 0;
                        }
                    }
                    context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ instruction[1];
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).SET_STROKE_STYLE:
                    lastStrokeInstruction = instruction;
                    if (pendingStroke) {
                        context.stroke();
                        pendingStroke = 0;
                    }
                    this.setStrokeStyle_(context, /** @type {Array<*>} */ instruction);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).STROKE:
                    if (batchSize) pendingStroke++;
                    else context.stroke();
                    ++i;
                    break;
                default:
                    ++i;
                    break;
            }
        }
        if (pendingFill) this.fill_(context);
        if (pendingStroke) context.stroke();
        return undefined;
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */ execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree) {
        this.viewRotation_ = viewRotation;
        this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, declutterTree);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */ executeHitDetection(context, transform, viewRotation, featureCallback, hitExtent) {
        this.viewRotation_ = viewRotation;
        return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, featureCallback, hitExtent);
    }
}
exports.default = Executor;

},{"./Instruction.js":"aw1sl","./TextBuilder.js":"hSSq4","../../transform.js":"9LrRk","../../extent.js":"bGUel","../canvas.js":"6S9WQ","../../geom/flat/textpath.js":"i5YRI","../../array.js":"hyet5","../../geom/flat/length.js":"Cl4Mx","../../geom/flat/transform.js":"7FFJr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i5YRI":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/textpath
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */ parcelHelpers.export(exports, "drawTextOnPath", ()=>drawTextOnPath);
var _mathJs = require("../../math.js");
var _transformJs = require("./transform.js");
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
    let x2 = flatCoordinates[offset];
    let y2 = flatCoordinates[offset + 1];
    let x1 = 0;
    let y1 = 0;
    let segmentLength = 0;
    let segmentM = 0;
    function advance() {
        x1 = x2;
        y1 = y2;
        offset += stride;
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        segmentM += segmentLength;
        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    do advance();
    while (offset < end - stride && segmentM + segmentLength < startM);
    let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
    const beginX = (0, _mathJs.lerp)(x1, x2, interpolate);
    const beginY = (0, _mathJs.lerp)(y1, y2, interpolate);
    const startOffset = offset - stride;
    const startLength = segmentM;
    const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
    while(offset < end - stride && segmentM + segmentLength < endM)advance();
    interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
    const endX = (0, _mathJs.lerp)(x1, x2, interpolate);
    const endY = (0, _mathJs.lerp)(y1, y2, interpolate);
    // Keep text upright
    let reverse;
    if (rotation) {
        const flat = [
            beginX,
            beginY,
            endX,
            endY
        ];
        (0, _transformJs.rotate)(flat, 0, 4, 2, rotation, flat, flat);
        reverse = flat[0] > flat[2];
    } else reverse = beginX > endX;
    const PI = Math.PI;
    const result = [];
    const singleSegment = startOffset + stride === offset;
    offset = startOffset;
    segmentLength = 0;
    segmentM = startLength;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    let previousAngle;
    // All on the same segment
    if (singleSegment) {
        advance();
        previousAngle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) previousAngle += previousAngle > 0 ? -PI : PI;
        const x = (endX + beginX) / 2;
        const y = (endY + beginY) / 2;
        result[0] = [
            x,
            y,
            (endM - startM) / 2,
            previousAngle,
            text
        ];
        return result;
    }
    // rendering across line segments
    text = text.replace(/\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines
    for(let i = 0, ii = text.length; i < ii;){
        advance();
        let angle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) angle += angle > 0 ? -PI : PI;
        if (previousAngle !== undefined) {
            let delta = angle - previousAngle;
            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
            if (Math.abs(delta) > maxAngle) return null;
        }
        previousAngle = angle;
        const iStart = i;
        let charLength = 0;
        for(; i < ii; ++i){
            const index = reverse ? ii - i - 1 : i;
            const len = scale * measureAndCacheTextWidth(font, text[index], cache);
            if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) break;
            charLength += len;
        }
        if (i === iStart) continue;
        const chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
        interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
        const x = (0, _mathJs.lerp)(x1, x2, interpolate);
        const y = (0, _mathJs.lerp)(y1, y2, interpolate);
        result.push([
            x,
            y,
            charLength / 2,
            angle,
            chars
        ]);
        startM += charLength;
    }
    return result;
}

},{"../../math.js":"d8zSj","./transform.js":"7FFJr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"Cl4Mx":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/length
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lineStringLength", ()=>lineStringLength);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */ parcelHelpers.export(exports, "linearRingLength", ()=>linearRingLength);
function lineStringLength(flatCoordinates, offset, end, stride) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    let length = 0;
    for(let i = offset + stride; i < end; i += stride){
        const x2 = flatCoordinates[i];
        const y2 = flatCoordinates[i + 1];
        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        x1 = x2;
        y1 = y2;
    }
    return length;
}
function linearRingLength(flatCoordinates, offset, end, stride) {
    let perimeter = lineStringLength(flatCoordinates, offset, end, stride);
    const dx = flatCoordinates[end - stride] - flatCoordinates[offset];
    const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
    perimeter += Math.sqrt(dx * dx + dy * dy);
    return perimeter;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7dVZW":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/hitdetect
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HIT_DETECT_RESOLUTION", ()=>HIT_DETECT_RESOLUTION);
/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */ parcelHelpers.export(exports, "createHitDetectionImageData", ()=>createHitDetectionImageData);
/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<F>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<F>} Features.
 * @template {import("../../Feature.js").FeatureLike} F
 */ parcelHelpers.export(exports, "hitDetect", ()=>hitDetect);
var _immediateJs = require("./Immediate.js");
var _immediateJsDefault = parcelHelpers.interopDefault(_immediateJs);
var _styleJs = require("../../style.js");
var _arrayJs = require("../../array.js");
var _mathJs = require("../../math.js");
var _domJs = require("../../dom.js");
var _extentJs = require("../../extent.js");
const HIT_DETECT_RESOLUTION = 0.5;
function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
    const width = size[0] * HIT_DETECT_RESOLUTION;
    const height = size[1] * HIT_DETECT_RESOLUTION;
    const context = (0, _domJs.createCanvasContext2D)(width, height);
    context.imageSmoothingEnabled = false;
    const canvas = context.canvas;
    const renderer = new (0, _immediateJsDefault.default)(context, HIT_DETECT_RESOLUTION, extent, null, rotation);
    const featureCount = features.length;
    // Stretch hit detection index to use the whole available color range
    const indexFactor = Math.floor(16777215 / featureCount);
    const featuresByZIndex = {};
    for(let i = 1; i <= featureCount; ++i){
        const feature = features[i - 1];
        const featureStyleFunction = feature.getStyleFunction() || styleFunction;
        if (!featureStyleFunction) continue;
        let styles = featureStyleFunction(feature, resolution);
        if (!styles) continue;
        if (!Array.isArray(styles)) styles = [
            styles
        ];
        const index = i * indexFactor;
        const color = index.toString(16).padStart(7, '#00000');
        for(let j = 0, jj = styles.length; j < jj; ++j){
            const originalStyle = styles[j];
            const geometry = originalStyle.getGeometryFunction()(feature);
            if (!geometry || !(0, _extentJs.intersects)(extent, geometry.getExtent())) continue;
            const style = originalStyle.clone();
            const fill = style.getFill();
            if (fill) fill.setColor(color);
            const stroke = style.getStroke();
            if (stroke) {
                stroke.setColor(color);
                stroke.setLineDash(null);
            }
            style.setText(undefined);
            const image = originalStyle.getImage();
            if (image) {
                const imgSize = image.getImageSize();
                if (!imgSize) continue;
                const imgContext = (0, _domJs.createCanvasContext2D)(imgSize[0], imgSize[1], undefined, {
                    alpha: false
                });
                const img = imgContext.canvas;
                imgContext.fillStyle = color;
                imgContext.fillRect(0, 0, img.width, img.height);
                style.setImage(new (0, _styleJs.Icon)({
                    img: img,
                    anchor: image.getAnchor(),
                    anchorXUnits: 'pixels',
                    anchorYUnits: 'pixels',
                    offset: image.getOrigin(),
                    opacity: 1,
                    size: image.getSize(),
                    scale: image.getScale(),
                    rotation: image.getRotation(),
                    rotateWithView: image.getRotateWithView()
                }));
            }
            const zIndex = style.getZIndex() || 0;
            let byGeometryType = featuresByZIndex[zIndex];
            if (!byGeometryType) {
                byGeometryType = {};
                featuresByZIndex[zIndex] = byGeometryType;
                byGeometryType['Polygon'] = [];
                byGeometryType['Circle'] = [];
                byGeometryType['LineString'] = [];
                byGeometryType['Point'] = [];
            }
            const type = geometry.getType();
            if (type === 'GeometryCollection') {
                const geometries = /** @type {import("../../geom/GeometryCollection.js").default} */ geometry.getGeometriesArrayRecursive();
                for(let i = 0, ii = geometries.length; i < ii; ++i){
                    const geometry = geometries[i];
                    byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
                }
            } else byGeometryType[type.replace('Multi', '')].push(geometry, style);
        }
    }
    const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort((0, _arrayJs.ascending));
    for(let i = 0, ii = zIndexKeys.length; i < ii; ++i){
        const byGeometryType = featuresByZIndex[zIndexKeys[i]];
        for(const type in byGeometryType){
            const geomAndStyle = byGeometryType[type];
            for(let j = 0, jj = geomAndStyle.length; j < jj; j += 2){
                renderer.setStyle(geomAndStyle[j + 1]);
                for(let k = 0, kk = transforms.length; k < kk; ++k){
                    renderer.setTransform(transforms[k]);
                    renderer.drawGeometry(geomAndStyle[j]);
                }
            }
        }
    }
    return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
    /** @type {Array<F>} */ const resultFeatures = [];
    if (imageData) {
        const x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
        const y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
        // The pixel coordinate is clamped down to the hit-detect canvas' size to account
        // for browsers returning coordinates slightly larger than the actual canvas size
        // due to a non-integer pixel ratio.
        const index = ((0, _mathJs.clamp)(x, 0, imageData.width - 1) + (0, _mathJs.clamp)(y, 0, imageData.height - 1) * imageData.width) * 4;
        const r = imageData.data[index];
        const g = imageData.data[index + 1];
        const b = imageData.data[index + 2];
        const i = b + 256 * (g + 256 * r);
        const indexFactor = Math.floor(16777215 / features.length);
        if (i && i % indexFactor === 0) resultFeatures.push(features[i / indexFactor - 1]);
    }
    return resultFeatures;
}

},{"./Immediate.js":"cxZdQ","../../style.js":"kOk47","../../array.js":"hyet5","../../math.js":"d8zSj","../../dom.js":"h98kD","../../extent.js":"bGUel","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cxZdQ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/Immediate
 */ // FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vectorContextJs = require("../VectorContext.js");
var _vectorContextJsDefault = parcelHelpers.interopDefault(_vectorContextJs);
var _colorlikeJs = require("../../colorlike.js");
var _transformJs = require("../../transform.js");
var _canvasJs = require("../canvas.js");
var _arrayJs = require("../../array.js");
var _extentJs = require("../../extent.js");
var _mathJs = require("../../math.js");
var _transformJs1 = require("../../geom/flat/transform.js");
var _simpleGeometryJs = require("../../geom/SimpleGeometry.js");
/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext~VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */ class CanvasImmediateRenderer extends (0, _vectorContextJsDefault.default) {
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */ constructor(context, pixelRatio, extent, transform, viewRotation, squaredTolerance, userTransform){
        super();
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.context_ = context;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.extent_ = extent;
        /**
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.transform_ = transform;
        /**
     * @private
     * @type {number}
     */ this.transformRotation_ = transform ? (0, _mathJs.toFixed)(Math.atan2(transform[1], transform[0]), 10) : 0;
        /**
     * @private
     * @type {number}
     */ this.viewRotation_ = viewRotation;
        /**
     * @private
     * @type {number}
     */ this.squaredTolerance_ = squaredTolerance;
        /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */ this.userTransform_ = userTransform;
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.contextFillState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.contextStrokeState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */ this.contextTextState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.fillState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.strokeState_ = null;
        /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */ this.image_ = null;
        /**
     * @private
     * @type {number}
     */ this.imageAnchorX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageAnchorY_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageHeight_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageOpacity_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageOriginX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageOriginY_ = 0;
        /**
     * @private
     * @type {boolean}
     */ this.imageRotateWithView_ = false;
        /**
     * @private
     * @type {number}
     */ this.imageRotation_ = 0;
        /**
     * @private
     * @type {import("../../size.js").Size}
     */ this.imageScale_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {number}
     */ this.imageWidth_ = 0;
        /**
     * @private
     * @type {string}
     */ this.text_ = '';
        /**
     * @private
     * @type {number}
     */ this.textOffsetX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.textOffsetY_ = 0;
        /**
     * @private
     * @type {boolean}
     */ this.textRotateWithView_ = false;
        /**
     * @private
     * @type {number}
     */ this.textRotation_ = 0;
        /**
     * @private
     * @type {import("../../size.js").Size}
     */ this.textScale_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.textFillState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.textStrokeState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */ this.textState_ = null;
        /**
     * @private
     * @type {Array<number>}
     */ this.pixelCoordinates_ = [];
        /**
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.tmpLocalTransform_ = (0, _transformJs.create)();
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */ drawImages_(flatCoordinates, offset, end, stride) {
        if (!this.image_) return;
        const pixelCoordinates = (0, _transformJs1.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        const context = this.context_;
        const localTransform = this.tmpLocalTransform_;
        const alpha = context.globalAlpha;
        if (this.imageOpacity_ != 1) context.globalAlpha = alpha * this.imageOpacity_;
        let rotation = this.imageRotation_;
        if (this.transformRotation_ === 0) rotation -= this.viewRotation_;
        if (this.imageRotateWithView_) rotation += this.viewRotation_;
        for(let i = 0, ii = pixelCoordinates.length; i < ii; i += 2){
            const x = pixelCoordinates[i] - this.imageAnchorX_;
            const y = pixelCoordinates[i + 1] - this.imageAnchorY_;
            if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
                const centerX = x + this.imageAnchorX_;
                const centerY = y + this.imageAnchorY_;
                (0, _transformJs.compose)(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                context.save();
                context.transform.apply(context, localTransform);
                context.translate(centerX, centerY);
                context.scale(this.imageScale_[0], this.imageScale_[1]);
                context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                context.restore();
            } else context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
        }
        if (this.imageOpacity_ != 1) context.globalAlpha = alpha;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */ drawText_(flatCoordinates, offset, end, stride) {
        if (!this.textState_ || this.text_ === '') return;
        if (this.textFillState_) this.setContextFillState_(this.textFillState_);
        if (this.textStrokeState_) this.setContextStrokeState_(this.textStrokeState_);
        this.setContextTextState_(this.textState_);
        const pixelCoordinates = (0, _transformJs1.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        const context = this.context_;
        let rotation = this.textRotation_;
        if (this.transformRotation_ === 0) rotation -= this.viewRotation_;
        if (this.textRotateWithView_) rotation += this.viewRotation_;
        for(; offset < end; offset += stride){
            const x = pixelCoordinates[offset] + this.textOffsetX_;
            const y = pixelCoordinates[offset + 1] + this.textOffsetY_;
            if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
                context.save();
                context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
                context.rotate(rotation);
                context.translate(this.textOffsetX_, this.textOffsetY_);
                context.scale(this.textScale_[0], this.textScale_[1]);
                if (this.textStrokeState_) context.strokeText(this.text_, 0, 0);
                if (this.textFillState_) context.fillText(this.text_, 0, 0);
                context.restore();
            } else {
                if (this.textStrokeState_) context.strokeText(this.text_, x, y);
                if (this.textFillState_) context.fillText(this.text_, x, y);
            }
        }
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */ moveToLineTo_(flatCoordinates, offset, end, stride, close) {
        const context = this.context_;
        const pixelCoordinates = (0, _transformJs1.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
        let length = pixelCoordinates.length;
        if (close) length -= 2;
        for(let i = 2; i < length; i += 2)context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
        if (close) context.closePath();
        return end;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */ drawRings_(flatCoordinates, offset, ends, stride) {
        for(let i = 0, ii = ends.length; i < ii; ++i)offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
        return offset;
    }
    /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */ drawCircle(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/Circle.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.fillState_ || this.strokeState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            const pixelCoordinates = (0, _simpleGeometryJs.transformGeom2D)(geometry, this.transform_, this.pixelCoordinates_);
            const dx = pixelCoordinates[2] - pixelCoordinates[0];
            const dy = pixelCoordinates[3] - pixelCoordinates[1];
            const radius = Math.sqrt(dx * dx + dy * dy);
            const context = this.context_;
            context.beginPath();
            context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== '') this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
    /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */ setStyle(style) {
        this.setFillStrokeStyle(style.getFill(), style.getStroke());
        this.setImageStyle(style.getImage());
        this.setTextStyle(style.getText());
    }
    /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */ setTransform(transform) {
        this.transform_ = transform;
    }
    /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */ drawGeometry(geometry) {
        const type = geometry.getType();
        switch(type){
            case 'Point':
                this.drawPoint(/** @type {import("../../geom/Point.js").default} */ geometry);
                break;
            case 'LineString':
                this.drawLineString(/** @type {import("../../geom/LineString.js").default} */ geometry);
                break;
            case 'Polygon':
                this.drawPolygon(/** @type {import("../../geom/Polygon.js").default} */ geometry);
                break;
            case 'MultiPoint':
                this.drawMultiPoint(/** @type {import("../../geom/MultiPoint.js").default} */ geometry);
                break;
            case 'MultiLineString':
                this.drawMultiLineString(/** @type {import("../../geom/MultiLineString.js").default} */ geometry);
                break;
            case 'MultiPolygon':
                this.drawMultiPolygon(/** @type {import("../../geom/MultiPolygon.js").default} */ geometry);
                break;
            case 'GeometryCollection':
                this.drawGeometryCollection(/** @type {import("../../geom/GeometryCollection.js").default} */ geometry);
                break;
            case 'Circle':
                this.drawCircle(/** @type {import("../../geom/Circle.js").default} */ geometry);
                break;
            default:
        }
    }
    /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */ drawFeature(feature, style) {
        const geometry = style.getGeometryFunction()(feature);
        if (!geometry) return;
        this.setStyle(style);
        this.drawGeometry(geometry);
    }
    /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */ drawGeometryCollection(geometry) {
        const geometries = geometry.getGeometriesArray();
        for(let i = 0, ii = geometries.length; i < ii; ++i)this.drawGeometry(geometries[i]);
    }
    /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */ drawPoint(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/Point.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        if (this.text_ !== '') this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */ drawMultiPoint(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/MultiPoint.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        if (this.text_ !== '') this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */ drawLineString(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/LineString.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            const flatCoordinates = geometry.getFlatCoordinates();
            context.beginPath();
            this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
            context.stroke();
        }
        if (this.text_ !== '') {
            const flatMidpoint = geometry.getFlatMidpoint();
            this.drawText_(flatMidpoint, 0, 2, 2);
        }
    }
    /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */ drawMultiLineString(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        const geometryExtent = geometry.getExtent();
        if (!(0, _extentJs.intersects)(this.extent_, geometryExtent)) return;
        if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            const flatCoordinates = geometry.getFlatCoordinates();
            let offset = 0;
            const ends = /** @type {Array<number>} */ geometry.getEnds();
            const stride = geometry.getStride();
            context.beginPath();
            for(let i = 0, ii = ends.length; i < ii; ++i)offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
            context.stroke();
        }
        if (this.text_ !== '') {
            const flatMidpoints = geometry.getFlatMidpoints();
            this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
        }
    }
    /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */ drawPolygon(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/Polygon.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_ || this.fillState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            context.beginPath();
            this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, /** @type {Array<number>} */ geometry.getEnds(), geometry.getStride());
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== '') {
            const flatInteriorPoint = geometry.getFlatInteriorPoint();
            this.drawText_(flatInteriorPoint, 0, 2, 2);
        }
    }
    /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */ drawMultiPolygon(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_ || this.fillState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            const flatCoordinates = geometry.getOrientedFlatCoordinates();
            let offset = 0;
            const endss = geometry.getEndss();
            const stride = geometry.getStride();
            context.beginPath();
            for(let i = 0, ii = endss.length; i < ii; ++i){
                const ends = endss[i];
                offset = this.drawRings_(flatCoordinates, offset, ends, stride);
            }
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== '') {
            const flatInteriorPoints = geometry.getFlatInteriorPoints();
            this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
        }
    }
    /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */ setContextFillState_(fillState) {
        const context = this.context_;
        const contextFillState = this.contextFillState_;
        if (!contextFillState) {
            context.fillStyle = fillState.fillStyle;
            this.contextFillState_ = {
                fillStyle: fillState.fillStyle
            };
        } else if (contextFillState.fillStyle != fillState.fillStyle) {
            contextFillState.fillStyle = fillState.fillStyle;
            context.fillStyle = fillState.fillStyle;
        }
    }
    /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */ setContextStrokeState_(strokeState) {
        const context = this.context_;
        const contextStrokeState = this.contextStrokeState_;
        if (!contextStrokeState) {
            context.lineCap = strokeState.lineCap;
            context.setLineDash(strokeState.lineDash);
            context.lineDashOffset = strokeState.lineDashOffset;
            context.lineJoin = strokeState.lineJoin;
            context.lineWidth = strokeState.lineWidth;
            context.miterLimit = strokeState.miterLimit;
            context.strokeStyle = strokeState.strokeStyle;
            this.contextStrokeState_ = {
                lineCap: strokeState.lineCap,
                lineDash: strokeState.lineDash,
                lineDashOffset: strokeState.lineDashOffset,
                lineJoin: strokeState.lineJoin,
                lineWidth: strokeState.lineWidth,
                miterLimit: strokeState.miterLimit,
                strokeStyle: strokeState.strokeStyle
            };
        } else {
            if (contextStrokeState.lineCap != strokeState.lineCap) {
                contextStrokeState.lineCap = strokeState.lineCap;
                context.lineCap = strokeState.lineCap;
            }
            if (!(0, _arrayJs.equals)(contextStrokeState.lineDash, strokeState.lineDash)) context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
            if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                context.lineDashOffset = strokeState.lineDashOffset;
            }
            if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                contextStrokeState.lineJoin = strokeState.lineJoin;
                context.lineJoin = strokeState.lineJoin;
            }
            if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                contextStrokeState.lineWidth = strokeState.lineWidth;
                context.lineWidth = strokeState.lineWidth;
            }
            if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                contextStrokeState.miterLimit = strokeState.miterLimit;
                context.miterLimit = strokeState.miterLimit;
            }
            if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                contextStrokeState.strokeStyle = strokeState.strokeStyle;
                context.strokeStyle = strokeState.strokeStyle;
            }
        }
    }
    /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */ setContextTextState_(textState) {
        const context = this.context_;
        const contextTextState = this.contextTextState_;
        const textAlign = textState.textAlign ? textState.textAlign : (0, _canvasJs.defaultTextAlign);
        if (!contextTextState) {
            context.font = textState.font;
            context.textAlign = textAlign;
            context.textBaseline = textState.textBaseline;
            this.contextTextState_ = {
                font: textState.font,
                textAlign: textAlign,
                textBaseline: textState.textBaseline
            };
        } else {
            if (contextTextState.font != textState.font) {
                contextTextState.font = textState.font;
                context.font = textState.font;
            }
            if (contextTextState.textAlign != textAlign) {
                contextTextState.textAlign = textAlign;
                context.textAlign = textAlign;
            }
            if (contextTextState.textBaseline != textState.textBaseline) {
                contextTextState.textBaseline = textState.textBaseline;
                context.textBaseline = textState.textBaseline;
            }
        }
    }
    /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */ setFillStrokeStyle(fillStyle, strokeStyle) {
        if (!fillStyle) this.fillState_ = null;
        else {
            const fillStyleColor = fillStyle.getColor();
            this.fillState_ = {
                fillStyle: (0, _colorlikeJs.asColorLike)(fillStyleColor ? fillStyleColor : (0, _canvasJs.defaultFillStyle))
            };
        }
        if (!strokeStyle) this.strokeState_ = null;
        else {
            const strokeStyleColor = strokeStyle.getColor();
            const strokeStyleLineCap = strokeStyle.getLineCap();
            const strokeStyleLineDash = strokeStyle.getLineDash();
            const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
            const strokeStyleLineJoin = strokeStyle.getLineJoin();
            const strokeStyleWidth = strokeStyle.getWidth();
            const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            const lineDash = strokeStyleLineDash ? strokeStyleLineDash : (0, _canvasJs.defaultLineDash);
            this.strokeState_ = {
                lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : (0, _canvasJs.defaultLineCap),
                lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n)=>n * this.pixelRatio_),
                lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : (0, _canvasJs.defaultLineDashOffset)) * this.pixelRatio_,
                lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : (0, _canvasJs.defaultLineJoin),
                lineWidth: (strokeStyleWidth !== undefined ? strokeStyleWidth : (0, _canvasJs.defaultLineWidth)) * this.pixelRatio_,
                miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : (0, _canvasJs.defaultMiterLimit),
                strokeStyle: (0, _colorlikeJs.asColorLike)(strokeStyleColor ? strokeStyleColor : (0, _canvasJs.defaultStrokeStyle))
            };
        }
    }
    /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */ setImageStyle(imageStyle) {
        let imageSize;
        if (!imageStyle || !(imageSize = imageStyle.getSize())) {
            this.image_ = null;
            return;
        }
        const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
        const imageAnchor = imageStyle.getAnchor();
        const imageOrigin = imageStyle.getOrigin();
        this.image_ = imageStyle.getImage(this.pixelRatio_);
        this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
        this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
        this.imageHeight_ = imageSize[1] * imagePixelRatio;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        const imageScale = imageStyle.getScaleArray();
        this.imageScale_ = [
            imageScale[0] * this.pixelRatio_ / imagePixelRatio,
            imageScale[1] * this.pixelRatio_ / imagePixelRatio
        ];
        this.imageWidth_ = imageSize[0] * imagePixelRatio;
    }
    /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */ setTextStyle(textStyle) {
        if (!textStyle) this.text_ = '';
        else {
            const textFillStyle = textStyle.getFill();
            if (!textFillStyle) this.textFillState_ = null;
            else {
                const textFillStyleColor = textFillStyle.getColor();
                this.textFillState_ = {
                    fillStyle: (0, _colorlikeJs.asColorLike)(textFillStyleColor ? textFillStyleColor : (0, _canvasJs.defaultFillStyle))
                };
            }
            const textStrokeStyle = textStyle.getStroke();
            if (!textStrokeStyle) this.textStrokeState_ = null;
            else {
                const textStrokeStyleColor = textStrokeStyle.getColor();
                const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                const textStrokeStyleWidth = textStrokeStyle.getWidth();
                const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                this.textStrokeState_ = {
                    lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : (0, _canvasJs.defaultLineCap),
                    lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : (0, _canvasJs.defaultLineDash),
                    lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : (0, _canvasJs.defaultLineDashOffset),
                    lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : (0, _canvasJs.defaultLineJoin),
                    lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : (0, _canvasJs.defaultLineWidth),
                    miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : (0, _canvasJs.defaultMiterLimit),
                    strokeStyle: (0, _colorlikeJs.asColorLike)(textStrokeStyleColor ? textStrokeStyleColor : (0, _canvasJs.defaultStrokeStyle))
                };
            }
            const textFont = textStyle.getFont();
            const textOffsetX = textStyle.getOffsetX();
            const textOffsetY = textStyle.getOffsetY();
            const textRotateWithView = textStyle.getRotateWithView();
            const textRotation = textStyle.getRotation();
            const textScale = textStyle.getScaleArray();
            const textText = textStyle.getText();
            const textTextAlign = textStyle.getTextAlign();
            const textTextBaseline = textStyle.getTextBaseline();
            this.textState_ = {
                font: textFont !== undefined ? textFont : (0, _canvasJs.defaultFont),
                textAlign: textTextAlign !== undefined ? textTextAlign : (0, _canvasJs.defaultTextAlign),
                textBaseline: textTextBaseline !== undefined ? textTextBaseline : (0, _canvasJs.defaultTextBaseline)
            };
            this.text_ = textText !== undefined ? Array.isArray(textText) ? textText.reduce((acc, t, i)=>acc += i % 2 ? ' ' : t, '') : textText : '';
            this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
            this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
            this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
            this.textRotation_ = textRotation !== undefined ? textRotation : 0;
            this.textScale_ = [
                this.pixelRatio_ * textScale[0],
                this.pixelRatio_ * textScale[1]
            ];
        }
    }
}
exports.default = CanvasImmediateRenderer;

},{"../VectorContext.js":"627sc","../../colorlike.js":"36IFz","../../transform.js":"9LrRk","../canvas.js":"6S9WQ","../../array.js":"hyet5","../../extent.js":"bGUel","../../math.js":"d8zSj","../../geom/flat/transform.js":"7FFJr","../../geom/SimpleGeometry.js":"iZYIt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kOk47":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Circle", ()=>(0, _circleJsDefault.default));
parcelHelpers.export(exports, "Fill", ()=>(0, _fillJsDefault.default));
parcelHelpers.export(exports, "Icon", ()=>(0, _iconJsDefault.default));
parcelHelpers.export(exports, "IconImage", ()=>(0, _iconImageJsDefault.default));
parcelHelpers.export(exports, "Image", ()=>(0, _imageJsDefault.default));
parcelHelpers.export(exports, "RegularShape", ()=>(0, _regularShapeJsDefault.default));
parcelHelpers.export(exports, "Stroke", ()=>(0, _strokeJsDefault.default));
parcelHelpers.export(exports, "Style", ()=>(0, _styleJsDefault.default));
parcelHelpers.export(exports, "Text", ()=>(0, _textJsDefault.default));
var _circleJs = require("./style/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("./style/Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _iconJs = require("./style/Icon.js");
var _iconJsDefault = parcelHelpers.interopDefault(_iconJs);
var _iconImageJs = require("./style/IconImage.js");
var _iconImageJsDefault = parcelHelpers.interopDefault(_iconImageJs);
var _imageJs = require("./style/Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _regularShapeJs = require("./style/RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
var _strokeJs = require("./style/Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _styleJs = require("./style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _textJs = require("./style/Text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);

},{"./style/Circle.js":false,"./style/Fill.js":false,"./style/Icon.js":"1mjWl","./style/IconImage.js":false,"./style/Image.js":false,"./style/RegularShape.js":false,"./style/Stroke.js":"1uQwy","./style/Style.js":"8opjn","./style/Text.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1VLk4":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/vector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */ parcelHelpers.export(exports, "defaultOrder", ()=>defaultOrder);
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */ parcelHelpers.export(exports, "getSquaredTolerance", ()=>getSquaredTolerance);
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */ parcelHelpers.export(exports, "getTolerance", ()=>getTolerance);
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */ parcelHelpers.export(exports, "renderFeature", ()=>renderFeature);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _utilJs = require("../util.js");
/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */ /**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */ const SIMPLIFY_TOLERANCE = 0.5;
/**
 * @const
 * @type {Object<import("../geom/Geometry.js").Type,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */ const GEOMETRY_RENDERERS = {
    'Point': renderPointGeometry,
    'LineString': renderLineStringGeometry,
    'Polygon': renderPolygonGeometry,
    'MultiPoint': renderMultiPointGeometry,
    'MultiLineString': renderMultiLineStringGeometry,
    'MultiPolygon': renderMultiPolygonGeometry,
    'GeometryCollection': renderGeometryCollectionGeometry,
    'Circle': renderCircleGeometry
};
function defaultOrder(feature1, feature2) {
    return parseInt((0, _utilJs.getUid)(feature1), 10) - parseInt((0, _utilJs.getUid)(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
    const tolerance = getTolerance(resolution, pixelRatio);
    return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
    return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderCircleGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');
        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        circleReplay.drawCircle(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform, declutterBuilderGroup) {
    let loading = false;
    const imageStyle = style.getImage();
    if (imageStyle) {
        const imageState = imageStyle.getImageState();
        if (imageState == (0, _imageStateJsDefault.default).LOADED || imageState == (0, _imageStateJsDefault.default).ERROR) imageStyle.unlistenImageChange(listener);
        else {
            if (imageState == (0, _imageStateJsDefault.default).IDLE) imageStyle.load();
            imageStyle.listenImageChange(listener);
            loading = true;
        }
    }
    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutterBuilderGroup);
    return loading;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutterBuilderGroup) {
    const geometry = style.getGeometryFunction()(feature);
    if (!geometry) return;
    const simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, transform);
    const renderer = style.getRenderer();
    if (renderer) renderGeometry(replayGroup, simplifiedGeometry, style, feature);
    else {
        const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, declutterBuilderGroup);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */ function renderGeometry(replayGroup, geometry, style, feature) {
    if (geometry.getType() == 'GeometryCollection') {
        const geometries = /** @type {import("../geom/GeometryCollection.js").default} */ geometry.getGeometries();
        for(let i = 0, ii = geometries.length; i < ii; ++i)renderGeometry(replayGroup, geometries[i], style, feature);
        return;
    }
    const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');
    replay.drawCustom(/** @type {import("../geom/SimpleGeometry.js").default} */ geometry, feature, style.getRenderer(), style.getHitDetectionRenderer());
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup) {
    const geometries = geometry.getGeometriesArray();
    let i, ii;
    for(i = 0, ii = geometries.length; i < ii; ++i){
        const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
        geometryRenderer(replayGroup, geometries[i], style, feature, declutterBuilderGroup);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const strokeStyle = style.getStroke();
    if (strokeStyle) {
        const lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawLineString(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const strokeStyle = style.getStroke();
    if (strokeStyle) {
        const lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawMultiLineString(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (strokeStyle || fillStyle) {
        const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawMultiPolygon(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const imageStyle = style.getImage();
    const textStyle = style.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */ let declutterImageWithText;
    if (imageStyle) {
        if (imageStyle.getImageState() != (0, _imageStateJsDefault.default).LOADED) return;
        let imageBuilderGroup = builderGroup;
        if (declutterBuilderGroup) {
            const declutterMode = imageStyle.getDeclutterMode();
            if (declutterMode !== 'none') {
                imageBuilderGroup = declutterBuilderGroup;
                if (declutterMode === 'obstacle') {
                    // draw in non-declutter group:
                    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');
                    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
                    imageReplay.drawPoint(geometry, feature);
                } else if (textStyle && textStyle.getText()) declutterImageWithText = {};
            }
        }
        const imageReplay = imageBuilderGroup.getBuilder(style.getZIndex(), 'Image');
        imageReplay.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay.drawPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
        let textBuilderGroup = builderGroup;
        if (declutterBuilderGroup) textBuilderGroup = declutterBuilderGroup;
        const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const imageStyle = style.getImage();
    const textStyle = style.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */ let declutterImageWithText;
    if (imageStyle) {
        if (imageStyle.getImageState() != (0, _imageStateJsDefault.default).LOADED) return;
        let imageBuilderGroup = builderGroup;
        if (declutterBuilderGroup) {
            const declutterMode = imageStyle.getDeclutterMode();
            if (declutterMode !== 'none') {
                imageBuilderGroup = declutterBuilderGroup;
                if (declutterMode === 'obstacle') {
                    // draw in non-declutter group:
                    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');
                    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
                    imageReplay.drawMultiPoint(geometry, feature);
                } else if (textStyle && textStyle.getText()) declutterImageWithText = {};
            }
        }
        const imageReplay = imageBuilderGroup.getBuilder(style.getZIndex(), 'Image');
        imageReplay.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay.drawMultiPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
        let textBuilderGroup = builderGroup;
        if (declutterBuilderGroup) textBuilderGroup = declutterBuilderGroup;
        const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawPolygon(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}

},{"../ImageState.js":"jCrEd","../util.js":"l1iPW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7wT1g":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/Vector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this
 * type.
 * @template {import("../Feature.js").FeatureLike} [FeatureClass=import("../Feature.js").default]
 */ parcelHelpers.export(exports, "VectorSourceEvent", ()=>VectorSourceEvent);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _rbushJs = require("../structs/RBush.js");
var _rbushJsDefault = parcelHelpers.interopDefault(_rbushJs);
var _featureJs = require("../render/Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _sourceJs = require("./Source.js");
var _sourceJsDefault = parcelHelpers.interopDefault(_sourceJs);
var _vectorEventTypeJs = require("./VectorEventType.js");
var _vectorEventTypeJsDefault = parcelHelpers.interopDefault(_vectorEventTypeJs);
var _functionsJs = require("../functions.js");
var _loadingstrategyJs = require("../loadingstrategy.js");
var _assertsJs = require("../asserts.js");
var _extentJs = require("../extent.js");
var _arrayJs = require("../array.js");
var _utilJs = require("../util.js");
var _objJs = require("../obj.js");
var _eventsJs = require("../events.js");
var _featureloaderJs = require("../featureloader.js");
class VectorSourceEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Type.
   * @param {FeatureClass} [feature] Feature.
   * @param {Array<FeatureClass>} [features] Features.
   */ constructor(type, feature, features){
        super(type);
        /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {FeatureClass|undefined}
     * @api
     */ this.feature = feature;
        /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<FeatureClass>|undefined}
     * @api
     */ this.features = features;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */ /**
 * @template {import("../Feature.js").FeatureLike} [FeatureClass=import("../Feature.js").default]
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<FeatureClass>|Collection<FeatureClass>} [features]
 * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import Vector from 'ol/source/Vector.js';
 * import GeoJSON from 'ol/format/GeoJSON.js';
 * import {bbox} from 'ol/loadingstrategy.js';
 *
 * const vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      const proj = projection.getCode();
 *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      const xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      const onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox,
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection~Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */ /**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../Feature.js").FeatureLike} [FeatureClass=import("../Feature.js").default]
 */ class VectorSource extends (0, _sourceJsDefault.default) {
    /**
   * @param {Options<FeatureClass>} [options] Vector source options.
   */ constructor(options){
        options = options || {};
        super({
            attributions: options.attributions,
            interpolate: true,
            projection: undefined,
            state: 'ready',
            wrapX: options.wrapX !== undefined ? options.wrapX : true
        });
        /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {VectorSourceOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */ this.loader_ = (0, _functionsJs.VOID);
        /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */ this.format_ = options.format;
        /**
     * @private
     * @type {boolean}
     */ this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
        /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */ this.url_ = options.url;
        if (options.loader !== undefined) this.loader_ = options.loader;
        else if (this.url_ !== undefined) {
            (0, _assertsJs.assert)(this.format_, '`format` must be set when `url` is set');
            // create a XHR feature loader for "url" and "format"
            this.loader_ = (0, _featureloaderJs.xhr)(this.url_, /** @type {import("../format/Feature.js").default} */ this.format_);
        }
        /**
     * @private
     * @type {LoadingStrategy}
     */ this.strategy_ = options.strategy !== undefined ? options.strategy : (0, _loadingstrategyJs.all);
        const useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
        /**
     * @private
     * @type {RBush<FeatureClass>}
     */ this.featuresRtree_ = useSpatialIndex ? new (0, _rbushJsDefault.default)() : null;
        /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */ this.loadedExtentsRtree_ = new (0, _rbushJsDefault.default)();
        /**
     * @type {number}
     * @private
     */ this.loadingExtentsCount_ = 0;
        /**
     * @private
     * @type {!Object<string, FeatureClass>}
     */ this.nullGeometryFeatures_ = {};
        /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, FeatureClass|Array<RenderFeature>>}
     */ this.idIndex_ = {};
        /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, FeatureClass>}
     */ this.uidIndex_ = {};
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */ this.featureChangeKeys_ = {};
        /**
     * @private
     * @type {Collection<FeatureClass>|null}
     */ this.featuresCollection_ = null;
        /** @type {Collection<FeatureClass>} */ let collection;
        /** @type {Array<FeatureClass>} */ let features;
        if (Array.isArray(options.features)) features = options.features;
        else if (options.features) {
            collection = options.features;
            features = collection.getArray();
        }
        if (!useSpatialIndex && collection === undefined) collection = new (0, _collectionJsDefault.default)(features);
        if (features !== undefined) this.addFeaturesInternal(features);
        if (collection !== undefined) this.bindFeaturesCollection_(collection);
    }
    /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureClass} feature Feature to add.
   * @api
   */ addFeature(feature) {
        this.addFeatureInternal(feature);
        this.changed();
    }
    /**
   * Add a feature without firing a `change` event.
   * @param {FeatureClass} feature Feature.
   * @protected
   */ addFeatureInternal(feature) {
        const featureKey = (0, _utilJs.getUid)(feature);
        if (!this.addToIndex_(featureKey, feature)) {
            if (this.featuresCollection_) this.featuresCollection_.remove(feature);
            return;
        }
        this.setupChangeEvents_(featureKey, feature);
        const geometry = feature.getGeometry();
        if (geometry) {
            const extent = geometry.getExtent();
            if (this.featuresRtree_) this.featuresRtree_.insert(extent, feature);
        } else this.nullGeometryFeatures_[featureKey] = feature;
        this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).ADDFEATURE, feature));
    }
    /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureClass} feature The feature.
   * @private
   */ setupChangeEvents_(featureKey, feature) {
        if (feature instanceof (0, _featureJsDefault.default)) return;
        this.featureChangeKeys_[featureKey] = [
            (0, _eventsJs.listen)(feature, (0, _eventTypeJsDefault.default).CHANGE, this.handleFeatureChange_, this),
            (0, _eventsJs.listen)(feature, (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, this.handleFeatureChange_, this)
        ];
    }
    /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureClass} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */ addToIndex_(featureKey, feature) {
        let valid = true;
        if (feature.getId() !== undefined) {
            const id = String(feature.getId());
            if (!(id in this.idIndex_)) this.idIndex_[id] = feature;
            else if (feature instanceof (0, _featureJsDefault.default)) {
                const indexedFeature = this.idIndex_[id];
                if (!(indexedFeature instanceof (0, _featureJsDefault.default))) valid = false;
                else if (!Array.isArray(indexedFeature)) this.idIndex_[id] = [
                    indexedFeature,
                    feature
                ];
                else indexedFeature.push(feature);
            } else valid = false;
        }
        if (valid) {
            (0, _assertsJs.assert)(!(featureKey in this.uidIndex_), 'The passed `feature` was already added to the source');
            this.uidIndex_[featureKey] = feature;
        }
        return valid;
    }
    /**
   * Add a batch of features to the source.
   * @param {Array<FeatureClass>} features Features to add.
   * @api
   */ addFeatures(features) {
        this.addFeaturesInternal(features);
        this.changed();
    }
    /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureClass>} features Features.
   * @protected
   */ addFeaturesInternal(features) {
        const extents = [];
        /** @type {Array<FeatureClass>} */ const newFeatures = [];
        /** @type Array<FeatureClass> */ const geometryFeatures = [];
        for(let i = 0, length = features.length; i < length; i++){
            const feature = features[i];
            const featureKey = (0, _utilJs.getUid)(feature);
            if (this.addToIndex_(featureKey, feature)) newFeatures.push(feature);
        }
        for(let i = 0, length = newFeatures.length; i < length; i++){
            const feature = newFeatures[i];
            const featureKey = (0, _utilJs.getUid)(feature);
            this.setupChangeEvents_(featureKey, feature);
            const geometry = feature.getGeometry();
            if (geometry) {
                const extent = geometry.getExtent();
                extents.push(extent);
                geometryFeatures.push(feature);
            } else this.nullGeometryFeatures_[featureKey] = feature;
        }
        if (this.featuresRtree_) this.featuresRtree_.load(extents, geometryFeatures);
        if (this.hasListener((0, _vectorEventTypeJsDefault.default).ADDFEATURE)) for(let i = 0, length = newFeatures.length; i < length; i++)this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).ADDFEATURE, newFeatures[i]));
    }
    /**
   * @param {!Collection<FeatureClass>} collection Collection.
   * @private
   */ bindFeaturesCollection_(collection) {
        let modifyingCollection = false;
        this.addEventListener((0, _vectorEventTypeJsDefault.default).ADDFEATURE, /**
       * @param {VectorSourceEvent<FeatureClass>} evt The vector source event
       */ function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.push(evt.feature);
                modifyingCollection = false;
            }
        });
        this.addEventListener((0, _vectorEventTypeJsDefault.default).REMOVEFEATURE, /**
       * @param {VectorSourceEvent<FeatureClass>} evt The vector source event
       */ function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.remove(evt.feature);
                modifyingCollection = false;
            }
        });
        collection.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, /**
       * @param {import("../Collection.js").CollectionEvent<FeatureClass>} evt The collection event
       */ (evt)=>{
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.addFeature(evt.element);
                modifyingCollection = false;
            }
        });
        collection.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, /**
       * @param {import("../Collection.js").CollectionEvent<FeatureClass>} evt The collection event
       */ (evt)=>{
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.removeFeature(evt.element);
                modifyingCollection = false;
            }
        });
        this.featuresCollection_ = collection;
    }
    /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */ clear(fast) {
        if (fast) {
            for(const featureId in this.featureChangeKeys_){
                const keys = this.featureChangeKeys_[featureId];
                keys.forEach((0, _eventsJs.unlistenByKey));
            }
            if (!this.featuresCollection_) {
                this.featureChangeKeys_ = {};
                this.idIndex_ = {};
                this.uidIndex_ = {};
            }
        } else if (this.featuresRtree_) {
            const removeAndIgnoreReturn = (feature)=>{
                this.removeFeatureInternal(feature);
            };
            this.featuresRtree_.forEach(removeAndIgnoreReturn);
            for(const id in this.nullGeometryFeatures_)this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
        if (this.featuresCollection_) this.featuresCollection_.clear();
        if (this.featuresRtree_) this.featuresRtree_.clear();
        this.nullGeometryFeatures_ = {};
        const clearEvent = new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).CLEAR);
        this.dispatchEvent(clearEvent);
        this.changed();
    }
    /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureClass): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeature(callback) {
        if (this.featuresRtree_) return this.featuresRtree_.forEach(callback);
        if (this.featuresCollection_) this.featuresCollection_.forEach(callback);
    }
    /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureClass): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */ forEachFeatureAtCoordinateDirect(coordinate, callback) {
        const extent = [
            coordinate[0],
            coordinate[1],
            coordinate[0],
            coordinate[1]
        ];
        return this.forEachFeatureInExtent(extent, function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof (0, _featureJsDefault.default) || geometry.intersectsCoordinate(coordinate)) return callback(feature);
            return undefined;
        });
    }
    /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureClass): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeatureInExtent(extent, callback) {
        if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(extent, callback);
        if (this.featuresCollection_) this.featuresCollection_.forEach(callback);
    }
    /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureClass): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeatureIntersectingExtent(extent, callback) {
        return this.forEachFeatureInExtent(extent, /**
       * @param {FeatureClass} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */ function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof (0, _featureJsDefault.default) || geometry.intersectsExtent(extent)) {
                const result = callback(feature);
                if (result) return result;
            }
        });
    }
    /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureClass>|null} The collection of features.
   * @api
   */ getFeaturesCollection() {
        return this.featuresCollection_;
    }
    /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureClass>} Features.
   * @api
   */ getFeatures() {
        let features;
        if (this.featuresCollection_) features = this.featuresCollection_.getArray().slice(0);
        else if (this.featuresRtree_) {
            features = this.featuresRtree_.getAll();
            if (!(0, _objJs.isEmpty)(this.nullGeometryFeatures_)) (0, _arrayJs.extend)(features, Object.values(this.nullGeometryFeatures_));
        }
        return features;
    }
    /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */ getFeaturesAtCoordinate(coordinate) {
        const features = [];
        this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
            features.push(feature);
        });
        return features;
    }
    /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureClass>} Features.
   * @api
   */ getFeaturesInExtent(extent, projection) {
        if (this.featuresRtree_) {
            const multiWorld = projection && projection.canWrapX() && this.getWrapX();
            if (!multiWorld) return this.featuresRtree_.getInExtent(extent);
            const extents = (0, _extentJs.wrapAndSliceX)(extent, projection);
            return [].concat(...extents.map((anExtent)=>this.featuresRtree_.getInExtent(anExtent)));
        }
        if (this.featuresCollection_) return this.featuresCollection_.getArray().slice(0);
        return [];
    }
    /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureClass):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureClass} Closest feature.
   * @api
   */ getClosestFeatureToCoordinate(coordinate, filter) {
        // Find the closest feature using branch and bound.  We start searching an
        // infinite extent, and find the distance from the first feature found.  This
        // becomes the closest feature.  We then compute a smaller extent which any
        // closer feature must intersect.  We continue searching with this smaller
        // extent, trying to find a closer feature.  Every time we find a closer
        // feature, we update the extent being searched so that any even closer
        // feature must intersect it.  We continue until we run out of features.
        const x = coordinate[0];
        const y = coordinate[1];
        let closestFeature = null;
        const closestPoint = [
            NaN,
            NaN
        ];
        let minSquaredDistance = Infinity;
        const extent = [
            -Infinity,
            -Infinity,
            Infinity,
            Infinity
        ];
        filter = filter ? filter : (0, _functionsJs.TRUE);
        this.featuresRtree_.forEachInExtent(extent, /**
       * @param {FeatureClass} feature Feature.
       */ function(feature) {
            if (filter(feature)) {
                const geometry = feature.getGeometry();
                const previousMinSquaredDistance = minSquaredDistance;
                minSquaredDistance = geometry instanceof (0, _featureJsDefault.default) ? 0 : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                if (minSquaredDistance < previousMinSquaredDistance) {
                    closestFeature = feature;
                    // This is sneaky.  Reduce the extent that it is currently being
                    // searched while the R-Tree traversal using this same extent object
                    // is still in progress.  This is safe because the new extent is
                    // strictly contained by the old extent.
                    const minDistance = Math.sqrt(minSquaredDistance);
                    extent[0] = x - minDistance;
                    extent[1] = y - minDistance;
                    extent[2] = x + minDistance;
                    extent[3] = y + minDistance;
                }
            }
        });
        return closestFeature;
    }
    /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent(extent) {
        return this.featuresRtree_.getExtent(extent);
    }
    /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClass|Array<RenderFeature>|null} The feature (or `null` if not found).
   * @api
   */ getFeatureById(id) {
        const feature = this.idIndex_[id.toString()];
        return feature !== undefined ? feature : null;
    }
    /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureClass|null} The feature (or `null` if not found).
   */ getFeatureByUid(uid) {
        const feature = this.uidIndex_[uid];
        return feature !== undefined ? feature : null;
    }
    /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */ getFormat() {
        return this.format_;
    }
    /**
   * @return {boolean} The source can have overlapping geometries.
   */ getOverlaps() {
        return this.overlaps_;
    }
    /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */ getUrl() {
        return this.url_;
    }
    /**
   * @param {Event} event Event.
   * @private
   */ handleFeatureChange_(event) {
        const feature = /** @type {FeatureClass} */ event.target;
        const featureKey = (0, _utilJs.getUid)(feature);
        const geometry = feature.getGeometry();
        if (!geometry) {
            if (!(featureKey in this.nullGeometryFeatures_)) {
                if (this.featuresRtree_) this.featuresRtree_.remove(feature);
                this.nullGeometryFeatures_[featureKey] = feature;
            }
        } else {
            const extent = geometry.getExtent();
            if (featureKey in this.nullGeometryFeatures_) {
                delete this.nullGeometryFeatures_[featureKey];
                if (this.featuresRtree_) this.featuresRtree_.insert(extent, feature);
            } else if (this.featuresRtree_) this.featuresRtree_.update(extent, feature);
        }
        const id = feature.getId();
        if (id !== undefined) {
            const sid = id.toString();
            if (this.idIndex_[sid] !== feature) {
                this.removeFromIdIndex_(feature);
                this.idIndex_[sid] = feature;
            }
        } else {
            this.removeFromIdIndex_(feature);
            this.uidIndex_[featureKey] = feature;
        }
        this.changed();
        this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).CHANGEFEATURE, feature));
    }
    /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureClass} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */ hasFeature(feature) {
        const id = feature.getId();
        if (id !== undefined) return id in this.idIndex_;
        return (0, _utilJs.getUid)(feature) in this.uidIndex_;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        if (this.featuresRtree_) return this.featuresRtree_.isEmpty() && (0, _objJs.isEmpty)(this.nullGeometryFeatures_);
        if (this.featuresCollection_) return this.featuresCollection_.getLength() === 0;
        return true;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */ loadFeatures(extent, resolution, projection) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        const extentsToLoad = this.strategy_(extent, resolution, projection);
        for(let i = 0, ii = extentsToLoad.length; i < ii; ++i){
            const extentToLoad = extentsToLoad[i];
            const alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */ function(object) {
                return (0, _extentJs.containsExtent)(object.extent, extentToLoad);
            });
            if (!alreadyLoaded) {
                ++this.loadingExtentsCount_;
                this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).FEATURESLOADSTART));
                this.loader_.call(this, extentToLoad, resolution, projection, (features)=>{
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).FEATURESLOADEND, undefined, features));
                }, ()=>{
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).FEATURESLOADERROR));
                });
                loadedExtentsRtree.insert(extentToLoad, {
                    extent: extentToLoad.slice()
                });
            }
        }
        this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
    }
    refresh() {
        this.clear(true);
        this.loadedExtentsRtree_.clear();
        super.refresh();
    }
    /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */ removeLoadedExtent(extent) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        let obj;
        loadedExtentsRtree.forEachInExtent(extent, function(object) {
            if ((0, _extentJs.equals)(object.extent, extent)) {
                obj = object;
                return true;
            }
        });
        if (obj) loadedExtentsRtree.remove(obj);
    }
    /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {FeatureClass} feature Feature to remove.
   * @api
   */ removeFeature(feature) {
        if (!feature) return;
        const featureKey = (0, _utilJs.getUid)(feature);
        if (featureKey in this.nullGeometryFeatures_) delete this.nullGeometryFeatures_[featureKey];
        else if (this.featuresRtree_) this.featuresRtree_.remove(feature);
        const result = this.removeFeatureInternal(feature);
        if (result) this.changed();
    }
    /**
   * Remove feature without firing a `change` event.
   * @param {FeatureClass} feature Feature.
   * @return {FeatureClass|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */ removeFeatureInternal(feature) {
        const featureKey = (0, _utilJs.getUid)(feature);
        const featureChangeKeys = this.featureChangeKeys_[featureKey];
        if (!featureChangeKeys) return;
        featureChangeKeys.forEach((0, _eventsJs.unlistenByKey));
        delete this.featureChangeKeys_[featureKey];
        const id = feature.getId();
        if (id !== undefined) delete this.idIndex_[id.toString()];
        delete this.uidIndex_[featureKey];
        this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).REMOVEFEATURE, feature));
        return feature;
    }
    /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureClass} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */ removeFromIdIndex_(feature) {
        let removed = false;
        for(const id in this.idIndex_){
            const indexedFeature = this.idIndex_[id];
            if (feature instanceof (0, _featureJsDefault.default) && Array.isArray(indexedFeature) && indexedFeature.includes(feature)) indexedFeature.splice(indexedFeature.indexOf(feature), 1);
            else if (this.idIndex_[id] === feature) {
                delete this.idIndex_[id];
                removed = true;
                break;
            }
        }
        return removed;
    }
    /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */ setLoader(loader) {
        this.loader_ = loader;
    }
    /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */ setUrl(url) {
        (0, _assertsJs.assert)(this.format_, '`format` must be set when `url` is set');
        this.url_ = url;
        this.setLoader((0, _featureloaderJs.xhr)(url, this.format_));
    }
}
exports.default = VectorSource;

},{"../Collection.js":"hzcJw","../CollectionEventType.js":"auN7R","../events/Event.js":"kooRA","../events/EventType.js":"3uT2C","../ObjectEventType.js":"cu9ir","../structs/RBush.js":"hKwrW","../render/Feature.js":"dtdcp","./Source.js":"bjb1h","./VectorEventType.js":"efeJd","../functions.js":"1QSsQ","../loadingstrategy.js":"6s91V","../asserts.js":"k0OL6","../extent.js":"bGUel","../array.js":"hyet5","../util.js":"l1iPW","../obj.js":"7RZD4","../events.js":"lh4km","../featureloader.js":"2YhmV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hKwrW":[function(require,module,exports,__globalThis) {
/**
 * @module ol/structs/RBush
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rbush = require("rbush");
var _rbushDefault = parcelHelpers.interopDefault(_rbush);
var _extentJs = require("../extent.js");
var _utilJs = require("../util.js");
var _objJs = require("../obj.js");
/**
 * @typedef {Object} Entry
 * @property {number} minX MinX.
 * @property {number} minY MinY.
 * @property {number} maxX MaxX.
 * @property {number} maxY MaxY.
 * @property {Object} [value] Value.
 */ /**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */ class RBush {
    /**
   * @param {number} [maxEntries] Max entries.
   */ constructor(maxEntries){
        /**
     * @private
     */ this.rbush_ = new (0, _rbushDefault.default)(maxEntries);
        /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry>}
     */ this.items_ = {};
    }
    /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */ insert(extent, value) {
        /** @type {Entry} */ const item = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
            value: value
        };
        this.rbush_.insert(item);
        this.items_[(0, _utilJs.getUid)(value)] = item;
    }
    /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */ load(extents, values) {
        const items = new Array(values.length);
        for(let i = 0, l = values.length; i < l; i++){
            const extent = extents[i];
            const value = values[i];
            /** @type {Entry} */ const item = {
                minX: extent[0],
                minY: extent[1],
                maxX: extent[2],
                maxY: extent[3],
                value: value
            };
            items[i] = item;
            this.items_[(0, _utilJs.getUid)(value)] = item;
        }
        this.rbush_.load(items);
    }
    /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */ remove(value) {
        const uid = (0, _utilJs.getUid)(value);
        // get the object in which the value was wrapped when adding to the
        // internal rbush. then use that object to do the removal.
        const item = this.items_[uid];
        delete this.items_[uid];
        return this.rbush_.remove(item) !== null;
    }
    /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */ update(extent, value) {
        const item = this.items_[(0, _utilJs.getUid)(value)];
        const bbox = [
            item.minX,
            item.minY,
            item.maxX,
            item.maxY
        ];
        if (!(0, _extentJs.equals)(bbox, extent)) {
            this.remove(value);
            this.insert(extent, value);
        }
    }
    /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */ getAll() {
        const items = this.rbush_.all();
        return items.map(function(item) {
            return item.value;
        });
    }
    /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */ getInExtent(extent) {
        /** @type {Entry} */ const bbox = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3]
        };
        const items = this.rbush_.search(bbox);
        return items.map(function(item) {
            return item.value;
        });
    }
    /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */ forEach(callback) {
        return this.forEach_(this.getAll(), callback);
    }
    /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */ forEachInExtent(extent, callback) {
        return this.forEach_(this.getInExtent(extent), callback);
    }
    /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */ forEach_(values, callback) {
        let result;
        for(let i = 0, l = values.length; i < l; i++){
            result = callback(values[i]);
            if (result) return result;
        }
        return result;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return (0, _objJs.isEmpty)(this.items_);
    }
    /**
   * Remove all values from the RBush.
   */ clear() {
        this.rbush_.clear();
        this.items_ = {};
    }
    /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */ getExtent(extent) {
        const data = this.rbush_.toJSON();
        return (0, _extentJs.createOrUpdate)(data.minX, data.minY, data.maxX, data.maxY, extent);
    }
    /**
   * @param {RBush} rbush R-Tree.
   */ concat(rbush) {
        this.rbush_.load(rbush.rbush_.all());
        for(const i in rbush.items_)this.items_[i] = rbush.items_[i];
    }
}
exports.default = RBush;

},{"rbush":"dgmWo","../extent.js":"bGUel","../util.js":"l1iPW","../obj.js":"7RZD4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dtdcp":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/Feature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a geometry from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature
 * Render Feature
 * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}
 * New geometry instance.
 * @api
 */ parcelHelpers.export(exports, "toGeometry", ()=>toGeometry);
/**
 * Create an `ol/Feature` from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature RenderFeature
 * @param {string} [geometryName='geometry'] Geometry name to use
 * when creating the Feature.
 * @return {Feature} Newly constructed `ol/Feature` with properties,
 * geometry, and id copied over.
 * @api
 */ parcelHelpers.export(exports, "toFeature", ()=>toFeature);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geomJs = require("../geom.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _simplifyJs = require("../geom/flat/simplify.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("../geom/flat/interiorpoint.js");
var _projJs = require("../proj.js");
var _orientJs = require("../geom/flat/orient.js");
var _interpolateJs = require("../geom/flat/interpolate.js");
var _centerJs = require("../geom/flat/center.js");
var _functionsJs = require("../functions.js");
var _transformJs1 = require("../geom/flat/transform.js");
/**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.
 */ /**
 * @type {import("../transform.js").Transform}
 */ const tmpTransform = (0, _transformJs.create)();
/**
 * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like
 * structure, optimized for vector tile rendering and styling. Geometry access
 * through the API is limited to getting the type and extent of the geometry.
 */ class RenderFeature {
    /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */ constructor(type, flatCoordinates, ends, stride, properties, id){
        /**
     * @type {import("../style/Style.js").StyleFunction|undefined}
     */ this.styleFunction;
        /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */ this.extent_;
        /**
     * @private
     * @type {number|string|undefined}
     */ this.id_ = id;
        /**
     * @private
     * @type {Type}
     */ this.type_ = type;
        /**
     * @private
     * @type {Array<number>}
     */ this.flatCoordinates_ = flatCoordinates;
        /**
     * @private
     * @type {Array<number>}
     */ this.flatInteriorPoints_ = null;
        /**
     * @private
     * @type {Array<number>}
     */ this.flatMidpoints_ = null;
        /**
     * @private
     * @type {Array<number>}
     */ this.ends_ = ends;
        /**
     * @private
     * @type {Object<string, *>}
     */ this.properties_ = properties;
        /**
     * @type {number}
     */ this.squaredTolerance_;
        /**
     * @type {number}
     */ this.stride_ = stride;
        /**
     * @private
     * @type {RenderFeature}
     */ this.simplifiedGeometry_;
    }
    /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */ get(key) {
        return this.properties_[key];
    }
    /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent() {
        if (!this.extent_) this.extent_ = this.type_ === 'Point' ? (0, _extentJs.createOrUpdateFromCoordinate)(this.flatCoordinates_) : (0, _extentJs.createOrUpdateFromFlatCoordinates)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
        return this.extent_;
    }
    /**
   * @return {Array<number>} Flat interior points.
   */ getFlatInteriorPoint() {
        if (!this.flatInteriorPoints_) {
            const flatCenter = (0, _extentJs.getCenter)(this.getExtent());
            this.flatInteriorPoints_ = (0, _interiorpointJs.getInteriorPointOfArray)(this.flatCoordinates_, 0, /** @type {Array<number>} */ this.ends_, 2, flatCenter, 0);
        }
        return this.flatInteriorPoints_;
    }
    /**
   * @return {Array<number>} Flat interior points.
   */ getFlatInteriorPoints() {
        if (!this.flatInteriorPoints_) {
            const ends = (0, _orientJs.inflateEnds)(this.flatCoordinates_, this.ends_);
            const flatCenters = (0, _centerJs.linearRingss)(this.flatCoordinates_, 0, ends, 2);
            this.flatInteriorPoints_ = (0, _interiorpointJs.getInteriorPointsOfMultiArray)(this.flatCoordinates_, 0, ends, 2, flatCenters);
        }
        return this.flatInteriorPoints_;
    }
    /**
   * @return {Array<number>} Flat midpoint.
   */ getFlatMidpoint() {
        if (!this.flatMidpoints_) this.flatMidpoints_ = (0, _interpolateJs.interpolatePoint)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
        return this.flatMidpoints_;
    }
    /**
   * @return {Array<number>} Flat midpoints.
   */ getFlatMidpoints() {
        if (!this.flatMidpoints_) {
            this.flatMidpoints_ = [];
            const flatCoordinates = this.flatCoordinates_;
            let offset = 0;
            const ends = /** @type {Array<number>} */ this.ends_;
            for(let i = 0, ii = ends.length; i < ii; ++i){
                const end = ends[i];
                const midpoint = (0, _interpolateJs.interpolatePoint)(flatCoordinates, offset, end, 2, 0.5);
                (0, _arrayJs.extend)(this.flatMidpoints_, midpoint);
                offset = end;
            }
        }
        return this.flatMidpoints_;
    }
    /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */ getId() {
        return this.id_;
    }
    /**
   * @return {Array<number>} Flat coordinates.
   */ getOrientedFlatCoordinates() {
        return this.flatCoordinates_;
    }
    /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */ getGeometry() {
        return this;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */ getSimplifiedGeometry(squaredTolerance) {
        return this;
    }
    /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */ simplifyTransformed(squaredTolerance, transform) {
        return this;
    }
    /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */ getProperties() {
        return this.properties_;
    }
    /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */ getPropertiesInternal() {
        return this.properties_;
    }
    /**
   * @return {number} Stride.
   */ getStride() {
        return this.stride_;
    }
    /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */ getStyleFunction() {
        return this.styleFunction;
    }
    /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */ getType() {
        return this.type_;
    }
    /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */ transform(projection) {
        projection = (0, _projJs.get)(projection);
        const pixelExtent = projection.getExtent();
        const projectedExtent = projection.getWorldExtent();
        if (pixelExtent && projectedExtent) {
            const scale = (0, _extentJs.getHeight)(projectedExtent) / (0, _extentJs.getHeight)(pixelExtent);
            (0, _transformJs.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
            (0, _transformJs1.transform2D)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);
        }
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */ applyTransform(transformFn) {
        transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
    }
    /**
   * @return {RenderFeature} A cloned render feature.
   */ clone() {
        return new RenderFeature(this.type_, this.flatCoordinates_.slice(), this.ends_.slice(), this.stride_, Object.assign({}, this.properties_), this.id_);
    }
    /**
   * @return {Array<number>} Ends.
   */ getEnds() {
        return this.ends_;
    }
    /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */ enableSimplifyTransformed() {
        this.simplifyTransformed = (0, _functionsJs.memoizeOne)((squaredTolerance, transform)=>{
            if (squaredTolerance === this.squaredTolerance_) return this.simplifiedGeometry_;
            this.simplifiedGeometry_ = this.clone();
            if (transform) this.simplifiedGeometry_.applyTransform(transform);
            const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();
            let simplifiedEnds;
            switch(this.type_){
                case 'LineString':
                    simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeucker)(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.flatCoordinates_.length, this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0);
                    simplifiedEnds = [
                        simplifiedFlatCoordinates.length
                    ];
                    break;
                case 'MultiLineString':
                    simplifiedEnds = [];
                    simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeuckerArray)(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
                    break;
                case 'Polygon':
                    simplifiedEnds = [];
                    simplifiedFlatCoordinates.length = (0, _simplifyJs.quantizeArray)(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
                    break;
                default:
            }
            if (simplifiedEnds) this.simplifiedGeometry_ = new RenderFeature(this.type_, simplifiedFlatCoordinates, simplifiedEnds, 2, this.properties_, this.id_);
            this.squaredTolerance_ = squaredTolerance;
            return this.simplifiedGeometry_;
        });
        return this;
    }
}
/**
 * @return {Array<number>} Flat coordinates.
 */ RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
function toGeometry(renderFeature) {
    const geometryType = renderFeature.getType();
    switch(geometryType){
        case 'Point':
            return new (0, _geomJs.Point)(renderFeature.getFlatCoordinates());
        case 'MultiPoint':
            return new (0, _geomJs.MultiPoint)(renderFeature.getFlatCoordinates(), 'XY');
        case 'LineString':
            return new (0, _geomJs.LineString)(renderFeature.getFlatCoordinates(), 'XY');
        case 'MultiLineString':
            return new (0, _geomJs.MultiLineString)(renderFeature.getFlatCoordinates(), 'XY', /** @type {Array<number>} */ renderFeature.getEnds());
        case 'Polygon':
            const flatCoordinates = renderFeature.getFlatCoordinates();
            const ends = /** @type {Array<number>} */ renderFeature.getEnds();
            const endss = (0, _orientJs.inflateEnds)(flatCoordinates, ends);
            return endss.length > 1 ? new (0, _geomJs.MultiPolygon)(flatCoordinates, 'XY', endss) : new (0, _geomJs.Polygon)(flatCoordinates, 'XY', ends);
        default:
            throw new Error('Invalid geometry type:' + geometryType);
    }
}
function toFeature(renderFeature, geometryName) {
    const id = renderFeature.getId();
    const geometry = toGeometry(renderFeature);
    const properties = renderFeature.getProperties();
    const feature = new (0, _featureJsDefault.default)();
    if (geometryName !== undefined) feature.setGeometryName(geometryName);
    feature.setGeometry(geometry);
    if (id !== undefined) feature.setId(id);
    feature.setProperties(properties, true);
    return feature;
}
exports.default = RenderFeature;

},{"../Feature.js":"3qocF","../geom.js":"ce4yU","../transform.js":"9LrRk","../extent.js":"bGUel","../geom/flat/simplify.js":"gXvXA","../array.js":"hyet5","../geom/flat/interiorpoint.js":"ii0ve","../proj.js":"8OK47","../geom/flat/orient.js":"kVTqd","../geom/flat/interpolate.js":"2FPjT","../geom/flat/center.js":"1Xznx","../functions.js":"1QSsQ","../geom/flat/transform.js":"7FFJr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3qocF":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Feature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */ parcelHelpers.export(exports, "createStyleFunction", ()=>createStyleFunction);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _assertsJs = require("./asserts.js");
var _eventsJs = require("./events.js");
/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */ /**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */ /***
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */ /**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature.js';
 * import Polygon from 'ol/geom/Polygon.js';
 * import Point from 'ol/geom/Point.js';
 *
 * const feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon',
 * });
 *
 * // get the polygon geometry
 * const poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * const point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */ class Feature extends (0, _objectJsDefault.default) {
    /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */ constructor(geometryOrProperties){
        super();
        /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {FeatureOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {number|string|undefined}
     */ this.id_ = undefined;
        /**
     * @type {string}
     * @private
     */ this.geometryName_ = 'geometry';
        /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */ this.style_ = null;
        /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */ this.styleFunction_ = undefined;
        /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */ this.geometryChangeKey_ = null;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        if (geometryOrProperties) {
            if (typeof /** @type {?} */ geometryOrProperties.getSimplifiedGeometry === 'function') {
                const geometry = /** @type {Geometry} */ geometryOrProperties;
                this.setGeometry(geometry);
            } else {
                /** @type {Object<string, *>} */ const properties = geometryOrProperties;
                this.setProperties(properties);
            }
        }
    }
    /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */ clone() {
        const clone = /** @type {Feature<Geometry>} */ new Feature(this.hasProperties() ? this.getProperties() : null);
        clone.setGeometryName(this.getGeometryName());
        const geometry = this.getGeometry();
        if (geometry) clone.setGeometry(/** @type {Geometry} */ geometry.clone());
        const style = this.getStyle();
        if (style) clone.setStyle(style);
        return clone;
    }
    /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */ getGeometry() {
        return /** @type {Geometry|undefined} */ this.get(this.geometryName_);
    }
    /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */ getId() {
        return this.id_;
    }
    /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */ getGeometryName() {
        return this.geometryName_;
    }
    /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */ getStyle() {
        return this.style_;
    }
    /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */ getStyleFunction() {
        return this.styleFunction_;
    }
    /**
   * @private
   */ handleGeometryChange_() {
        this.changed();
    }
    /**
   * @private
   */ handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
            (0, _eventsJs.unlistenByKey)(this.geometryChangeKey_);
            this.geometryChangeKey_ = null;
        }
        const geometry = this.getGeometry();
        if (geometry) this.geometryChangeKey_ = (0, _eventsJs.listen)(geometry, (0, _eventTypeJsDefault.default).CHANGE, this.handleGeometryChange_, this);
        this.changed();
    }
    /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */ setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
    }
    /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */ setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? undefined : createStyleFunction(style);
        this.changed();
    }
    /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */ setId(id) {
        this.id_ = id;
        this.changed();
    }
    /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */ setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
    }
}
function createStyleFunction(obj) {
    if (typeof obj === 'function') return obj;
    /**
   * @type {Array<import("./style/Style.js").default>}
   */ let styles;
    if (Array.isArray(obj)) styles = obj;
    else {
        (0, _assertsJs.assert)(typeof /** @type {?} */ obj.getZIndex === 'function', 'Expected an `ol/style/Style` or an array of `ol/style/Style.js`');
        const style = /** @type {import("./style/Style.js").default} */ obj;
        styles = [
            style
        ];
    }
    return function() {
        return styles;
    };
}
exports.default = Feature;

},{"./Object.js":"N6yIf","./events/EventType.js":"3uT2C","./asserts.js":"k0OL6","./events.js":"lh4km","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ce4yU":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Circle", ()=>(0, _circleJsDefault.default));
parcelHelpers.export(exports, "Geometry", ()=>(0, _geometryJsDefault.default));
parcelHelpers.export(exports, "GeometryCollection", ()=>(0, _geometryCollectionJsDefault.default));
parcelHelpers.export(exports, "LinearRing", ()=>(0, _linearRingJsDefault.default));
parcelHelpers.export(exports, "LineString", ()=>(0, _lineStringJsDefault.default));
parcelHelpers.export(exports, "MultiLineString", ()=>(0, _multiLineStringJsDefault.default));
parcelHelpers.export(exports, "MultiPoint", ()=>(0, _multiPointJsDefault.default));
parcelHelpers.export(exports, "MultiPolygon", ()=>(0, _multiPolygonJsDefault.default));
parcelHelpers.export(exports, "Point", ()=>(0, _pointJsDefault.default));
parcelHelpers.export(exports, "Polygon", ()=>(0, _polygonJsDefault.default));
parcelHelpers.export(exports, "SimpleGeometry", ()=>(0, _simpleGeometryJsDefault.default));
var _circleJs = require("./geom/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _geometryJs = require("./geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _geometryCollectionJs = require("./geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _linearRingJs = require("./geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _lineStringJs = require("./geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _multiLineStringJs = require("./geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPointJs = require("./geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _multiPolygonJs = require("./geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _pointJs = require("./geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("./geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _simpleGeometryJs = require("./geom/SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);

},{"./geom/Circle.js":false,"./geom/Geometry.js":false,"./geom/GeometryCollection.js":"6lIhA","./geom/LinearRing.js":false,"./geom/LineString.js":"gknRz","./geom/MultiLineString.js":"4FjXg","./geom/MultiPoint.js":"gXgmP","./geom/MultiPolygon.js":"b4GDd","./geom/Point.js":"6SybV","./geom/Polygon.js":"8Vwps","./geom/SimpleGeometry.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jRv80":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/Circle
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _transformJs = require("./flat/transform.js");
/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */ class Circle extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius in units of the projection.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(center, radius, layout){
        super();
        if (layout !== undefined && radius === undefined) this.setFlatCoordinates(layout, center);
        else {
            radius = radius ? radius : 0;
            this.setCenterAndRadius(center, radius, layout);
        }
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */ clone() {
        const circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);
        circle.applyProperties(this);
        return circle;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const dx = x - flatCoordinates[0];
        const dy = y - flatCoordinates[1];
        const squaredDistance = dx * dx + dy * dy;
        if (squaredDistance < minSquaredDistance) {
            if (squaredDistance === 0) for(let i = 0; i < this.stride; ++i)closestPoint[i] = flatCoordinates[i];
            else {
                const delta = this.getRadius() / Math.sqrt(squaredDistance);
                closestPoint[0] = flatCoordinates[0] + delta * dx;
                closestPoint[1] = flatCoordinates[1] + delta * dy;
                for(let i = 2; i < this.stride; ++i)closestPoint[i] = flatCoordinates[i];
            }
            closestPoint.length = this.stride;
            return squaredDistance;
        }
        return minSquaredDistance;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        const flatCoordinates = this.flatCoordinates;
        const dx = x - flatCoordinates[0];
        const dy = y - flatCoordinates[1];
        return dx * dx + dy * dy <= this.getRadiusSquared_();
    }
    /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */ getCenter() {
        return this.flatCoordinates.slice(0, this.stride);
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const radius = flatCoordinates[this.stride] - flatCoordinates[0];
        return (0, _extentJs.createOrUpdate)(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
    }
    /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */ getRadius() {
        return Math.sqrt(this.getRadiusSquared_());
    }
    /**
   * @private
   * @return {number} Radius squared.
   */ getRadiusSquared_() {
        const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
        const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
        return dx * dx + dy * dy;
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'Circle';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        const circleExtent = this.getExtent();
        if ((0, _extentJs.intersects)(extent, circleExtent)) {
            const center = this.getCenter();
            if (extent[0] <= center[0] && extent[2] >= center[0]) return true;
            if (extent[1] <= center[1] && extent[3] >= center[1]) return true;
            return (0, _extentJs.forEachCorner)(extent, this.intersectsCoordinate.bind(this));
        }
        return false;
    }
    /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */ setCenter(center) {
        const stride = this.stride;
        const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
        const flatCoordinates = center.slice();
        flatCoordinates[stride] = flatCoordinates[0] + radius;
        for(let i = 1; i < stride; ++i)flatCoordinates[stride + i] = center[i];
        this.setFlatCoordinates(this.layout, flatCoordinates);
        this.changed();
    }
    /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCenterAndRadius(center, radius, layout) {
        this.setLayout(layout, center, 0);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        /** @type {Array<number>} */ const flatCoordinates = this.flatCoordinates;
        let offset = (0, _deflateJs.deflateCoordinate)(flatCoordinates, 0, center, this.stride);
        flatCoordinates[offset++] = flatCoordinates[0] + radius;
        for(let i = 1, ii = this.stride; i < ii; ++i)flatCoordinates[offset++] = flatCoordinates[i];
        flatCoordinates.length = offset;
        this.changed();
    }
    getCoordinates() {
        return null;
    }
    setCoordinates(coordinates, layout) {}
    /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */ setRadius(radius) {
        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
        this.changed();
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        const center = this.getCenter();
        const stride = this.getStride();
        this.setCenter((0, _transformJs.rotate)(center, 0, center.length, stride, angle, anchor, center));
        this.changed();
    }
}
/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */ Circle.prototype.transform;
exports.default = Circle;

},{"./SimpleGeometry.js":"iZYIt","../extent.js":"bGUel","./flat/deflate.js":"is4mF","./flat/transform.js":"7FFJr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6lIhA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/GeometryCollection
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
/**
 * @classdesc
 * An array of {@link module:ol/geom/Geometry~Geometry} objects.
 *
 * @api
 */ class GeometryCollection extends (0, _geometryJsDefault.default) {
    /**
   * @param {Array<Geometry>} [geometries] Geometries.
   */ constructor(geometries){
        super();
        /**
     * @private
     * @type {Array<Geometry>}
     */ this.geometries_ = geometries ? geometries : null;
        /**
     * @type {Array<import("../events.js").EventsKey>}
     */ this.changeEventsKeys_ = [];
        this.listenGeometriesChange_();
    }
    /**
   * @private
   */ unlistenGeometriesChange_() {
        this.changeEventsKeys_.forEach((0, _eventsJs.unlistenByKey));
        this.changeEventsKeys_.length = 0;
    }
    /**
   * @private
   */ listenGeometriesChange_() {
        if (!this.geometries_) return;
        for(let i = 0, ii = this.geometries_.length; i < ii; ++i)this.changeEventsKeys_.push((0, _eventsJs.listen)(this.geometries_[i], (0, _eventTypeJsDefault.default).CHANGE, this.changed, this));
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */ clone() {
        const geometryCollection = new GeometryCollection(null);
        geometryCollection.setGeometries(this.geometries_);
        geometryCollection.applyProperties(this);
        return geometryCollection;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
        return minSquaredDistance;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i){
            if (geometries[i].containsXY(x, y)) return true;
        }
        return false;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        (0, _extentJs.createOrUpdateEmpty)(extent);
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)(0, _extentJs.extend)(extent, geometries[i].getExtent());
        return extent;
    }
    /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */ getGeometries() {
        return cloneGeometries(this.geometries_);
    }
    /**
   * @return {Array<Geometry>} Geometries.
   */ getGeometriesArray() {
        return this.geometries_;
    }
    /**
   * @return {Array<Geometry>} Geometries.
   */ getGeometriesArrayRecursive() {
        /** @type {Array<Geometry>} */ let geometriesArray = [];
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)if (geometries[i].getType() === this.getType()) geometriesArray = geometriesArray.concat(/** @type {GeometryCollection} */ geometries[i].getGeometriesArrayRecursive());
        else geometriesArray.push(geometries[i]);
        return geometriesArray;
    }
    /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */ getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
            this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) return this;
        const simplifiedGeometries = [];
        const geometries = this.geometries_;
        let simplified = false;
        for(let i = 0, ii = geometries.length; i < ii; ++i){
            const geometry = geometries[i];
            const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
            simplifiedGeometries.push(simplifiedGeometry);
            if (simplifiedGeometry !== geometry) simplified = true;
        }
        if (simplified) {
            const simplifiedGeometryCollection = new GeometryCollection(null);
            simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
            return simplifiedGeometryCollection;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'GeometryCollection';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i){
            if (geometries[i].intersectsExtent(extent)) return true;
        }
        return false;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return this.geometries_.length === 0;
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].rotate(angle, anchor);
        this.changed();
    }
    /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */ scale(sx, sy, anchor) {
        if (!anchor) anchor = (0, _extentJs.getCenter)(this.getExtent());
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].scale(sx, sy, anchor);
        this.changed();
    }
    /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */ setGeometries(geometries) {
        this.setGeometriesArray(cloneGeometries(geometries));
    }
    /**
   * @param {Array<Geometry>} geometries Geometries.
   */ setGeometriesArray(geometries) {
        this.unlistenGeometriesChange_();
        this.geometries_ = geometries;
        this.listenGeometriesChange_();
        this.changed();
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */ applyTransform(transformFn) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].applyTransform(transformFn);
        this.changed();
    }
    /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */ translate(deltaX, deltaY) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].translate(deltaX, deltaY);
        this.changed();
    }
    /**
   * Clean up.
   */ disposeInternal() {
        this.unlistenGeometriesChange_();
        super.disposeInternal();
    }
}
/**
 * @param {Array<Geometry>} geometries Geometries.
 * @return {Array<Geometry>} Cloned geometries.
 */ function cloneGeometries(geometries) {
    const clonedGeometries = [];
    for(let i = 0, ii = geometries.length; i < ii; ++i)clonedGeometries.push(geometries[i].clone());
    return clonedGeometries;
}
exports.default = GeometryCollection;

},{"../events/EventType.js":"3uT2C","./Geometry.js":"6K9DH","../extent.js":"bGUel","../events.js":"lh4km","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gknRz":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/LineString
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _arrayJs = require("../array.js");
var _segmentsJs = require("./flat/segments.js");
var _inflateJs = require("./flat/inflate.js");
var _interpolateJs = require("./flat/interpolate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _lengthJs = require("./flat/length.js");
/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */ class LineString extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */ this.flatMidpoint_ = null;
        /**
     * @private
     * @type {number}
     */ this.flatMidpointRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        if (layout !== undefined && !Array.isArray(coordinates[0])) this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
        else this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ coordinates, layout);
    }
    /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */ appendCoordinate(coordinate) {
        (0, _arrayJs.extend)(this.flatCoordinates, coordinate);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */ clone() {
        const lineString = new LineString(this.flatCoordinates.slice(), this.layout);
        lineString.applyProperties(this);
        return lineString;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */ forEachSegment(callback) {
        return (0, _segmentsJs.forEach)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
    }
    /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */ getCoordinateAtM(m, extrapolate) {
        if (this.layout != 'XYM' && this.layout != 'XYZM') return null;
        extrapolate = extrapolate !== undefined ? extrapolate : false;
        return (0, _interpolateJs.lineStringCoordinateAtM)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
    }
    /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */ getCoordinateAt(fraction, dest) {
        return (0, _interpolateJs.interpolatePoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, dest, this.stride);
    }
    /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */ getLength() {
        return (0, _lengthJs.lineStringLength)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * @return {Array<number>} Flat midpoint.
   */ getFlatMidpoint() {
        if (this.flatMidpointRevision_ != this.getRevision()) {
            this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_ ?? undefined);
            this.flatMidpointRevision_ = this.getRevision();
        }
        return /** @type {Array<number>} */ this.flatMidpoint_;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        /** @type {Array<number>} */ const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LineString(simplifiedFlatCoordinates, 'XY');
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'LineString';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLineString)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    }
    /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = LineString;

},{"./SimpleGeometry.js":"iZYIt","./flat/closest.js":"5urVB","../extent.js":"bGUel","./flat/deflate.js":"is4mF","./flat/simplify.js":"gXvXA","../array.js":"hyet5","./flat/segments.js":"1jUrz","./flat/inflate.js":"hm7Zu","./flat/interpolate.js":"2FPjT","./flat/intersectsextent.js":"empkw","./flat/length.js":"Cl4Mx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2FPjT":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/interpolate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */ parcelHelpers.export(exports, "interpolatePoint", ()=>interpolatePoint);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */ parcelHelpers.export(exports, "lineStringCoordinateAtM", ()=>lineStringCoordinateAtM);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */ parcelHelpers.export(exports, "lineStringsCoordinateAtM", ()=>lineStringsCoordinateAtM);
var _arrayJs = require("../../array.js");
var _mathJs = require("../../math.js");
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
    let o, t;
    const n = (end - offset) / stride;
    if (n === 1) o = offset;
    else if (n === 2) {
        o = offset;
        t = fraction;
    } else if (n !== 0) {
        let x1 = flatCoordinates[offset];
        let y1 = flatCoordinates[offset + 1];
        let length = 0;
        const cumulativeLengths = [
            0
        ];
        for(let i = offset + stride; i < end; i += stride){
            const x2 = flatCoordinates[i];
            const y2 = flatCoordinates[i + 1];
            length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            cumulativeLengths.push(length);
            x1 = x2;
            y1 = y2;
        }
        const target = fraction * length;
        const index = (0, _arrayJs.binarySearch)(cumulativeLengths, target);
        if (index < 0) {
            t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
            o = offset + (-index - 2) * stride;
        } else o = offset + index * stride;
    }
    dimension = dimension > 1 ? dimension : 2;
    dest = dest ? dest : new Array(dimension);
    for(let i = 0; i < dimension; ++i)dest[i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + i] : (0, _mathJs.lerp)(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
    return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
    if (end == offset) return null;
    let coordinate;
    if (m < flatCoordinates[offset + stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(offset, offset + stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        return null;
    }
    if (flatCoordinates[end - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(end - stride, end);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        return null;
    }
    // FIXME use O(1) search
    if (m == flatCoordinates[offset + stride - 1]) return flatCoordinates.slice(offset, offset + stride);
    let lo = offset / stride;
    let hi = end / stride;
    while(lo < hi){
        const mid = lo + hi >> 1;
        if (m < flatCoordinates[(mid + 1) * stride - 1]) hi = mid;
        else lo = mid + 1;
    }
    const m0 = flatCoordinates[lo * stride - 1];
    if (m == m0) return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
    const m1 = flatCoordinates[(lo + 1) * stride - 1];
    const t = (m - m0) / (m1 - m0);
    coordinate = [];
    for(let i = 0; i < stride - 1; ++i)coordinate.push((0, _mathJs.lerp)(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
    coordinate.push(m);
    return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
    if (interpolate) return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
    let coordinate;
    if (m < flatCoordinates[stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(0, stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        return null;
    }
    if (flatCoordinates[flatCoordinates.length - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        return null;
    }
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        if (offset == end) continue;
        if (m < flatCoordinates[offset + stride - 1]) return null;
        if (m <= flatCoordinates[end - 1]) return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
        offset = end;
    }
    return null;
}

},{"../../array.js":"hyet5","../../math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4FjXg":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/MultiLineString
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("./LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _arrayJs = require("../array.js");
var _inflateJs = require("./flat/inflate.js");
var _interpolateJs = require("./flat/interpolate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */ class MultiLineString extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */ constructor(coordinates, layout, ends){
        super();
        /**
     * @type {Array<number>}
     * @private
     */ this.ends_ = [];
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        if (Array.isArray(coordinates[0])) this.setCoordinates(/** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ coordinates, layout);
        else if (layout !== undefined && ends) {
            this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
            this.ends_ = ends;
        } else {
            const lineStrings = /** @type {Array<LineString>} */ coordinates;
            /** @type {Array<number>} */ const flatCoordinates = [];
            const ends = [];
            for(let i = 0, ii = lineStrings.length; i < ii; ++i){
                const lineString = lineStrings[i];
                (0, _arrayJs.extend)(flatCoordinates, lineString.getFlatCoordinates());
                ends.push(flatCoordinates.length);
            }
            const layout = lineStrings.length === 0 ? this.getLayout() : lineStrings[0].getLayout();
            this.setFlatCoordinates(layout, flatCoordinates);
            this.ends_ = ends;
        }
    }
    /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */ appendLineString(lineString) {
        (0, _arrayJs.extend)(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */ clone() {
        const multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        multiLineString.applyProperties(this);
        return multiLineString;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */ getCoordinateAtM(m, extrapolate, interpolate) {
        if (this.layout != 'XYM' && this.layout != 'XYZM' || this.flatCoordinates.length === 0) return null;
        extrapolate = extrapolate !== undefined ? extrapolate : false;
        interpolate = interpolate !== undefined ? interpolate : false;
        return (0, _interpolateJs.lineStringsCoordinateAtM)(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
    }
    /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinatesArray)(this.flatCoordinates, 0, this.ends_, this.stride);
    }
    /**
   * @return {Array<number>} Ends.
   */ getEnds() {
        return this.ends_;
    }
    /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */ getLineString(index) {
        if (index < 0 || this.ends_.length <= index) return null;
        return new (0, _lineStringJsDefault.default)(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    }
    /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */ getLineStrings() {
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const layout = this.layout;
        /** @type {Array<LineString>} */ const lineStrings = [];
        let offset = 0;
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const lineString = new (0, _lineStringJsDefault.default)(flatCoordinates.slice(offset, end), layout);
            lineStrings.push(lineString);
            offset = end;
        }
        return lineStrings;
    }
    /**
   * @return {Array<number>} Flat midpoints.
   */ getFlatMidpoints() {
        /** @type {Array<number>} */ const midpoints = [];
        const flatCoordinates = this.flatCoordinates;
        let offset = 0;
        const ends = this.ends_;
        const stride = this.stride;
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const midpoint = (0, _interpolateJs.interpolatePoint)(flatCoordinates, offset, end, stride, 0.5);
            (0, _arrayJs.extend)(midpoints, midpoint);
            offset = end;
        }
        return midpoints;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        /** @type {Array<number>} */ const simplifiedFlatCoordinates = [];
        /** @type {Array<number>} */ const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeuckerArray)(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'MultiLineString';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLineStringArray)(this.flatCoordinates, 0, this.ends_, this.stride, extent);
    }
    /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 2);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        const ends = (0, _deflateJs.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
    }
}
exports.default = MultiLineString;

},{"./LineString.js":"gknRz","./SimpleGeometry.js":"iZYIt","./flat/closest.js":"5urVB","../extent.js":"bGUel","./flat/deflate.js":"is4mF","./flat/simplify.js":"gXvXA","../array.js":"hyet5","./flat/inflate.js":"hm7Zu","./flat/interpolate.js":"2FPjT","./flat/intersectsextent.js":"empkw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gXgmP":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/MultiPoint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointJs = require("./Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _inflateJs = require("./flat/inflate.js");
var _mathJs = require("../math.js");
/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */ class MultiPoint extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        if (layout && !Array.isArray(coordinates[0])) this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
        else this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ coordinates, layout);
    }
    /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */ appendPoint(point) {
        (0, _arrayJs.extend)(this.flatCoordinates, point.getFlatCoordinates());
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */ clone() {
        const multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
        multiPoint.applyProperties(this);
        return multiPoint;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            const squaredDistance = (0, _mathJs.squaredDistance)(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
            if (squaredDistance < minSquaredDistance) {
                minSquaredDistance = squaredDistance;
                for(let j = 0; j < stride; ++j)closestPoint[j] = flatCoordinates[i + j];
                closestPoint.length = stride;
            }
        }
        return minSquaredDistance;
    }
    /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */ getPoint(index) {
        const n = this.flatCoordinates.length / this.stride;
        if (index < 0 || n <= index) return null;
        return new (0, _pointJsDefault.default)(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
    }
    /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */ getPoints() {
        const flatCoordinates = this.flatCoordinates;
        const layout = this.layout;
        const stride = this.stride;
        /** @type {Array<Point>} */ const points = [];
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            const point = new (0, _pointJsDefault.default)(flatCoordinates.slice(i, i + stride), layout);
            points.push(point);
        }
        return points;
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'MultiPoint';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            const x = flatCoordinates[i];
            const y = flatCoordinates[i + 1];
            if ((0, _extentJs.containsXY)(extent, x, y)) return true;
        }
        return false;
    }
    /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = MultiPoint;

},{"./Point.js":"6SybV","./SimpleGeometry.js":"iZYIt","../extent.js":"bGUel","./flat/deflate.js":"is4mF","../array.js":"hyet5","./flat/inflate.js":"hm7Zu","../math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b4GDd":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/MultiPolygon
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _multiPointJs = require("./MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _polygonJs = require("./Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("./flat/interiorpoint.js");
var _inflateJs = require("./flat/inflate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _orientJs = require("./flat/orient.js");
var _areaJs = require("./flat/area.js");
var _centerJs = require("./flat/center.js");
var _containsJs = require("./flat/contains.js");
var _simplifyJs = require("./flat/simplify.js");
/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */ class MultiPolygon extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */ constructor(coordinates, layout, endss){
        super();
        /**
     * @type {Array<Array<number>>}
     * @private
     */ this.endss_ = [];
        /**
     * @private
     * @type {number}
     */ this.flatInteriorPointsRevision_ = -1;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.flatInteriorPoints_ = null;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.orientedRevision_ = -1;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.orientedFlatCoordinates_ = null;
        if (!endss && !Array.isArray(coordinates[0])) {
            const polygons = /** @type {Array<Polygon>} */ coordinates;
            /** @type {Array<number>} */ const flatCoordinates = [];
            const thisEndss = [];
            for(let i = 0, ii = polygons.length; i < ii; ++i){
                const polygon = polygons[i];
                const offset = flatCoordinates.length;
                const ends = polygon.getEnds();
                for(let j = 0, jj = ends.length; j < jj; ++j)ends[j] += offset;
                (0, _arrayJs.extend)(flatCoordinates, polygon.getFlatCoordinates());
                thisEndss.push(ends);
            }
            layout = polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();
            coordinates = flatCoordinates;
            endss = thisEndss;
        }
        if (layout !== undefined && endss) {
            this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
            this.endss_ = endss;
        } else this.setCoordinates(/** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ coordinates, layout);
    }
    /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */ appendPolygon(polygon) {
        /** @type {Array<number>} */ let ends;
        if (!this.flatCoordinates) {
            this.flatCoordinates = polygon.getFlatCoordinates().slice();
            ends = polygon.getEnds().slice();
            this.endss_.push();
        } else {
            const offset = this.flatCoordinates.length;
            (0, _arrayJs.extend)(this.flatCoordinates, polygon.getFlatCoordinates());
            ends = polygon.getEnds().slice();
            for(let i = 0, ii = ends.length; i < ii; ++i)ends[i] += offset;
        }
        this.endss_.push(ends);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */ clone() {
        const len = this.endss_.length;
        const newEndss = new Array(len);
        for(let i = 0; i < len; ++i)newEndss[i] = this.endss_[i].slice();
        const multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
        multiPolygon.applyProperties(this);
        return multiPolygon;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.multiArrayMaxSquaredDelta)(this.flatCoordinates, 0, this.endss_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestMultiArrayPoint)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        return (0, _containsJs.linearRingssContainsXY)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
    }
    /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */ getArea() {
        return (0, _areaJs.linearRingss)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
    }
    /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */ getCoordinates(right) {
        let flatCoordinates;
        if (right !== undefined) {
            flatCoordinates = this.getOrientedFlatCoordinates().slice();
            (0, _orientJs.orientLinearRingsArray)(flatCoordinates, 0, this.endss_, this.stride, right);
        } else flatCoordinates = this.flatCoordinates;
        return (0, _inflateJs.inflateMultiCoordinatesArray)(flatCoordinates, 0, this.endss_, this.stride);
    }
    /**
   * @return {Array<Array<number>>} Endss.
   */ getEndss() {
        return this.endss_;
    }
    /**
   * @return {Array<number>} Flat interior points.
   */ getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
            const flatCenters = (0, _centerJs.linearRingss)(this.flatCoordinates, 0, this.endss_, this.stride);
            this.flatInteriorPoints_ = (0, _interiorpointJs.getInteriorPointsOfMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
            this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return /** @type {Array<number>} */ this.flatInteriorPoints_;
    }
    /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */ getInteriorPoints() {
        return new (0, _multiPointJsDefault.default)(this.getFlatInteriorPoints().slice(), 'XYM');
    }
    /**
   * @return {Array<number>} Oriented flat coordinates.
   */ getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
            const flatCoordinates = this.flatCoordinates;
            if ((0, _orientJs.linearRingssAreOriented)(flatCoordinates, 0, this.endss_, this.stride)) this.orientedFlatCoordinates_ = flatCoordinates;
            else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = (0, _orientJs.orientLinearRingsArray)(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
            }
            this.orientedRevision_ = this.getRevision();
        }
        return /** @type {Array<number>} */ this.orientedFlatCoordinates_;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        /** @type {Array<number>} */ const simplifiedFlatCoordinates = [];
        /** @type {Array<Array<number>>} */ const simplifiedEndss = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.quantizeMultiArray)(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
        return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);
    }
    /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */ getPolygon(index) {
        if (index < 0 || this.endss_.length <= index) return null;
        let offset;
        if (index === 0) offset = 0;
        else {
            const prevEnds = this.endss_[index - 1];
            offset = prevEnds[prevEnds.length - 1];
        }
        const ends = this.endss_[index].slice();
        const end = ends[ends.length - 1];
        if (offset !== 0) for(let i = 0, ii = ends.length; i < ii; ++i)ends[i] -= offset;
        return new (0, _polygonJsDefault.default)(this.flatCoordinates.slice(offset, end), this.layout, ends);
    }
    /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */ getPolygons() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const endss = this.endss_;
        const polygons = [];
        let offset = 0;
        for(let i = 0, ii = endss.length; i < ii; ++i){
            const ends = endss[i].slice();
            const end = ends[ends.length - 1];
            if (offset !== 0) for(let j = 0, jj = ends.length; j < jj; ++j)ends[j] -= offset;
            const polygon = new (0, _polygonJsDefault.default)(flatCoordinates.slice(offset, end), layout, ends);
            polygons.push(polygon);
            offset = end;
        }
        return polygons;
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'MultiPolygon';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLinearRingMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
    }
    /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 3);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        const endss = (0, _deflateJs.deflateMultiCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
        if (endss.length === 0) this.flatCoordinates.length = 0;
        else {
            const lastEnds = endss[endss.length - 1];
            this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
    }
}
exports.default = MultiPolygon;

},{"./MultiPoint.js":"gXgmP","./Polygon.js":"8Vwps","./SimpleGeometry.js":"iZYIt","./flat/closest.js":"5urVB","../extent.js":"bGUel","./flat/deflate.js":"is4mF","../array.js":"hyet5","./flat/interiorpoint.js":"ii0ve","./flat/inflate.js":"hm7Zu","./flat/intersectsextent.js":"empkw","./flat/orient.js":"kVTqd","./flat/area.js":"8w7cR","./flat/center.js":"1Xznx","./flat/contains.js":"kCfKA","./flat/simplify.js":"gXvXA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1Xznx":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/center
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */ parcelHelpers.export(exports, "linearRingss", ()=>linearRingss);
var _extentJs = require("../../extent.js");
function linearRingss(flatCoordinates, offset, endss, stride) {
    const flatCenters = [];
    let extent = (0, _extentJs.createEmpty)();
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        extent = (0, _extentJs.createOrUpdateFromFlatCoordinates)(flatCoordinates, offset, ends[0], stride);
        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
        offset = ends[ends.length - 1];
    }
    return flatCenters;
}

},{"../../extent.js":"bGUel","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"efeJd":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/VectorEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */ ADDFEATURE: 'addfeature',
    /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */ CHANGEFEATURE: 'changefeature',
    /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */ CLEAR: 'clear',
    /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */ REMOVEFEATURE: 'removefeature',
    /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */ FEATURESLOADSTART: 'featuresloadstart',
    /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */ FEATURESLOADEND: 'featuresloadend',
    /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */ FEATURESLOADERROR: 'featuresloaderror'
}; /**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6s91V":[function(require,module,exports,__globalThis) {
/**
 * @module ol/loadingstrategy
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */ parcelHelpers.export(exports, "all", ()=>all);
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */ parcelHelpers.export(exports, "bbox", ()=>bbox);
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */ parcelHelpers.export(exports, "tile", ()=>tile);
var _projJs = require("./proj.js");
function all(extent, resolution) {
    return [
        [
            -Infinity,
            -Infinity,
            Infinity,
            Infinity
        ]
    ];
}
function bbox(extent, resolution) {
    return [
        extent
    ];
}
function tile(tileGrid) {
    return(/**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */ function(extent, resolution, projection) {
        const z = tileGrid.getZForResolution((0, _projJs.fromUserResolution)(resolution, projection));
        const tileRange = tileGrid.getTileRangeForExtentAndZ((0, _projJs.fromUserExtent)(extent, projection), z);
        /** @type {Array<import("./extent.js").Extent>} */ const extents = [];
        /** @type {import("./tilecoord.js").TileCoord} */ const tileCoord = [
            z,
            0,
            0
        ];
        for(tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1])for(tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2])extents.push((0, _projJs.toUserExtent)(tileGrid.getTileCoordExtent(tileCoord), projection));
        return extents;
    });
}

},{"./proj.js":"8OK47","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2YhmV":[function(require,module,exports,__globalThis) {
/**
 * @module ol/featureloader
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an
 * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:ol/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */ /**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */ /**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */ parcelHelpers.export(exports, "loadFeaturesXhr", ()=>loadFeaturesXhr);
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */ parcelHelpers.export(exports, "xhr", ()=>xhr);
/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */ parcelHelpers.export(exports, "setWithCredentials", ()=>setWithCredentials);
var _functionsJs = require("./functions.js");
/**
 *
 * @type {boolean}
 * @private
 */ let withCredentials = false;
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
    if (format.getType() == 'arraybuffer') xhr.responseType = 'arraybuffer';
    xhr.withCredentials = withCredentials;
    /**
   * @param {Event} event Event.
   * @private
   */ xhr.onload = function(event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
            const type = format.getType();
            /** @type {Document|Node|Object|string|undefined} */ let source;
            if (type == 'json') source = JSON.parse(xhr.responseText);
            else if (type == 'text') source = xhr.responseText;
            else if (type == 'xml') {
                source = xhr.responseXML;
                if (!source) source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
            } else if (type == 'arraybuffer') source = /** @type {ArrayBuffer} */ xhr.response;
            if (source) success(/** @type {Array<import("./Feature.js").default>} */ format.readFeatures(source, {
                extent: extent,
                featureProjection: projection
            }), format.readProjection(source));
            else failure();
        } else failure();
    };
    /**
   * @private
   */ xhr.onerror = failure;
    xhr.send();
}
function xhr(url, format) {
    /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {function(Array<import("./Feature.js").default>): void} [success] Success
   *      Function called when loading succeeded.
   * @param {function(): void} [failure] Failure
   *      Function called when loading failed.
   */ return function(extent, resolution, projection, success, failure) {
        const source = /** @type {import("./source/Vector").default} */ this;
        loadFeaturesXhr(url, format, extent, resolution, projection, /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */ function(features, dataProjection) {
            source.addFeatures(features);
            if (success !== undefined) success(features);
        }, /* FIXME handle error */ failure ? failure : (0, _functionsJs.VOID));
    };
}
function setWithCredentials(xhrWithCredentials) {
    withCredentials = xhrWithCredentials;
}

},{"./functions.js":"1QSsQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gp2Gj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "current_location", ()=>current_location);
var _featureJs = require("ol/Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geolocationJs = require("ol/Geolocation.js");
var _geolocationJsDefault = parcelHelpers.interopDefault(_geolocationJs);
var _pointJs = require("ol/geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _vectorJs = require("ol/layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _vectorJs1 = require("ol/source/Vector.js");
var _vectorJsDefault1 = parcelHelpers.interopDefault(_vectorJs1);
var _circleJs = require("ol/style/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("ol/style/Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _strokeJs = require("ol/style/Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _styleJs = require("ol/style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _circle = require("ol/geom/Circle");
var _circleDefault = parcelHelpers.interopDefault(_circle);
function current_location(view) {
    console.log("Initializing geolocation");
    // Check if geolocation is supported
    if (!navigator.geolocation) return Promise.reject(new Error("Geolocation is not supported by this browser"));
    const geolocation = new (0, _geolocationJsDefault.default)({
        trackingOptions: {
            enableHighAccuracy: true,
            timeout: 15000,
            maximumAge: 0 // Don't use cached position
        },
        projection: view.getProjection()
    });
    geolocation.setTracking(true);
    const accuracyFeature = new (0, _featureJsDefault.default)();
    const positionFeature = new (0, _featureJsDefault.default)();
    positionFeature.setStyle(new (0, _styleJsDefault.default)({
        image: new (0, _circleJsDefault.default)({
            radius: 6,
            fill: new (0, _fillJsDefault.default)({
                color: '#3399CC'
            }),
            stroke: new (0, _strokeJsDefault.default)({
                color: '#fff',
                width: 2
            })
        })
    }));
    accuracyFeature.setStyle(new (0, _styleJsDefault.default)({
        fill: new (0, _fillJsDefault.default)({
            color: 'rgba(0, 0, 255, 0.2)'
        })
    }));
    const locationLayer = new (0, _vectorJsDefault.default)({
        source: new (0, _vectorJsDefault1.default)({
            features: [
                accuracyFeature,
                positionFeature
            ]
        }),
        title: "location-layer"
    });
    return new Promise((resolve, reject)=>{
        // Add error handler
        geolocation.on('error', function(error) {
            console.error('Geolocation error:', error);
            // Show user-friendly error message based on error code
            if (error.code === 1) reject(new Error("Location permission denied. Please allow location access in your browser settings."));
            else if (error.code === 2) reject(new Error("Location unavailable. Please try again or check your device settings."));
            else if (error.code === 3) reject(new Error("Location request timed out. Please try again with better signal."));
            else reject(error);
        });
        const onPositionChange = ()=>{
            console.log("Position changed");
            const coordinates = geolocation.getPosition();
            if (coordinates) {
                console.log("Got coordinates:", coordinates);
                const point = new (0, _pointJsDefault.default)(coordinates);
                let accuracyGeom = geolocation.getAccuracyGeometry();
                if (!accuracyGeom) {
                    console.log("No accuracy geometry, creating default circle");
                    const circle = new (0, _circleDefault.default)(coordinates, 100);
                    accuracyGeom = circle;
                }
                accuracyFeature.setGeometry(accuracyGeom);
                positionFeature.setGeometry(point);
                view.fit(point.getExtent(), {
                    maxZoom: 15,
                    duration: 220
                });
                // Clear timeout since we got a position
                clearTimeout(timeoutId);
                geolocation.un('change:position', onPositionChange);
                resolve({
                    layer: locationLayer,
                    pointFeature: positionFeature
                });
            } else console.log("No coordinates available yet");
        };
        // Set a timeout to reject if no position is received
        const timeoutId = setTimeout(()=>{
            if (!geolocation.getPosition()) {
                geolocation.un('change:position', onPositionChange);
                reject(new Error("Geolocation timeout - no position received. Please check your browser location permissions."));
            }
        }, 15000); // Increased to 15 seconds
        geolocation.on('change:position', onPositionChange);
        // Check if position is already available
        if (geolocation.getPosition()) {
            console.log("Position already available");
            onPositionChange();
        }
    });
}

},{"ol/Feature.js":"3qocF","ol/Geolocation.js":"dfIH0","ol/geom/Point.js":"6SybV","ol/layer/Vector.js":"6bOIK","ol/source/Vector.js":"7wT1g","ol/style/Circle.js":"3LBvw","ol/style/Fill.js":"cHc7U","ol/style/Stroke.js":"1uQwy","ol/style/Style.js":"8opjn","ol/geom/Circle":"jRv80","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dfIH0":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Geolocation
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted on [GeolocationPositionError](https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPositionError).
 */ parcelHelpers.export(exports, "GeolocationError", ()=>GeolocationError);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _polygonJs = require("./geom/Polygon.js");
var _projJs = require("./proj.js");
var _mathJs = require("./math.js");
/**
 * @enum {string}
 */ const Property = {
    ACCURACY: 'accuracy',
    ACCURACY_GEOMETRY: 'accuracyGeometry',
    ALTITUDE: 'altitude',
    ALTITUDE_ACCURACY: 'altitudeAccuracy',
    HEADING: 'heading',
    POSITION: 'position',
    PROJECTION: 'projection',
    SPEED: 'speed',
    TRACKING: 'tracking',
    TRACKING_OPTIONS: 'trackingOptions'
};
/**
 * @enum string
 */ const GeolocationErrorType = {
    /**
   * Triggered when a `GeolocationPositionError` occurs.
   * @event module:ol/Geolocation.GeolocationError#error
   * @api
   */ ERROR: 'error'
};
class GeolocationError extends (0, _eventJsDefault.default) {
    /**
   * @param {GeolocationPositionError} error error object.
   */ constructor(error){
        super(GeolocationErrorType.ERROR);
        /**
     * Code of the underlying `GeolocationPositionError`.
     * @type {number}
     * @api
     */ this.code = error.code;
        /**
     * Message of the underlying `GeolocationPositionError`.
     * @type {string}
     * @api
     */ this.message = error.message;
    }
}
/**
 * @typedef {Object} Options
 * @property {boolean} [tracking=false] Start Tracking right after
 * instantiation.
 * @property {PositionOptions} [trackingOptions] Tracking options.
 * See https://www.w3.org/TR/geolocation-API/#position_options_interface.
 * @property {import("./proj.js").ProjectionLike} [projection] The projection the position
 * is reported in.
 */ /**
 * @typedef {import("./ObjectEventType").Types|'change:accuracy'|'change:accuracyGeometry'|'change:altitude'|
 *    'change:altitudeAccuracy'|'change:heading'|'change:position'|'change:projection'|'change:speed'|'change:tracking'|
 *    'change:trackingOptions'} GeolocationObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<GeolocationObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'error', GeolocationError, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|GeolocationObjectEventTypes, Return> &
 *   import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return>} GeolocationOnSignature
 */ /**
 * @classdesc
 * Helper class for providing HTML5 Geolocation capabilities.
 * The [Geolocation API](https://www.w3.org/TR/geolocation-API/)
 * is used to locate a user's position.
 *
 * To get notified of position changes and errors, register listeners for the generic
 * `change` event and the `error` event on your instance of {@link module:ol/Geolocation~Geolocation}.
 *
 * Example:
 *
 *     const geolocation = new Geolocation({
 *       // take the projection to use from the map's view
 *       projection: view.getProjection()
 *     });
 *     // listen to changes in position
 *     geolocation.on('change', function(evt) {
 *       console.log(geolocation.getPosition());
 *     });
 *     // listen to error
 *     geolocation.on('error', function(evt) {
 *       window.console.log(evt.message);
 *     });
 *
 * @fires GeolocationError
 * @api
 */ class Geolocation extends (0, _objectJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        /***
     * @type {GeolocationOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {GeolocationOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {GeolocationOnSignature<void>}
     */ this.un;
        options = options || {};
        /**
     * The unprojected (EPSG:4326) device position.
     * @private
     * @type {?import("./coordinate.js").Coordinate}
     */ this.position_ = null;
        /**
     * @private
     * @type {import("./proj.js").TransformFunction}
     */ this.transform_ = (0, _projJs.identityTransform);
        /**
     * @private
     * @type {number|undefined}
     */ this.watchId_ = undefined;
        this.addChangeListener(Property.PROJECTION, this.handleProjectionChanged_);
        this.addChangeListener(Property.TRACKING, this.handleTrackingChanged_);
        if (options.projection !== undefined) this.setProjection(options.projection);
        if (options.trackingOptions !== undefined) this.setTrackingOptions(options.trackingOptions);
        this.setTracking(options.tracking !== undefined ? options.tracking : false);
    }
    /**
   * Clean up.
   */ disposeInternal() {
        this.setTracking(false);
        super.disposeInternal();
    }
    /**
   * @private
   */ handleProjectionChanged_() {
        const projection = this.getProjection();
        if (projection) {
            this.transform_ = (0, _projJs.getTransformFromProjections)((0, _projJs.get)('EPSG:4326'), projection);
            if (this.position_) this.set(Property.POSITION, this.transform_(this.position_));
        }
    }
    /**
   * @private
   */ handleTrackingChanged_() {
        if ('geolocation' in navigator) {
            const tracking = this.getTracking();
            if (tracking && this.watchId_ === undefined) this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());
            else if (!tracking && this.watchId_ !== undefined) {
                navigator.geolocation.clearWatch(this.watchId_);
                this.watchId_ = undefined;
            }
        }
    }
    /**
   * @private
   * @param {GeolocationPosition} position position event.
   */ positionChange_(position) {
        const coords = position.coords;
        this.set(Property.ACCURACY, coords.accuracy);
        this.set(Property.ALTITUDE, coords.altitude === null ? undefined : coords.altitude);
        this.set(Property.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? undefined : coords.altitudeAccuracy);
        this.set(Property.HEADING, coords.heading === null ? undefined : (0, _mathJs.toRadians)(coords.heading));
        if (!this.position_) this.position_ = [
            coords.longitude,
            coords.latitude
        ];
        else {
            this.position_[0] = coords.longitude;
            this.position_[1] = coords.latitude;
        }
        const projectedPosition = this.transform_(this.position_);
        this.set(Property.POSITION, projectedPosition.slice());
        this.set(Property.SPEED, coords.speed === null ? undefined : coords.speed);
        const geometry = (0, _polygonJs.circular)(this.position_, coords.accuracy);
        geometry.applyTransform(this.transform_);
        this.set(Property.ACCURACY_GEOMETRY, geometry);
        this.changed();
    }
    /**
   * @private
   * @param {GeolocationPositionError} error error object.
   */ positionError_(error) {
        this.dispatchEvent(new GeolocationError(error));
    }
    /**
   * Get the accuracy of the position in meters.
   * @return {number|undefined} The accuracy of the position measurement in
   *     meters.
   * @observable
   * @api
   */ getAccuracy() {
        return /** @type {number|undefined} */ this.get(Property.ACCURACY);
    }
    /**
   * Get a geometry of the position accuracy.
   * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.
   * @observable
   * @api
   */ getAccuracyGeometry() {
        return /** @type {?import("./geom/Polygon.js").default} */ this.get(Property.ACCURACY_GEOMETRY) || null;
    }
    /**
   * Get the altitude associated with the position.
   * @return {number|undefined} The altitude of the position in meters above mean
   *     sea level.
   * @observable
   * @api
   */ getAltitude() {
        return /** @type {number|undefined} */ this.get(Property.ALTITUDE);
    }
    /**
   * Get the altitude accuracy of the position.
   * @return {number|undefined} The accuracy of the altitude measurement in
   *     meters.
   * @observable
   * @api
   */ getAltitudeAccuracy() {
        return /** @type {number|undefined} */ this.get(Property.ALTITUDE_ACCURACY);
    }
    /**
   * Get the heading as radians clockwise from North.
   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`
   * is set to `true` in the tracking options.
   * @return {number|undefined} The heading of the device in radians from north.
   * @observable
   * @api
   */ getHeading() {
        return /** @type {number|undefined} */ this.get(Property.HEADING);
    }
    /**
   * Get the position of the device.
   * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported
   *     in the current projection.
   * @observable
   * @api
   */ getPosition() {
        return /** @type {import("./coordinate.js").Coordinate|undefined} */ this.get(Property.POSITION);
    }
    /**
   * Get the projection associated with the position.
   * @return {import("./proj/Projection.js").default|undefined} The projection the position is
   *     reported in.
   * @observable
   * @api
   */ getProjection() {
        return /** @type {import("./proj/Projection.js").default|undefined} */ this.get(Property.PROJECTION);
    }
    /**
   * Get the speed in meters per second.
   * @return {number|undefined} The instantaneous speed of the device in meters
   *     per second.
   * @observable
   * @api
   */ getSpeed() {
        return /** @type {number|undefined} */ this.get(Property.SPEED);
    }
    /**
   * Determine if the device location is being tracked.
   * @return {boolean} The device location is being tracked.
   * @observable
   * @api
   */ getTracking() {
        return /** @type {boolean} */ this.get(Property.TRACKING);
    }
    /**
   * Get the tracking options.
   * See https://www.w3.org/TR/geolocation-API/#position-options.
   * @return {PositionOptions|undefined} PositionOptions as defined by
   *     the [HTML5 Geolocation spec
   *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */ getTrackingOptions() {
        return /** @type {PositionOptions|undefined} */ this.get(Property.TRACKING_OPTIONS);
    }
    /**
   * Set the projection to use for transforming the coordinates.
   * @param {import("./proj.js").ProjectionLike} projection The projection the position is
   *     reported in.
   * @observable
   * @api
   */ setProjection(projection) {
        this.set(Property.PROJECTION, (0, _projJs.get)(projection));
    }
    /**
   * Enable or disable tracking.
   * @param {boolean} tracking Enable tracking.
   * @observable
   * @api
   */ setTracking(tracking) {
        this.set(Property.TRACKING, tracking);
    }
    /**
   * Set the tracking options.
   * See http://www.w3.org/TR/geolocation-API/#position-options.
   * @param {PositionOptions} options PositionOptions as defined by the
   *     [HTML5 Geolocation spec
   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */ setTrackingOptions(options) {
        this.set(Property.TRACKING_OPTIONS, options);
    }
}
exports.default = Geolocation;

},{"./events/Event.js":"kooRA","./Object.js":"N6yIf","./geom/Polygon.js":"8Vwps","./proj.js":"8OK47","./math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aG9FU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createFlightRouteLayer", ()=>createFlightRouteLayer);
var _proj = require("ol/proj");
var _feature = require("ol/Feature");
var _featureDefault = parcelHelpers.interopDefault(_feature);
var _point = require("ol/geom/Point");
var _pointDefault = parcelHelpers.interopDefault(_point);
var _lineString = require("ol/geom/LineString");
var _lineStringDefault = parcelHelpers.interopDefault(_lineString);
var _vector = require("ol/source/Vector");
var _vectorDefault = parcelHelpers.interopDefault(_vector);
var _vector1 = require("ol/layer/Vector");
var _vectorDefault1 = parcelHelpers.interopDefault(_vector1);
var _style = require("ol/style");
function createFlightRouteLayer(destinationLonLat, view) {
    const pune = (0, _proj.fromLonLat)([
        73.8567,
        18.5204
    ]);
    const dest = (0, _proj.fromLonLat)(destinationLonLat);
    const dagana = (0, _proj.fromLonLat)([
        73.8567,
        23.5204
    ]);
    // Create a LineString with all points for the straight line visualization
    const route = new (0, _lineStringDefault.default)([
        pune,
        dest,
        dagana,
        pune
    ]);
    const routeFeature = new (0, _featureDefault.default)(route);
    const source = new (0, _vectorDefault.default)();
    const layer = new (0, _vectorDefault1.default)({
        source,
        style: function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof (0, _pointDefault.default)) return new (0, _style.Style)({
                image: new (0, _style.Icon)({
                    src: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
                    scale: 0.05
                })
            });
            return new (0, _style.Style)({
                stroke: new (0, _style.Stroke)({
                    color: 'rgba(0, 153, 255, 0.8)',
                    width: 5,
                    lineDash: [
                        10,
                        10
                    ]
                })
            });
        },
        title: 'flight-layer'
    });
    if (view) view.fit(route.getExtent(), {
        padding: [
            50,
            50,
            50,
            50
        ],
        duration: 1000
    });
    // Create great circle arcs for each segment of the journey
    const features = [];
    // Pune to Destination
    const arc1 = new window.arc.GreatCircle({
        x: 73.8567,
        y: 18.5204
    }, {
        x: destinationLonLat[0],
        y: destinationLonLat[1]
    });
    const arcLine1 = arc1.Arc(100, {
        offset: 10
    });
    // Destination to Dagana
    const arc2 = new window.arc.GreatCircle({
        x: destinationLonLat[0],
        y: destinationLonLat[1]
    }, {
        x: 73.8567,
        y: 23.5204
    });
    const arcLine2 = arc2.Arc(100, {
        offset: 10
    });
    // Dagana to Pune
    const arc3 = new window.arc.GreatCircle({
        x: 73.8567,
        y: 23.52044
    }, {
        x: 73.8567,
        y: 18.5204
    });
    const arcLine3 = arc3.Arc(100, {
        offset: 10
    });
    // Process all arc segments
    [
        arcLine1,
        arcLine2,
        arcLine3
    ].forEach((arcLine)=>{
        arcLine.geometries.forEach((geometry)=>{
            const line = new (0, _lineStringDefault.default)(geometry.coords);
            line.transform('EPSG:4326', 'EPSG:3857');
            features.push(new (0, _featureDefault.default)({
                geometry: line
            }));
        });
    });
    // Add marker for Pune
    const puneMarker = new (0, _featureDefault.default)({
        geometry: new (0, _pointDefault.default)(pune)
    });
    // Add marker for Destination
    const destMarker = new (0, _featureDefault.default)({
        geometry: new (0, _pointDefault.default)(dest)
    });
    // Add marker for Dagana
    const daganaMarker = new (0, _featureDefault.default)({
        geometry: new (0, _pointDefault.default)(dagana)
    });
    features.push(puneMarker, destMarker, daganaMarker);
    source.addFeatures(features);
    return layer;
}

},{"ol/proj":"8OK47","ol/Feature":"3qocF","ol/geom/Point":"6SybV","ol/geom/LineString":"gknRz","ol/source/Vector":"7wT1g","ol/layer/Vector":"6bOIK","ol/style":"kOk47","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bsKzT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildWFSRequest", ()=>buildWFSRequest);
parcelHelpers.export(exports, "postWFSRequest", ()=>postWFSRequest);
parcelHelpers.export(exports, "parseWFSGeoJSON", ()=>parseWFSGeoJSON);
parcelHelpers.export(exports, "fetchFeatures", ()=>fetchFeatures);
parcelHelpers.export(exports, "createWfsLayer", ()=>createWfsLayer);
var _wfs = require("ol/format/WFS");
var _wfsDefault = parcelHelpers.interopDefault(_wfs);
var _geoJSON = require("ol/format/GeoJSON");
var _geoJSONDefault = parcelHelpers.interopDefault(_geoJSON);
var _vector = require("ol/source/Vector");
var _vectorDefault = parcelHelpers.interopDefault(_vector);
var _vector1 = require("ol/layer/Vector");
var _vectorDefault1 = parcelHelpers.interopDefault(_vector1);
var _style = require("ol/style/Style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _circle = require("ol/style/Circle");
var _circleDefault = parcelHelpers.interopDefault(_circle);
var _fill = require("ol/style/Fill");
var _fillDefault = parcelHelpers.interopDefault(_fill);
var _stroke = require("ol/style/Stroke");
var _strokeDefault = parcelHelpers.interopDefault(_stroke);
function buildWFSRequest({ srsName, featurePrefix, featureType, filter }) {
    const wfsFormat = new (0, _wfsDefault.default)();
    return wfsFormat.writeGetFeature({
        srsName,
        featurePrefix,
        featureTypes: [
            featureType
        ],
        outputFormat: 'application/json',
        filter: filter
    });
}
async function postWFSRequest({ url, xmlRequest, headers }) {
    const response = await fetch(url, {
        method: 'POST',
        mode: 'cors',
        headers,
        body: new XMLSerializer().serializeToString(xmlRequest)
    });
    if (!response.ok) throw new Error(`WFS request failed: ${response.statusText}`);
    return await response.json();
}
function parseWFSGeoJSON(json, projection = 'EPSG:3857') {
    const geojsonFormat = new (0, _geoJSONDefault.default)();
    return geojsonFormat.readFeatures(json);
}
async function fetchFeatures(url = 'https://localhost:8080/geoserver/ows', workspace, layer_name, user, password) {
    const geoserverURL = url;
    const workingPrefix = workspace;
    const workingGeoserverLayer = layer_name;
    const xmlRequest = buildWFSRequest({
        srsName: 'EPSG:3857',
        featurePrefix: workingPrefix,
        featureType: workingGeoserverLayer
    });
    const json = await postWFSRequest({
        url: geoserverURL,
        xmlRequest,
        headers: {
            'Content-Type': 'text/xml',
            'Authorization': 'Basic ' + btoa(`${user}:${password}`)
        }
    });
    const features = parseWFSGeoJSON(json);
    return features;
}
function createWfsLayer(features) {
    const layerSource = new (0, _vectorDefault.default)();
    layerSource.addFeatures(features);
    const styleFunction = (feature)=>{
        const type = feature.getGeometry().getType();
        if (type === 'Point' || type === 'MultiPoint') return new (0, _styleDefault.default)({
            image: new (0, _circleDefault.default)({
                radius: 5,
                fill: new (0, _fillDefault.default)({
                    color: 'blue'
                }),
                stroke: new (0, _strokeDefault.default)({
                    color: 'white',
                    width: 1
                })
            })
        });
        if (type.includes('Line')) return new (0, _styleDefault.default)({
            stroke: new (0, _strokeDefault.default)({
                color: 'green',
                width: 2
            })
        });
        if (type.includes('Polygon')) return new (0, _styleDefault.default)({
            stroke: new (0, _strokeDefault.default)({
                color: 'orange',
                width: 1
            }),
            fill: new (0, _fillDefault.default)({
                color: 'rgba(255,165,0,0.3)'
            })
        });
        return new (0, _styleDefault.default)({
            stroke: new (0, _strokeDefault.default)({
                color: 'gray',
                width: 1
            }),
            fill: new (0, _fillDefault.default)({
                color: 'rgba(200, 200, 200, 0.3)'
            })
        });
    };
    const layer = new (0, _vectorDefault1.default)({
        source: layerSource,
        style: styleFunction,
        title: "wfs-layer"
    });
    return layer;
}

},{"ol/format/WFS":"bv3Sz","ol/format/GeoJSON":"9jWnV","ol/source/Vector":"7wT1g","ol/layer/Vector":"6bOIK","ol/style/Style":"8opjn","ol/style/Circle":"3LBvw","ol/style/Fill":"cHc7U","ol/style/Stroke":"1uQwy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bv3Sz":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/WFS
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Encode filter as WFS `Filter` and return the Node.
 *
 * @param {import("./filter/Filter.js").default} filter Filter.
 * @param {string} version WFS version. If not provided defaults to '1.1.0'
 * @return {Node} Result.
 * @api
 */ parcelHelpers.export(exports, "writeFilter", ()=>writeFilter);
var _gml2Js = require("./GML2.js");
var _gml2JsDefault = parcelHelpers.interopDefault(_gml2Js);
var _gml3Js = require("./GML3.js");
var _gml3JsDefault = parcelHelpers.interopDefault(_gml3Js);
var _gml32Js = require("./GML32.js");
var _gml32JsDefault = parcelHelpers.interopDefault(_gml32Js);
var _gmlbaseJs = require("./GMLBase.js");
var _gmlbaseJsDefault = parcelHelpers.interopDefault(_gmlbaseJs);
var _xmlfeatureJs = require("./XMLFeature.js");
var _xmlfeatureJsDefault = parcelHelpers.interopDefault(_xmlfeatureJs);
var _xmlJs = require("../xml.js");
var _filterJs = require("./filter.js");
var _assertsJs = require("../asserts.js");
var _projJs = require("../proj.js");
var _xsdJs = require("./xsd.js");
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ const FEATURE_COLLECTION_PARSERS = {
    'http://www.opengis.net/gml': {
        'boundedBy': (0, _xmlJs.makeObjectPropertySetter)((0, _gmlbaseJsDefault.default).prototype.readExtentElement, 'bounds')
    },
    'http://www.opengis.net/wfs/2.0': {
        'member': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readFeaturesInternal)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ const TRANSACTION_SUMMARY_PARSERS = {
    'http://www.opengis.net/wfs': {
        'totalInserted': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
        'totalUpdated': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
        'totalDeleted': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger))
    },
    'http://www.opengis.net/wfs/2.0': {
        'totalInserted': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
        'totalUpdated': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
        'totalDeleted': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger))
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ const TRANSACTION_RESPONSE_PARSERS = {
    'http://www.opengis.net/wfs': {
        'TransactionSummary': (0, _xmlJs.makeObjectPropertySetter)(readTransactionSummary, 'transactionSummary'),
        'InsertResults': (0, _xmlJs.makeObjectPropertySetter)(readInsertResults, 'insertIds')
    },
    'http://www.opengis.net/wfs/2.0': {
        'TransactionSummary': (0, _xmlJs.makeObjectPropertySetter)(readTransactionSummary, 'transactionSummary'),
        'InsertResults': (0, _xmlJs.makeObjectPropertySetter)(readInsertResults, 'insertIds')
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ const QUERY_SERIALIZERS = {
    'http://www.opengis.net/wfs': {
        'PropertyName': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode))
    },
    'http://www.opengis.net/wfs/2.0': {
        'PropertyName': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode))
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ const TRANSACTION_SERIALIZERS = {
    'http://www.opengis.net/wfs': {
        'Insert': (0, _xmlJs.makeChildAppender)(writeFeature),
        'Update': (0, _xmlJs.makeChildAppender)(writeUpdate),
        'Delete': (0, _xmlJs.makeChildAppender)(writeDelete),
        'Property': (0, _xmlJs.makeChildAppender)(writeProperty),
        'Native': (0, _xmlJs.makeChildAppender)(writeNative)
    },
    'http://www.opengis.net/wfs/2.0': {
        'Insert': (0, _xmlJs.makeChildAppender)(writeFeature),
        'Update': (0, _xmlJs.makeChildAppender)(writeUpdate),
        'Delete': (0, _xmlJs.makeChildAppender)(writeDelete),
        'Property': (0, _xmlJs.makeChildAppender)(writeProperty),
        'Native': (0, _xmlJs.makeChildAppender)(writeNative)
    }
};
/**
 * @typedef {Object} Options
 * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.
 * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.
 * @property {GMLBase} [gmlFormat] The GML format to use to parse the response.
 * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.
 * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.
 * @property {string} [version='1.1.0'] WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.
 */ /**
 * @typedef {Object} WriteGetFeatureOptions
 * @property {string} featureNS The namespace URI used for features.
 * @property {string} featurePrefix The prefix for the feature namespace.
 * @property {Array<string|FeatureType>} featureTypes The feature type names or FeatureType objects to
 * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are
 * ignored.).
 * @property {string} [srsName] SRS name. No srsName attribute will be set on
 * geometries when this is not provided.
 * @property {string} [handle] Handle.
 * @property {string} [outputFormat] Output format.
 * @property {number} [maxFeatures] Maximum number of features to fetch.
 * @property {string} [geometryName] Geometry name to use in a BBOX filter.
 * @property {Array<string>} [propertyNames] Optional list of property names to serialize.
 * @property {string} [viewParams] viewParams GeoServer vendor parameter.
 * @property {number} [startIndex] Start index to use for WFS paging. This is a
 * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.
 * @property {number} [count] Number of features to retrieve when paging. This is a
 * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some
 * Web Feature Services have repurposed `maxfeatures` instead.
 * @property {import("../extent.js").Extent} [bbox] Extent to use for the BBOX filter. The `geometryName`
 * option must be set.
 * @property {import("./filter/Filter.js").default} [filter] Filter condition. See
 * {@link module:ol/format/filter} for more information.
 * @property {string} [resultType] Indicates what response should be returned,
 * e.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.
 */ /**
 * @typedef {Object} FeatureType
 * @property {!string} name The feature type name.
 * @property {!import("../extent.js").Extent} bbox Extent to use for the BBOX filter.
 * @property {!string} geometryName Geometry name to use in the BBOX filter.
 */ /**
 * @typedef {Object} WriteTransactionOptions
 * @property {string} featureNS The namespace URI used for features.
 * @property {string} featurePrefix The prefix for the feature namespace.
 * @property {string} featureType The feature type name.
 * @property {string} [srsName] SRS name. No srsName attribute will be set on
 * geometries when this is not provided.
 * @property {string} [handle] Handle.
 * @property {boolean} [hasZ] Must be set to true if the transaction is for
 * a 3D layer. This will allow the Z coordinate to be included in the transaction.
 * @property {Array<Object>} nativeElements Native elements. Currently not supported.
 * @property {import("./GMLBase.js").Options} [gmlOptions] GML options for the WFS transaction writer.
 * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.
 */ /**
 * Number of features; bounds/extent.
 * @typedef {Object} FeatureCollectionMetadata
 * @property {number} numberOfFeatures NumberOfFeatures.
 * @property {import("../extent.js").Extent} bounds Bounds.
 */ /**
 * Total deleted; total inserted; total updated; array of insert ids.
 * @typedef {Object} TransactionResponse
 * @property {number} totalDeleted TotalDeleted.
 * @property {number} totalInserted TotalInserted.
 * @property {number} totalUpdated TotalUpdated.
 * @property {Array<string>} insertIds InsertIds.
 */ /**
 * @type {string}
 */ const FEATURE_PREFIX = 'feature';
/**
 * @type {string}
 */ const XMLNS = 'http://www.w3.org/2000/xmlns/';
/**
 * @type {Object<string, string>}
 */ const OGCNS = {
    '2.0.0': 'http://www.opengis.net/ogc/1.1',
    '1.1.0': 'http://www.opengis.net/ogc',
    '1.0.0': 'http://www.opengis.net/ogc'
};
/**
 * @type {Object<string, string>}
 */ const WFSNS = {
    '2.0.0': 'http://www.opengis.net/wfs/2.0',
    '1.1.0': 'http://www.opengis.net/wfs',
    '1.0.0': 'http://www.opengis.net/wfs'
};
/**
 * @type {Object<string, string>}
 */ const FESNS = {
    '2.0.0': 'http://www.opengis.net/fes/2.0',
    '1.1.0': 'http://www.opengis.net/fes',
    '1.0.0': 'http://www.opengis.net/fes'
};
/**
 * @type {Object<string, string>}
 */ const SCHEMA_LOCATIONS = {
    '2.0.0': 'http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd',
    '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',
    '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'
};
/**
 * @type {Object<string, object>}
 */ const GML_FORMATS = {
    '2.0.0': (0, _gml32JsDefault.default),
    '1.1.0': (0, _gml3JsDefault.default),
    '1.0.0': (0, _gml2JsDefault.default)
};
/**
 * @const
 * @type {string}
 */ const DEFAULT_VERSION = '1.1.0';
/**
 * @classdesc
 * Feature format for reading and writing data in the WFS format.
 * By default, supports WFS version 1.1.0. You can pass a GML format
 * as option to override the default.
 * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.
 *
 * @api
 */ class WFS extends (0, _xmlfeatureJsDefault.default) {
    /**
   * @param {Options} [options] Optional configuration object.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @private
     * @type {string}
     */ this.version_ = options.version ? options.version : DEFAULT_VERSION;
        /**
     * @private
     * @type {Array<string>|string|undefined}
     */ this.featureType_ = options.featureType;
        /**
     * @private
     * @type {Object<string, string>|string|undefined}
     */ this.featureNS_ = options.featureNS;
        /**
     * @private
     * @type {GMLBase}
     */ this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[this.version_]();
        /**
     * @private
     * @type {string}
     */ this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[this.version_];
    }
    /**
   * @return {Array<string>|string|undefined} featureType
   */ getFeatureType() {
        return this.featureType_;
    }
    /**
   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
   */ setFeatureType(featureType) {
        this.featureType_ = featureType;
    }
    /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */ readFeaturesFromNode(node, options) {
        /** @type {import("../xml.js").NodeStackItem} */ const context = {
            node
        };
        Object.assign(context, {
            'featureType': this.featureType_,
            'featureNS': this.featureNS_
        });
        Object.assign(context, this.getReadOptions(node, options ? options : {}));
        const objectStack = [
            context
        ];
        let featuresNS;
        if (this.version_ === '2.0.0') featuresNS = FEATURE_COLLECTION_PARSERS;
        else featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
        let features = (0, _xmlJs.pushParseAndPop)([], featuresNS, node, objectStack, this.gmlFormat_);
        if (!features) features = [];
        return features;
    }
    /**
   * Read transaction response of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {TransactionResponse|undefined} Transaction response.
   * @api
   */ readTransactionResponse(source) {
        if (!source) return undefined;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readTransactionResponseFromDocument(doc);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readTransactionResponseFromDocument(/** @type {Document} */ source);
        return this.readTransactionResponseFromNode(/** @type {Element} */ source);
    }
    /**
   * Read feature collection metadata of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   * @api
   */ readFeatureCollectionMetadata(source) {
        if (!source) return undefined;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readFeatureCollectionMetadataFromDocument(doc);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readFeatureCollectionMetadataFromDocument(/** @type {Document} */ source);
        return this.readFeatureCollectionMetadataFromNode(/** @type {Element} */ source);
    }
    /**
   * @param {Document} doc Document.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */ readFeatureCollectionMetadataFromDocument(doc) {
        for(let n = /** @type {Node} */ doc.firstChild; n; n = n.nextSibling){
            if (n.nodeType == Node.ELEMENT_NODE) return this.readFeatureCollectionMetadataFromNode(/** @type {Element} */ n);
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */ readFeatureCollectionMetadataFromNode(node) {
        const result = {};
        const value = (0, _xsdJs.readNonNegativeIntegerString)(node.getAttribute('numberOfFeatures'));
        result['numberOfFeatures'] = value;
        return (0, _xmlJs.pushParseAndPop)(/** @type {FeatureCollectionMetadata} */ result, FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);
    }
    /**
   * @param {Document} doc Document.
   * @return {TransactionResponse|undefined} Transaction response.
   */ readTransactionResponseFromDocument(doc) {
        for(let n = /** @type {Node} */ doc.firstChild; n; n = n.nextSibling){
            if (n.nodeType == Node.ELEMENT_NODE) return this.readTransactionResponseFromNode(/** @type {Element} */ n);
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @return {TransactionResponse|undefined} Transaction response.
   */ readTransactionResponseFromNode(node) {
        return (0, _xmlJs.pushParseAndPop)(/** @type {TransactionResponse} */ {}, TRANSACTION_RESPONSE_PARSERS, node, []);
    }
    /**
   * Encode format as WFS `GetFeature` and return the Node.
   *
   * @param {WriteGetFeatureOptions} options Options.
   * @return {Node} Result.
   * @api
   */ writeGetFeature(options) {
        const node = (0, _xmlJs.createElementNS)(WFSNS[this.version_], 'GetFeature');
        node.setAttribute('service', 'WFS');
        node.setAttribute('version', this.version_);
        if (options.handle) node.setAttribute('handle', options.handle);
        if (options.outputFormat) node.setAttribute('outputFormat', options.outputFormat);
        if (options.maxFeatures !== undefined) node.setAttribute('maxFeatures', String(options.maxFeatures));
        if (options.resultType) node.setAttribute('resultType', options.resultType);
        if (options.startIndex !== undefined) node.setAttribute('startIndex', String(options.startIndex));
        if (options.count !== undefined) node.setAttribute('count', String(options.count));
        if (options.viewParams !== undefined) node.setAttribute('viewParams', options.viewParams);
        node.setAttributeNS((0, _xmlJs.XML_SCHEMA_INSTANCE_URI), 'xsi:schemaLocation', this.schemaLocation_);
        /** @type {import("../xml.js").NodeStackItem} */ const context = {
            node
        };
        Object.assign(context, {
            'version': this.version_,
            'srsName': options.srsName,
            'featureNS': options.featureNS ? options.featureNS : this.featureNS_,
            'featurePrefix': options.featurePrefix,
            'propertyNames': options.propertyNames ? options.propertyNames : []
        });
        (0, _assertsJs.assert)(Array.isArray(options.featureTypes), '`options.featureTypes` must be an Array');
        if (typeof options.featureTypes[0] === 'string') {
            let filter = options.filter;
            if (options.bbox) {
                (0, _assertsJs.assert)(options.geometryName, '`options.geometryName` must also be provided when `options.bbox` is set');
                filter = this.combineBboxAndFilter(options.geometryName, options.bbox, options.srsName, filter);
            }
            Object.assign(context, {
                'geometryName': options.geometryName,
                'filter': filter
            });
            writeGetFeature(node, /** @type {!Array<string>} */ options.featureTypes, [
                context
            ]);
        } else // Write one query node per element in featuresType.
        options.featureTypes.forEach((/** @type {FeatureType} */ featureType)=>{
            const completeFilter = this.combineBboxAndFilter(featureType.geometryName, featureType.bbox, options.srsName, options.filter);
            Object.assign(context, {
                'geometryName': featureType.geometryName,
                'filter': completeFilter
            });
            writeGetFeature(node, [
                featureType.name
            ], [
                context
            ]);
        });
        return node;
    }
    /**
   * Create a bbox filter and combine it with another optional filter.
   *
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   * @param {import("./filter/Filter.js").default} [filter] Filter condition.
   * @return {import("./filter/Filter.js").default} The filter.
   */ combineBboxAndFilter(geometryName, extent, srsName, filter) {
        const bboxFilter = (0, _filterJs.bbox)(geometryName, extent, srsName);
        if (filter) // if bbox and filter are both set, combine the two into a single filter
        return (0, _filterJs.and)(filter, bboxFilter);
        return bboxFilter;
    }
    /**
   * Encode format as WFS `Transaction` and return the Node.
   *
   * @param {Array<import("../Feature.js").default>} inserts The features to insert.
   * @param {Array<import("../Feature.js").default>} updates The features to update.
   * @param {Array<import("../Feature.js").default>} deletes The features to delete.
   * @param {WriteTransactionOptions} options Write options.
   * @return {Node} Result.
   * @api
   */ writeTransaction(inserts, updates, deletes, options) {
        const objectStack = [];
        const version = options.version ? options.version : this.version_;
        const node = (0, _xmlJs.createElementNS)(WFSNS[version], 'Transaction');
        node.setAttribute('service', 'WFS');
        node.setAttribute('version', version);
        let baseObj;
        /** @type {import("../xml.js").NodeStackItem} */ if (options) {
            baseObj = options.gmlOptions ? options.gmlOptions : {};
            if (options.handle) node.setAttribute('handle', options.handle);
        }
        node.setAttributeNS((0, _xmlJs.XML_SCHEMA_INSTANCE_URI), 'xsi:schemaLocation', SCHEMA_LOCATIONS[version]);
        const request = createTransactionRequest(node, baseObj, version, options);
        if (inserts) serializeTransactionRequest('Insert', inserts, objectStack, request);
        if (updates) serializeTransactionRequest('Update', updates, objectStack, request);
        if (deletes) serializeTransactionRequest('Delete', deletes, objectStack, request);
        if (options.nativeElements) serializeTransactionRequest('Native', options.nativeElements, objectStack, request);
        return node;
    }
    /**
   * @param {Document} doc Document.
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromDocument(doc) {
        for(let n = doc.firstChild; n; n = n.nextSibling){
            if (n.nodeType == Node.ELEMENT_NODE) return this.readProjectionFromNode(/** @type {Element} */ n);
        }
        return null;
    }
    /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromNode(node) {
        if (node.firstElementChild && node.firstElementChild.firstElementChild) {
            node = node.firstElementChild.firstElementChild;
            for(let n = node.firstElementChild; n; n = n.nextElementSibling)if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {
                const objectStack = [
                    {}
                ];
                this.gmlFormat_.readGeometryElement(n, objectStack);
                return (0, _projJs.get)(objectStack.pop().srsName);
            }
        }
        return null;
    }
}
/**
 * @param {Element} node Node.
 * @param {*} baseObj Base object.
 * @param {string} version Version.
 * @param {WriteTransactionOptions} options Options.
 * @return {Object} Request object.
 */ function createTransactionRequest(node, baseObj, version, options) {
    const featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;
    let gmlVersion;
    if (version === '1.0.0') gmlVersion = 2;
    else if (version === '1.1.0') gmlVersion = 3;
    else if (version === '2.0.0') gmlVersion = 3.2;
    const obj = Object.assign({
        node
    }, {
        version,
        'featureNS': options.featureNS,
        'featureType': options.featureType,
        'featurePrefix': featurePrefix,
        'gmlVersion': gmlVersion,
        'hasZ': options.hasZ,
        'srsName': options.srsName
    }, baseObj);
    return obj;
}
/**
 * @param {string} type Request type.
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {Array<*>} objectStack Object stack.
 * @param {Element} request Transaction Request.
 */ function serializeTransactionRequest(type, features, objectStack, request) {
    (0, _xmlJs.pushSerializeAndPop)(request, TRANSACTION_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)(type), features, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Transaction Summary.
 */ function readTransactionSummary(node, objectStack) {
    return (0, _xmlJs.pushParseAndPop)({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ const OGC_FID_PARSERS = {
    'http://www.opengis.net/ogc': {
        'FeatureId': (0, _xmlJs.makeArrayPusher)(function(node, objectStack) {
            return node.getAttribute('fid');
        })
    },
    'http://www.opengis.net/ogc/1.1': {
        'FeatureId': (0, _xmlJs.makeArrayPusher)(function(node, objectStack) {
            return node.getAttribute('fid');
        })
    }
};
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */ function fidParser(node, objectStack) {
    (0, _xmlJs.parseNode)(OGC_FID_PARSERS, node, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ const INSERT_RESULTS_PARSERS = {
    'http://www.opengis.net/wfs': {
        'Feature': fidParser
    },
    'http://www.opengis.net/wfs/2.0': {
        'Feature': fidParser
    }
};
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<string>|undefined} Insert results.
 */ function readInsertResults(node, objectStack) {
    return (0, _xmlJs.pushParseAndPop)([], INSERT_RESULTS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */ function writeFeature(node, feature, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const featureType = context['featureType'];
    const featureNS = context['featureNS'];
    const gmlVersion = context['gmlVersion'];
    const child = (0, _xmlJs.createElementNS)(featureNS, featureType);
    node.appendChild(child);
    if (gmlVersion === 2) (0, _gml2JsDefault.default).prototype.writeFeatureElement(child, feature, objectStack);
    else if (gmlVersion === 3) (0, _gml3JsDefault.default).prototype.writeFeatureElement(child, feature, objectStack);
    else (0, _gml32JsDefault.default).prototype.writeFeatureElement(child, feature, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {number|string} fid Feature identifier.
 * @param {Array<*>} objectStack Node stack.
 */ function writeOgcFidFilter(node, fid, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const version = context['version'];
    const ns = OGCNS[version];
    const filter = (0, _xmlJs.createElementNS)(ns, 'Filter');
    const child = (0, _xmlJs.createElementNS)(ns, 'FeatureId');
    filter.appendChild(child);
    child.setAttribute('fid', /** @type {string} */ fid);
    node.appendChild(filter);
}
/**
 * @param {string|undefined} featurePrefix The prefix of the feature.
 * @param {string} featureType The type of the feature.
 * @return {string} The value of the typeName property.
 */ function getTypeName(featurePrefix, featureType) {
    featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;
    const prefix = featurePrefix + ':';
    // The featureType already contains the prefix.
    if (featureType.startsWith(prefix)) return featureType;
    return prefix + featureType;
}
/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */ function writeDelete(node, feature, objectStack) {
    const context = objectStack[objectStack.length - 1];
    (0, _assertsJs.assert)(feature.getId() !== undefined, 'Features must have an id set');
    const featureType = context['featureType'];
    const featurePrefix = context['featurePrefix'];
    const featureNS = context['featureNS'];
    const typeName = getTypeName(featurePrefix, featureType);
    node.setAttribute('typeName', typeName);
    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
    const fid = feature.getId();
    if (fid !== undefined) writeOgcFidFilter(node, fid, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */ function writeUpdate(node, feature, objectStack) {
    const context = objectStack[objectStack.length - 1];
    (0, _assertsJs.assert)(feature.getId() !== undefined, 'Features must have an id set');
    const version = context['version'];
    const featureType = context['featureType'];
    const featurePrefix = context['featurePrefix'];
    const featureNS = context['featureNS'];
    const typeName = getTypeName(featurePrefix, featureType);
    const geometryName = feature.getGeometryName();
    node.setAttribute('typeName', typeName);
    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
    const fid = feature.getId();
    if (fid !== undefined) {
        const keys = feature.getKeys();
        const values = [];
        for(let i = 0, ii = keys.length; i < ii; i++){
            const value = feature.get(keys[i]);
            if (value !== undefined) {
                let name = keys[i];
                if (value && typeof /** @type {?} */ value.getSimplifiedGeometry === 'function') name = geometryName;
                values.push({
                    name: name,
                    value: value
                });
            }
        }
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ {
            version,
            'gmlVersion': context['gmlVersion'],
            node,
            'hasZ': context['hasZ'],
            'srsName': context['srsName']
        }, TRANSACTION_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)('Property'), values, objectStack);
        writeOgcFidFilter(node, fid, objectStack);
    }
}
/**
 * @param {Node} node Node.
 * @param {Object} pair Property name and value.
 * @param {Array<*>} objectStack Node stack.
 */ function writeProperty(node, pair, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const version = context['version'];
    const ns = WFSNS[version];
    const tagName = version === '2.0.0' ? 'ValueReference' : 'Name';
    const name = (0, _xmlJs.createElementNS)(ns, tagName);
    const gmlVersion = context['gmlVersion'];
    node.appendChild(name);
    (0, _xsdJs.writeStringTextNode)(name, pair.name);
    if (pair.value !== undefined && pair.value !== null) {
        const value = (0, _xmlJs.createElementNS)(ns, 'Value');
        node.appendChild(value);
        if (pair.value && typeof /** @type {?} */ pair.value.getSimplifiedGeometry === 'function') {
            if (gmlVersion === 2) (0, _gml2JsDefault.default).prototype.writeGeometryElement(value, pair.value, objectStack);
            else if (gmlVersion === 3) (0, _gml3JsDefault.default).prototype.writeGeometryElement(value, pair.value, objectStack);
            else (0, _gml32JsDefault.default).prototype.writeGeometryElement(value, pair.value, objectStack);
        } else (0, _xsdJs.writeStringTextNode)(value, pair.value);
    }
}
/**
 * @param {Element} node Node.
 * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.
 * @param {Array<*>} objectStack Node stack.
 */ function writeNative(node, nativeElement, objectStack) {
    if (nativeElement.vendorId) node.setAttribute('vendorId', nativeElement.vendorId);
    if (nativeElement.safeToIgnore !== undefined) node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));
    if (nativeElement.value !== undefined) (0, _xsdJs.writeStringTextNode)(node, nativeElement.value);
}
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ const GETFEATURE_SERIALIZERS = {
    'http://www.opengis.net/wfs': {
        'Query': (0, _xmlJs.makeChildAppender)(writeQuery)
    },
    'http://www.opengis.net/wfs/2.0': {
        'Query': (0, _xmlJs.makeChildAppender)(writeQuery)
    },
    'http://www.opengis.net/ogc': {
        'During': (0, _xmlJs.makeChildAppender)(writeDuringFilter),
        'And': (0, _xmlJs.makeChildAppender)(writeLogicalFilter),
        'Or': (0, _xmlJs.makeChildAppender)(writeLogicalFilter),
        'Not': (0, _xmlJs.makeChildAppender)(writeNotFilter),
        'BBOX': (0, _xmlJs.makeChildAppender)(writeBboxFilter),
        'Contains': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'Intersects': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'Within': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'DWithin': (0, _xmlJs.makeChildAppender)(writeDWithinFilter),
        'PropertyIsEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsNotEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsLessThan': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsLessThanOrEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsGreaterThan': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsGreaterThanOrEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsNull': (0, _xmlJs.makeChildAppender)(writeIsNullFilter),
        'PropertyIsBetween': (0, _xmlJs.makeChildAppender)(writeIsBetweenFilter),
        'PropertyIsLike': (0, _xmlJs.makeChildAppender)(writeIsLikeFilter)
    },
    'http://www.opengis.net/fes/2.0': {
        'During': (0, _xmlJs.makeChildAppender)(writeDuringFilter),
        'And': (0, _xmlJs.makeChildAppender)(writeLogicalFilter),
        'Or': (0, _xmlJs.makeChildAppender)(writeLogicalFilter),
        'Not': (0, _xmlJs.makeChildAppender)(writeNotFilter),
        'BBOX': (0, _xmlJs.makeChildAppender)(writeBboxFilter),
        'Contains': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'Disjoint': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'Intersects': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'ResourceId': (0, _xmlJs.makeChildAppender)(writeResourceIdFilter),
        'Within': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'DWithin': (0, _xmlJs.makeChildAppender)(writeDWithinFilter),
        'PropertyIsEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsNotEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsLessThan': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsLessThanOrEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsGreaterThan': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsGreaterThanOrEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsNull': (0, _xmlJs.makeChildAppender)(writeIsNullFilter),
        'PropertyIsBetween': (0, _xmlJs.makeChildAppender)(writeIsBetweenFilter),
        'PropertyIsLike': (0, _xmlJs.makeChildAppender)(writeIsLikeFilter)
    }
};
/**
 * @param {Element} node Node.
 * @param {string} featureType Feature type.
 * @param {Array<*>} objectStack Node stack.
 */ function writeQuery(node, featureType, objectStack) {
    const context = /** @type {Object} */ objectStack[objectStack.length - 1];
    const version = context['version'];
    const featurePrefix = context['featurePrefix'];
    const featureNS = context['featureNS'];
    const propertyNames = context['propertyNames'];
    const srsName = context['srsName'];
    let typeName;
    // If feature prefix is not defined, we must not use the default prefix.
    if (featurePrefix) typeName = getTypeName(featurePrefix, featureType);
    else typeName = featureType;
    let typeNameAttr;
    if (version === '2.0.0') typeNameAttr = 'typeNames';
    else typeNameAttr = 'typeName';
    node.setAttribute(typeNameAttr, typeName);
    if (srsName) node.setAttribute('srsName', srsName);
    if (featureNS) node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
    const item = /** @type {import("../xml.js").NodeStackItem} */ Object.assign({}, context);
    item.node = node;
    (0, _xmlJs.pushSerializeAndPop)(item, QUERY_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)('PropertyName'), propertyNames, objectStack);
    const filter = context['filter'];
    if (filter) {
        const child = (0, _xmlJs.createElementNS)(getFilterNS(version), 'Filter');
        node.appendChild(child);
        writeFilterCondition(child, filter, objectStack);
    }
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/Filter.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeFilterCondition(node, filter, objectStack) {
    const context = /** @type {Object} */ objectStack[objectStack.length - 1];
    /** @type {import("../xml.js").NodeStackItem} */ const item = {
        node
    };
    Object.assign(item, {
        context
    });
    (0, _xmlJs.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)(filter.getTagName()), [
        filter
    ], objectStack);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/Bbox.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeBboxFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    parent['srsName'] = filter.srsName;
    const format = GML_FORMATS[version];
    writePropertyName(version, node, filter.geometryName);
    format.prototype.writeGeometryElement(node, filter.extent, objectStack);
}
/**
 * @param {Element} node Element.
 * @param {import("./filter/ResourceId.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeResourceIdFilter(node, filter, objectStack) {
    node.setAttribute('rid', /** @type {string} */ filter.rid);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/Spatial.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeSpatialFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    parent['srsName'] = filter.srsName;
    const format = GML_FORMATS[version];
    writePropertyName(version, node, filter.geometryName);
    format.prototype.writeGeometryElement(node, filter.geometry, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/DWithin.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeDWithinFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    writeSpatialFilter(node, filter, objectStack);
    const distance = (0, _xmlJs.createElementNS)(getFilterNS(version), 'Distance');
    (0, _xsdJs.writeStringTextNode)(distance, filter.distance.toString());
    if (version === '2.0.0') distance.setAttribute('uom', filter.unit);
    else distance.setAttribute('units', filter.unit);
    node.appendChild(distance);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/During.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeDuringFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    writeExpression(FESNS[version], 'ValueReference', node, filter.propertyName);
    const timePeriod = (0, _xmlJs.createElementNS)((0, _gmlbaseJs.GMLNS), 'TimePeriod');
    node.appendChild(timePeriod);
    const begin = (0, _xmlJs.createElementNS)((0, _gmlbaseJs.GMLNS), 'begin');
    timePeriod.appendChild(begin);
    writeTimeInstant(begin, filter.begin);
    const end = (0, _xmlJs.createElementNS)((0, _gmlbaseJs.GMLNS), 'end');
    timePeriod.appendChild(end);
    writeTimeInstant(end, filter.end);
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/LogicalNary.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeLogicalFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    /** @type {import("../xml.js").NodeStackItem} */ const item = {
        node
    };
    Object.assign(item, {
        context
    });
    const conditions = filter.conditions;
    for(let i = 0, ii = conditions.length; i < ii; ++i){
        const condition = conditions[i];
        (0, _xmlJs.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)(condition.getTagName()), [
            condition
        ], objectStack);
    }
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/Not.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeNotFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    /** @type {import("../xml.js").NodeStackItem} */ const item = {
        node
    };
    Object.assign(item, {
        context
    });
    const condition = filter.condition;
    (0, _xmlJs.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)(condition.getTagName()), [
        condition
    ], objectStack);
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/ComparisonBinary.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeComparisonFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    if (filter.matchCase !== undefined) node.setAttribute('matchCase', filter.matchCase.toString());
    writePropertyName(version, node, filter.propertyName);
    writeLiteral(version, node, '' + filter.expression);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/IsNull.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeIsNullFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    writePropertyName(version, node, filter.propertyName);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/IsBetween.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeIsBetweenFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    const ns = getFilterNS(version);
    writePropertyName(version, node, filter.propertyName);
    const lowerBoundary = (0, _xmlJs.createElementNS)(ns, 'LowerBoundary');
    node.appendChild(lowerBoundary);
    writeLiteral(version, lowerBoundary, '' + filter.lowerBoundary);
    const upperBoundary = (0, _xmlJs.createElementNS)(ns, 'UpperBoundary');
    node.appendChild(upperBoundary);
    writeLiteral(version, upperBoundary, '' + filter.upperBoundary);
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/IsLike.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeIsLikeFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    node.setAttribute('wildCard', filter.wildCard);
    node.setAttribute('singleChar', filter.singleChar);
    node.setAttribute('escapeChar', filter.escapeChar);
    if (filter.matchCase !== undefined) node.setAttribute('matchCase', filter.matchCase.toString());
    writePropertyName(version, node, filter.propertyName);
    writeLiteral(version, node, '' + filter.pattern);
}
/**
 * @param {string} ns Namespace.
 * @param {string} tagName Tag name.
 * @param {Node} node Node.
 * @param {string} value Value.
 */ function writeExpression(ns, tagName, node, value) {
    const property = (0, _xmlJs.createElementNS)(ns, tagName);
    (0, _xsdJs.writeStringTextNode)(property, value);
    node.appendChild(property);
}
/**
 * @param {string} version Version.
 * @param {Node} node Node.
 * @param {string} value PropertyName value.
 */ function writeLiteral(version, node, value) {
    writeExpression(getFilterNS(version), 'Literal', node, value);
}
/**
 * @param {string} version Version.
 * @param {Node} node Node.
 * @param {string} value PropertyName value.
 */ function writePropertyName(version, node, value) {
    if (version === '2.0.0') writeExpression(FESNS[version], 'ValueReference', node, value);
    else writeExpression(OGCNS[version], 'PropertyName', node, value);
}
/**
 * @param {Node} node Node.
 * @param {string} time PropertyName value.
 */ function writeTimeInstant(node, time) {
    const timeInstant = (0, _xmlJs.createElementNS)((0, _gmlbaseJs.GMLNS), 'TimeInstant');
    node.appendChild(timeInstant);
    const timePosition = (0, _xmlJs.createElementNS)((0, _gmlbaseJs.GMLNS), 'timePosition');
    timeInstant.appendChild(timePosition);
    (0, _xsdJs.writeStringTextNode)(timePosition, time);
}
function writeFilter(filter, version) {
    version = version || '1.1.0';
    const child = (0, _xmlJs.createElementNS)(getFilterNS(version), 'Filter');
    const context = {
        node: child
    };
    Object.assign(context, {
        'version': version,
        'filter': filter
    });
    writeFilterCondition(child, filter, [
        context
    ]);
    return child;
}
/**
 * @param {Element} node Node.
 * @param {Array<string>} featureTypes Feature types.
 * @param {Array<*>} objectStack Node stack.
 */ function writeGetFeature(node, featureTypes, objectStack) {
    const context = /** @type {Object} */ objectStack[objectStack.length - 1];
    const item = /** @type {import("../xml.js").NodeStackItem} */ Object.assign({}, context);
    item.node = node;
    (0, _xmlJs.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)('Query'), featureTypes, objectStack);
}
function getFilterNS(version) {
    let ns;
    if (version === '2.0.0') ns = FESNS[version];
    else ns = OGCNS[version];
    return ns;
}
exports.default = WFS;

},{"./GML2.js":"uhKU3","./GML3.js":"41qzB","./GML32.js":"ggVYi","./GMLBase.js":"3Cnic","./XMLFeature.js":"gcNa4","../xml.js":"4rPIo","./filter.js":"gYXv7","../asserts.js":"k0OL6","../proj.js":"8OK47","./xsd.js":"cKLNr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"uhKU3":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/GML2
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _gmlbaseJs = require("./GMLBase.js");
var _gmlbaseJsDefault = parcelHelpers.interopDefault(_gmlbaseJs);
var _xmlJs = require("../xml.js");
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _featureJs = require("./Feature.js");
var _xsdJs = require("./xsd.js");
/**
 * @const
 * @type {string}
 */ const schemaLocation = (0, _gmlbaseJs.GMLNS) + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';
/**
 * @const
 * @type {Object<string, string>}
 */ const MULTIGEOMETRY_TO_MEMBER_NODENAME = {
    'MultiLineString': 'lineStringMember',
    'MultiCurve': 'curveMember',
    'MultiPolygon': 'polygonMember',
    'MultiSurface': 'surfaceMember'
};
/**
 * @classdesc
 * Feature format for reading and writing data in the GML format,
 * version 2.1.2.
 *
 * @api
 */ class GML2 extends (0, _gmlbaseJsDefault.default) {
    /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */ constructor(options){
        options = options ? options : {};
        super(options);
        this.FEATURE_COLLECTION_PARSERS[0, _gmlbaseJs.GMLNS]['featureMember'] = (0, _xmlJs.makeArrayPusher)(this.readFeaturesInternal);
        /**
     * @type {string}
     */ this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
    }
    /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */ readFlatCoordinates(node, objectStack) {
        const s = (0, _xmlJs.getAllTextContent)(node, false).replace(/^\s*|\s*$/g, '');
        const context = /** @type {import("../xml.js").NodeStackItem} */ objectStack[0];
        const containerSrs = context['srsName'];
        let axisOrientation = 'enu';
        if (containerSrs) {
            const proj = (0, _projJs.get)(containerSrs);
            if (proj) axisOrientation = proj.getAxisOrientation();
        }
        const coordsGroups = s.trim().split(/\s+/);
        const flatCoordinates = [];
        for(let i = 0, ii = coordsGroups.length; i < ii; i++){
            const coords = coordsGroups[i].split(/,+/);
            const x = parseFloat(coords[0]);
            const y = parseFloat(coords[1]);
            const z = coords.length === 3 ? parseFloat(coords[2]) : 0;
            if (axisOrientation.substr(0, 2) === 'en') flatCoordinates.push(x, y, z);
            else flatCoordinates.push(y, x, z);
        }
        return flatCoordinates;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */ readBox(node, objectStack) {
        /** @type {Array<number>} */ const flatCoordinates = (0, _xmlJs.pushParseAndPop)([
            null
        ], this.BOX_PARSERS_, node, objectStack, this);
        return (0, _extentJs.createOrUpdate)(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ innerBoundaryIsParser(node, objectStack) {
        /** @type {Array<number>|undefined} */ const flatLinearRing = (0, _xmlJs.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */ objectStack[objectStack.length - 1];
            flatLinearRings.push(flatLinearRing);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ outerBoundaryIsParser(node, objectStack) {
        /** @type {Array<number>|undefined} */ const flatLinearRing = (0, _xmlJs.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */ objectStack[objectStack.length - 1];
            flatLinearRings[0] = flatLinearRing;
        }
    }
    /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */ GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {
        const context = objectStack[objectStack.length - 1];
        const multiSurface = context['multiSurface'];
        const surface = context['surface'];
        const multiCurve = context['multiCurve'];
        if (!Array.isArray(value)) {
            nodeName = /** @type {import("../geom/Geometry.js").default} */ value.getType();
            if (nodeName === 'MultiPolygon' && multiSurface === true) nodeName = 'MultiSurface';
            else if (nodeName === 'Polygon' && surface === true) nodeName = 'Surface';
            else if (nodeName === 'MultiLineString' && multiCurve === true) nodeName = 'MultiCurve';
        } else nodeName = 'Envelope';
        return (0, _xmlJs.createElementNS)('http://www.opengis.net/gml', nodeName);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */ writeFeatureElement(node, feature, objectStack) {
        const fid = feature.getId();
        if (fid) node.setAttribute('fid', /** @type {string} */ fid);
        const context = /** @type {Object} */ objectStack[objectStack.length - 1];
        const featureNS = context['featureNS'];
        const geometryName = feature.getGeometryName();
        if (!context.serializers) {
            context.serializers = {};
            context.serializers[featureNS] = {};
        }
        const keys = [];
        const values = [];
        if (feature.hasProperties()) {
            const properties = feature.getProperties();
            for(const key in properties){
                const value = properties[key];
                if (value !== null) {
                    keys.push(key);
                    values.push(value);
                    if (key == geometryName || typeof /** @type {?} */ value.getSimplifiedGeometry === 'function') {
                        if (!(key in context.serializers[featureNS])) context.serializers[featureNS][key] = (0, _xmlJs.makeChildAppender)(this.writeGeometryElement, this);
                    } else if (!(key in context.serializers[featureNS])) context.serializers[featureNS][key] = (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode));
                }
            }
        }
        const item = Object.assign({}, context);
        item.node = node;
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ item, context.serializers, (0, _xmlJs.makeSimpleNodeFactory)(undefined, featureNS), values, objectStack, keys);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeCurveOrLineString(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (node.nodeName !== 'LineStringSegment' && srsName) node.setAttribute('srsName', srsName);
        if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {
            const coordinates = this.createCoordinatesNode_(node.namespaceURI);
            node.appendChild(coordinates);
            this.writeCoordinates_(coordinates, geometry, objectStack);
        } else if (node.nodeName === 'Curve') {
            const segments = (0, _xmlJs.createElementNS)(node.namespaceURI, 'segments');
            node.appendChild(segments);
            this.writeCurveSegments_(segments, geometry, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeLineStringOrCurveMember(node, line, objectStack) {
        const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
        if (child) {
            node.appendChild(child);
            this.writeCurveOrLineString(child, line, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiCurveOrLineString(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        const curve = context['curve'];
        if (srsName) node.setAttribute('srsName', srsName);
        const lines = geometry.getLineStrings();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName,
            curve: curve
        }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);
    }
    /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeGeometryElement(node, geometry, objectStack) {
        const context = /** @type {import("./Feature.js").WriteOptions} */ objectStack[objectStack.length - 1];
        const item = Object.assign({}, context);
        item['node'] = node;
        let value;
        if (Array.isArray(geometry)) value = (0, _featureJs.transformExtentWithOptions)(/** @type {import("../extent.js").Extent} */ geometry, context);
        else value = (0, _featureJs.transformGeometryWithOptions)(/** @type {import("../geom/Geometry.js").default} */ geometry, true, context);
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [
            value
        ], objectStack, undefined, this);
    }
    /**
   * @param {string} namespaceURI XML namespace.
   * @return {Element} coordinates node.
   * @private
   */ createCoordinatesNode_(namespaceURI) {
        const coordinates = (0, _xmlJs.createElementNS)(namespaceURI, 'coordinates');
        coordinates.setAttribute('decimal', '.');
        coordinates.setAttribute('cs', ',');
        coordinates.setAttribute('ts', ' ');
        return coordinates;
    }
    /**
   * @param {Node} node Node.
   * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeCoordinates_(node, value, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        // only 2d for simple features profile
        const points = value.getCoordinates();
        const len = points.length;
        const parts = new Array(len);
        for(let i = 0; i < len; ++i){
            const point = points[i];
            parts[i] = this.getCoords_(point, srsName, hasZ);
        }
        (0, _xsdJs.writeStringTextNode)(node, parts.join(' '));
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeCurveSegments_(node, line, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'LineStringSegment');
        node.appendChild(child);
        this.writeCurveOrLineString(child, line, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeSurfaceOrPolygon(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        if (node.nodeName !== 'PolygonPatch' && srsName) node.setAttribute('srsName', srsName);
        if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {
            const rings = geometry.getLinearRings();
            (0, _xmlJs.pushSerializeAndPop)({
                node: node,
                hasZ: hasZ,
                srsName: srsName
            }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);
        } else if (node.nodeName === 'Surface') {
            const patches = (0, _xmlJs.createElementNS)(node.namespaceURI, 'patches');
            node.appendChild(patches);
            this.writeSurfacePatches_(patches, geometry, objectStack);
        }
    }
    /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */ RING_NODE_FACTORY_(value, objectStack, nodeName) {
        const context = objectStack[objectStack.length - 1];
        const parentNode = context.node;
        const exteriorWritten = context['exteriorWritten'];
        if (exteriorWritten === undefined) context['exteriorWritten'] = true;
        return (0, _xmlJs.createElementNS)(parentNode.namespaceURI, exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs');
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeSurfacePatches_(node, polygon, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'PolygonPatch');
        node.appendChild(child);
        this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeRing(node, ring, objectStack) {
        const linearRing = (0, _xmlJs.createElementNS)(node.namespaceURI, 'LinearRing');
        node.appendChild(linearRing);
        this.writeLinearRing(linearRing, ring, objectStack);
    }
    /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */ getCoords_(point, srsName, hasZ) {
        let axisOrientation = 'enu';
        if (srsName) axisOrientation = (0, _projJs.get)(srsName).getAxisOrientation();
        let coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ',' + point[1] : point[1] + ',' + point[0];
        if (hasZ) {
            // For newly created points, Z can be undefined.
            const z = point[2] || 0;
            coords += ',' + z;
        }
        return coords;
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writePoint(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const coordinates = this.createCoordinatesNode_(node.namespaceURI);
        node.appendChild(coordinates);
        const point = geometry.getCoordinates();
        const coord = this.getCoords_(point, srsName, hasZ);
        (0, _xsdJs.writeStringTextNode)(coordinates, coord);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiPoint(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const points = geometry.getPoints();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName
        }, this.POINTMEMBER_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)('pointMember'), points, objectStack, undefined, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writePointMember(node, point, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'Point');
        node.appendChild(child);
        this.writePoint(child, point, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeLinearRing(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const coordinates = this.createCoordinatesNode_(node.namespaceURI);
        node.appendChild(coordinates);
        this.writeCoordinates_(coordinates, geometry, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiSurfaceOrPolygon(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        const surface = context['surface'];
        if (srsName) node.setAttribute('srsName', srsName);
        const polygons = geometry.getPolygons();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName,
            surface: surface
        }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);
    }
    /**
   * @param {Node} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeSurfaceOrPolygonMember(node, polygon, objectStack) {
        const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
        if (child) {
            node.appendChild(child);
            this.writeSurfaceOrPolygon(child, polygon, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */ writeEnvelope(node, extent, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const keys = [
            'lowerCorner',
            'upperCorner'
        ];
        const values = [
            extent[0] + ' ' + extent[1],
            extent[2] + ' ' + extent[3]
        ];
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ {
            node: node
        }, this.ENVELOPE_SERIALIZERS, (0, _xmlJs.OBJECT_PROPERTY_NODE_FACTORY), values, objectStack, keys, this);
    }
    /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */ MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {
        const parentNode = objectStack[objectStack.length - 1].node;
        return (0, _xmlJs.createElementNS)('http://www.opengis.net/gml', MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    'http://www.opengis.net/gml': {
        'coordinates': (0, _xmlJs.makeReplacer)(GML2.prototype.readFlatCoordinates)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    'http://www.opengis.net/gml': {
        'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,
        'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML2.prototype.BOX_PARSERS_ = {
    'http://www.opengis.net/gml': {
        'coordinates': (0, _xmlJs.makeArrayPusher)(GML2.prototype.readFlatCoordinates)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML2.prototype.GEOMETRY_PARSERS = {
    'http://www.opengis.net/gml': {
        'Point': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPoint),
        'MultiPoint': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPoint),
        'LineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLineString),
        'MultiLineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiLineString),
        'LinearRing': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLinearRing),
        'Polygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPolygon),
        'MultiPolygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPolygon),
        'Box': (0, _xmlJs.makeReplacer)(GML2.prototype.readBox)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.GEOMETRY_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'Curve': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeCurveOrLineString),
        'MultiCurve': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeMultiCurveOrLineString),
        'Point': (0, _xmlJs.makeChildAppender)(GML2.prototype.writePoint),
        'MultiPoint': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeMultiPoint),
        'LineString': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeCurveOrLineString),
        'MultiLineString': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeMultiCurveOrLineString),
        'LinearRing': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeLinearRing),
        'Polygon': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygon),
        'MultiPolygon': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeMultiSurfaceOrPolygon),
        'Surface': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygon),
        'MultiSurface': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeMultiSurfaceOrPolygon),
        'Envelope': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeEnvelope)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'lineStringMember': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeLineStringOrCurveMember),
        'curveMember': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeLineStringOrCurveMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.RING_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'outerBoundaryIs': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeRing),
        'innerBoundaryIs': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeRing)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.POINTMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'pointMember': (0, _xmlJs.makeChildAppender)(GML2.prototype.writePointMember)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'surfaceMember': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygonMember),
        'polygonMember': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygonMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.ENVELOPE_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'lowerCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode)),
        'upperCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode))
    }
};
exports.default = GML2;

},{"./GMLBase.js":"3Cnic","../xml.js":"4rPIo","../extent.js":"bGUel","../proj.js":"8OK47","./Feature.js":"arwL9","./xsd.js":"cKLNr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Cnic":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/GMLBase
 */ // FIXME Envelopes should not be treated as geometries! readEnvelope_ is part
// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect
// envelopes/extents, only geometries!
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GMLNS", ()=>GMLNS);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geometryJs = require("../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _linearRingJs = require("../geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPointJs = require("../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _xmlfeatureJs = require("./XMLFeature.js");
var _xmlfeatureJsDefault = parcelHelpers.interopDefault(_xmlfeatureJs);
var _arrayJs = require("../array.js");
var _xmlJs = require("../xml.js");
var _projJs = require("../proj.js");
var _featureJs1 = require("./Feature.js");
const GMLNS = 'http://www.opengis.net/gml';
/**
 * A regular expression that matches if a string only contains whitespace
 * characters. It will e.g. match `''`, `' '`, `'\n'` etc.
 *
 * @const
 * @type {RegExp}
 */ const ONLY_WHITESPACE_RE = /^\s*$/;
/**
 * @typedef {Object} Options
 * @property {Object<string, string>|string} [featureNS] Feature
 * namespace. If not defined will be derived from GML. If multiple
 * feature types have been configured which come from different feature
 * namespaces, this will be an object with the keys being the prefixes used
 * in the entries of featureType array. The values of the object will be the
 * feature namespaces themselves. So for instance there might be a featureType
 * item `topp:states` in the `featureType` array and then there will be a key
 * `topp` in the featureNS object with value `http://www.openplans.org/topp`.
 * @property {Array<string>|string} [featureType] Feature type(s) to parse.
 * If multiple feature types need to be configured
 * which come from different feature namespaces, `featureNS` will be an object
 * with the keys being the prefixes used in the entries of featureType array.
 * The values of the object will be the feature namespaces themselves.
 * So for instance there might be a featureType item `topp:states` and then
 * there will be a key named `topp` in the featureNS object with value
 * `http://www.openplans.org/topp`.
 * @property {string} [srsName] srsName to use when writing geometries.
 * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon
 * elements. This also affects the elements in multi-part geometries.
 * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString
 * elements. This also affects the elements in multi-part geometries.
 * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.
 * Since the latter is deprecated in GML 3.
 * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of
 * gml:MultiPolygon. Since the latter is deprecated in GML 3.
 * @property {string} [schemaLocation] Optional schemaLocation to use when
 * writing out the GML, this will override the default provided.
 * @property {boolean} [hasZ=false] If coordinates have a Z value.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Feature base format for reading and writing data in the GML format.
 * This class cannot be instantiated, it contains only base content that
 * is shared with versioned format classes GML2 and GML3.
 *
 * @abstract
 * @api
 */ class GMLBase extends (0, _xmlfeatureJsDefault.default) {
    /**
   * @param {Options} [options] Optional configuration object.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @protected
     * @type {Array<string>|string|undefined}
     */ this.featureType = options.featureType;
        /**
     * @protected
     * @type {Object<string, string>|string|undefined}
     */ this.featureNS = options.featureNS;
        /**
     * @protected
     * @type {string|undefined}
     */ this.srsName = options.srsName;
        /**
     * @protected
     * @type {string}
     */ this.schemaLocation = '';
        /**
     * @type {Object<string, Object<string, Object>>}
     */ this.FEATURE_COLLECTION_PARSERS = {};
        this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
            'featureMember': (0, _xmlJs.makeArrayPusher)(this.readFeaturesInternal),
            'featureMembers': (0, _xmlJs.makeReplacer)(this.readFeaturesInternal)
        };
        this.supportedMediaTypes = [
            'application/gml+xml'
        ];
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<Feature> | undefined} Features.
   */ readFeaturesInternal(node, objectStack) {
        const localName = node.localName;
        let features = null;
        if (localName == 'FeatureCollection') features = (0, _xmlJs.pushParseAndPop)([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);
        else if (localName == 'featureMembers' || localName == 'featureMember' || localName == 'member') {
            const context = objectStack[0];
            let featureType = context['featureType'];
            let featureNS = context['featureNS'];
            const prefix = 'p';
            const defaultPrefix = 'p0';
            if (!featureType && node.childNodes) {
                featureType = [], featureNS = {};
                for(let i = 0, ii = node.childNodes.length; i < ii; ++i){
                    const child = /** @type {Element} */ node.childNodes[i];
                    if (child.nodeType === 1) {
                        const ft = child.nodeName.split(':').pop();
                        if (!featureType.includes(ft)) {
                            let key = '';
                            let count = 0;
                            const uri = child.namespaceURI;
                            for(const candidate in featureNS){
                                if (featureNS[candidate] === uri) {
                                    key = candidate;
                                    break;
                                }
                                ++count;
                            }
                            if (!key) {
                                key = prefix + count;
                                featureNS[key] = uri;
                            }
                            featureType.push(key + ':' + ft);
                        }
                    }
                }
                if (localName != 'featureMember') {
                    // recheck featureType for each featureMember
                    context['featureType'] = featureType;
                    context['featureNS'] = featureNS;
                }
            }
            if (typeof featureNS === 'string') {
                const ns = featureNS;
                featureNS = {};
                featureNS[defaultPrefix] = ns;
            }
            /** @type {Object<string, Object<string, import("../xml.js").Parser>>} */ const parsersNS = {};
            const featureTypes = Array.isArray(featureType) ? featureType : [
                featureType
            ];
            for(const p in featureNS){
                /** @type {Object<string, import("../xml.js").Parser>} */ const parsers = {};
                for(let i = 0, ii = featureTypes.length; i < ii; ++i){
                    const featurePrefix = featureTypes[i].includes(':') ? featureTypes[i].split(':')[0] : defaultPrefix;
                    if (featurePrefix === p) parsers[featureTypes[i].split(':').pop()] = localName == 'featureMembers' ? (0, _xmlJs.makeArrayPusher)(this.readFeatureElement, this) : (0, _xmlJs.makeReplacer)(this.readFeatureElement, this);
                }
                parsersNS[featureNS[p]] = parsers;
            }
            if (localName == 'featureMember' || localName == 'member') features = (0, _xmlJs.pushParseAndPop)(undefined, parsersNS, node, objectStack);
            else features = (0, _xmlJs.pushParseAndPop)([], parsersNS, node, objectStack);
        }
        if (features === null) features = [];
        return features;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
   */ readGeometryOrExtent(node, objectStack) {
        const context = /** @type {Object} */ objectStack[0];
        context['srsName'] = node.firstElementChild.getAttribute('srsName');
        context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');
        return (0, _xmlJs.pushParseAndPop)(null, this.GEOMETRY_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Geometry.
   */ readExtentElement(node, objectStack) {
        const context = /** @type {Object} */ objectStack[0];
        const extent = /** @type {import("../extent.js").Extent} */ this.readGeometryOrExtent(node, objectStack);
        return extent ? (0, _featureJs1.transformExtentWithOptions)(extent, context) : undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|undefined} Geometry.
   */ readGeometryElement(node, objectStack) {
        const context = /** @type {Object} */ objectStack[0];
        const geometry = /** @type {import("../geom/Geometry.js").default} */ this.readGeometryOrExtent(node, objectStack);
        return geometry ? (0, _featureJs1.transformGeometryWithOptions)(geometry, false, context) : undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {boolean} asFeature whether result should be wrapped as a feature.
   * @return {Feature|Object} Feature
   */ readFeatureElementInternal(node, objectStack, asFeature) {
        let geometryName;
        const values = {};
        for(let n = node.firstElementChild; n; n = n.nextElementSibling){
            let value;
            const localName = n.localName;
            // first, check if it is simple attribute
            if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {
                value = (0, _xmlJs.getAllTextContent)(n, false);
                if (ONLY_WHITESPACE_RE.test(value)) value = undefined;
            } else {
                if (asFeature) //if feature, try it as a geometry or extent
                value = localName === 'boundedBy' ? this.readExtentElement(n, objectStack) : this.readGeometryElement(n, objectStack);
                if (!value) //if not a geometry or not a feature, treat it as a complex attribute
                value = this.readFeatureElementInternal(n, objectStack, false);
                else if (localName !== 'boundedBy') // boundedBy is an extent and must not be considered as a geometry
                geometryName = localName;
            }
            const len = n.attributes.length;
            if (len > 0 && !(value instanceof (0, _geometryJsDefault.default))) {
                value = {
                    _content_: value
                };
                for(let i = 0; i < len; i++){
                    const attName = n.attributes[i].name;
                    value[attName] = n.attributes[i].value;
                }
            }
            if (values[localName]) {
                if (!(values[localName] instanceof Array)) values[localName] = [
                    values[localName]
                ];
                values[localName].push(value);
            } else values[localName] = value;
        }
        if (!asFeature) return values;
        const feature = new (0, _featureJsDefault.default)(values);
        if (geometryName) feature.setGeometryName(geometryName);
        const fid = node.getAttribute('fid') || (0, _xmlJs.getAttributeNS)(node, this.namespace, 'id');
        if (fid) feature.setId(fid);
        return feature;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Feature} Feature.
   */ readFeatureElement(node, objectStack) {
        return this.readFeatureElementInternal(node, objectStack, true);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Point|undefined} Point.
   */ readPoint(node, objectStack) {
        const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) return new (0, _pointJsDefault.default)(flatCoordinates, 'XYZ');
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPoint|undefined} MultiPoint.
   */ readMultiPoint(node, objectStack) {
        /** @type {Array<Array<number>>} */ const coordinates = (0, _xmlJs.pushParseAndPop)([], this.MULTIPOINT_PARSERS, node, objectStack, this);
        if (coordinates) return new (0, _multiPointJsDefault.default)(coordinates);
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */ readMultiLineString(node, objectStack) {
        /** @type {Array<LineString>} */ const lineStrings = (0, _xmlJs.pushParseAndPop)([], this.MULTILINESTRING_PARSERS, node, objectStack, this);
        if (lineStrings) return new (0, _multiLineStringJsDefault.default)(lineStrings);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */ readMultiPolygon(node, objectStack) {
        /** @type {Array<Polygon>} */ const polygons = (0, _xmlJs.pushParseAndPop)([], this.MULTIPOLYGON_PARSERS, node, objectStack, this);
        if (polygons) return new (0, _multiPolygonJsDefault.default)(polygons);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ pointMemberParser(node, objectStack) {
        (0, _xmlJs.parseNode)(this.POINTMEMBER_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ lineStringMemberParser(node, objectStack) {
        (0, _xmlJs.parseNode)(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ polygonMemberParser(node, objectStack) {
        (0, _xmlJs.parseNode)(this.POLYGONMEMBER_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */ readLineString(node, objectStack) {
        const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) {
            const lineString = new (0, _lineStringJsDefault.default)(flatCoordinates, 'XYZ');
            return lineString;
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} LinearRing flat coordinates.
   */ readFlatLinearRing(node, objectStack) {
        const ring = (0, _xmlJs.pushParseAndPop)(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
        if (ring) return ring;
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LinearRing|undefined} LinearRing.
   */ readLinearRing(node, objectStack) {
        const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) return new (0, _linearRingJsDefault.default)(flatCoordinates, 'XYZ');
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */ readPolygon(node, objectStack) {
        /** @type {Array<Array<number>>} */ const flatLinearRings = (0, _xmlJs.pushParseAndPop)([
            null
        ], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
        if (flatLinearRings && flatLinearRings[0]) {
            const flatCoordinates = flatLinearRings[0];
            const ends = [
                flatCoordinates.length
            ];
            let i, ii;
            for(i = 1, ii = flatLinearRings.length; i < ii; ++i){
                (0, _arrayJs.extend)(flatCoordinates, flatLinearRings[i]);
                ends.push(flatCoordinates.length);
            }
            return new (0, _polygonJsDefault.default)(flatCoordinates, 'XYZ', ends);
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>} Flat coordinates.
   */ readFlatCoordinatesFromNode(node, objectStack) {
        return (0, _xmlJs.pushParseAndPop)(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromNode(node, options) {
        const geometry = this.readGeometryElement(node, [
            this.getReadOptions(node, options ? options : {})
        ]);
        return geometry ? geometry : null;
    }
    /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */ readFeaturesFromNode(node, options) {
        const internalOptions = {
            featureType: this.featureType,
            featureNS: this.featureNS
        };
        if (internalOptions) Object.assign(internalOptions, this.getReadOptions(node, options));
        const features = this.readFeaturesInternal(node, [
            internalOptions
        ]);
        return features || [];
    }
    /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromNode(node) {
        return (0, _projJs.get)(this.srsName ? this.srsName : node.firstElementChild.getAttribute('srsName'));
    }
}
GMLBase.prototype.namespace = GMLNS;
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    'http://www.opengis.net/gml': {}
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    'http://www.opengis.net/gml': {}
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.GEOMETRY_PARSERS = {
    'http://www.opengis.net/gml': {}
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.MULTIPOINT_PARSERS = {
    'http://www.opengis.net/gml': {
        'pointMember': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.pointMemberParser),
        'pointMembers': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.pointMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.MULTILINESTRING_PARSERS = {
    'http://www.opengis.net/gml': {
        'lineStringMember': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.lineStringMemberParser),
        'lineStringMembers': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.lineStringMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.MULTIPOLYGON_PARSERS = {
    'http://www.opengis.net/gml': {
        'polygonMember': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.polygonMemberParser),
        'polygonMembers': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.polygonMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.POINTMEMBER_PARSERS = {
    'http://www.opengis.net/gml': {
        'Point': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.readFlatCoordinatesFromNode)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.LINESTRINGMEMBER_PARSERS = {
    'http://www.opengis.net/gml': {
        'LineString': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.readLineString)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.POLYGONMEMBER_PARSERS = {
    'http://www.opengis.net/gml': {
        'Polygon': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.readPolygon)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.RING_PARSERS = {
    'http://www.opengis.net/gml': {
        'LinearRing': (0, _xmlJs.makeReplacer)(GMLBase.prototype.readFlatLinearRing)
    }
};
exports.default = GMLBase;

},{"../Feature.js":"3qocF","../geom/Geometry.js":"6K9DH","../geom/LineString.js":"gknRz","../geom/LinearRing.js":"gT85H","../geom/MultiLineString.js":"4FjXg","../geom/MultiPoint.js":"gXgmP","../geom/MultiPolygon.js":"b4GDd","../geom/Point.js":"6SybV","../geom/Polygon.js":"8Vwps","./XMLFeature.js":"gcNa4","../array.js":"hyet5","../xml.js":"4rPIo","../proj.js":"8OK47","./Feature.js":"arwL9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gcNa4":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/XMLFeature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _featureJs = require("../format/Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _utilJs = require("../util.js");
var _arrayJs = require("../array.js");
var _xmlJs = require("../xml.js");
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for XML feature formats.
 *
 * @abstract
 */ class XMLFeature extends (0, _featureJsDefault.default) {
    constructor(){
        super();
        /**
     * @type {XMLSerializer}
     * @private
     */ this.xmlSerializer_ = (0, _xmlJs.getXMLSerializer)();
    }
    /**
   * @return {import("./Feature.js").Type} Format.
   */ getType() {
        return 'xml';
    }
    /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */ readFeature(source, options) {
        if (!source) return null;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readFeatureFromDocument(doc, options);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readFeatureFromDocument(/** @type {Document} */ source, options);
        return this.readFeatureFromNode(/** @type {Element} */ source, options);
    }
    /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */ readFeatureFromDocument(doc, options) {
        const features = this.readFeaturesFromDocument(doc, options);
        if (features.length > 0) return features[0];
        return null;
    }
    /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */ readFeatureFromNode(node, options) {
        return null; // not implemented
    }
    /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */ readFeatures(source, options) {
        if (!source) return [];
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readFeaturesFromDocument(doc, options);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readFeaturesFromDocument(/** @type {Document} */ source, options);
        return this.readFeaturesFromNode(/** @type {Element} */ source, options);
    }
    /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */ readFeaturesFromDocument(doc, options) {
        /** @type {Array<import("../Feature.js").default>} */ const features = [];
        for(let n = doc.firstChild; n; n = n.nextSibling)if (n.nodeType == Node.ELEMENT_NODE) (0, _arrayJs.extend)(features, this.readFeaturesFromNode(/** @type {Element} */ n, options));
        return features;
    }
    /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */ readFeaturesFromNode(node, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometry(source, options) {
        if (!source) return null;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readGeometryFromDocument(doc, options);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readGeometryFromDocument(/** @type {Document} */ source, options);
        return this.readGeometryFromNode(/** @type {Element} */ source, options);
    }
    /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromDocument(doc, options) {
        return null; // not implemented
    }
    /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromNode(node, options) {
        return null; // not implemented
    }
    /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */ readProjection(source) {
        if (!source) return null;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readProjectionFromDocument(doc);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readProjectionFromDocument(/** @type {Document} */ source);
        return this.readProjectionFromNode(/** @type {Element} */ source);
    }
    /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromDocument(doc) {
        return this.dataProjection;
    }
    /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromNode(node) {
        return this.dataProjection;
    }
    /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   */ writeFeature(feature, options) {
        const node = this.writeFeatureNode(feature, options);
        return this.xmlSerializer_.serializeToString(node);
    }
    /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */ writeFeatureNode(feature, options) {
        return null; // not implemented
    }
    /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   */ writeFeatures(features, options) {
        const node = this.writeFeaturesNode(features, options);
        return this.xmlSerializer_.serializeToString(node);
    }
    /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */ writeFeaturesNode(features, options) {
        return null; // not implemented
    }
    /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   */ writeGeometry(geometry, options) {
        const node = this.writeGeometryNode(geometry, options);
        return this.xmlSerializer_.serializeToString(node);
    }
    /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */ writeGeometryNode(geometry, options) {
        return null; // not implemented
    }
}
exports.default = XMLFeature;

},{"../format/Feature.js":"arwL9","../util.js":"l1iPW","../array.js":"hyet5","../xml.js":"4rPIo","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"arwL9":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/Feature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @template {import("../geom/Geometry.js").default|RenderFeature} T
 * @param {T} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {WriteOptions|ReadOptions} [options] Options.
 * @return {T} Transformed geometry.
 */ parcelHelpers.export(exports, "transformGeometryWithOptions", ()=>transformGeometryWithOptions);
/**
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {ReadOptions} [options] Read options.
 * @return {import("../extent.js").Extent} Transformed extent.
 */ parcelHelpers.export(exports, "transformExtentWithOptions", ()=>transformExtentWithOptions);
/**
 * @param {FeatureObject} object Feature object.
 * @param {WriteOptions|ReadOptions} [options] Options.
 * @return {RenderFeature|Array<RenderFeature>} Render feature.
 */ parcelHelpers.export(exports, "createRenderFeature", ()=>createRenderFeature);
/**
 * @param {GeometryObject|null} object Geometry object.
 * @param {WriteOptions|ReadOptions} [options] Options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */ parcelHelpers.export(exports, "createGeometry", ()=>createGeometry);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _featureJs1 = require("../render/Feature.js");
var _featureJsDefault1 = parcelHelpers.interopDefault(_featureJs1);
var _geomJs = require("../geom.js");
var _utilJs = require("../util.js");
var _projJs = require("../proj.js");
var _orientJs = require("../geom/flat/orient.js");
/**
 * @typedef {Object} ReadOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
 * If not provided, the projection will be derived from the data (where possible) or
 * the `dataProjection` of the format is assigned (where set). If the projection
 * can not be derived from the data and if no `dataProjection` is set for a format,
 * the features will not be reprojected.
 * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
 * This is only required when reading data with tile pixels as geometry units. When configured,
 * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
 * provided.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * created by the format reader. If not provided, features will be returned in the
 * `dataProjection`.
 */ /**
 * @typedef {Object} WriteOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
 * If not provided, the `dataProjection` of the format is assigned (where set).
 * If no `dataProjection` is set for a format, the features will be returned
 * in the `featureProjection`.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * that will be serialized by the format writer. If not provided, geometries are assumed
 * to be in the `dataProjection` if that is set; in other words, they are not transformed.
 * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
 * rule for linear ring orientation.  This means that polygons will have counter-clockwise
 * exterior rings and clockwise interior rings.  By default, coordinates are serialized
 * as they are provided at construction.  If `true`, the right-hand rule will
 * be applied.  If `false`, the left-hand rule will be applied (clockwise for
 * exterior and counter-clockwise for interior rings).  Note that not all
 * formats support this.  The GeoJSON format does use this property when writing
 * geometries.
 * @property {number} [decimals] Maximum number of decimal places for coordinates.
 * Coordinates are stored internally as floats, but floating-point arithmetic can create
 * coordinates with a large number of decimal places, not generally wanted on output.
 * Set a number here to round coordinates. Can also be used to ensure that
 * coordinates read in can be written back out with the same number of decimals.
 * Default is no rounding.
 */ /**
 * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type
 */ /**
 * @typedef {Object} SimpleGeometryObject
 * @property {import('../geom/Geometry.js').Type} type Type.
 * @property {Array<number>} flatCoordinates Flat coordinates.
 * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.
 * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.
 */ /**
 * @typedef {Array<GeometryObject>} GeometryCollectionObject
 */ /**
 * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject
 */ /**
 * @typedef {Object} FeatureObject
 * @property {string|number} [id] Id.
 * @property {GeometryObject} [geometry] Geometry.
 * @property {Object<string, *>} [properties] Properties.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
 * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @abstract
 * @api
 */ class FeatureFormat {
    constructor(){
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */ this.dataProjection = undefined;
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */ this.defaultFeatureProjection = undefined;
        /**
     * @protected
     * @type {import("../Feature.js").FeatureClass}
     */ this.featureClass = (0, _featureJsDefault.default);
        /**
     * A list media types supported by the format in descending order of preference.
     * @type {Array<string>}
     */ this.supportedMediaTypes = null;
    }
    /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */ getReadOptions(source, options) {
        if (options) {
            let dataProjection = options.dataProjection ? (0, _projJs.get)(options.dataProjection) : this.readProjection(source);
            if (options.extent && dataProjection && dataProjection.getUnits() === 'tile-pixels') {
                dataProjection = (0, _projJs.get)(dataProjection);
                dataProjection.setWorldExtent(options.extent);
            }
            options = {
                dataProjection: dataProjection,
                featureProjection: options.featureProjection
            };
        }
        return this.adaptOptions(options);
    }
    /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */ adaptOptions(options) {
        return Object.assign({
            dataProjection: this.dataProjection,
            featureProjection: this.defaultFeatureProjection,
            featureClass: this.featureClass
        }, options);
    }
    /**
   * @abstract
   * @return {Type} The format type.
   */ getType() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike|Array<import("../render/Feature.js").default>} Feature.
   */ readFeature(source, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */ readFeatures(source, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometry(source, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */ readProjection(source) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeFeature(feature, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeFeatures(features, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeGeometry(geometry, options) {
        return (0, _utilJs.abstract)();
    }
}
exports.default = FeatureFormat;
function transformGeometryWithOptions(geometry, write, options) {
    const featureProjection = options ? (0, _projJs.get)(options.featureProjection) : null;
    const dataProjection = options ? (0, _projJs.get)(options.dataProjection) : null;
    let transformed = geometry;
    if (featureProjection && dataProjection && !(0, _projJs.equivalent)(featureProjection, dataProjection)) {
        if (write) transformed = /** @type {T} */ geometry.clone();
        const fromProjection = write ? featureProjection : dataProjection;
        const toProjection = write ? dataProjection : featureProjection;
        if (fromProjection.getUnits() === 'tile-pixels') transformed.transform(fromProjection, toProjection);
        else transformed.applyTransform((0, _projJs.getTransform)(fromProjection, toProjection));
    }
    if (write && options && /** @type {WriteOptions} */ options.decimals !== undefined) {
        const power = Math.pow(10, /** @type {WriteOptions} */ options.decimals);
        // if decimals option on write, round each coordinate appropriately
        /**
     * @param {Array<number>} coordinates Coordinates.
     * @return {Array<number>} Transformed coordinates.
     */ const transform = function(coordinates) {
            for(let i = 0, ii = coordinates.length; i < ii; ++i)coordinates[i] = Math.round(coordinates[i] * power) / power;
            return coordinates;
        };
        if (transformed === geometry) transformed = /** @type {T} */ geometry.clone();
        transformed.applyTransform(transform);
    }
    return transformed;
}
function transformExtentWithOptions(extent, options) {
    const featureProjection = options ? (0, _projJs.get)(options.featureProjection) : null;
    const dataProjection = options ? (0, _projJs.get)(options.dataProjection) : null;
    if (featureProjection && dataProjection && !(0, _projJs.equivalent)(featureProjection, dataProjection)) return (0, _projJs.transformExtent)(extent, dataProjection, featureProjection);
    return extent;
}
const GeometryConstructor = {
    Point: (0, _geomJs.Point),
    LineString: (0, _geomJs.LineString),
    Polygon: (0, _geomJs.Polygon),
    MultiPoint: (0, _geomJs.MultiPoint),
    MultiLineString: (0, _geomJs.MultiLineString),
    MultiPolygon: (0, _geomJs.MultiPolygon)
};
function orientFlatCoordinates(flatCoordinates, ends, stride) {
    if (Array.isArray(ends[0])) {
        // MultiPolagon
        if (!(0, _orientJs.linearRingssAreOriented)(flatCoordinates, 0, ends, stride)) {
            flatCoordinates = flatCoordinates.slice();
            (0, _orientJs.orientLinearRingsArray)(flatCoordinates, 0, ends, stride);
        }
        return flatCoordinates;
    }
    if (!(0, _orientJs.linearRingsAreOriented)(flatCoordinates, 0, ends, stride)) {
        flatCoordinates = flatCoordinates.slice();
        (0, _orientJs.orientLinearRings)(flatCoordinates, 0, ends, stride);
    }
    return flatCoordinates;
}
function createRenderFeature(object, options) {
    const geometry = object.geometry;
    if (!geometry) return [];
    if (Array.isArray(geometry)) return geometry.map((geometry)=>createRenderFeature({
            ...object,
            geometry
        })).flat();
    const geometryType = geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;
    if (geometryType === 'GeometryCollection' || geometryType === 'Circle') throw new Error('Unsupported geometry type: ' + geometryType);
    const stride = geometry.layout.length;
    return transformGeometryWithOptions(new (0, _featureJsDefault1.default)(geometryType, geometryType === 'Polygon' ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride) : geometry.flatCoordinates, geometry.ends?.flat(), stride, object.properties || {}, object.id).enableSimplifyTransformed(), false, options);
}
function createGeometry(object, options) {
    if (!object) return null;
    if (Array.isArray(object)) {
        const geometries = object.map((geometry)=>createGeometry(geometry, options));
        return new (0, _geomJs.GeometryCollection)(geometries);
    }
    const Geometry = GeometryConstructor[object.type];
    return transformGeometryWithOptions(new Geometry(object.flatCoordinates, object.layout, object.ends), false, options);
}

},{"../Feature.js":"3qocF","../render/Feature.js":"dtdcp","../geom.js":"ce4yU","../util.js":"l1iPW","../proj.js":"8OK47","../geom/flat/orient.js":"kVTqd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4rPIo":[function(require,module,exports,__globalThis) {
/**
 * @module ol/xml
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "XML_SCHEMA_INSTANCE_URI", ()=>XML_SCHEMA_INSTANCE_URI);
/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Element} Node.
 */ parcelHelpers.export(exports, "createElementNS", ()=>createElementNS);
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */ parcelHelpers.export(exports, "getAllTextContent", ()=>getAllTextContent);
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array<string>} accumulator Accumulator.
 * @private
 * @return {Array<string>} Accumulator.
 */ parcelHelpers.export(exports, "getAllTextContent_", ()=>getAllTextContent_);
/**
 * @param {Object} object Object.
 * @return {boolean} Is a document.
 */ parcelHelpers.export(exports, "isDocument", ()=>isDocument);
/**
 * @param {Element} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */ parcelHelpers.export(exports, "getAttributeNS", ()=>getAttributeNS);
/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */ parcelHelpers.export(exports, "parse", ()=>parse);
/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */ parcelHelpers.export(exports, "makeArrayExtender", ()=>makeArrayExtender);
/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */ parcelHelpers.export(exports, "makeArrayPusher", ()=>makeArrayPusher);
/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */ parcelHelpers.export(exports, "makeReplacer", ()=>makeReplacer);
/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [property] Property.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */ parcelHelpers.export(exports, "makeObjectPropertyPusher", ()=>makeObjectPropertyPusher);
/**
 * Make an object property setter function.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [property] Property.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */ parcelHelpers.export(exports, "makeObjectPropertySetter", ()=>makeObjectPropertySetter);
/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */ parcelHelpers.export(exports, "makeChildAppender", ()=>makeChildAppender);
/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the
 * `nodeWriter` called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */ parcelHelpers.export(exports, "makeArraySerializer", ()=>makeArraySerializer);
/**
 * Create a node factory which can use the `keys` passed to
 * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string} [fixedNodeName] Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.
 */ parcelHelpers.export(exports, "makeSimpleNodeFactory", ()=>makeSimpleNodeFactory);
parcelHelpers.export(exports, "OBJECT_PROPERTY_NODE_FACTORY", ()=>OBJECT_PROPERTY_NODE_FACTORY);
/**
 * Create an array of `values` to be used with {@link module:ol/xml.serialize} or
 * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `key` argument.
 * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array<*>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 */ parcelHelpers.export(exports, "makeSequence", ()=>makeSequence);
/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object<string, T>} [structureNS] Namespaced structure to add to.
 * @return {Object<string, T>} Namespaced structure.
 * @template T
 */ parcelHelpers.export(exports, "makeStructureNS", ()=>makeStructureNS);
/**
 * Parse a node using the parsers and object stack.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [thisArg] The object to use as `this`.
 */ parcelHelpers.export(exports, "parseNode", ()=>parseNode);
/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [thisArg] The object to use as `this`.
 * @return {T} Object.
 * @template T
 */ parcelHelpers.export(exports, "pushParseAndPop", ()=>pushParseAndPop);
/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:ol/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `keys` has
 *     to match the length of `values`. For serializing a sequence, `keys`
 *     determines the order of the sequence.
 * @param {T} [thisArg] The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */ parcelHelpers.export(exports, "serialize", ()=>serialize);
/**
 * @param {O} object Object.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:ol/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `keys` has
 *     to match the length of `values`. For serializing a sequence, `keys`
 *     determines the order of the sequence.
 * @param {T} [thisArg] The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */ parcelHelpers.export(exports, "pushSerializeAndPop", ()=>pushSerializeAndPop);
/**
 * Register a XMLSerializer. Can be used  to inject a XMLSerializer
 * where there is no globally available implementation.
 *
 * @param {XMLSerializer} xmlSerializer A XMLSerializer.
 * @api
 */ parcelHelpers.export(exports, "registerXMLSerializer", ()=>registerXMLSerializer);
/**
 * @return {XMLSerializer} The XMLSerializer.
 */ parcelHelpers.export(exports, "getXMLSerializer", ()=>getXMLSerializer);
/**
 * Register a Document to use when creating nodes for XML serializations. Can be used
 * to inject a Document where there is no globally available implementation.
 *
 * @param {Document} document A Document.
 * @api
 */ parcelHelpers.export(exports, "registerDocument", ()=>registerDocument);
/**
 * Get a document that should be used when creating nodes for XML serializations.
 * @return {Document} The document.
 */ parcelHelpers.export(exports, "getDocument", ()=>getDocument);
var _arrayJs = require("./array.js");
const XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';
function createElementNS(namespaceURI, qualifiedName) {
    return getDocument().createElementNS(namespaceURI, qualifiedName);
}
function getAllTextContent(node, normalizeWhitespace) {
    return getAllTextContent_(node, normalizeWhitespace, []).join('');
}
function getAllTextContent_(node, normalizeWhitespace, accumulator) {
    if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
        if (normalizeWhitespace) accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
        else accumulator.push(node.nodeValue);
    } else {
        let n;
        for(n = node.firstChild; n; n = n.nextSibling)getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
    return accumulator;
}
function isDocument(object) {
    return 'documentElement' in object;
}
function getAttributeNS(node, namespaceURI, name) {
    return node.getAttributeNS(namespaceURI, name) || '';
}
function parse(xml) {
    return new DOMParser().parseFromString(xml, 'application/xml');
}
function makeArrayExtender(valueReader, thisArg) {
    return(/**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */ function(node, objectStack) {
        const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);
        if (value !== undefined) {
            const array = /** @type {Array<*>} */ objectStack[objectStack.length - 1];
            (0, _arrayJs.extend)(array, value);
        }
    });
}
function makeArrayPusher(valueReader, thisArg) {
    return(/**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */ function(node, objectStack) {
        const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);
        if (value !== undefined) {
            const array = /** @type {Array<*>} */ objectStack[objectStack.length - 1];
            array.push(value);
        }
    });
}
function makeReplacer(valueReader, thisArg) {
    return(/**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */ function(node, objectStack) {
        const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);
        if (value !== undefined) objectStack[objectStack.length - 1] = value;
    });
}
function makeObjectPropertyPusher(valueReader, property, thisArg) {
    return(/**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */ function(node, objectStack) {
        const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);
        if (value !== undefined) {
            const object = /** @type {!Object} */ objectStack[objectStack.length - 1];
            const name = property !== undefined ? property : node.localName;
            let array;
            if (name in object) array = object[name];
            else {
                array = [];
                object[name] = array;
            }
            array.push(value);
        }
    });
}
function makeObjectPropertySetter(valueReader, property, thisArg) {
    return(/**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */ function(node, objectStack) {
        const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);
        if (value !== undefined) {
            const object = /** @type {!Object} */ objectStack[objectStack.length - 1];
            const name = property !== undefined ? property : node.localName;
            object[name] = value;
        }
    });
}
function makeChildAppender(nodeWriter, thisArg) {
    return function(node, value, objectStack) {
        nodeWriter.call(thisArg !== undefined ? thisArg : this, node, value, objectStack);
        const parent = /** @type {NodeStackItem} */ objectStack[objectStack.length - 1];
        const parentNode = parent.node;
        parentNode.appendChild(node);
    };
}
function makeArraySerializer(nodeWriter, thisArg) {
    let serializersNS, nodeFactory;
    return function(node, value, objectStack) {
        if (serializersNS === undefined) {
            serializersNS = {};
            const serializers = {};
            serializers[node.localName] = nodeWriter;
            serializersNS[node.namespaceURI] = serializers;
            nodeFactory = makeSimpleNodeFactory(node.localName);
        }
        serialize(serializersNS, nodeFactory, value, objectStack);
    };
}
function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {
    return(/**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */ function(value, objectStack, newNodeName) {
        const context = /** @type {NodeStackItem} */ objectStack[objectStack.length - 1];
        const node = context.node;
        let nodeName = fixedNodeName;
        if (nodeName === undefined) nodeName = newNodeName;
        const namespaceURI = fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;
        return createElementNS(namespaceURI, /** @type {string} */ nodeName);
    });
}
const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();
function makeSequence(object, orderedKeys) {
    const length = orderedKeys.length;
    const sequence = new Array(length);
    for(let i = 0; i < length; ++i)sequence[i] = object[orderedKeys[i]];
    return sequence;
}
function makeStructureNS(namespaceURIs, structure, structureNS) {
    structureNS = structureNS !== undefined ? structureNS : {};
    let i, ii;
    for(i = 0, ii = namespaceURIs.length; i < ii; ++i)structureNS[namespaceURIs[i]] = structure;
    return structureNS;
}
function parseNode(parsersNS, node, objectStack, thisArg) {
    let n;
    for(n = node.firstElementChild; n; n = n.nextElementSibling){
        const parsers = parsersNS[n.namespaceURI];
        if (parsers !== undefined) {
            const parser = parsers[n.localName];
            if (parser !== undefined) parser.call(thisArg, n, objectStack);
        }
    }
}
function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {
    objectStack.push(object);
    parseNode(parsersNS, node, objectStack, thisArg);
    return /** @type {T} */ objectStack.pop();
}
function serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg) {
    const length = (keys !== undefined ? keys : values).length;
    let value, node;
    for(let i = 0; i < length; ++i){
        value = values[i];
        if (value !== undefined) {
            node = nodeFactory.call(thisArg !== undefined ? thisArg : this, value, objectStack, keys !== undefined ? keys[i] : undefined);
            if (node !== undefined) serializersNS[node.namespaceURI][node.localName].call(thisArg, node, value, objectStack);
        }
    }
}
function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, keys, thisArg) {
    objectStack.push(object);
    serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);
    return /** @type {O|undefined} */ objectStack.pop();
}
let xmlSerializer_ = undefined;
function registerXMLSerializer(xmlSerializer) {
    xmlSerializer_ = xmlSerializer;
}
function getXMLSerializer() {
    if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') xmlSerializer_ = new XMLSerializer();
    return xmlSerializer_;
}
let document_ = undefined;
function registerDocument(document1) {
    document_ = document1;
}
function getDocument() {
    if (document_ === undefined && typeof document !== 'undefined') document_ = document.implementation.createDocument('', '', null);
    return document_;
}

},{"./array.js":"hyet5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cKLNr":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/xsd
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Node} node Node.
 * @return {boolean|undefined} Boolean.
 */ parcelHelpers.export(exports, "readBoolean", ()=>readBoolean);
/**
 * @param {string} string String.
 * @return {boolean|undefined} Boolean.
 */ parcelHelpers.export(exports, "readBooleanString", ()=>readBooleanString);
/**
 * @param {Node} node Node.
 * @return {number|undefined} DateTime in seconds.
 */ parcelHelpers.export(exports, "readDateTime", ()=>readDateTime);
/**
 * @param {Node} node Node.
 * @return {number|undefined} Decimal.
 */ parcelHelpers.export(exports, "readDecimal", ()=>readDecimal);
/**
 * @param {string} string String.
 * @return {number|undefined} Decimal.
 */ parcelHelpers.export(exports, "readDecimalString", ()=>readDecimalString);
/**
 * @param {Node} node Node.
 * @return {number|undefined} Non negative integer.
 */ parcelHelpers.export(exports, "readPositiveInteger", ()=>readPositiveInteger);
/**
 * @param {string} string String.
 * @return {number|undefined} Non negative integer.
 */ parcelHelpers.export(exports, "readNonNegativeIntegerString", ()=>readNonNegativeIntegerString);
/**
 * @param {Node} node Node.
 * @return {string|undefined} String.
 */ parcelHelpers.export(exports, "readString", ()=>readString);
/**
 * @param {Node} node Node to append a TextNode with the boolean to.
 * @param {boolean} bool Boolean.
 */ parcelHelpers.export(exports, "writeBooleanTextNode", ()=>writeBooleanTextNode);
/**
 * @param {Node} node Node to append a CDATA Section with the string to.
 * @param {string} string String.
 */ parcelHelpers.export(exports, "writeCDATASection", ()=>writeCDATASection);
/**
 * @param {Node} node Node to append a TextNode with the dateTime to.
 * @param {number} dateTime DateTime in seconds.
 */ parcelHelpers.export(exports, "writeDateTimeTextNode", ()=>writeDateTimeTextNode);
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} decimal Decimal.
 */ parcelHelpers.export(exports, "writeDecimalTextNode", ()=>writeDecimalTextNode);
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} nonNegativeInteger Non negative integer.
 */ parcelHelpers.export(exports, "writeNonNegativeIntegerTextNode", ()=>writeNonNegativeIntegerTextNode);
/**
 * @param {Node} node Node to append a TextNode with the string to.
 * @param {string} string String.
 */ parcelHelpers.export(exports, "writeStringTextNode", ()=>writeStringTextNode);
var _xmlJs = require("../xml.js");
var _stringJs = require("../string.js");
function readBoolean(node) {
    const s = (0, _xmlJs.getAllTextContent)(node, false);
    return readBooleanString(s);
}
function readBooleanString(string) {
    const m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
    if (m) return m[1] !== undefined || false;
    return undefined;
}
function readDateTime(node) {
    const s = (0, _xmlJs.getAllTextContent)(node, false);
    const dateTime = Date.parse(s);
    return isNaN(dateTime) ? undefined : dateTime / 1000;
}
function readDecimal(node) {
    const s = (0, _xmlJs.getAllTextContent)(node, false);
    return readDecimalString(s);
}
function readDecimalString(string) {
    // FIXME check spec
    const m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
    if (m) return parseFloat(m[1]);
    return undefined;
}
function readPositiveInteger(node) {
    const s = (0, _xmlJs.getAllTextContent)(node, false);
    return readNonNegativeIntegerString(s);
}
function readNonNegativeIntegerString(string) {
    const m = /^\s*(\d+)\s*$/.exec(string);
    if (m) return parseInt(m[1], 10);
    return undefined;
}
function readString(node) {
    return (0, _xmlJs.getAllTextContent)(node, false).trim();
}
function writeBooleanTextNode(node, bool) {
    writeStringTextNode(node, bool ? '1' : '0');
}
function writeCDATASection(node, string) {
    node.appendChild((0, _xmlJs.getDocument)().createCDATASection(string));
}
function writeDateTimeTextNode(node, dateTime) {
    const date = new Date(dateTime * 1000);
    const string = date.getUTCFullYear() + '-' + (0, _stringJs.padNumber)(date.getUTCMonth() + 1, 2) + '-' + (0, _stringJs.padNumber)(date.getUTCDate(), 2) + 'T' + (0, _stringJs.padNumber)(date.getUTCHours(), 2) + ':' + (0, _stringJs.padNumber)(date.getUTCMinutes(), 2) + ':' + (0, _stringJs.padNumber)(date.getUTCSeconds(), 2) + 'Z';
    node.appendChild((0, _xmlJs.getDocument)().createTextNode(string));
}
function writeDecimalTextNode(node, decimal) {
    const string = decimal.toPrecision();
    node.appendChild((0, _xmlJs.getDocument)().createTextNode(string));
}
function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {
    const string = nonNegativeInteger.toString();
    node.appendChild((0, _xmlJs.getDocument)().createTextNode(string));
}
function writeStringTextNode(node, string) {
    node.appendChild((0, _xmlJs.getDocument)().createTextNode(string));
}

},{"../xml.js":"4rPIo","../string.js":"3uF0z","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"41qzB":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/GML3
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _gml2Js = require("./GML2.js");
var _gml2JsDefault = parcelHelpers.interopDefault(_gml2Js);
var _gmlbaseJs = require("./GMLBase.js");
var _gmlbaseJsDefault = parcelHelpers.interopDefault(_gmlbaseJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _xmlJs = require("../xml.js");
var _extentJs = require("../extent.js");
var _arrayJs = require("../array.js");
var _projJs = require("../proj.js");
var _xsdJs = require("./xsd.js");
var _featureJs = require("./Feature.js");
/**
 * @const
 * @type {string}
 * @private
 */ const schemaLocation = (0, _gmlbaseJs.GMLNS) + ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' + '1.0.0/gmlsf.xsd';
/**
 * @const
 * @type {Object<string, string>}
 */ const MULTIGEOMETRY_TO_MEMBER_NODENAME = {
    'MultiLineString': 'lineStringMember',
    'MultiCurve': 'curveMember',
    'MultiPolygon': 'polygonMember',
    'MultiSurface': 'surfaceMember'
};
/**
 * @classdesc
 * Feature format for reading and writing data in the GML format
 * version 3.1.1.
 * Currently only supports GML 3.1.1 Simple Features profile.
 *
 * @api
 */ class GML3 extends (0, _gmlbaseJsDefault.default) {
    /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */ constructor(options){
        options = options ? options : {};
        super(options);
        /**
     * @private
     * @type {boolean}
     */ this.surface_ = options.surface !== undefined ? options.surface : false;
        /**
     * @private
     * @type {boolean}
     */ this.curve_ = options.curve !== undefined ? options.curve : false;
        /**
     * @private
     * @type {boolean}
     */ this.multiCurve_ = options.multiCurve !== undefined ? options.multiCurve : true;
        /**
     * @private
     * @type {boolean}
     */ this.multiSurface_ = options.multiSurface !== undefined ? options.multiSurface : true;
        /**
     * @type {string}
     */ this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
        /**
     * @private
     * @type {boolean}
     */ this.hasZ = options.hasZ !== undefined ? options.hasZ : false;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */ readMultiCurve(node, objectStack) {
        /** @type {Array<LineString>} */ const lineStrings = (0, _xmlJs.pushParseAndPop)([], this.MULTICURVE_PARSERS, node, objectStack, this);
        if (lineStrings) {
            const multiLineString = new (0, _multiLineStringJsDefault.default)(lineStrings);
            return multiLineString;
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Polygon.
   */ readFlatCurveRing(node, objectStack) {
        /** @type {Array<LineString>} */ const lineStrings = (0, _xmlJs.pushParseAndPop)([], this.MULTICURVE_PARSERS, node, objectStack, this);
        const flatCoordinates = [];
        for(let i = 0, ii = lineStrings.length; i < ii; ++i)(0, _arrayJs.extend)(flatCoordinates, lineStrings[i].getFlatCoordinates());
        return flatCoordinates;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */ readMultiSurface(node, objectStack) {
        /** @type {Array<Polygon>} */ const polygons = (0, _xmlJs.pushParseAndPop)([], this.MULTISURFACE_PARSERS, node, objectStack, this);
        if (polygons) return new (0, _multiPolygonJsDefault.default)(polygons);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ curveMemberParser(node, objectStack) {
        (0, _xmlJs.parseNode)(this.CURVEMEMBER_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ surfaceMemberParser(node, objectStack) {
        (0, _xmlJs.parseNode)(this.SURFACEMEMBER_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */ readPatch(node, objectStack) {
        return (0, _xmlJs.pushParseAndPop)([
            null
        ], this.PATCHES_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */ readSegment(node, objectStack) {
        return (0, _xmlJs.pushParseAndPop)([], this.SEGMENTS_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */ readPolygonPatch(node, objectStack) {
        return (0, _xmlJs.pushParseAndPop)([
            null
        ], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */ readLineStringSegment(node, objectStack) {
        return (0, _xmlJs.pushParseAndPop)([
            null
        ], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ interiorParser(node, objectStack) {
        /** @type {Array<number>|undefined} */ const flatLinearRing = (0, _xmlJs.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */ objectStack[objectStack.length - 1];
            flatLinearRings.push(flatLinearRing);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ exteriorParser(node, objectStack) {
        /** @type {Array<number>|undefined} */ const flatLinearRing = (0, _xmlJs.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */ objectStack[objectStack.length - 1];
            flatLinearRings[0] = flatLinearRing;
        }
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */ readSurface(node, objectStack) {
        /** @type {Array<Array<number>>} */ const flatLinearRings = (0, _xmlJs.pushParseAndPop)([
            null
        ], this.SURFACE_PARSERS, node, objectStack, this);
        if (flatLinearRings && flatLinearRings[0]) {
            const flatCoordinates = flatLinearRings[0];
            const ends = [
                flatCoordinates.length
            ];
            let i, ii;
            for(i = 1, ii = flatLinearRings.length; i < ii; ++i){
                (0, _arrayJs.extend)(flatCoordinates, flatLinearRings[i]);
                ends.push(flatCoordinates.length);
            }
            return new (0, _polygonJsDefault.default)(flatCoordinates, 'XYZ', ends);
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */ readCurve(node, objectStack) {
        /** @type {Array<number>} */ const flatCoordinates = (0, _xmlJs.pushParseAndPop)([
            null
        ], this.CURVE_PARSERS, node, objectStack, this);
        if (flatCoordinates) {
            const lineString = new (0, _lineStringJsDefault.default)(flatCoordinates, 'XYZ');
            return lineString;
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */ readEnvelope(node, objectStack) {
        /** @type {Array<number>} */ const flatCoordinates = (0, _xmlJs.pushParseAndPop)([
            null
        ], this.ENVELOPE_PARSERS, node, objectStack, this);
        return (0, _extentJs.createOrUpdate)(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);
    }
    /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */ readFlatPos(node, objectStack) {
        let s = (0, _xmlJs.getAllTextContent)(node, false);
        const re = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
        /** @type {Array<number>} */ const flatCoordinates = [];
        let m;
        while(m = re.exec(s)){
            flatCoordinates.push(parseFloat(m[1]));
            s = s.substr(m[0].length);
        }
        if (s !== '') return undefined;
        const context = objectStack[0];
        const containerSrs = context['srsName'];
        let axisOrientation = 'enu';
        if (containerSrs) {
            const proj = (0, _projJs.get)(containerSrs);
            axisOrientation = proj.getAxisOrientation();
        }
        if (axisOrientation === 'neu') {
            let i, ii;
            for(i = 0, ii = flatCoordinates.length; i < ii; i += 3){
                const y = flatCoordinates[i];
                const x = flatCoordinates[i + 1];
                flatCoordinates[i] = x;
                flatCoordinates[i + 1] = y;
            }
        }
        const len = flatCoordinates.length;
        if (len == 2) flatCoordinates.push(0);
        if (len === 0) return undefined;
        return flatCoordinates;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */ readFlatPosList(node, objectStack) {
        const s = (0, _xmlJs.getAllTextContent)(node, false).replace(/^\s*|\s*$/g, '');
        const context = objectStack[0];
        const containerSrs = context['srsName'];
        const contextDimension = context['srsDimension'];
        let axisOrientation = 'enu';
        if (containerSrs) {
            const proj = (0, _projJs.get)(containerSrs);
            axisOrientation = proj.getAxisOrientation();
        }
        const coords = s.split(/\s+/);
        // The "dimension" attribute is from the GML 3.0.1 spec.
        let dim = 2;
        if (node.getAttribute('srsDimension')) dim = (0, _xsdJs.readNonNegativeIntegerString)(node.getAttribute('srsDimension'));
        else if (node.getAttribute('dimension')) dim = (0, _xsdJs.readNonNegativeIntegerString)(node.getAttribute('dimension'));
        else if (/** @type {Element} */ node.parentNode.getAttribute('srsDimension')) dim = (0, _xsdJs.readNonNegativeIntegerString)(/** @type {Element} */ node.parentNode.getAttribute('srsDimension'));
        else if (contextDimension) dim = (0, _xsdJs.readNonNegativeIntegerString)(contextDimension);
        let x, y, z;
        const flatCoordinates = [];
        for(let i = 0, ii = coords.length; i < ii; i += dim){
            x = parseFloat(coords[i]);
            y = parseFloat(coords[i + 1]);
            z = dim === 3 ? parseFloat(coords[i + 2]) : 0;
            if (axisOrientation.substr(0, 2) === 'en') flatCoordinates.push(x, y, z);
            else flatCoordinates.push(y, x, z);
        }
        return flatCoordinates;
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} value Point geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writePos_(node, value, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsDimension = hasZ ? '3' : '2';
        node.setAttribute('srsDimension', srsDimension);
        const srsName = context['srsName'];
        let axisOrientation = 'enu';
        if (srsName) axisOrientation = (0, _projJs.get)(srsName).getAxisOrientation();
        const point = value.getCoordinates();
        let coords;
        // only 2d for simple features profile
        if (axisOrientation.substr(0, 2) === 'en') coords = point[0] + ' ' + point[1];
        else coords = point[1] + ' ' + point[0];
        if (hasZ) {
            // For newly created points, Z can be undefined.
            const z = point[2] || 0;
            coords += ' ' + z;
        }
        (0, _xsdJs.writeStringTextNode)(node, coords);
    }
    /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */ getCoords_(point, srsName, hasZ) {
        let axisOrientation = 'enu';
        if (srsName) axisOrientation = (0, _projJs.get)(srsName).getAxisOrientation();
        let coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ' ' + point[1] : point[1] + ' ' + point[0];
        if (hasZ) {
            // For newly created points, Z can be undefined.
            const z = point[2] || 0;
            coords += ' ' + z;
        }
        return coords;
    }
    /**
   * @param {Element} node Node.
   * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writePosList_(node, value, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsDimension = hasZ ? '3' : '2';
        node.setAttribute('srsDimension', srsDimension);
        const srsName = context['srsName'];
        // only 2d for simple features profile
        const points = value.getCoordinates();
        const len = points.length;
        const parts = new Array(len);
        let point;
        for(let i = 0; i < len; ++i){
            point = points[i];
            parts[i] = this.getCoords_(point, srsName, hasZ);
        }
        (0, _xsdJs.writeStringTextNode)(node, parts.join(' '));
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writePoint(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const pos = (0, _xmlJs.createElementNS)(node.namespaceURI, 'pos');
        node.appendChild(pos);
        this.writePos_(pos, geometry, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */ writeEnvelope(node, extent, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const keys = [
            'lowerCorner',
            'upperCorner'
        ];
        const values = [
            extent[0] + ' ' + extent[1],
            extent[2] + ' ' + extent[3]
        ];
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ {
            node: node
        }, this.ENVELOPE_SERIALIZERS, (0, _xmlJs.OBJECT_PROPERTY_NODE_FACTORY), values, objectStack, keys, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeLinearRing(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const posList = (0, _xmlJs.createElementNS)(node.namespaceURI, 'posList');
        node.appendChild(posList);
        this.writePosList_(posList, geometry, objectStack);
    }
    /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */ RING_NODE_FACTORY_(value, objectStack, nodeName) {
        const context = objectStack[objectStack.length - 1];
        const parentNode = context.node;
        const exteriorWritten = context['exteriorWritten'];
        if (exteriorWritten === undefined) context['exteriorWritten'] = true;
        return (0, _xmlJs.createElementNS)(parentNode.namespaceURI, exteriorWritten !== undefined ? 'interior' : 'exterior');
    }
    /**
   * @param {Element} node Node.
   * @param {Polygon} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeSurfaceOrPolygon(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        if (node.nodeName !== 'PolygonPatch' && srsName) node.setAttribute('srsName', srsName);
        if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {
            const rings = geometry.getLinearRings();
            (0, _xmlJs.pushSerializeAndPop)({
                node: node,
                hasZ: hasZ,
                srsName: srsName
            }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);
        } else if (node.nodeName === 'Surface') {
            const patches = (0, _xmlJs.createElementNS)(node.namespaceURI, 'patches');
            node.appendChild(patches);
            this.writeSurfacePatches_(patches, geometry, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {LineString} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeCurveOrLineString(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (node.nodeName !== 'LineStringSegment' && srsName) node.setAttribute('srsName', srsName);
        if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {
            const posList = (0, _xmlJs.createElementNS)(node.namespaceURI, 'posList');
            node.appendChild(posList);
            this.writePosList_(posList, geometry, objectStack);
        } else if (node.nodeName === 'Curve') {
            const segments = (0, _xmlJs.createElementNS)(node.namespaceURI, 'segments');
            node.appendChild(segments);
            this.writeCurveSegments_(segments, geometry, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {MultiPolygon} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiSurfaceOrPolygon(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        const surface = context['surface'];
        if (srsName) node.setAttribute('srsName', srsName);
        const polygons = geometry.getPolygons();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName,
            surface: surface
        }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiPoint(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        const hasZ = context['hasZ'];
        if (srsName) node.setAttribute('srsName', srsName);
        const points = geometry.getPoints();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName
        }, this.POINTMEMBER_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)('pointMember'), points, objectStack, undefined, this);
    }
    /**
   * @param {Element} node Node.
   * @param {MultiLineString} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiCurveOrLineString(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        const curve = context['curve'];
        if (srsName) node.setAttribute('srsName', srsName);
        const lines = geometry.getLineStrings();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName,
            curve: curve
        }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeRing(node, ring, objectStack) {
        const linearRing = (0, _xmlJs.createElementNS)(node.namespaceURI, 'LinearRing');
        node.appendChild(linearRing);
        this.writeLinearRing(linearRing, ring, objectStack);
    }
    /**
   * @param {Node} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeSurfaceOrPolygonMember(node, polygon, objectStack) {
        const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
        if (child) {
            node.appendChild(child);
            this.writeSurfaceOrPolygon(child, polygon, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writePointMember(node, point, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'Point');
        node.appendChild(child);
        this.writePoint(child, point, objectStack);
    }
    /**
   * @param {Node} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeLineStringOrCurveMember(node, line, objectStack) {
        const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
        if (child) {
            node.appendChild(child);
            this.writeCurveOrLineString(child, line, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeSurfacePatches_(node, polygon, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'PolygonPatch');
        node.appendChild(child);
        this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeCurveSegments_(node, line, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'LineStringSegment');
        node.appendChild(child);
        this.writeCurveOrLineString(child, line, objectStack);
    }
    /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeGeometryElement(node, geometry, objectStack) {
        const context = /** @type {import("./Feature.js").WriteOptions} */ objectStack[objectStack.length - 1];
        const item = Object.assign({}, context);
        item['node'] = node;
        let value;
        if (Array.isArray(geometry)) value = (0, _featureJs.transformExtentWithOptions)(/** @type {import("../extent.js").Extent} */ geometry, context);
        else value = (0, _featureJs.transformGeometryWithOptions)(/** @type {import("../geom/Geometry.js").default} */ geometry, true, context);
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [
            value
        ], objectStack, undefined, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */ writeFeatureElement(node, feature, objectStack) {
        const fid = feature.getId();
        if (fid) node.setAttribute('fid', /** @type {string} */ fid);
        const context = /** @type {Object} */ objectStack[objectStack.length - 1];
        const featureNS = context['featureNS'];
        const geometryName = feature.getGeometryName();
        if (!context.serializers) {
            context.serializers = {};
            context.serializers[featureNS] = {};
        }
        const keys = [];
        const values = [];
        if (feature.hasProperties()) {
            const properties = feature.getProperties();
            for(const key in properties){
                const value = properties[key];
                if (value !== null) {
                    keys.push(key);
                    values.push(value);
                    if (key == geometryName || typeof /** @type {?} */ value.getSimplifiedGeometry === 'function') {
                        if (!(key in context.serializers[featureNS])) context.serializers[featureNS][key] = (0, _xmlJs.makeChildAppender)(this.writeGeometryElement, this);
                    } else if (!(key in context.serializers[featureNS])) context.serializers[featureNS][key] = (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode));
                }
            }
        }
        const item = Object.assign({}, context);
        item.node = node;
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ item, context.serializers, (0, _xmlJs.makeSimpleNodeFactory)(undefined, featureNS), values, objectStack, keys);
    }
    /**
   * @param {Node} node Node.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeFeatureMembers_(node, features, objectStack) {
        const context = /** @type {Object} */ objectStack[objectStack.length - 1];
        const featureType = context['featureType'];
        const featureNS = context['featureNS'];
        /** @type {Object<string, Object<string, import("../xml.js").Serializer>>} */ const serializers = {};
        serializers[featureNS] = {};
        serializers[featureNS][featureType] = (0, _xmlJs.makeChildAppender)(this.writeFeatureElement, this);
        const item = Object.assign({}, context);
        item.node = node;
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ item, serializers, (0, _xmlJs.makeSimpleNodeFactory)(featureType, featureNS), features, objectStack);
    }
    /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */ MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {
        const parentNode = objectStack[objectStack.length - 1].node;
        return (0, _xmlJs.createElementNS)(this.namespace, MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
    }
    /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */ GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {
        const context = objectStack[objectStack.length - 1];
        const multiSurface = context['multiSurface'];
        const surface = context['surface'];
        const curve = context['curve'];
        const multiCurve = context['multiCurve'];
        if (!Array.isArray(value)) {
            nodeName = /** @type {import("../geom/Geometry.js").default} */ value.getType();
            if (nodeName === 'MultiPolygon' && multiSurface === true) nodeName = 'MultiSurface';
            else if (nodeName === 'Polygon' && surface === true) nodeName = 'Surface';
            else if (nodeName === 'LineString' && curve === true) nodeName = 'Curve';
            else if (nodeName === 'MultiLineString' && multiCurve === true) nodeName = 'MultiCurve';
        } else nodeName = 'Envelope';
        return (0, _xmlJs.createElementNS)(this.namespace, nodeName);
    }
    /**
   * Encode a geometry in GML 3.1.1 Simple Features.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */ writeGeometryNode(geometry, options) {
        options = this.adaptOptions(options);
        const geom = (0, _xmlJs.createElementNS)(this.namespace, 'geom');
        const context = {
            node: geom,
            hasZ: this.hasZ,
            srsName: this.srsName,
            curve: this.curve_,
            surface: this.surface_,
            multiSurface: this.multiSurface_,
            multiCurve: this.multiCurve_
        };
        if (options) Object.assign(context, options);
        this.writeGeometryElement(geom, geometry, [
            context
        ]);
        return geom;
    }
    /**
   * Encode an array of features in the GML 3.1.1 format as an XML node.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Element} Node.
   * @api
   */ writeFeaturesNode(features, options) {
        options = this.adaptOptions(options);
        const node = (0, _xmlJs.createElementNS)(this.namespace, 'featureMembers');
        node.setAttributeNS((0, _xmlJs.XML_SCHEMA_INSTANCE_URI), 'xsi:schemaLocation', this.schemaLocation);
        const context = {
            srsName: this.srsName,
            hasZ: this.hasZ,
            curve: this.curve_,
            surface: this.surface_,
            multiSurface: this.multiSurface_,
            multiCurve: this.multiCurve_,
            featureNS: this.featureNS,
            featureType: this.featureType
        };
        if (options) Object.assign(context, options);
        this.writeFeatureMembers_(node, features, [
            context
        ]);
        return node;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    'http://www.opengis.net/gml': {
        'pos': (0, _xmlJs.makeReplacer)(GML3.prototype.readFlatPos),
        'posList': (0, _xmlJs.makeReplacer)(GML3.prototype.readFlatPosList),
        'coordinates': (0, _xmlJs.makeReplacer)((0, _gml2JsDefault.default).prototype.readFlatCoordinates)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    'http://www.opengis.net/gml': {
        'interior': GML3.prototype.interiorParser,
        'exterior': GML3.prototype.exteriorParser
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.GEOMETRY_PARSERS = {
    'http://www.opengis.net/gml': {
        'Point': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPoint),
        'MultiPoint': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPoint),
        'LineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLineString),
        'MultiLineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiLineString),
        'LinearRing': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLinearRing),
        'Polygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPolygon),
        'MultiPolygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPolygon),
        'Surface': (0, _xmlJs.makeReplacer)(GML3.prototype.readSurface),
        'MultiSurface': (0, _xmlJs.makeReplacer)(GML3.prototype.readMultiSurface),
        'Curve': (0, _xmlJs.makeReplacer)(GML3.prototype.readCurve),
        'MultiCurve': (0, _xmlJs.makeReplacer)(GML3.prototype.readMultiCurve),
        'Envelope': (0, _xmlJs.makeReplacer)(GML3.prototype.readEnvelope)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.MULTICURVE_PARSERS = {
    'http://www.opengis.net/gml': {
        'curveMember': (0, _xmlJs.makeArrayPusher)(GML3.prototype.curveMemberParser),
        'curveMembers': (0, _xmlJs.makeArrayPusher)(GML3.prototype.curveMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.MULTISURFACE_PARSERS = {
    'http://www.opengis.net/gml': {
        'surfaceMember': (0, _xmlJs.makeArrayPusher)(GML3.prototype.surfaceMemberParser),
        'surfaceMembers': (0, _xmlJs.makeArrayPusher)(GML3.prototype.surfaceMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.CURVEMEMBER_PARSERS = {
    'http://www.opengis.net/gml': {
        'LineString': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readLineString),
        'Curve': (0, _xmlJs.makeArrayPusher)(GML3.prototype.readCurve)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.SURFACEMEMBER_PARSERS = {
    'http://www.opengis.net/gml': {
        'Polygon': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readPolygon),
        'Surface': (0, _xmlJs.makeArrayPusher)(GML3.prototype.readSurface)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.SURFACE_PARSERS = {
    'http://www.opengis.net/gml': {
        'patches': (0, _xmlJs.makeReplacer)(GML3.prototype.readPatch)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.CURVE_PARSERS = {
    'http://www.opengis.net/gml': {
        'segments': (0, _xmlJs.makeReplacer)(GML3.prototype.readSegment)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.ENVELOPE_PARSERS = {
    'http://www.opengis.net/gml': {
        'lowerCorner': (0, _xmlJs.makeArrayPusher)(GML3.prototype.readFlatPosList),
        'upperCorner': (0, _xmlJs.makeArrayPusher)(GML3.prototype.readFlatPosList)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.PATCHES_PARSERS = {
    'http://www.opengis.net/gml': {
        'PolygonPatch': (0, _xmlJs.makeReplacer)(GML3.prototype.readPolygonPatch)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.SEGMENTS_PARSERS = {
    'http://www.opengis.net/gml': {
        'LineStringSegment': (0, _xmlJs.makeArrayExtender)(GML3.prototype.readLineStringSegment)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ (0, _gmlbaseJsDefault.default).prototype.RING_PARSERS = {
    'http://www.opengis.net/gml': {
        'LinearRing': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readFlatLinearRing),
        'Ring': (0, _xmlJs.makeReplacer)(GML3.prototype.readFlatCurveRing)
    }
};
/**
 * Encode an array of features in GML 3.1.1 Simple Features.
 *
 * @function
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {import("./Feature.js").WriteOptions} [options] Options.
 * @return {string} Result.
 * @api
 */ GML3.prototype.writeFeatures;
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.RING_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'exterior': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeRing),
        'interior': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeRing)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.ENVELOPE_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'lowerCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode)),
        'upperCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode))
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'surfaceMember': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygonMember),
        'polygonMember': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygonMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.POINTMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'pointMember': (0, _xmlJs.makeChildAppender)(GML3.prototype.writePointMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'lineStringMember': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeLineStringOrCurveMember),
        'curveMember': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeLineStringOrCurveMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.GEOMETRY_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'Curve': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeCurveOrLineString),
        'MultiCurve': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeMultiCurveOrLineString),
        'Point': (0, _xmlJs.makeChildAppender)(GML3.prototype.writePoint),
        'MultiPoint': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeMultiPoint),
        'LineString': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeCurveOrLineString),
        'MultiLineString': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeMultiCurveOrLineString),
        'LinearRing': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeLinearRing),
        'Polygon': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygon),
        'MultiPolygon': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeMultiSurfaceOrPolygon),
        'Surface': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygon),
        'MultiSurface': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeMultiSurfaceOrPolygon),
        'Envelope': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeEnvelope)
    }
};
exports.default = GML3;

},{"./GML2.js":"uhKU3","./GMLBase.js":"3Cnic","../geom/LineString.js":"gknRz","../geom/MultiLineString.js":"4FjXg","../geom/MultiPolygon.js":"b4GDd","../geom/Polygon.js":"8Vwps","../xml.js":"4rPIo","../extent.js":"bGUel","../array.js":"hyet5","../proj.js":"8OK47","./xsd.js":"cKLNr","./Feature.js":"arwL9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ggVYi":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/GML32
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _gml2Js = require("./GML2.js");
var _gml2JsDefault = parcelHelpers.interopDefault(_gml2Js);
var _gml3Js = require("./GML3.js");
var _gml3JsDefault = parcelHelpers.interopDefault(_gml3Js);
var _gmlbaseJs = require("./GMLBase.js");
var _gmlbaseJsDefault = parcelHelpers.interopDefault(_gmlbaseJs);
var _xmlJs = require("../xml.js");
var _xsdJs = require("../format/xsd.js");
/**
 * @classdesc Feature format for reading and writing data in the GML format
 *            version 3.2.1.
 * @api
 */ class GML32 extends (0, _gml3JsDefault.default) {
    /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */ constructor(options){
        options = options ? options : {};
        super(options);
        /**
     * @type {string}
     */ this.schemaLocation = options.schemaLocation ? options.schemaLocation : this.namespace + ' http://schemas.opengis.net/gml/3.2.1/gml.xsd';
    }
    /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeGeometryElement(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        objectStack[objectStack.length - 1] = Object.assign({
            multiCurve: true,
            multiSurface: true
        }, context);
        super.writeGeometryElement(node, geometry, objectStack);
    }
}
GML32.prototype.namespace = 'http://www.opengis.net/gml/3.2';
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'pos': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readFlatPos),
        'posList': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readFlatPosList),
        'coordinates': (0, _xmlJs.makeReplacer)((0, _gml2JsDefault.default).prototype.readFlatCoordinates)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'interior': (0, _gml3JsDefault.default).prototype.interiorParser,
        'exterior': (0, _gml3JsDefault.default).prototype.exteriorParser
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.GEOMETRY_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'Point': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPoint),
        'MultiPoint': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPoint),
        'LineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLineString),
        'MultiLineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiLineString),
        'LinearRing': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLinearRing),
        'Polygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPolygon),
        'MultiPolygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPolygon),
        'Surface': (0, _xmlJs.makeReplacer)(GML32.prototype.readSurface),
        'MultiSurface': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readMultiSurface),
        'Curve': (0, _xmlJs.makeReplacer)(GML32.prototype.readCurve),
        'MultiCurve': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readMultiCurve),
        'Envelope': (0, _xmlJs.makeReplacer)(GML32.prototype.readEnvelope)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.MULTICURVE_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'curveMember': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.curveMemberParser),
        'curveMembers': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.curveMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.MULTISURFACE_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'surfaceMember': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.surfaceMemberParser),
        'surfaceMembers': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.surfaceMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.CURVEMEMBER_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'LineString': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readLineString),
        'Curve': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.readCurve)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.SURFACEMEMBER_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'Polygon': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readPolygon),
        'Surface': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.readSurface)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.SURFACE_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'patches': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readPatch)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.CURVE_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'segments': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readSegment)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.ENVELOPE_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'lowerCorner': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.readFlatPosList),
        'upperCorner': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.readFlatPosList)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.PATCHES_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'PolygonPatch': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readPolygonPatch)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.SEGMENTS_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'LineStringSegment': (0, _xmlJs.makeArrayExtender)((0, _gml3JsDefault.default).prototype.readLineStringSegment)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.MULTIPOINT_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'pointMember': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.pointMemberParser),
        'pointMembers': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.pointMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.MULTILINESTRING_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'lineStringMember': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.lineStringMemberParser),
        'lineStringMembers': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.lineStringMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.MULTIPOLYGON_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'polygonMember': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.polygonMemberParser),
        'polygonMembers': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.polygonMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.POINTMEMBER_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'Point': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readFlatCoordinatesFromNode)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.LINESTRINGMEMBER_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'LineString': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readLineString)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.POLYGONMEMBER_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'Polygon': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readPolygon)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.RING_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'LinearRing': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readFlatLinearRing),
        'Ring': (0, _xmlJs.makeReplacer)(GML32.prototype.readFlatCurveRing)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.RING_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'exterior': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeRing),
        'interior': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeRing)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.ENVELOPE_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'lowerCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode)),
        'upperCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode))
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'surfaceMember': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeSurfaceOrPolygonMember),
        'polygonMember': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeSurfaceOrPolygonMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.POINTMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'pointMember': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writePointMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'lineStringMember': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeLineStringOrCurveMember),
        'curveMember': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeLineStringOrCurveMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.GEOMETRY_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'Curve': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeCurveOrLineString),
        'MultiCurve': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeMultiCurveOrLineString),
        'Point': (0, _xmlJs.makeChildAppender)(GML32.prototype.writePoint),
        'MultiPoint': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeMultiPoint),
        'LineString': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeCurveOrLineString),
        'MultiLineString': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeMultiCurveOrLineString),
        'LinearRing': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeLinearRing),
        'Polygon': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeSurfaceOrPolygon),
        'MultiPolygon': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeMultiSurfaceOrPolygon),
        'Surface': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeSurfaceOrPolygon),
        'MultiSurface': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeMultiSurfaceOrPolygon),
        'Envelope': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeEnvelope)
    }
};
exports.default = GML32;

},{"./GML2.js":"uhKU3","./GML3.js":"41qzB","./GMLBase.js":"3Cnic","../xml.js":"4rPIo","../format/xsd.js":"cKLNr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gYXv7":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a logical `<And>` operator between two or more filter conditions.
 *
 * @param {...import("./filter/Filter.js").default} conditions Filter conditions.
 * @return {!And} `<And>` operator.
 * @api
 */ parcelHelpers.export(exports, "and", ()=>and);
/**
 * Create a logical `<Or>` operator between two or more filter conditions.
 *
 * @param {...import("./filter/Filter.js").default} conditions Filter conditions.
 * @return {!Or} `<Or>` operator.
 * @api
 */ parcelHelpers.export(exports, "or", ()=>or);
/**
 * Represents a logical `<Not>` operator for a filter condition.
 *
 * @param {!import("./filter/Filter.js").default} condition Filter condition.
 * @return {!Not} `<Not>` operator.
 * @api
 */ parcelHelpers.export(exports, "not", ()=>not);
/**
 * Create a `<BBOX>` operator to test whether a geometry-valued property
 * intersects a fixed bounding box
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../extent.js").Extent} extent Extent.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Bbox} `<BBOX>` operator.
 * @api
 */ parcelHelpers.export(exports, "bbox", ()=>bbox);
/**
 * Create a `<Contains>` operator to test whether a geometry-valued property
 * contains a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Contains} `<Contains>` operator.
 * @api
 */ parcelHelpers.export(exports, "contains", ()=>contains);
/**
 * Create a `<Intersects>` operator to test whether a geometry-valued property
 * intersects a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Intersects} `<Intersects>` operator.
 * @api
 */ parcelHelpers.export(exports, "intersects", ()=>intersects);
/**
 * Create a `<Disjoint>` operator to test whether a geometry-valued property
 * is disjoint to a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Disjoint} `<Disjoint>` operator.
 * @api
 */ parcelHelpers.export(exports, "disjoint", ()=>disjoint);
/**
 * Create a `<Within>` operator to test whether a geometry-valued property
 * is within a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Within} `<Within>` operator.
 * @api
 */ parcelHelpers.export(exports, "within", ()=>within);
/**
 * Create a `<DWithin>` operator to test whether a geometry-valued property
 * is within a distance to a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {!number} distance Distance.
 * @param {!string} unit Unit.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!DWithin} `<DWithin>` operator.
 * @api
 */ parcelHelpers.export(exports, "dwithin", ()=>dwithin);
/**
 * Creates a `<PropertyIsEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!(string|number)} expression The value to compare.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!EqualTo} `<PropertyIsEqualTo>` operator.
 * @api
 */ parcelHelpers.export(exports, "equalTo", ()=>equalTo);
/**
 * Creates a `<PropertyIsNotEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!(string|number)} expression The value to compare.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.
 * @api
 */ parcelHelpers.export(exports, "notEqualTo", ()=>notEqualTo);
/**
 * Creates a `<PropertyIsLessThan>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!LessThan} `<PropertyIsLessThan>` operator.
 * @api
 */ parcelHelpers.export(exports, "lessThan", ()=>lessThan);
/**
 * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.
 * @api
 */ parcelHelpers.export(exports, "lessThanOrEqualTo", ()=>lessThanOrEqualTo);
/**
 * Creates a `<PropertyIsGreaterThan>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!GreaterThan} `<PropertyIsGreaterThan>` operator.
 * @api
 */ parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
/**
 * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.
 * @api
 */ parcelHelpers.export(exports, "greaterThanOrEqualTo", ()=>greaterThanOrEqualTo);
/**
 * Creates a `<PropertyIsNull>` comparison operator to test whether a property value
 * is null.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @return {!IsNull} `<PropertyIsNull>` operator.
 * @api
 */ parcelHelpers.export(exports, "isNull", ()=>isNull);
/**
 * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression
 * value lies within a range given by a lower and upper bound (inclusive).
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} lowerBoundary The lower bound of the range.
 * @param {!number} upperBoundary The upper bound of the range.
 * @return {!IsBetween} `<PropertyIsBetween>` operator.
 * @api
 */ parcelHelpers.export(exports, "between", ()=>between);
/**
 * Represents a `<PropertyIsLike>` comparison operator that matches a string property
 * value against a text pattern.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!string} pattern Text pattern.
 * @param {string} [wildCard] Pattern character which matches any sequence of
 *    zero or more string characters. Default is '*'.
 * @param {string} [singleChar] pattern character which matches any single
 *    string character. Default is '.'.
 * @param {string} [escapeChar] Escape character which can be used to escape
 *    the pattern characters. Default is '!'.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!IsLike} `<PropertyIsLike>` operator.
 * @api
 */ parcelHelpers.export(exports, "like", ()=>like);
/**
 * Create a `<During>` temporal operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!string} begin The begin date in ISO-8601 format.
 * @param {!string} end The end date in ISO-8601 format.
 * @return {!During} `<During>` operator.
 * @api
 */ parcelHelpers.export(exports, "during", ()=>during);
parcelHelpers.export(exports, "resourceId", ()=>resourceId);
var _andJs = require("./filter/And.js");
var _andJsDefault = parcelHelpers.interopDefault(_andJs);
var _bboxJs = require("./filter/Bbox.js");
var _bboxJsDefault = parcelHelpers.interopDefault(_bboxJs);
var _containsJs = require("./filter/Contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _dwithinJs = require("./filter/DWithin.js");
var _dwithinJsDefault = parcelHelpers.interopDefault(_dwithinJs);
var _disjointJs = require("./filter/Disjoint.js");
var _disjointJsDefault = parcelHelpers.interopDefault(_disjointJs);
var _duringJs = require("./filter/During.js");
var _duringJsDefault = parcelHelpers.interopDefault(_duringJs);
var _equalToJs = require("./filter/EqualTo.js");
var _equalToJsDefault = parcelHelpers.interopDefault(_equalToJs);
var _greaterThanJs = require("./filter/GreaterThan.js");
var _greaterThanJsDefault = parcelHelpers.interopDefault(_greaterThanJs);
var _greaterThanOrEqualToJs = require("./filter/GreaterThanOrEqualTo.js");
var _greaterThanOrEqualToJsDefault = parcelHelpers.interopDefault(_greaterThanOrEqualToJs);
var _intersectsJs = require("./filter/Intersects.js");
var _intersectsJsDefault = parcelHelpers.interopDefault(_intersectsJs);
var _isBetweenJs = require("./filter/IsBetween.js");
var _isBetweenJsDefault = parcelHelpers.interopDefault(_isBetweenJs);
var _isLikeJs = require("./filter/IsLike.js");
var _isLikeJsDefault = parcelHelpers.interopDefault(_isLikeJs);
var _isNullJs = require("./filter/IsNull.js");
var _isNullJsDefault = parcelHelpers.interopDefault(_isNullJs);
var _lessThanJs = require("./filter/LessThan.js");
var _lessThanJsDefault = parcelHelpers.interopDefault(_lessThanJs);
var _lessThanOrEqualToJs = require("./filter/LessThanOrEqualTo.js");
var _lessThanOrEqualToJsDefault = parcelHelpers.interopDefault(_lessThanOrEqualToJs);
var _notJs = require("./filter/Not.js");
var _notJsDefault = parcelHelpers.interopDefault(_notJs);
var _notEqualToJs = require("./filter/NotEqualTo.js");
var _notEqualToJsDefault = parcelHelpers.interopDefault(_notEqualToJs);
var _orJs = require("./filter/Or.js");
var _orJsDefault = parcelHelpers.interopDefault(_orJs);
var _resourceIdJs = require("./filter/ResourceId.js");
var _resourceIdJsDefault = parcelHelpers.interopDefault(_resourceIdJs);
var _withinJs = require("./filter/Within.js");
var _withinJsDefault = parcelHelpers.interopDefault(_withinJs);
function and(conditions) {
    const params = [
        null
    ].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply((0, _andJsDefault.default), params))();
}
function or(conditions) {
    const params = [
        null
    ].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply((0, _orJsDefault.default), params))();
}
function not(condition) {
    return new (0, _notJsDefault.default)(condition);
}
function bbox(geometryName, extent, srsName) {
    return new (0, _bboxJsDefault.default)(geometryName, extent, srsName);
}
function contains(geometryName, geometry, srsName) {
    return new (0, _containsJsDefault.default)(geometryName, geometry, srsName);
}
function intersects(geometryName, geometry, srsName) {
    return new (0, _intersectsJsDefault.default)(geometryName, geometry, srsName);
}
function disjoint(geometryName, geometry, srsName) {
    return new (0, _disjointJsDefault.default)(geometryName, geometry, srsName);
}
function within(geometryName, geometry, srsName) {
    return new (0, _withinJsDefault.default)(geometryName, geometry, srsName);
}
function dwithin(geometryName, geometry, distance, unit, srsName) {
    return new (0, _dwithinJsDefault.default)(geometryName, geometry, distance, unit, srsName);
}
function equalTo(propertyName, expression, matchCase) {
    return new (0, _equalToJsDefault.default)(propertyName, expression, matchCase);
}
function notEqualTo(propertyName, expression, matchCase) {
    return new (0, _notEqualToJsDefault.default)(propertyName, expression, matchCase);
}
function lessThan(propertyName, expression) {
    return new (0, _lessThanJsDefault.default)(propertyName, expression);
}
function lessThanOrEqualTo(propertyName, expression) {
    return new (0, _lessThanOrEqualToJsDefault.default)(propertyName, expression);
}
function greaterThan(propertyName, expression) {
    return new (0, _greaterThanJsDefault.default)(propertyName, expression);
}
function greaterThanOrEqualTo(propertyName, expression) {
    return new (0, _greaterThanOrEqualToJsDefault.default)(propertyName, expression);
}
function isNull(propertyName) {
    return new (0, _isNullJsDefault.default)(propertyName);
}
function between(propertyName, lowerBoundary, upperBoundary) {
    return new (0, _isBetweenJsDefault.default)(propertyName, lowerBoundary, upperBoundary);
}
function like(propertyName, pattern, wildCard, singleChar, escapeChar, matchCase) {
    return new (0, _isLikeJsDefault.default)(propertyName, pattern, wildCard, singleChar, escapeChar, matchCase);
}
function during(propertyName, begin, end) {
    return new (0, _duringJsDefault.default)(propertyName, begin, end);
}
function resourceId(rid) {
    return new (0, _resourceIdJsDefault.default)(rid);
}

},{"./filter/And.js":"eAZYn","./filter/Bbox.js":"gCCGU","./filter/Contains.js":"hofzr","./filter/DWithin.js":"7ubSK","./filter/Disjoint.js":"g6GWJ","./filter/During.js":"g4yvi","./filter/EqualTo.js":"f2psT","./filter/GreaterThan.js":"fmLtY","./filter/GreaterThanOrEqualTo.js":"9uPer","./filter/Intersects.js":"aQX05","./filter/IsBetween.js":"999VA","./filter/IsLike.js":"8TiPB","./filter/IsNull.js":"3llct","./filter/LessThan.js":"4u0Wj","./filter/LessThanOrEqualTo.js":"kdneA","./filter/Not.js":"cgY9U","./filter/NotEqualTo.js":"6v2MZ","./filter/Or.js":"5QE3I","./filter/ResourceId.js":"kP4sL","./filter/Within.js":"GweRX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eAZYn":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/And
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _logicalNaryJs = require("./LogicalNary.js");
var _logicalNaryJsDefault = parcelHelpers.interopDefault(_logicalNaryJs);
/**
 * @classdesc
 * Represents a logical `<And>` operator between two or more filter conditions.
 *
 * @abstract
 */ class And extends (0, _logicalNaryJsDefault.default) {
    /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */ constructor(conditions){
        super('And', Array.prototype.slice.call(arguments));
    }
}
exports.default = And;

},{"./LogicalNary.js":"e8jG4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e8jG4":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/LogicalNary
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _assertsJs = require("../../asserts.js");
/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature n-ary logical filters.
 *
 * @abstract
 */ class LogicalNary extends (0, _filterJsDefault.default) {
    /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {Array<import("./Filter.js").default>} conditions Conditions.
   */ constructor(tagName, conditions){
        super(tagName);
        /**
     * @type {Array<import("./Filter.js").default>}
     */ this.conditions = conditions;
        (0, _assertsJs.assert)(this.conditions.length >= 2, 'At least 2 conditions are required');
    }
}
exports.default = LogicalNary;

},{"./Filter.js":"2hhow","../../asserts.js":"k0OL6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2hhow":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Filter
 */ /**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature filters.
 *
 * @abstract
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Filter {
    /**
   * @param {!string} tagName The XML tag name for this filter.
   */ constructor(tagName){
        /**
     * @private
     * @type {!string}
     */ this.tagName_ = tagName;
    }
    /**
   * The XML tag name for a filter.
   * @return {!string} Name.
   */ getTagName() {
        return this.tagName_;
    }
}
exports.default = Filter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gCCGU":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Bbox
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
/**
 * @classdesc
 * Represents a `<BBOX>` operator to test whether a geometry-valued property
 * intersects a fixed bounding box
 *
 * @api
 */ class Bbox extends (0, _filterJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be set
   * on geometries when this is not provided.
   */ constructor(geometryName, extent, srsName){
        super('BBOX');
        /**
     * @type {!string}
     */ this.geometryName = geometryName;
        /**
     * @type {import("../../extent.js").Extent}
     */ this.extent = extent;
        if (extent.length !== 4) throw new Error('Expected an extent with four values ([minX, minY, maxX, maxY])');
        /**
     * @type {string|undefined}
     */ this.srsName = srsName;
    }
}
exports.default = Bbox;

},{"./Filter.js":"2hhow","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hofzr":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Contains
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spatialJs = require("./Spatial.js");
var _spatialJsDefault = parcelHelpers.interopDefault(_spatialJs);
/**
 * @classdesc
 * Represents a `<Contains>` operator to test whether a geometry-valued property
 * contains a given geometry.
 * @api
 */ class Contains extends (0, _spatialJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(geometryName, geometry, srsName){
        super('Contains', geometryName, geometry, srsName);
    }
}
exports.default = Contains;

},{"./Spatial.js":"fXoqW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fXoqW":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Spatial
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Represents a spatial operator to test whether a geometry-valued property
 * relates to a given geometry.
 *
 * @abstract
 */ class Spatial extends (0, _filterJsDefault.default) {
    /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(tagName, geometryName, geometry, srsName){
        super(tagName);
        /**
     * @type {!string}
     */ this.geometryName = geometryName || 'the_geom';
        /**
     * @type {import("../../geom/Geometry.js").default}
     */ this.geometry = geometry;
        /**
     * @type {string|undefined}
     */ this.srsName = srsName;
    }
}
exports.default = Spatial;

},{"./Filter.js":"2hhow","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7ubSK":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/DWithin
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spatialJs = require("./Spatial.js");
var _spatialJsDefault = parcelHelpers.interopDefault(_spatialJs);
/**
 * @classdesc
 * Represents a `<DWithin>` operator to test whether a geometry-valued property
 * is within a distance to a given geometry.
 * @api
 */ class DWithin extends (0, _spatialJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {!number} distance Distance.
   * @param {!string} unit Unit.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(geometryName, geometry, distance, unit, srsName){
        super('DWithin', geometryName, geometry, srsName);
        /**
     * @public
     * @type {!number}
     */ this.distance = distance;
        /**
     * @public
     * @type {!string}
     */ this.unit = unit;
    }
}
exports.default = DWithin;

},{"./Spatial.js":"fXoqW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g6GWJ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Disjoint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spatialJs = require("./Spatial.js");
var _spatialJsDefault = parcelHelpers.interopDefault(_spatialJs);
/**
 * @classdesc
 * Represents a `<Disjoint>` operator to test whether a geometry-valued property
 * is disjoint to a given geometry.
 * @api
 */ class Disjoint extends (0, _spatialJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(geometryName, geometry, srsName){
        super('Disjoint', geometryName, geometry, srsName);
    }
}
exports.default = Disjoint;

},{"./Spatial.js":"fXoqW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g4yvi":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/During
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonJs = require("./Comparison.js");
var _comparisonJsDefault = parcelHelpers.interopDefault(_comparisonJs);
/**
 * @classdesc
 * Represents a `<During>` comparison operator.
 * @api
 */ class During extends (0, _comparisonJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!string} begin The begin date in ISO-8601 format.
   * @param {!string} end The end date in ISO-8601 format.
   */ constructor(propertyName, begin, end){
        super('During', propertyName);
        /**
     * @type {!string}
     */ this.begin = begin;
        /**
     * @type {!string}
     */ this.end = end;
    }
}
exports.default = During;

},{"./Comparison.js":"hVvOT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hVvOT":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Comparison
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature property comparison filters.
 *
 * @abstract
 */ class Comparison extends (0, _filterJsDefault.default) {
    /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} propertyName Name of the context property to compare.
   */ constructor(tagName, propertyName){
        super(tagName);
        /**
     * @type {!string}
     */ this.propertyName = propertyName;
    }
}
exports.default = Comparison;

},{"./Filter.js":"2hhow","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f2psT":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/EqualTo
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsEqualTo>` comparison operator.
 * @api
 */ class EqualTo extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [matchCase] Case-sensitive?
   */ constructor(propertyName, expression, matchCase){
        super('PropertyIsEqualTo', propertyName, expression, matchCase);
    }
}
exports.default = EqualTo;

},{"./ComparisonBinary.js":"ijUSx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ijUSx":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/ComparisonBinary
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonJs = require("./Comparison.js");
var _comparisonJsDefault = parcelHelpers.interopDefault(_comparisonJs);
/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature property binary comparison filters.
 *
 * @abstract
 */ class ComparisonBinary extends (0, _comparisonJsDefault.default) {
    /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [matchCase] Case-sensitive?
   */ constructor(tagName, propertyName, expression, matchCase){
        super(tagName, propertyName);
        /**
     * @type {!(string|number)}
     */ this.expression = expression;
        /**
     * @type {boolean|undefined}
     */ this.matchCase = matchCase;
    }
}
exports.default = ComparisonBinary;

},{"./Comparison.js":"hVvOT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fmLtY":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/GreaterThan
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsGreaterThan>` comparison operator.
 * @api
 */ class GreaterThan extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */ constructor(propertyName, expression){
        super('PropertyIsGreaterThan', propertyName, expression);
    }
}
exports.default = GreaterThan;

},{"./ComparisonBinary.js":"ijUSx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9uPer":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/GreaterThanOrEqualTo
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.
 * @api
 */ class GreaterThanOrEqualTo extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */ constructor(propertyName, expression){
        super('PropertyIsGreaterThanOrEqualTo', propertyName, expression);
    }
}
exports.default = GreaterThanOrEqualTo;

},{"./ComparisonBinary.js":"ijUSx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aQX05":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Intersects
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spatialJs = require("./Spatial.js");
var _spatialJsDefault = parcelHelpers.interopDefault(_spatialJs);
/**
 * @classdesc
 * Represents a `<Intersects>` operator to test whether a geometry-valued property
 * intersects a given geometry.
 * @api
 */ class Intersects extends (0, _spatialJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(geometryName, geometry, srsName){
        super('Intersects', geometryName, geometry, srsName);
    }
}
exports.default = Intersects;

},{"./Spatial.js":"fXoqW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"999VA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/IsBetween
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonJs = require("./Comparison.js");
var _comparisonJsDefault = parcelHelpers.interopDefault(_comparisonJs);
/**
 * @classdesc
 * Represents a `<PropertyIsBetween>` comparison operator.
 * @api
 */ class IsBetween extends (0, _comparisonJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} lowerBoundary The lower bound of the range.
   * @param {!number} upperBoundary The upper bound of the range.
   */ constructor(propertyName, lowerBoundary, upperBoundary){
        super('PropertyIsBetween', propertyName);
        /**
     * @type {!number}
     */ this.lowerBoundary = lowerBoundary;
        /**
     * @type {!number}
     */ this.upperBoundary = upperBoundary;
    }
}
exports.default = IsBetween;

},{"./Comparison.js":"hVvOT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8TiPB":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/IsLike
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonJs = require("./Comparison.js");
var _comparisonJsDefault = parcelHelpers.interopDefault(_comparisonJs);
/**
 * @classdesc
 * Represents a `<PropertyIsLike>` comparison operator.
 * @api
 */ class IsLike extends (0, _comparisonJsDefault.default) {
    /**
   * [constructor description]
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!string} pattern Text pattern.
   * @param {string} [wildCard] Pattern character which matches any sequence of
   *    zero or more string characters. Default is '*'.
   * @param {string} [singleChar] pattern character which matches any single
   *    string character. Default is '.'.
   * @param {string} [escapeChar] Escape character which can be used to escape
   *    the pattern characters. Default is '!'.
   * @param {boolean} [matchCase] Case-sensitive?
   */ constructor(propertyName, pattern, wildCard, singleChar, escapeChar, matchCase){
        super('PropertyIsLike', propertyName);
        /**
     * @type {!string}
     */ this.pattern = pattern;
        /**
     * @type {!string}
     */ this.wildCard = wildCard !== undefined ? wildCard : '*';
        /**
     * @type {!string}
     */ this.singleChar = singleChar !== undefined ? singleChar : '.';
        /**
     * @type {!string}
     */ this.escapeChar = escapeChar !== undefined ? escapeChar : '!';
        /**
     * @type {boolean|undefined}
     */ this.matchCase = matchCase;
    }
}
exports.default = IsLike;

},{"./Comparison.js":"hVvOT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3llct":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/IsNull
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonJs = require("./Comparison.js");
var _comparisonJsDefault = parcelHelpers.interopDefault(_comparisonJs);
/**
 * @classdesc
 * Represents a `<PropertyIsNull>` comparison operator.
 * @api
 */ class IsNull extends (0, _comparisonJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   */ constructor(propertyName){
        super('PropertyIsNull', propertyName);
    }
}
exports.default = IsNull;

},{"./Comparison.js":"hVvOT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4u0Wj":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/LessThan
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsLessThan>` comparison operator.
 * @api
 */ class LessThan extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */ constructor(propertyName, expression){
        super('PropertyIsLessThan', propertyName, expression);
    }
}
exports.default = LessThan;

},{"./ComparisonBinary.js":"ijUSx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kdneA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/LessThanOrEqualTo
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsLessThanOrEqualTo>` comparison operator.
 * @api
 */ class LessThanOrEqualTo extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */ constructor(propertyName, expression){
        super('PropertyIsLessThanOrEqualTo', propertyName, expression);
    }
}
exports.default = LessThanOrEqualTo;

},{"./ComparisonBinary.js":"ijUSx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cgY9U":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Not
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
/**
 * @classdesc
 * Represents a logical `<Not>` operator for a filter condition.
 * @api
 */ class Not extends (0, _filterJsDefault.default) {
    /**
   * @param {!import("./Filter.js").default} condition Filter condition.
   */ constructor(condition){
        super('Not');
        /**
     * @type {!import("./Filter.js").default}
     */ this.condition = condition;
    }
}
exports.default = Not;

},{"./Filter.js":"2hhow","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6v2MZ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/NotEqualTo
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsNotEqualTo>` comparison operator.
 * @api
 */ class NotEqualTo extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [matchCase] Case-sensitive?
   */ constructor(propertyName, expression, matchCase){
        super('PropertyIsNotEqualTo', propertyName, expression, matchCase);
    }
}
exports.default = NotEqualTo;

},{"./ComparisonBinary.js":"ijUSx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5QE3I":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Or
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _logicalNaryJs = require("./LogicalNary.js");
var _logicalNaryJsDefault = parcelHelpers.interopDefault(_logicalNaryJs);
/**
 * @classdesc
 * Represents a logical `<Or>` operator between two or more filter conditions.
 * @api
 */ class Or extends (0, _logicalNaryJsDefault.default) {
    /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */ constructor(conditions){
        super('Or', Array.prototype.slice.call(arguments));
    }
}
exports.default = Or;

},{"./LogicalNary.js":"e8jG4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kP4sL":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/ResourceId
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
/**
 * @classdesc
 *
 * @abstract
 */ class ResourceId extends (0, _filterJsDefault.default) {
    /**
   * @param {!string} rid Resource ID.
   */ constructor(rid){
        super('ResourceId');
        /**
     * @type {!string}
     */ this.rid = rid;
    }
}
exports.default = ResourceId;

},{"./Filter.js":"2hhow","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"GweRX":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Within
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spatialJs = require("./Spatial.js");
var _spatialJsDefault = parcelHelpers.interopDefault(_spatialJs);
/**
 * @classdesc
 * Represents a `<Within>` operator to test whether a geometry-valued property
 * is within a given geometry.
 * @api
 */ class Within extends (0, _spatialJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(geometryName, geometry, srsName){
        super('Within', geometryName, geometry, srsName);
    }
}
exports.default = Within;

},{"./Spatial.js":"fXoqW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9jWnV":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/GeoJSON
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _jsonfeatureJs = require("./JSONFeature.js");
var _jsonfeatureJsDefault = parcelHelpers.interopDefault(_jsonfeatureJs);
var _featureJs1 = require("../render/Feature.js");
var _featureJsDefault1 = parcelHelpers.interopDefault(_featureJs1);
var _featureJs2 = require("./Feature.js");
var _deflateJs = require("../geom/flat/deflate.js");
var _simpleGeometryJs = require("../geom/SimpleGeometry.js");
var _projJs = require("../proj.js");
var _objJs = require("../obj.js");
/**
 * @typedef {import("geojson").GeoJSON} GeoJSONObject
 * @typedef {import("geojson").Feature} GeoJSONFeature
 * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
 * @typedef {import("geojson").Geometry} GeoJSONGeometry
 * @typedef {import("geojson").Point} GeoJSONPoint
 * @typedef {import("geojson").LineString} GeoJSONLineString
 * @typedef {import("geojson").Polygon} GeoJSONPolygon
 * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
 * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
 * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
 * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
 */ /**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
 * written by the format.  Options passed to read or write methods will take precedence.
 * @property {string} [geometryName] Geometry name to use when creating features.
 * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
 * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
 * will look for that field to set the geometry name. If both this field is set to `true`
 * and a `geometryName` is provided, the `geometryName` will take precedence.
 * @property {import("../Feature.js").FeatureClass} [featureClass] Feature class
 * to be used when reading features. The default is {@link module:ol/Feature~Feature}. If performance is
 * the primary concern, and features are not going to be modified or round-tripped through the format,
 * consider using {@link module:ol/render/Feature~RenderFeature}
 */ /**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @api
 */ class GeoJSON extends (0, _jsonfeatureJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super();
        /**
     * @type {import("../proj/Projection.js").default}
     */ this.dataProjection = (0, _projJs.get)(options.dataProjection ? options.dataProjection : 'EPSG:4326');
        if (options.featureProjection) /**
       * @type {import("../proj/Projection.js").default}
       */ this.defaultFeatureProjection = (0, _projJs.get)(options.featureProjection);
        if (options.featureClass) this.featureClass = options.featureClass;
        /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */ this.geometryName_ = options.geometryName;
        /**
     * Look for the geometry name in the feature GeoJSON
     * @type {boolean|undefined}
     * @private
     */ this.extractGeometryName_ = options.extractGeometryName;
        this.supportedMediaTypes = [
            'application/geo+json',
            'application/vnd.geo+json'
        ];
    }
    /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Feature|RenderFeature|Array<RenderFeature>}.default} Feature.
   */ readFeatureFromObject(object, options) {
        /**
     * @type {GeoJSONFeature}
     */ let geoJSONFeature = null;
        if (object['type'] === 'Feature') geoJSONFeature = /** @type {GeoJSONFeature} */ object;
        else geoJSONFeature = {
            'type': 'Feature',
            'geometry': /** @type {GeoJSONGeometry} */ object,
            'properties': null
        };
        const geometry = readGeometryInternal(geoJSONFeature['geometry'], options);
        if (this.featureClass === (0, _featureJsDefault1.default)) return (0, _featureJs2.createRenderFeature)({
            geometry,
            id: geoJSONFeature['id'],
            properties: geoJSONFeature['properties']
        }, options);
        const feature = new (0, _featureJsDefault.default)();
        if (this.geometryName_) feature.setGeometryName(this.geometryName_);
        else if (this.extractGeometryName_ && true) feature.setGeometryName(geoJSONFeature['geometry_name']);
        feature.setGeometry((0, _featureJs2.createGeometry)(geometry, options));
        if ('id' in geoJSONFeature) feature.setId(geoJSONFeature['id']);
        if (geoJSONFeature['properties']) feature.setProperties(geoJSONFeature['properties'], true);
        return feature;
    }
    /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature|RenderFeature>} Features.
   */ readFeaturesFromObject(object, options) {
        const geoJSONObject = /** @type {GeoJSONObject} */ object;
        /** @type {Array<Feature|RenderFeature|Array<RenderFeature>>} */ let features = null;
        if (geoJSONObject['type'] === 'FeatureCollection') {
            const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ object;
            features = [];
            const geoJSONFeatures = geoJSONFeatureCollection['features'];
            for(let i = 0, ii = geoJSONFeatures.length; i < ii; ++i){
                const featureObject = this.readFeatureFromObject(geoJSONFeatures[i], options);
                if (!featureObject) continue;
                features.push(featureObject);
            }
        } else features = [
            this.readFeatureFromObject(object, options)
        ];
        return features.flat();
    }
    /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromObject(object, options) {
        return readGeometry(object, options);
    }
    /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromObject(object) {
        const crs = object['crs'];
        let projection;
        if (crs) {
            if (crs['type'] == 'name') projection = (0, _projJs.get)(crs['properties']['name']);
            else if (crs['type'] === 'EPSG') projection = (0, _projJs.get)('EPSG:' + crs['properties']['code']);
            else throw new Error('Unknown SRS type');
        } else projection = this.dataProjection;
        return /** @type {import("../proj/Projection.js").default} */ projection;
    }
    /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */ writeFeatureObject(feature, options) {
        options = this.adaptOptions(options);
        /** @type {GeoJSONFeature} */ const object = {
            'type': 'Feature',
            geometry: null,
            properties: null
        };
        const id = feature.getId();
        if (id !== undefined) object.id = id;
        if (!feature.hasProperties()) return object;
        const properties = feature.getProperties();
        const geometry = feature.getGeometry();
        if (geometry) {
            object.geometry = writeGeometry(geometry, options);
            delete properties[feature.getGeometryName()];
        }
        if (!(0, _objJs.isEmpty)(properties)) object.properties = properties;
        return object;
    }
    /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */ writeFeaturesObject(features, options) {
        options = this.adaptOptions(options);
        const objects = [];
        for(let i = 0, ii = features.length; i < ii; ++i)objects.push(this.writeFeatureObject(features[i], options));
        return {
            type: 'FeatureCollection',
            features: objects
        };
    }
    /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */ writeGeometryObject(geometry, options) {
        return writeGeometry(geometry, this.adaptOptions(options));
    }
}
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("./Feature.js").GeometryObject} Geometry.
 */ function readGeometryInternal(object, options) {
    if (!object) return null;
    /** @type {import("./Feature.js").GeometryObject} */ let geometry;
    switch(object['type']){
        case 'Point':
            geometry = readPointGeometry(/** @type {GeoJSONPoint} */ object);
            break;
        case 'LineString':
            geometry = readLineStringGeometry(/** @type {GeoJSONLineString} */ object);
            break;
        case 'Polygon':
            geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ object);
            break;
        case 'MultiPoint':
            geometry = readMultiPointGeometry(/** @type {GeoJSONMultiPoint} */ object);
            break;
        case 'MultiLineString':
            geometry = readMultiLineStringGeometry(/** @type {GeoJSONMultiLineString} */ object);
            break;
        case 'MultiPolygon':
            geometry = readMultiPolygonGeometry(/** @type {GeoJSONMultiPolygon} */ object);
            break;
        case 'GeometryCollection':
            geometry = readGeometryCollectionGeometry(/** @type {GeoJSONGeometryCollection} */ object);
            break;
        default:
            throw new Error('Unsupported GeoJSON type: ' + object['type']);
    }
    return geometry;
}
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */ function readGeometry(object, options) {
    const geometryObject = readGeometryInternal(object, options);
    return (0, _featureJs2.createGeometry)(geometryObject, options);
}
/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("./Feature.js").GeometryCollectionObject} Geometry collection.
 */ function readGeometryCollectionGeometry(object, options) {
    const geometries = object['geometries'].map(/**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */ function(geometry) {
        return readGeometryInternal(geometry, options);
    });
    return geometries;
}
/**
 * @param {GeoJSONPoint} object Input object.
 * @return {import("./Feature.js").GeometryObject} Point geometry.
 */ function readPointGeometry(object) {
    const flatCoordinates = object['coordinates'];
    return {
        type: 'Point',
        flatCoordinates,
        layout: (0, _simpleGeometryJs.getLayoutForStride)(flatCoordinates.length)
    };
}
/**
 * @param {GeoJSONLineString} object Object.
 * @return {import("./Feature.js").GeometryObject} LineString geometry.
 */ function readLineStringGeometry(object) {
    const coordinates = object['coordinates'];
    const flatCoordinates = coordinates.flat();
    return {
        type: 'LineString',
        flatCoordinates,
        ends: [
            flatCoordinates.length
        ],
        layout: (0, _simpleGeometryJs.getLayoutForStride)(coordinates[0].length)
    };
}
/**
 * @param {GeoJSONMultiLineString} object Object.
 * @return {import("./Feature.js").GeometryObject} MultiLineString geometry.
 */ function readMultiLineStringGeometry(object) {
    const coordinates = object['coordinates'];
    const stride = coordinates[0][0].length;
    const flatCoordinates = [];
    const ends = (0, _deflateJs.deflateCoordinatesArray)(flatCoordinates, 0, coordinates, stride);
    return {
        type: 'MultiLineString',
        flatCoordinates,
        ends,
        layout: (0, _simpleGeometryJs.getLayoutForStride)(stride)
    };
}
/**
 * @param {GeoJSONMultiPoint} object Object.
 * @return {import("./Feature.js").GeometryObject} MultiPoint geometry.
 */ function readMultiPointGeometry(object) {
    const coordinates = object['coordinates'];
    return {
        type: 'MultiPoint',
        flatCoordinates: coordinates.flat(),
        layout: (0, _simpleGeometryJs.getLayoutForStride)(coordinates[0].length)
    };
}
/**
 * @param {GeoJSONMultiPolygon} object Object.
 * @return {import("./Feature.js").GeometryObject} MultiPolygon geometry.
 */ function readMultiPolygonGeometry(object) {
    const coordinates = object['coordinates'];
    const flatCoordinates = [];
    const stride = coordinates[0][0][0].length;
    const endss = (0, _deflateJs.deflateMultiCoordinatesArray)(flatCoordinates, 0, coordinates, stride);
    return {
        type: 'MultiPolygon',
        flatCoordinates,
        ends: endss,
        layout: (0, _simpleGeometryJs.getLayoutForStride)(stride)
    };
}
/**
 * @param {GeoJSONPolygon} object Object.
 * @return {import("./Feature.js").GeometryObject} Polygon.
 */ function readPolygonGeometry(object) {
    const coordinates = object['coordinates'];
    const flatCoordinates = [];
    const stride = coordinates[0][0].length;
    const ends = (0, _deflateJs.deflateCoordinatesArray)(flatCoordinates, 0, coordinates, stride);
    return {
        type: 'Polygon',
        flatCoordinates,
        ends,
        layout: (0, _simpleGeometryJs.getLayoutForStride)(stride)
    };
}
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeGeometry(geometry, options) {
    geometry = (0, _featureJs2.transformGeometryWithOptions)(geometry, true, options);
    const type = geometry.getType();
    /** @type {GeoJSONGeometry} */ let geoJSON;
    switch(type){
        case 'Point':
            geoJSON = writePointGeometry(/** @type {import("../geom/Point.js").default} */ geometry, options);
            break;
        case 'LineString':
            geoJSON = writeLineStringGeometry(/** @type {import("../geom/LineString.js").default} */ geometry, options);
            break;
        case 'Polygon':
            geoJSON = writePolygonGeometry(/** @type {import("../geom/Polygon.js").default} */ geometry, options);
            break;
        case 'MultiPoint':
            geoJSON = writeMultiPointGeometry(/** @type {import("../geom/MultiPoint.js").default} */ geometry, options);
            break;
        case 'MultiLineString':
            geoJSON = writeMultiLineStringGeometry(/** @type {import("../geom/MultiLineString.js").default} */ geometry, options);
            break;
        case 'MultiPolygon':
            geoJSON = writeMultiPolygonGeometry(/** @type {import("../geom/MultiPolygon.js").default} */ geometry, options);
            break;
        case 'GeometryCollection':
            geoJSON = writeGeometryCollectionGeometry(/** @type {import("../geom/GeometryCollection.js").default} */ geometry, options);
            break;
        case 'Circle':
            geoJSON = {
                type: 'GeometryCollection',
                geometries: []
            };
            break;
        default:
            throw new Error('Unsupported geometry type: ' + type);
    }
    return geoJSON;
}
/**
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */ function writeGeometryCollectionGeometry(geometry, options) {
    options = Object.assign({}, options);
    delete options.featureProjection;
    const geometries = geometry.getGeometriesArray().map(function(geometry) {
        return writeGeometry(geometry, options);
    });
    return {
        type: 'GeometryCollection',
        geometries: geometries
    };
}
/**
 * @param {import("../geom/LineString.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeLineStringGeometry(geometry, options) {
    return {
        type: 'LineString',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiLineStringGeometry(geometry, options) {
    return {
        type: 'MultiLineString',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiPointGeometry(geometry, options) {
    return {
        type: 'MultiPoint',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiPolygonGeometry(geometry, options) {
    let right;
    if (options) right = options.rightHanded;
    return {
        type: 'MultiPolygon',
        coordinates: geometry.getCoordinates(right)
    };
}
/**
 * @param {import("../geom/Point.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writePointGeometry(geometry, options) {
    return {
        type: 'Point',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/Polygon.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writePolygonGeometry(geometry, options) {
    let right;
    if (options) right = options.rightHanded;
    return {
        type: 'Polygon',
        coordinates: geometry.getCoordinates(right)
    };
}
exports.default = GeoJSON;

},{"../Feature.js":"3qocF","./JSONFeature.js":"iWcPA","../render/Feature.js":"dtdcp","./Feature.js":"arwL9","../geom/flat/deflate.js":"is4mF","../geom/SimpleGeometry.js":"iZYIt","../proj.js":"8OK47","../obj.js":"7RZD4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iWcPA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/JSONFeature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _featureJs = require("./Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _utilJs = require("../util.js");
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @abstract
 */ class JSONFeature extends (0, _featureJsDefault.default) {
    constructor(){
        super();
    }
    /**
   * @return {import("./Feature.js").Type} Format.
   */ getType() {
        return 'json';
    }
    /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike|Array<import("../render/Feature.js").default>} Feature.
   * @api
   */ readFeature(source, options) {
        return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */ readFeatures(source, options) {
        return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default|import("../render/Feature.js").default|Array<import("../render/Feature.js").default>} Feature.
   */ readFeatureFromObject(object, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default|import("../render/Feature.js").default>} Features.
   */ readFeaturesFromObject(object, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */ readGeometry(source, options) {
        return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromObject(object, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */ readProjection(source) {
        return this.readProjectionFromObject(getObject(source));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromObject(object) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */ writeFeature(feature, options) {
        return JSON.stringify(this.writeFeatureObject(feature, options));
    }
    /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeFeatureObject(feature, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */ writeFeatures(features, options) {
        return JSON.stringify(this.writeFeaturesObject(features, options));
    }
    /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeFeaturesObject(features, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */ writeGeometry(geometry, options) {
        return JSON.stringify(this.writeGeometryObject(geometry, options));
    }
    /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeGeometryObject(geometry, options) {
        return (0, _utilJs.abstract)();
    }
}
/**
 * @param {Document|Element|Object|string} source Source.
 * @return {Object} Object.
 */ function getObject(source) {
    if (typeof source === 'string') {
        const object = JSON.parse(source);
        return object ? /** @type {Object} */ object : null;
    }
    if (source !== null) return source;
    return null;
}
exports.default = JSONFeature;

},{"./Feature.js":"arwL9","../util.js":"l1iPW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8l3Ji":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadWms", ()=>loadWms);
var _tile = require("ol/layer/Tile");
var _tileDefault = parcelHelpers.interopDefault(_tile);
var _tileWMS = require("ol/source/TileWMS");
var _tileWMSDefault = parcelHelpers.interopDefault(_tileWMS);
function loadWms(geoserverURL, layer_name, workspace) {
    const url = geoserverURL + "/wms";
    console.log("Hello from function ");
    const layer = new (0, _tileDefault.default)({
        source: new (0, _tileWMSDefault.default)({
            url: url,
            params: {
                "LAYERS": workspace + ":" + layer_name,
                "TILED": true
            },
            serverType: "geoserver",
            transition: 0
        }),
        title: "wms-layer-" + layer_name
    });
    return layer;
}

},{"ol/layer/Tile":"8sJWw","ol/source/TileWMS":"97DKw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"97DKw":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/TileWMS
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tileImageJs = require("./TileImage.js");
var _tileImageJsDefault = parcelHelpers.interopDefault(_tileImageJs);
var _wmsJs = require("./wms.js");
var _uriJs = require("../uri.js");
var _extentJs = require("../extent.js");
var _reprojJs = require("../reproj.js");
var _stringJs = require("../string.js");
var _projJs = require("../proj.js");
var _mathJs = require("../math.js");
var _tilecoordJs = require("../tilecoord.js");
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {number} [gutter=0]
 * The size in pixels of the gutter around image tiles to ignore. By setting
 * this property to a non-zero value, images will be requested that are wider
 * and taller than the tile size by a value of `2 x gutter`.
 * Using a non-zero value allows artifacts of rendering at tile edges to be
 * ignored. If you control the WMS service it is recommended to address
 * "artifacts at tile edges" issues by properly configuring the WMS service. For
 * example, MapServer has a `tile_map_edge_buffer` configuration parameter for
 * this. See https://mapserver.org/output/tile_mode.html.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used.
 * @property {import("./wms.js").ServerType} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
 * Only needed if `hidpi` is `true`.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] WMS service URL.
 * @property {Array<string>} [urls] WMS service urls.
 * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When `true`, tiles will be requested for one world only,
 * but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */ /**
 * @classdesc
 * Layer source for tile data from WMS servers.
 * @api
 */ class TileWMS extends (0, _tileImageJsDefault.default) {
    /**
   * @param {Options} [options] Tile WMS options.
   */ constructor(options){
        options = options ? options : /** @type {Options} */ {};
        const params = Object.assign({}, options.params);
        const transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;
        super({
            attributions: options.attributions,
            attributionsCollapsible: options.attributionsCollapsible,
            cacheSize: options.cacheSize,
            crossOrigin: options.crossOrigin,
            interpolate: options.interpolate,
            opaque: !transparent,
            projection: options.projection,
            reprojectionErrorThreshold: options.reprojectionErrorThreshold,
            tileClass: options.tileClass,
            tileGrid: options.tileGrid,
            tileLoadFunction: options.tileLoadFunction,
            url: options.url,
            urls: options.urls,
            wrapX: options.wrapX !== undefined ? options.wrapX : true,
            transition: options.transition,
            zDirection: options.zDirection
        });
        /**
     * @private
     * @type {number}
     */ this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
        /**
     * @private
     * @type {!Object}
     */ this.params_ = params;
        /**
     * @private
     * @type {boolean}
     */ this.v13_ = true;
        /**
     * @private
     * @type {import("./wms.js").ServerType}
     */ this.serverType_ = options.serverType;
        /**
     * @private
     * @type {boolean}
     */ this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.tmpExtent_ = (0, _extentJs.createEmpty)();
        this.updateV13_();
        this.setKey(this.getKeyForParams_());
    }
    /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */ getFeatureInfoUrl(coordinate, resolution, projection, params) {
        const projectionObj = (0, _projJs.get)(projection);
        const sourceProjectionObj = this.getProjection() || projectionObj;
        let tileGrid = this.getTileGrid();
        if (!tileGrid) tileGrid = this.getTileGridForProjection(sourceProjectionObj);
        const sourceProjCoord = (0, _projJs.transform)(coordinate, projectionObj, sourceProjectionObj);
        const sourceResolution = (0, _reprojJs.calculateSourceResolution)(sourceProjectionObj, projectionObj, coordinate, resolution);
        const z = tileGrid.getZForResolution(sourceResolution, this.zDirection);
        const tileResolution = tileGrid.getResolution(z);
        const tileCoord = tileGrid.getTileCoordForCoordAndZ(sourceProjCoord, z);
        if (tileGrid.getResolutions().length <= tileCoord[0]) return undefined;
        let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
        const gutter = this.gutter_;
        if (gutter !== 0) tileExtent = (0, _extentJs.buffer)(tileExtent, tileResolution * gutter, tileExtent);
        const baseParams = {
            'QUERY_LAYERS': this.params_['LAYERS']
        };
        Object.assign(baseParams, (0, _wmsJs.getRequestParams)(this.params_, 'GetFeatureInfo'), params);
        const x = Math.floor((sourceProjCoord[0] - tileExtent[0]) / tileResolution);
        const y = Math.floor((tileExtent[3] - sourceProjCoord[1]) / tileResolution);
        baseParams[this.v13_ ? 'I' : 'X'] = x;
        baseParams[this.v13_ ? 'J' : 'Y'] = y;
        return this.getRequestUrl_(tileCoord, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
    }
    /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */ getLegendUrl(resolution, params) {
        if (this.urls[0] === undefined) return undefined;
        const baseParams = {
            'SERVICE': 'WMS',
            'VERSION': (0, _wmsJs.DEFAULT_VERSION),
            'REQUEST': 'GetLegendGraphic',
            'FORMAT': 'image/png'
        };
        if (params === undefined || params['LAYER'] === undefined) {
            const layers = this.params_.LAYERS;
            const isSingleLayer = !Array.isArray(layers) || layers.length === 1;
            if (!isSingleLayer) return undefined;
            baseParams['LAYER'] = layers;
        }
        if (resolution !== undefined) {
            const mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
            const pixelSize = 0.00028;
            baseParams['SCALE'] = resolution * mpu / pixelSize;
        }
        Object.assign(baseParams, params);
        return (0, _uriJs.appendParams)(/** @type {string} */ this.urls[0], baseParams);
    }
    /**
   * @return {number} Gutter.
   */ getGutter() {
        return this.gutter_;
    }
    /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */ getParams() {
        return this.params_;
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */ getRequestUrl_(tileCoord, tileExtent, pixelRatio, projection, params) {
        const urls = this.urls;
        if (!urls) return undefined;
        let url;
        if (urls.length == 1) url = urls[0];
        else {
            const index = (0, _mathJs.modulo)((0, _tilecoordJs.hash)(tileCoord), urls.length);
            url = urls[index];
        }
        return (0, _wmsJs.getImageSrc)(tileExtent, (this.tileGrid || this.getTileGridForProjection(projection)).getResolution(tileCoord[0]), pixelRatio, projection, url, params, this.serverType_);
    }
    /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */ getTilePixelRatio(pixelRatio) {
        return !this.hidpi_ || this.serverType_ === undefined ? 1 : pixelRatio;
    }
    /**
   * @private
   * @return {string} The key for the current params.
   */ getKeyForParams_() {
        let i = 0;
        const res = [];
        for(const key in this.params_)res[i++] = key + '-' + this.params_[key];
        return res.join('/');
    }
    /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */ updateParams(params) {
        Object.assign(this.params_, params);
        this.updateV13_();
        this.setKey(this.getKeyForParams_());
    }
    /**
   * @private
   */ updateV13_() {
        const version = this.params_['VERSION'] || (0, _wmsJs.DEFAULT_VERSION);
        this.v13_ = (0, _stringJs.compareVersions)(version, '1.3') >= 0;
    }
    /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */ tileUrlFunction(tileCoord, pixelRatio, projection) {
        let tileGrid = this.getTileGrid();
        if (!tileGrid) tileGrid = this.getTileGridForProjection(projection);
        if (tileGrid.getResolutions().length <= tileCoord[0]) return undefined;
        if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) pixelRatio = 1;
        const tileResolution = tileGrid.getResolution(tileCoord[0]);
        let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
        const gutter = this.gutter_;
        if (gutter !== 0) tileExtent = (0, _extentJs.buffer)(tileExtent, tileResolution * gutter, tileExtent);
        const baseParams = Object.assign({}, (0, _wmsJs.getRequestParams)(this.params_, 'GetMap'));
        return this.getRequestUrl_(tileCoord, tileExtent, pixelRatio, projection, baseParams);
    }
}
exports.default = TileWMS;

},{"./TileImage.js":"kLfUI","./wms.js":"ldTfv","../uri.js":"fEC4D","../extent.js":"bGUel","../reproj.js":"i3wKe","../string.js":"3uF0z","../proj.js":"8OK47","../math.js":"d8zSj","../tilecoord.js":"ksONy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ldTfv":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/wms
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_VERSION", ()=>DEFAULT_VERSION);
/**
 * @api
 * @typedef {'carmentaserver' | 'geoserver' | 'mapserver' | 'qgis'} ServerType
 * Set the server type to use implementation-specific parameters beyond the WMS specification.
 *  - `'carmentaserver'`: HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
 *  - `'geoserver'`: HiDPI support for [GeoServer](https://geoserver.org/)
 *  - `'mapserver'`: HiDPI support for [MapServer](https://mapserver.org/)
 *  - `'qgis'`: HiDPI support for [QGIS](https://qgis.org/)
 */ /**
 * @param {string} baseUrl Base URL.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {import("../size.js").Size} size Size.
 * @param {import("../proj/Projection.js").default} projection Projection.
 * @param {Object} params WMS params. Will be modified in place.
 * @return {string} Request URL.
 */ parcelHelpers.export(exports, "getRequestUrl", ()=>getRequestUrl);
/**
 * @param {import("../extent").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio pixel ratio.
 * @param {import("../proj.js").Projection} projection Projection.
 * @param {string} url WMS service url.
 * @param {Object} params WMS params.
 * @param {import("./wms.js").ServerType} serverType The type of the remote WMS server.
 * @return {string} Image src.
 */ parcelHelpers.export(exports, "getImageSrc", ()=>getImageSrc);
/**
 * @param {Object} params WMS params.
 * @param {string} request WMS `REQUEST`.
 * @return {Object} WMS params with required properties set.
 */ parcelHelpers.export(exports, "getRequestParams", ()=>getRequestParams);
/**
 * @typedef {Object} LoaderOptions
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {Object<string,*>} [params] WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT` and `BBOX` will be set
 * dynamically. `CRS` (`SRS` for WMS version < 1.3.0) will is derived from the `proection` config.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is 'EPSG:3857'.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {import("./wms.js").ServerType} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.
 * Only needed if `hidpi` is `true`.
 * @property {string} url WMS service URL.
 * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function
 * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and
 * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.
 */ /**
 * Creates a loader for WMS images.
 * @param {LoaderOptions} options Loader options.
 * @return {import("../Image.js").ImageObjectPromiseLoader} Loader.
 * @api
 */ parcelHelpers.export(exports, "createLoader", ()=>createLoader);
/**
 * Get the GetFeatureInfo URL for the passed coordinate and resolution. Returns `undefined` if the
 * GetFeatureInfo URL cannot be constructed.
 * @param {LoaderOptions} options Options passed the `createWMSLoader()` function. In addition to
 * the params required by the loader, `INFO_FORMAT` should be specified, it defaults to
 * `application/json`. If `QUERY_LAYERS` is not provided, then the layers specified in the `LAYERS`
 * parameter will be used.
 * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @return {string|undefined} GetFeatureInfo URL.
 * @api
 */ parcelHelpers.export(exports, "getFeatureInfoUrl", ()=>getFeatureInfoUrl);
/**
 * Get the GetLegendGraphic URL, optionally optimized for the passed resolution and possibly
 * including any passed specific parameters. Returns `undefined` if the GetLegendGraphic URL
 * cannot be constructed.
 *
 * @param {LoaderOptions} options Options passed the `createWMSLoader()` function.
 * @param {number} [resolution] Resolution. If not provided, `SCALE` will not be calculated and
 * included in URL.
 * @return {string|undefined} GetLegendGraphic URL.
 * @api
 */ parcelHelpers.export(exports, "getLegendUrl", ()=>getLegendUrl);
var _commonJs = require("./common.js");
var _uriJs = require("../uri.js");
var _stringJs = require("../string.js");
var _imageJs = require("../Image.js");
var _mathJs = require("../math.js");
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _imageJs1 = require("./Image.js");
const DEFAULT_VERSION = '1.3.0';
/**
 * @const
 * @type {import("../size.js").Size}
 */ const GETFEATUREINFO_IMAGE_SIZE = [
    101,
    101
];
function getRequestUrl(baseUrl, extent, size, projection, params) {
    params['WIDTH'] = size[0];
    params['HEIGHT'] = size[1];
    const axisOrientation = projection.getAxisOrientation();
    let bbox;
    const v13 = (0, _stringJs.compareVersions)(params['VERSION'], '1.3') >= 0;
    params[v13 ? 'CRS' : 'SRS'] = projection.getCode();
    if (v13 && axisOrientation.substr(0, 2) == 'ne') bbox = [
        extent[1],
        extent[0],
        extent[3],
        extent[2]
    ];
    else bbox = extent;
    params['BBOX'] = bbox.join(',');
    return (0, _uriJs.appendParams)(/** @type {string} */ baseUrl, params);
}
function getImageSrc(extent, resolution, pixelRatio, projection, url, params, serverType) {
    params = Object.assign({
        REQUEST: 'GetMap'
    }, params);
    const imageResolution = resolution / pixelRatio;
    const imageSize = [
        (0, _mathJs.round)((0, _extentJs.getWidth)(extent) / imageResolution, (0, _commonJs.DECIMALS)),
        (0, _mathJs.round)((0, _extentJs.getHeight)(extent) / imageResolution, (0, _commonJs.DECIMALS))
    ];
    if (pixelRatio != 1) switch(serverType){
        case 'geoserver':
            const dpi = 90 * pixelRatio + 0.5 | 0;
            if ('FORMAT_OPTIONS' in params) params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
            else params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
            break;
        case 'mapserver':
            params['MAP_RESOLUTION'] = 90 * pixelRatio;
            break;
        case 'carmentaserver':
        case 'qgis':
            params['DPI'] = 90 * pixelRatio;
            break;
        default:
            throw new Error('Unknown `serverType` configured');
    }
    const src = getRequestUrl(url, extent, imageSize, projection, params);
    return src;
}
function getRequestParams(params, request) {
    return Object.assign({
        'REQUEST': request,
        'SERVICE': 'WMS',
        'VERSION': DEFAULT_VERSION,
        'FORMAT': 'image/png',
        'STYLES': '',
        'TRANSPARENT': true
    }, params);
}
function createLoader(options) {
    const hidpi = options.hidpi === undefined ? true : options.hidpi;
    const projection = (0, _projJs.get)(options.projection || 'EPSG:3857');
    const ratio = options.ratio || 1.5;
    const load = options.load || (0, _imageJs.decode);
    /**
   * @type {import("../Image.js").Loader}
   */ return (extent, resolution, pixelRatio)=>{
        extent = (0, _imageJs1.getRequestExtent)(extent, resolution, pixelRatio, ratio);
        if (pixelRatio != 1 && (!hidpi || options.serverType === undefined)) pixelRatio = 1;
        const src = getImageSrc(extent, resolution, pixelRatio, projection, options.url, getRequestParams(options.params, 'GetMap'), options.serverType);
        const image = new Image();
        if (options.crossOrigin !== null) image.crossOrigin = options.crossOrigin;
        return load(image, src).then((image)=>({
                image,
                extent,
                pixelRatio
            }));
    };
}
function getFeatureInfoUrl(options, coordinate, resolution) {
    if (options.url === undefined) return undefined;
    const projectionObj = (0, _projJs.get)(options.projection || 'EPSG:3857');
    const extent = (0, _extentJs.getForViewAndSize)(coordinate, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);
    const baseParams = {
        'QUERY_LAYERS': options.params['LAYERS'],
        'INFO_FORMAT': 'application/json'
    };
    Object.assign(baseParams, getRequestParams(options.params, 'GetFeatureInfo'), options.params);
    const x = (0, _mathJs.floor)((coordinate[0] - extent[0]) / resolution, (0, _commonJs.DECIMALS));
    const y = (0, _mathJs.floor)((extent[3] - coordinate[1]) / resolution, (0, _commonJs.DECIMALS));
    const v13 = (0, _stringJs.compareVersions)(baseParams['VERSION'], '1.3') >= 0;
    baseParams[v13 ? 'I' : 'X'] = x;
    baseParams[v13 ? 'J' : 'Y'] = y;
    return getRequestUrl(options.url, extent, GETFEATUREINFO_IMAGE_SIZE, projectionObj, baseParams);
}
function getLegendUrl(options, resolution) {
    if (options.url === undefined) return undefined;
    const baseParams = {
        'SERVICE': 'WMS',
        'VERSION': DEFAULT_VERSION,
        'REQUEST': 'GetLegendGraphic',
        'FORMAT': 'image/png'
    };
    if (options.params === undefined || options.params['LAYER'] === undefined) {
        const layers = options.params.LAYERS;
        const isSingleLayer = !Array.isArray(layers) || layers.length === 1;
        if (!isSingleLayer) return undefined;
        baseParams['LAYER'] = layers;
    }
    if (resolution !== undefined) {
        const mpu = (0, _projJs.get)(options.projection || 'EPSG:3857').getMetersPerUnit() || 1;
        const pixelSize = 0.00028;
        baseParams['SCALE'] = resolution * mpu / pixelSize;
    }
    Object.assign(baseParams, options.params);
    return (0, _uriJs.appendParams)(options.url, baseParams);
}

},{"./common.js":"47QSt","../uri.js":"fEC4D","../string.js":"3uF0z","../Image.js":"7I8uM","../math.js":"d8zSj","../extent.js":"bGUel","../proj.js":"8OK47","./Image.js":"fGOvH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"47QSt":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/common
 */ /**
 * Default WMS version.
 * @type {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_WMS_VERSION", ()=>DEFAULT_WMS_VERSION);
parcelHelpers.export(exports, "DECIMALS", ()=>DECIMALS);
const DEFAULT_WMS_VERSION = '1.3.0';
const DECIMALS = 4;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fEC4D":[function(require,module,exports,__globalThis) {
/**
 * @module ol/uri
 */ /**
 * Appends query parameters to a URI.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object} params An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.
 * @return {string} The new URI.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "appendParams", ()=>appendParams);
function appendParams(uri, params) {
    /** @type {Array<string>} */ const keyParams = [];
    // Skip any null or undefined parameter values
    Object.keys(params).forEach(function(k) {
        if (params[k] !== null && params[k] !== undefined) keyParams.push(k + '=' + encodeURIComponent(params[k]));
    });
    const qs = keyParams.join('&');
    // remove any trailing ? or &
    uri = uri.replace(/[?&]$/, '');
    // append ? or & depending on whether uri has existing parameters
    uri += uri.includes('?') ? '&' : '?';
    return uri + qs;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fGOvH":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ImageSourceEventType", ()=>ImageSourceEventType);
/**
 * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this
 * type.
 */ parcelHelpers.export(exports, "ImageSourceEvent", ()=>ImageSourceEvent);
/**
 * Default image load function for image sources that use import("../Image.js").Image image
 * instances.
 * @param {import("../Image.js").default} image Image.
 * @param {string} src Source.
 */ parcelHelpers.export(exports, "defaultImageLoadFunction", ()=>defaultImageLoadFunction);
/**
 * Adjusts the extent so it aligns with pixel boundaries.
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {number} resolution Reolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} ratio Ratio between request size and view size.
 * @return {import("../extent.js").Extent} Request extent.
 */ parcelHelpers.export(exports, "getRequestExtent", ()=>getRequestExtent);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("../Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _imageJs1 = require("../reproj/Image.js");
var _imageJsDefault1 = parcelHelpers.interopDefault(_imageJs1);
var _sourceJs = require("./Source.js");
var _sourceJsDefault = parcelHelpers.interopDefault(_sourceJs);
var _commonJs = require("./common.js");
var _mathJs = require("../math.js");
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _resolutionJs = require("../resolution.js");
var _arrayJs = require("../array.js");
const ImageSourceEventType = {
    /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */ IMAGELOADSTART: 'imageloadstart',
    /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */ IMAGELOADEND: 'imageloadend',
    /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */ IMAGELOADERROR: 'imageloaderror'
};
class ImageSourceEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */ constructor(type, image){
        super(type);
        /**
     * The image related to the event.
     * @type {import("../Image.js").default}
     * @api
     */ this.image = image;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../Image.js").Loader} [loader] Loader. Can either be a custom loader, or one of the
 * loaders created with a `createLoader()` function ({@link module:ol/source/wms.createLoader wms},
 * {@link module:ol/source/arcgisRest.createLoader arcgisRest}, {@link module:ol/source/mapguide.createLoader mapguide},
 * {@link module:ol/source/static.createLoader static}).
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {Array<number>} [resolutions] Resolutions.
 * @property {import("./Source.js").State} [state] State.
 */ /**
 * @classdesc
 * Base class for sources providing a single image.
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */ class ImageSource extends (0, _sourceJsDefault.default) {
    /**
   * @param {Options} options Single image source options.
   */ constructor(options){
        super({
            attributions: options.attributions,
            projection: options.projection,
            state: options.state,
            interpolate: options.interpolate !== undefined ? options.interpolate : true
        });
        /***
     * @type {ImageSourceOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {ImageSourceOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {ImageSourceOnSignature<void>}
     */ this.un;
        /**
     * @protected
     * @type {import("../Image.js").Loader}
     */ this.loader = options.loader || null;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.resolutions_ = options.resolutions !== undefined ? options.resolutions : null;
        /**
     * @private
     * @type {import("../reproj/Image.js").default}
     */ this.reprojectedImage_ = null;
        /**
     * @private
     * @type {number}
     */ this.reprojectedRevision_ = 0;
        /**
     * @protected
     * @type {import("../Image.js").default}
     */ this.image = null;
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.wantedExtent_;
        /**
     * @private
     * @type {number}
     */ this.wantedResolution_;
        /**
     * @private
     * @type {boolean}
     */ this.static_ = options.loader ? options.loader.length === 0 : false;
        /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */ this.wantedProjection_ = null;
    }
    /**
   * @return {Array<number>|null} Resolutions.
   */ getResolutions() {
        return this.resolutions_;
    }
    /**
   * @param {Array<number>|null} resolutions Resolutions.
   */ setResolutions(resolutions) {
        this.resolutions_ = resolutions;
    }
    /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */ findNearestResolution(resolution) {
        const resolutions = this.getResolutions();
        if (resolutions) {
            const idx = (0, _arrayJs.linearFindNearest)(resolutions, resolution, 0);
            resolution = resolutions[idx];
        }
        return resolution;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */ getImage(extent, resolution, pixelRatio, projection) {
        const sourceProjection = this.getProjection();
        if (!sourceProjection || !projection || (0, _projJs.equivalent)(sourceProjection, projection)) {
            if (sourceProjection) projection = sourceProjection;
            return this.getImageInternal(extent, resolution, pixelRatio, projection);
        }
        if (this.reprojectedImage_) {
            if (this.reprojectedRevision_ == this.getRevision() && (0, _projJs.equivalent)(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && (0, _extentJs.equals)(this.reprojectedImage_.getExtent(), extent)) return this.reprojectedImage_;
            this.reprojectedImage_.dispose();
            this.reprojectedImage_ = null;
        }
        this.reprojectedImage_ = new (0, _imageJsDefault1.default)(sourceProjection, projection, extent, resolution, pixelRatio, (extent, resolution, pixelRatio)=>this.getImageInternal(extent, resolution, pixelRatio, sourceProjection), this.getInterpolate());
        this.reprojectedRevision_ = this.getRevision();
        return this.reprojectedImage_;
    }
    /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @protected
   */ getImageInternal(extent, resolution, pixelRatio, projection) {
        if (this.loader) {
            const requestExtent = getRequestExtent(extent, resolution, pixelRatio, 1);
            const requestResolution = this.findNearestResolution(resolution);
            if (this.image && (this.static_ || this.wantedProjection_ === projection && (this.wantedExtent_ && (0, _extentJs.containsExtent)(this.wantedExtent_, requestExtent) || (0, _extentJs.containsExtent)(this.image.getExtent(), requestExtent)) && (this.wantedResolution_ && (0, _resolutionJs.fromResolutionLike)(this.wantedResolution_) === requestResolution || (0, _resolutionJs.fromResolutionLike)(this.image.getResolution()) === requestResolution))) return this.image;
            this.wantedProjection_ = projection;
            this.wantedExtent_ = requestExtent;
            this.wantedResolution_ = requestResolution;
            this.image = new (0, _imageJsDefault.default)(requestExtent, requestResolution, pixelRatio, this.loader);
            this.image.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.handleImageChange.bind(this));
        }
        return this.image;
    }
    /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */ handleImageChange(event) {
        const image = /** @type {import("../Image.js").default} */ event.target;
        let type;
        switch(image.getState()){
            case (0, _imageStateJsDefault.default).LOADING:
                this.loading = true;
                type = ImageSourceEventType.IMAGELOADSTART;
                break;
            case (0, _imageStateJsDefault.default).LOADED:
                this.loading = false;
                type = ImageSourceEventType.IMAGELOADEND;
                break;
            case (0, _imageStateJsDefault.default).ERROR:
                this.loading = false;
                type = ImageSourceEventType.IMAGELOADERROR;
                break;
            default:
                return;
        }
        if (this.hasListener(type)) this.dispatchEvent(new ImageSourceEvent(type, image));
    }
}
function defaultImageLoadFunction(image, src) {
    /** @type {HTMLImageElement|HTMLVideoElement} */ image.getImage().src = src;
}
function getRequestExtent(extent, resolution, pixelRatio, ratio) {
    const imageResolution = resolution / pixelRatio;
    const center = (0, _extentJs.getCenter)(extent);
    const viewWidth = (0, _mathJs.ceil)((0, _extentJs.getWidth)(extent) / imageResolution, (0, _commonJs.DECIMALS));
    const viewHeight = (0, _mathJs.ceil)((0, _extentJs.getHeight)(extent) / imageResolution, (0, _commonJs.DECIMALS));
    const marginWidth = (0, _mathJs.ceil)((ratio - 1) * viewWidth / 2, (0, _commonJs.DECIMALS));
    const requestWidth = viewWidth + 2 * marginWidth;
    const marginHeight = (0, _mathJs.ceil)((ratio - 1) * viewHeight / 2, (0, _commonJs.DECIMALS));
    const requestHeight = viewHeight + 2 * marginHeight;
    return (0, _extentJs.getForViewAndSize)(center, imageResolution, 0, [
        requestWidth,
        requestHeight
    ]);
}
exports.default = ImageSource;

},{"../events/Event.js":"kooRA","../events/EventType.js":"3uT2C","../ImageState.js":"jCrEd","../Image.js":"7I8uM","../reproj/Image.js":"gLar6","./Source.js":"bjb1h","./common.js":"47QSt","../math.js":"d8zSj","../extent.js":"bGUel","../proj.js":"8OK47","../resolution.js":"d2O2f","../array.js":"hyet5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gLar6":[function(require,module,exports,__globalThis) {
/**
 * @module ol/reproj/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _commonJs = require("./common.js");
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("../Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _triangulationJs = require("./Triangulation.js");
var _triangulationJsDefault = parcelHelpers.interopDefault(_triangulationJs);
var _reprojJs = require("../reproj.js");
var _resolutionJs = require("../resolution.js");
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
/**
 * @typedef {function(import("../extent.js").Extent, number, number) : import("../Image.js").default} FunctionType
 */ /**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link module:ol/source/Image~ImageSource}.
 */ class ReprojImage extends (0, _imageJsDefault.default) {
    /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */ constructor(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, interpolate){
        let maxSourceExtent = sourceProj.getExtent();
        if (maxSourceExtent && sourceProj.canWrapX()) {
            maxSourceExtent = maxSourceExtent.slice();
            maxSourceExtent[0] = -Infinity;
            maxSourceExtent[2] = Infinity;
        }
        let maxTargetExtent = targetProj.getExtent();
        if (maxTargetExtent && targetProj.canWrapX()) {
            maxTargetExtent = maxTargetExtent.slice();
            maxTargetExtent[0] = -Infinity;
            maxTargetExtent[2] = Infinity;
        }
        const limitedTargetExtent = maxTargetExtent ? (0, _extentJs.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;
        const targetCenter = (0, _extentJs.getCenter)(limitedTargetExtent);
        const sourceResolution = (0, _reprojJs.calculateSourceResolution)(sourceProj, targetProj, targetCenter, targetResolution);
        const errorThresholdInPixels = (0, _commonJs.ERROR_THRESHOLD);
        const triangulation = new (0, _triangulationJsDefault.default)(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
        const sourceExtent = triangulation.calculateSourceExtent();
        const sourceImage = (0, _extentJs.isEmpty)(sourceExtent) ? null : getImageFunction(sourceExtent, sourceResolution, pixelRatio);
        const state = sourceImage ? (0, _imageStateJsDefault.default).IDLE : (0, _imageStateJsDefault.default).EMPTY;
        const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
        super(targetExtent, targetResolution, sourcePixelRatio, state);
        /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */ this.targetProj_ = targetProj;
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.maxSourceExtent_ = maxSourceExtent;
        /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */ this.triangulation_ = triangulation;
        /**
     * @private
     * @type {number}
     */ this.targetResolution_ = targetResolution;
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.targetExtent_ = targetExtent;
        /**
     * @private
     * @type {import("../Image.js").default}
     */ this.sourceImage_ = sourceImage;
        /**
     * @private
     * @type {number}
     */ this.sourcePixelRatio_ = sourcePixelRatio;
        /**
     * @private
     * @type {boolean}
     */ this.interpolate_ = interpolate;
        /**
     * @private
     * @type {HTMLCanvasElement}
     */ this.canvas_ = null;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.sourceListenerKey_ = null;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        if (this.state == (0, _imageStateJsDefault.default).LOADING) this.unlistenSource_();
        super.disposeInternal();
    }
    /**
   * @return {HTMLCanvasElement} Image.
   */ getImage() {
        return this.canvas_;
    }
    /**
   * @return {import("../proj/Projection.js").default} Projection.
   */ getProjection() {
        return this.targetProj_;
    }
    /**
   * @private
   */ reproject_() {
        const sourceState = this.sourceImage_.getState();
        if (sourceState == (0, _imageStateJsDefault.default).LOADED) {
            const width = (0, _extentJs.getWidth)(this.targetExtent_) / this.targetResolution_;
            const height = (0, _extentJs.getHeight)(this.targetExtent_) / this.targetResolution_;
            this.canvas_ = (0, _reprojJs.render)(width, height, this.sourcePixelRatio_, (0, _resolutionJs.fromResolutionLike)(this.sourceImage_.getResolution()), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [
                {
                    extent: this.sourceImage_.getExtent(),
                    image: this.sourceImage_.getImage()
                }
            ], 0, undefined, this.interpolate_, true);
        }
        this.state = sourceState;
        this.changed();
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.state == (0, _imageStateJsDefault.default).IDLE) {
            this.state = (0, _imageStateJsDefault.default).LOADING;
            this.changed();
            const sourceState = this.sourceImage_.getState();
            if (sourceState == (0, _imageStateJsDefault.default).LOADED || sourceState == (0, _imageStateJsDefault.default).ERROR) this.reproject_();
            else {
                this.sourceListenerKey_ = (0, _eventsJs.listen)(this.sourceImage_, (0, _eventTypeJsDefault.default).CHANGE, function(e) {
                    const sourceState = this.sourceImage_.getState();
                    if (sourceState == (0, _imageStateJsDefault.default).LOADED || sourceState == (0, _imageStateJsDefault.default).ERROR) {
                        this.unlistenSource_();
                        this.reproject_();
                    }
                }, this);
                this.sourceImage_.load();
            }
        }
    }
    /**
   * @private
   */ unlistenSource_() {
        (0, _eventsJs.unlistenByKey)(/** @type {!import("../events.js").EventsKey} */ this.sourceListenerKey_);
        this.sourceListenerKey_ = null;
    }
}
exports.default = ReprojImage;

},{"./common.js":"aQ4PW","../events/EventType.js":"3uT2C","../ImageState.js":"jCrEd","../Image.js":"7I8uM","./Triangulation.js":"eWboV","../reproj.js":"i3wKe","../resolution.js":"d2O2f","../extent.js":"bGUel","../events.js":"lh4km","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d2O2f":[function(require,module,exports,__globalThis) {
/**
 * @module ol/resolution
 */ /**
 * @typedef {number|Array<number>} ResolutionLike
 */ /**
 * @param {ResolutionLike} resolution Resolution.
 * @return {number} Resolution.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromResolutionLike", ()=>fromResolutionLike);
function fromResolutionLike(resolution) {
    if (Array.isArray(resolution)) return Math.min(...resolution);
    return resolution;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9euAx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Check if a feature intersects with any existing features in the layer
 * @param {Feature} feature - The feature to check
 * @param {VectorLayer} layer - The vector layer containing existing features
 * @param {boolean} showAlert - Whether to show an alert message
 * @returns {boolean} - True if intersection found, false otherwise
 */ parcelHelpers.export(exports, "checkIntersection", ()=>checkIntersection);
/**
 * Calculate area of a polygon feature in square meters and hectares
 * @param {Feature} feature - The feature to calculate area for
 * @returns {Object} - Object containing area in square meters and hectares
 */ parcelHelpers.export(exports, "calculateArea", ()=>calculateArea);
parcelHelpers.export(exports, "enableDraw", ()=>enableDraw);
parcelHelpers.export(exports, "createDrawLayer", ()=>createDrawLayer);
parcelHelpers.export(exports, "checkInteraction", ()=>checkInteraction);
/**
 * Initialize drawing tools on an existing map
 * @param {import('ol/Map.js').default} map - The OpenLayers map instance
 * @returns {Object} - Object containing drawing tools and methods
 */ parcelHelpers.export(exports, "initDrawTools", ()=>initDrawTools);
/**
 * Union selected features using JSTS
 * @param {Array<Feature>} features - Array of features to union
 * @param {VectorSource} source - Vector source to add the result to and remove original features from
 * @returns {Feature|null} - The union result as a feature, or null if operation fails
 */ parcelHelpers.export(exports, "unionSelectedFeatures", ()=>unionSelectedFeatures);
var _draw = require("ol/interaction/Draw");
var _drawDefault = parcelHelpers.interopDefault(_draw);
var _geoserverCrudJs = require("./geoserver-crud.js");
var _ol = require("ol");
var _vector = require("ol/source/Vector");
var _vectorDefault = parcelHelpers.interopDefault(_vector);
var _vector1 = require("ol/layer/Vector");
var _vectorDefault1 = parcelHelpers.interopDefault(_vector1);
var _style = require("ol/style/Style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _circle = require("ol/style/Circle");
var _circleDefault = parcelHelpers.interopDefault(_circle);
var _fill = require("ol/style/Fill");
var _fillDefault = parcelHelpers.interopDefault(_fill);
var _stroke = require("ol/style/Stroke");
var _strokeDefault = parcelHelpers.interopDefault(_stroke);
var _modifyJs = require("ol/interaction/Modify.js");
var _modifyJsDefault = parcelHelpers.interopDefault(_modifyJs);
var _snapJs = require("ol/interaction/Snap.js");
var _snapJsDefault = parcelHelpers.interopDefault(_snapJs);
var _popupMessageJs = require("./popup-message.js");
var _extentJs = require("ol/extent.js");
var _geoJSON = require("ol/format/GeoJSON");
var _geoJSONDefault = parcelHelpers.interopDefault(_geoJSON);
var _sphere = require("ol/sphere");
// Import OpenLayers geometry classes for JSTS parser
var _point = require("ol/geom/Point");
var _pointDefault = parcelHelpers.interopDefault(_point);
var _lineString = require("ol/geom/LineString");
var _lineStringDefault = parcelHelpers.interopDefault(_lineString);
var _linearRing = require("ol/geom/LinearRing");
var _linearRingDefault = parcelHelpers.interopDefault(_linearRing);
var _polygon = require("ol/geom/Polygon");
var _polygonDefault = parcelHelpers.interopDefault(_polygon);
var _multiPoint = require("ol/geom/MultiPoint");
var _multiPointDefault = parcelHelpers.interopDefault(_multiPoint);
var _multiLineString = require("ol/geom/MultiLineString");
var _multiLineStringDefault = parcelHelpers.interopDefault(_multiLineString);
var _multiPolygon = require("ol/geom/MultiPolygon");
var _multiPolygonDefault = parcelHelpers.interopDefault(_multiPolygon);
var _geometryCollection = require("ol/geom/GeometryCollection");
var _geometryCollectionDefault = parcelHelpers.interopDefault(_geometryCollection);
// Import JSTS for precise intersection checking
var _ol3Parser = require("jsts/org/locationtech/jts/io/OL3Parser");
var _ol3ParserDefault = parcelHelpers.interopDefault(_ol3Parser);
var _relate = require("jsts/org/locationtech/jts/operation/relate");
var _union = require("jsts/org/locationtech/jts/operation/union");
function checkIntersection(feature, layer, showAlert = true) {
    if (!feature || !layer) return false;
    const drawGeom = feature.getGeometry();
    if (!drawGeom) return false;
    // Validate geometry before proceeding
    if (drawGeom.getType() === 'Polygon') {
        const coords = drawGeom.getCoordinates();
        if (!coords || !coords[0] || coords[0].length < 4) {
            console.warn("Invalid polygon: not enough points for a LinearRing", coords);
            return false;
        }
    }
    // Use JSTS for precise intersection checking
    const parser = new (0, _ol3ParserDefault.default)();
    parser.inject((0, _pointDefault.default), (0, _lineStringDefault.default), (0, _linearRingDefault.default), (0, _polygonDefault.default), (0, _multiPointDefault.default), (0, _multiLineStringDefault.default), (0, _multiPolygonDefault.default), (0, _geometryCollectionDefault.default));
    try {
        // Convert the drawn geometry to JSTS geometry
        const jstsGeom = parser.read(drawGeom);
        // Get the extent of the drawn geometry for quick filtering
        const drawGeomExtent = drawGeom.getExtent();
        let hasIntersection = false;
        let intersectingFeature = null;
        // Check against each existing feature
        layer.getSource().getFeatures().forEach((existingFeature)=>{
            // Skip checking against itself
            if (existingFeature === feature) return;
            const existingGeom = existingFeature.getGeometry();
            if (!existingGeom) return;
            // Validate existing geometry
            if (existingGeom.getType() === 'Polygon') {
                const coords = existingGeom.getCoordinates();
                if (!coords || !coords[0] || coords[0].length < 4) {
                    console.warn("Invalid existing polygon: not enough points for a LinearRing", coords);
                    return;
                }
            }
            // Quick check with extents first (bounding boxes)
            if ((0, _extentJs.intersects)(drawGeomExtent, existingGeom.getExtent())) try {
                // Convert existing geometry to JSTS geometry
                const jstsExistingGeom = parser.read(existingGeom);
                // Perform precise intersection check
                if ((0, _relate.RelateOp).intersects(jstsGeom, jstsExistingGeom)) {
                    hasIntersection = true;
                    intersectingFeature = existingFeature;
                    // Show alert if requested
                    if (showAlert) {
                        const featureType = drawGeom.getType();
                        const existingType = existingGeom.getType();
                        (0, _popupMessageJs.showPopupMessage)(`Intersection detected between ${featureType} and existing ${existingType}`, "warning");
                        // Highlight the intersecting feature
                        highlightIntersectingFeature(existingFeature, layer);
                    }
                    // We found an intersection, no need to check further
                    return;
                }
            } catch (error) {
                console.error("Error checking intersection:", error);
            }
        });
        return hasIntersection;
    } catch (error) {
        console.error("Error in checkIntersection:", error);
        return false;
    }
}
/**
 * Temporarily highlight an intersecting feature
 * @param {Feature} feature - The feature to highlight
 * @param {VectorLayer} layer - The vector layer containing the feature
 */ function highlightIntersectingFeature(feature, layer) {
    // Store the original style
    const originalStyle = feature.getStyle() || layer.getStyle();
    // Set a highlight style
    feature.setStyle(new (0, _styleDefault.default)({
        stroke: new (0, _strokeDefault.default)({
            color: "red",
            width: 3
        }),
        fill: new (0, _fillDefault.default)({
            color: "rgba(255, 0, 0, 0.3)"
        }),
        image: new (0, _circleDefault.default)({
            radius: 7,
            fill: new (0, _fillDefault.default)({
                color: "red"
            })
        })
    }));
    // Reset to original style after 2 seconds
    setTimeout(()=>{
        feature.setStyle(originalStyle);
    }, 2000);
}
function calculateArea(feature) {
    if (!feature) return {
        m2: 0,
        ha: 0
    };
    const geometry = feature.getGeometry();
    if (!geometry || geometry.getType() !== "Polygon") return {
        m2: 0,
        ha: 0
    };
    // Get area in square meters
    const areaInM2 = (0, _sphere.getArea)(geometry);
    // Convert to hectares (1 hectare = 10,000 m²)
    const areaInHa = areaInM2 / 10000;
    return {
        m2: Math.round(areaInM2 * 100) / 100,
        ha: Math.round(areaInHa * 10000) / 10000
    };
}
function enableDraw(map, vectorLayer, drawType = "Polygon", geoserverURL) {
    let drawnfeatures = [];
    let modifiedFeatures = [];
    let isDrawing = false;
    let originalFeatureGeometries = new Map(); // Store original geometries for potential rollback
    // Create draw interaction
    const draw = new (0, _drawDefault.default)({
        source: vectorLayer.getSource(),
        type: drawType
    });
    map.addInteraction(draw);
    // Track when drawing starts
    draw.on("drawstart", (event)=>{
        isDrawing = true;
        const hasIntersection = checkIntersection(event.feature, vectorLayer);
        console.log("Has Intersection: ", hasIntersection);
        const preventIntersections = document.getElementById("prevent-intersections")?.checked || false;
        if (hasIntersection && preventIntersections) {
            // Remove the feature that was just drawn
            vectorLayer.getSource().removeFeature(event.feature);
            (0, _popupMessageJs.showPopupMessage)("Drawing removed due to intersection with existing feature", "warning");
            return;
        }
        console.log("Drawing started");
    });
    // Handle drawing end
    draw.on("drawend", async (event)=>{
        isDrawing = false;
        console.log("Drawing ended");
        const feature = event.feature;
        // Check for intersections with existing features
        const hasIntersection = checkIntersection(feature, vectorLayer);
        console.log("Intersection check result:", hasIntersection);
        // If intersection is found and we want to prevent it
        const preventIntersections = document.getElementById("prevent-intersections")?.checked || false;
        if (hasIntersection && preventIntersections) {
            // Remove the feature that was just drawn
            vectorLayer.getSource().removeFeature(feature);
            (0, _popupMessageJs.showPopupMessage)("Drawing removed due to intersection with existing feature", "warning");
            return;
        }
        // Calculate area for polygons
        if (drawType === "Polygon") {
            const area = calculateArea(feature);
            feature.setProperties({
                area_m2: area.m2,
                area_ha: area.ha
            });
            // Show area information
            (0, _popupMessageJs.showPopupMessage)(`Area: ${area.m2} m\xb2 (${area.ha} ha)`, "info");
        }
        const newFeat = new (0, _ol.Feature)();
        newFeat.setGeometryName("geom");
        newFeat.setGeometry(feature.getGeometry());
        newFeat.setProperties({
            name: "test",
            ...feature.getProperties()
        });
        const autoSave = document.getElementById("auto-save")?.checked || false;
        if (autoSave) try {
            const res = await (0, _geoserverCrudJs.transactWFS)("insert", [
                newFeat
            ], "ne", "draw_layer", "EPSG:3857", "admin", "geoserver", geoserverURL);
            const featureId = parseInt(res.insertedFIDs[0].split(".")[1]);
            event.feature.setProperties({
                fid: featureId
            });
            console.log("Feature drawn and saved to server");
        } catch (error) {
            console.error("Error saving feature:", error);
            (0, _popupMessageJs.showPopupMessage)("Error saving feature to server", "error");
        }
        else {
            drawnfeatures.push(newFeat);
            console.log("Feature drawn and saved to memory");
        }
    });
    const modify = new (0, _modifyJsDefault.default)({
        source: vectorLayer.getSource()
    });
    map.addInteraction(modify);
    // Store original geometry before modification
    modify.on("modifystart", (event)=>{
        const features = event.features.getArray();
        features.forEach((feature)=>{
            // Store a clone of the original geometry
            originalFeatureGeometries.set(feature, feature.getGeometry().clone());
        });
    });
    // Handle feature modification
    modify.on("modifyend", (event)=>{
        console.log("Modification ended");
        const features = event.features.getArray();
        features.forEach(async (feature)=>{
            // Check for intersections with existing features
            const hasIntersection = checkIntersection(feature, vectorLayer);
            console.log("Modification intersection check result:", hasIntersection);
            // If intersection is found and we want to prevent it
            const preventIntersections = document.getElementById("prevent-intersections")?.checked || false;
            if (hasIntersection && preventIntersections) {
                // Revert the modification using the stored original geometry
                const originalGeometry = originalFeatureGeometries.get(feature);
                if (originalGeometry) {
                    feature.setGeometry(originalGeometry);
                    (0, _popupMessageJs.showPopupMessage)("Modification reverted due to intersection with existing feature", "warning");
                    return; // Skip the rest of the processing for this feature
                } else (0, _popupMessageJs.showPopupMessage)("Modification creates intersection with existing feature", "warning");
            }
            // Recalculate area for polygons
            if (feature.getGeometry().getType() === "Polygon") {
                const area = calculateArea(feature);
                feature.setProperties({
                    area_m2: area.m2,
                    area_ha: area.ha
                });
                // Show updated area information
                (0, _popupMessageJs.showPopupMessage)(`Updated area: ${area.m2} m\xb2 (${area.ha} ha)`, "info");
            }
            const newFeat = new (0, _ol.Feature)();
            newFeat.setGeometryName("geom");
            newFeat.setGeometry(feature.getGeometry());
            newFeat.setId(feature.getProperties().fid);
            const autoSave = document.getElementById("auto-save")?.checked || false;
            if (autoSave) try {
                await (0, _geoserverCrudJs.transactWFS)("update", [
                    newFeat
                ], "ne", "draw_layer", "EPSG:3857", "admin", "geoserver", geoserverURL);
                console.log("Feature modified and saved to server");
            } catch (error) {
                console.error("Error updating feature:", error);
                (0, _popupMessageJs.showPopupMessage)("Error updating feature on server", "error");
            }
            else {
                modifiedFeatures.push(newFeat);
                console.log("Feature modified and saved to memory");
            }
        });
        // Clear the stored geometries
        originalFeatureGeometries.clear();
    });
    const snap = new (0, _snapJsDefault.default)({
        source: vectorLayer.getSource()
    });
    map.addInteraction(snap);
    return {
        draw,
        modify,
        snap,
        disable: ()=>{
            map.removeInteraction(draw);
            map.removeInteraction(modify);
            map.removeInteraction(snap);
        },
        save: async ()=>{
            let res;
            let savedCount = 0;
            if (drawnfeatures.length > 0) try {
                res = await (0, _geoserverCrudJs.transactWFS)("insert", drawnfeatures, "ne", "draw_layer", "EPSG:3857", "admin", "geoserver", geoserverURL);
                savedCount += drawnfeatures.length;
                drawnfeatures = [];
            } catch (error) {
                console.error("Error saving drawn features:", error);
                (0, _popupMessageJs.showPopupMessage)("Error saving drawn features", "error");
            }
            if (modifiedFeatures.length > 0) try {
                res = await (0, _geoserverCrudJs.transactWFS)("update", modifiedFeatures, "ne", "draw_layer", "EPSG:3857", "admin", "geoserver", geoserverURL);
                savedCount += modifiedFeatures.length;
                modifiedFeatures = [];
            } catch (error) {
                console.error("Error saving modified features:", error);
                (0, _popupMessageJs.showPopupMessage)("Error saving modified features", "error");
            }
            if (savedCount > 0) (0, _popupMessageJs.showPopupMessage)(`Successfully saved ${savedCount} feature(s)!`, "success");
            else if (drawnfeatures.length === 0 && modifiedFeatures.length === 0) (0, _popupMessageJs.showPopupMessage)("No features to save", "info");
            return res;
        },
        delete: async ()=>{
            const source = vectorLayer.getSource();
            const features = source.getFeatures();
            if (features.length > 0) {
                const autoSave = document.getElementById("auto-save")?.checked || false;
                if (autoSave) {
                    // Get all features with FIDs
                    const featuresToDelete = features.filter((f)=>f.getProperties().fid);
                    if (featuresToDelete.length > 0) try {
                        await (0, _geoserverCrudJs.transactWFS)("delete", featuresToDelete, "ne", "draw_layer", "EPSG:3857", "admin", "geoserver", geoserverURL);
                    } catch (error) {
                        console.error("Error deleting features:", error);
                        (0, _popupMessageJs.showPopupMessage)("Error deleting features from server", "error");
                    }
                }
                // Clear all features from the source
                source.clear();
                drawnfeatures = [];
                modifiedFeatures = [];
                (0, _popupMessageJs.showPopupMessage)("All features deleted", "success");
            } else (0, _popupMessageJs.showPopupMessage)("No features to delete", "info");
        },
        exportGeoJSON: ()=>{
            const source = vectorLayer.getSource();
            const features = source.getFeatures();
            if (features.length === 0) {
                (0, _popupMessageJs.showPopupMessage)("No features to export", "info");
                return null;
            }
            const format = new (0, _geoJSONDefault.default)();
            const geojson = format.writeFeaturesObject(features);
            // Add area properties for polygons
            geojson.features.forEach((feature)=>{
                if (feature.geometry.type === "Polygon") {
                    const olFeature = source.getFeatureById(feature.id);
                    const area = calculateArea(olFeature);
                    feature.properties.area_m2 = area.m2;
                    feature.properties.area_ha = area.ha;
                }
            });
            return geojson;
        }
    };
}
function createDrawLayer() {
    const drawSource = new (0, _vectorDefault.default)();
    const drawStyle = (feature)=>{
        const type = feature.getGeometry().getType();
        if (type === "Point" || type === "MultiPoint") return new (0, _styleDefault.default)({
            image: new (0, _circleDefault.default)({
                radius: 5,
                fill: new (0, _fillDefault.default)({
                    color: "blue"
                }),
                stroke: new (0, _strokeDefault.default)({
                    color: "white",
                    width: 1
                })
            })
        });
        if (type.includes("Line")) return new (0, _styleDefault.default)({
            stroke: new (0, _strokeDefault.default)({
                color: "green",
                width: 2
            })
        });
        if (type.includes("Polygon")) return new (0, _styleDefault.default)({
            stroke: new (0, _strokeDefault.default)({
                color: "orange",
                width: 1
            }),
            fill: new (0, _fillDefault.default)({
                color: "rgba(255,165,0,0.3)"
            })
        });
        return new (0, _styleDefault.default)({
            stroke: new (0, _strokeDefault.default)({
                color: "gray",
                width: 1
            }),
            fill: new (0, _fillDefault.default)({
                color: "rgba(200, 200, 200, 0.3)"
            })
        });
    };
    const drawLayer = new (0, _vectorDefault1.default)({
        source: drawSource,
        style: drawStyle,
        title: "draw-layer"
    });
    return drawLayer;
}
function checkInteraction(lineDraw, polyDraw, pointDraw) {
    if (lineDraw) lineDraw.disable();
    if (polyDraw) polyDraw.disable();
    if (pointDraw) pointDraw.disable();
}
function initDrawTools(map) {
    // Create a vector source and layer for the drawings
    const drawLayer = createDrawLayer();
    map.addLayer(drawLayer);
    // Get the source from the layer
    const source = drawLayer.getSource();
    // Create draw, modify, and snap interactions
    const typeSelect = document.getElementById("type");
    let draw, modify, snap;
    function addInteractions() {
        // Get the GeoServer URL from the global variable or use a default
        const geoserverURL = window.geoserverURL || "http://localhost:8080/geoserver";
        // Create drawing tools with the selected geometry type
        const drawingTools = enableDraw(map, drawLayer, typeSelect.value, geoserverURL);
        // Store references to the interactions
        draw = drawingTools.draw;
        modify = drawingTools.modify;
        snap = drawingTools.snap;
        return drawingTools;
    }
    // Initialize interactions with the default geometry type
    let drawingTools = addInteractions();
    // Handle change in geometry type
    if (typeSelect) typeSelect.onchange = function() {
        // Remove existing interactions
        if (drawingTools && drawingTools.disable) drawingTools.disable();
        // Add new interactions with the selected geometry type
        drawingTools = addInteractions();
    };
    // Return an object with methods to control the drawing tools
    return {
        source: source,
        layer: drawLayer,
        // Method to enable/disable drawing tools
        setActive: function(active) {
            if (active) // Re-add interactions if they were removed
            {
                if (!map.getInteractions().getArray().includes(draw)) drawingTools = addInteractions();
            } else // Remove interactions if they exist
            if (drawingTools && drawingTools.disable) drawingTools.disable();
        },
        // Method to save drawings
        save: function() {
            if (drawingTools && drawingTools.save) return drawingTools.save();
            return Promise.resolve({
                status: "error",
                message: "Drawing tools not initialized"
            });
        },
        // Method to delete drawings
        delete: function() {
            if (drawingTools && drawingTools.delete) return drawingTools.delete();
            return Promise.resolve({
                status: "error",
                message: "Drawing tools not initialized"
            });
        },
        // Method to export drawings as GeoJSON
        exportGeoJSON: function() {
            if (drawingTools && drawingTools.exportGeoJSON) return drawingTools.exportGeoJSON();
            return null;
        },
        // Reference to the source for direct access
        source: source
    };
}
function unionSelectedFeatures(features, source) {
    if (!features || features.length < 2) {
        (0, _popupMessageJs.showPopupMessage)("Select at least two features to union", "warning");
        return null;
    }
    try {
        // Create a JSTS parser
        const parser = new (0, _ol3ParserDefault.default)();
        parser.inject((0, _pointDefault.default), (0, _lineStringDefault.default), (0, _linearRingDefault.default), (0, _polygonDefault.default), (0, _multiPointDefault.default), (0, _multiLineStringDefault.default), (0, _multiPolygonDefault.default), (0, _geometryCollectionDefault.default));
        // Convert all features to JSTS geometries
        const jstsGeometries = features.map((feature)=>{
            const geometry = feature.getGeometry();
            if (!geometry) {
                console.warn("Feature has no geometry:", feature);
                return null;
            }
            return parser.read(geometry);
        }).filter((geom)=>geom !== null);
        if (jstsGeometries.length < 2) {
            (0, _popupMessageJs.showPopupMessage)("Not enough valid geometries to union", "warning");
            return null;
        }
        console.log("JSTS geometries for union:", jstsGeometries);
        // Perform the union operation
        const unionGeometry = (0, _union.UnaryUnionOp).union(jstsGeometries);
        console.log("Union result:", unionGeometry);
        if (!unionGeometry) {
            (0, _popupMessageJs.showPopupMessage)("Union operation failed", "error");
            return null;
        }
        // Convert back to OpenLayers geometry
        const olGeometry = parser.write(unionGeometry);
        // Create a new feature with the union geometry
        const unionFeature = new (0, _ol.Feature)({
            geometry: olGeometry
        });
        // Remove original features and add the union result
        if (source) {
            features.forEach((feature)=>{
                source.removeFeature(feature);
            });
            source.addFeature(unionFeature);
        }
        (0, _popupMessageJs.showPopupMessage)("Union operation completed successfully", "success");
        return unionFeature;
    } catch (error) {
        console.error("Error in unionSelectedFeatures:", error);
        (0, _popupMessageJs.showPopupMessage)("Union operation failed: " + error.message, "error");
        return null;
    }
}

},{"ol/interaction/Modify.js":"cQEIv","ol/interaction/Snap.js":"3IZ3n","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT","ol/extent.js":"bGUel","ol/interaction/Draw":"aLfQY","./geoserver-crud.js":"7uIM7","ol":"7JF0u","ol/source/Vector":"7wT1g","ol/layer/Vector":"6bOIK","ol/style/Style":"8opjn","ol/style/Circle":"3LBvw","ol/style/Fill":"cHc7U","ol/style/Stroke":"1uQwy","./popup-message.js":"98E40","ol/format/GeoJSON":"9jWnV","ol/sphere":"dCFM7","ol/geom/Point":"6SybV","ol/geom/LineString":"gknRz","ol/geom/LinearRing":"gT85H","ol/geom/Polygon":"8Vwps","ol/geom/MultiPoint":"gXgmP","ol/geom/MultiLineString":"4FjXg","ol/geom/MultiPolygon":"b4GDd","ol/geom/GeometryCollection":"6lIhA","jsts/org/locationtech/jts/io/OL3Parser":"1NdLK","jsts/org/locationtech/jts/operation/relate":"lomLd","jsts/org/locationtech/jts/operation/union":"b4ekL"}],"cQEIv":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Modify
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth] Depth.
 * @property {Feature} feature Feature.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} [index] Index.
 * @property {Array<Array<number>>} segment Segment.
 * @property {Array<SegmentData>} [featureSegments] FeatureSegments.
 */ /**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition.primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition.singleClick} with
 * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex should be added to the sketch
 * features. Default is {@link module:ol/events/condition.always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style used for the modification point or vertex. For linestrings and polygons, this will
 * be the affected vertex, for circles a point along the circle, and for points the actual
 * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).
 * When using a style function, the point feature passed to the function will have a `features`
 * property - an array whose entries are the features that are being modified, and a `geometries`
 * property - an array whose entries are the geometries that are being modified. Both arrays are
 * in the same order. The `geometries` are only useful when modifying geometry collections, where
 * the geometry will be the particular geometry from the collection that is being modified.
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the `features` option.
 * @property {boolean|import("../layer/BaseVector").default} [hitDetection] When configured, point
 * features will be considered for modification based on their visual appearance, instead of being within
 * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is
 * provided, only the rendered representation of the features on that layer will be considered.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the `source` option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the
 * pointer coordinate when clicked within the `pixelTolerance`.
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */ parcelHelpers.export(exports, "ModifyEvent", ()=>ModifyEvent);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _rbushJs = require("../structs/RBush.js");
var _rbushJsDefault = parcelHelpers.interopDefault(_rbushJs);
var _vectorEventTypeJs = require("../source/VectorEventType.js");
var _vectorEventTypeJsDefault = parcelHelpers.interopDefault(_vectorEventTypeJs);
var _vectorJs = require("../layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _vectorJs1 = require("../source/Vector.js");
var _vectorJsDefault1 = parcelHelpers.interopDefault(_vectorJs1);
var _conditionJs = require("../events/condition.js");
var _extentJs = require("../extent.js");
var _coordinateJs = require("../coordinate.js");
var _styleJs = require("../style/Style.js");
var _arrayJs = require("../array.js");
var _polygonJs = require("../geom/Polygon.js");
var _projJs = require("../proj.js");
var _utilJs = require("../util.js");
/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */ const CIRCLE_CENTER_INDEX = 0;
/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */ const CIRCLE_CIRCUMFERENCE_INDEX = 1;
const tempExtent = [
    0,
    0,
    0,
    0
];
const tempSegment = [];
/**
 * @enum {string}
 */ const ModifyEventType = {
    /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */ MODIFYSTART: 'modifystart',
    /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */ MODIFYEND: 'modifyend'
};
class ModifyEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */ constructor(type, features, mapBrowserEvent){
        super(type);
        /**
     * The features being modified.
     * @type {Collection<Feature>}
     * @api
     */ this.features = features;
        /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */ this.mapBrowserEvent = mapBrowserEvent;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature
 */ /**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * Cartesian distance from the pointer is used to determine the features that
 * will be modified. This means that geometries will only be considered for
 * modification when they are within the configured `pixelTolerance`. For point
 * geometries, the `hitDetection` option can be used to match their visual
 * appearance.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */ class Modify extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        super(/** @type {import("./Pointer.js").Options} */ options);
        /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {ModifyOnSignature<void>}
     */ this.un;
        /** @private */ this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : (0, _conditionJs.primaryAction);
        /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */ this.defaultDeleteCondition_ = function(mapBrowserEvent) {
            return (0, _conditionJs.altKeyOnly)(mapBrowserEvent) && (0, _conditionJs.singleClick)(mapBrowserEvent);
        };
        /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */ this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : this.defaultDeleteCondition_;
        /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */ this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : (0, _conditionJs.always);
        /**
     * Editing vertex.
     * @type {Feature<Point>}
     * @private
     */ this.vertexFeature_ = null;
        /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */ this.vertexSegments_ = null;
        /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */ this.lastPixel_ = [
            0,
            0
        ];
        /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */ this.ignoreNextSingleClick_ = false;
        /**
     * @type {Collection<Feature>}
     * @private
     */ this.featuresBeingModified_ = null;
        /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */ this.rBush_ = new (0, _rbushJsDefault.default)();
        /**
     * @type {number}
     * @private
     */ this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
        /**
     * @type {boolean}
     * @private
     */ this.snappedToVertex_ = false;
        /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */ this.changingFeature_ = false;
        /**
     * @type {Array}
     * @private
     */ this.dragSegments_ = [];
        /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */ this.overlay_ = new (0, _vectorJsDefault.default)({
            source: new (0, _vectorJsDefault1.default)({
                useSpatialIndex: false,
                wrapX: !!options.wrapX
            }),
            style: options.style ? options.style : getDefaultStyleFunction(),
            updateWhileAnimating: true,
            updateWhileInteracting: true
        });
        /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
     */ this.SEGMENT_WRITERS_ = {
            'Point': this.writePointGeometry_.bind(this),
            'LineString': this.writeLineStringGeometry_.bind(this),
            'LinearRing': this.writeLineStringGeometry_.bind(this),
            'Polygon': this.writePolygonGeometry_.bind(this),
            'MultiPoint': this.writeMultiPointGeometry_.bind(this),
            'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),
            'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),
            'Circle': this.writeCircleGeometry_.bind(this),
            'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this)
        };
        /**
     * @type {VectorSource}
     * @private
     */ this.source_ = null;
        /**
     * @type {boolean|import("../layer/BaseVector").default}
     */ this.hitDetection_ = null;
        /** @type {Collection<Feature>} */ let features;
        if (options.features) features = options.features;
        else if (options.source) {
            this.source_ = options.source;
            features = new (0, _collectionJsDefault.default)(this.source_.getFeatures());
            this.source_.addEventListener((0, _vectorEventTypeJsDefault.default).ADDFEATURE, this.handleSourceAdd_.bind(this));
            this.source_.addEventListener((0, _vectorEventTypeJsDefault.default).REMOVEFEATURE, this.handleSourceRemove_.bind(this));
        }
        if (!features) throw new Error('The modify interaction requires features, a source or a layer');
        if (options.hitDetection) this.hitDetection_ = options.hitDetection;
        /**
     * @type {Collection<Feature>}
     * @private
     */ this.features_ = features;
        this.features_.forEach(this.addFeature_.bind(this));
        this.features_.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, this.handleFeatureAdd_.bind(this));
        this.features_.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, this.handleFeatureRemove_.bind(this));
        /**
     * @type {import("../MapBrowserEvent.js").default}
     * @private
     */ this.lastPointerEvent_ = null;
        /**
     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.
     * @type {Array<number>}
     */ this.delta_ = [
            0,
            0
        ];
        /**
     * @private
     */ this.snapToPointer_ = options.snapToPointer === undefined ? !this.hitDetection_ : options.snapToPointer;
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ addFeature_(feature) {
        const geometry = feature.getGeometry();
        if (geometry) {
            const writer = this.SEGMENT_WRITERS_[geometry.getType()];
            if (writer) writer(feature, geometry);
        }
        const map = this.getMap();
        if (map && map.isRendered() && this.getActive()) this.handlePointerAtPixel_(this.lastPixel_, map);
        feature.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleFeatureChange_);
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */ willModifyFeatures_(evt, segments) {
        if (!this.featuresBeingModified_) {
            this.featuresBeingModified_ = new (0, _collectionJsDefault.default)();
            const features = this.featuresBeingModified_.getArray();
            for(let i = 0, ii = segments.length; i < ii; ++i){
                const segment = segments[i];
                for(let s = 0, ss = segment.length; s < ss; ++s){
                    const feature = segment[s].feature;
                    if (feature && !features.includes(feature)) this.featuresBeingModified_.push(feature);
                }
            }
            if (this.featuresBeingModified_.getLength() === 0) this.featuresBeingModified_ = null;
            else this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
        }
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ removeFeature_(feature) {
        this.removeFeatureSegmentData_(feature);
        // Remove the vertex feature if the collection of candidate features is empty.
        if (this.vertexFeature_ && this.features_.getLength() === 0) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
        feature.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleFeatureChange_);
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ removeFeatureSegmentData_(feature) {
        const rBush = this.rBush_;
        /** @type {Array<SegmentData>} */ const nodesToRemove = [];
        rBush.forEach(/**
       * @param {SegmentData} node RTree node.
       */ function(node) {
            if (feature === node.feature) nodesToRemove.push(node);
        });
        for(let i = nodesToRemove.length - 1; i >= 0; --i){
            const nodeToRemove = nodesToRemove[i];
            for(let j = this.dragSegments_.length - 1; j >= 0; --j)if (this.dragSegments_[j][0] === nodeToRemove) this.dragSegments_.splice(j, 1);
            rBush.remove(nodeToRemove);
        }
    }
    /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */ setActive(active) {
        if (this.vertexFeature_ && !active) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
        super.setActive(active);
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */ setMap(map) {
        this.overlay_.setMap(map);
        super.setMap(map);
    }
    /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */ getOverlay() {
        return this.overlay_;
    }
    /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */ handleSourceAdd_(event) {
        if (event.feature) this.features_.push(event.feature);
    }
    /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */ handleSourceRemove_(event) {
        if (event.feature) this.features_.remove(event.feature);
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */ handleFeatureAdd_(evt) {
        this.addFeature_(evt.element);
    }
    /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */ handleFeatureChange_(evt) {
        if (!this.changingFeature_) {
            const feature = /** @type {Feature} */ evt.target;
            this.removeFeature_(feature);
            this.addFeature_(feature);
        }
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */ handleFeatureRemove_(evt) {
        this.removeFeature_(evt.element);
    }
    /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */ writePointGeometry_(feature, geometry) {
        const coordinates = geometry.getCoordinates();
        /** @type {SegmentData} */ const segmentData = {
            feature: feature,
            geometry: geometry,
            segment: [
                coordinates,
                coordinates
            ]
        };
        this.rBush_.insert(geometry.getExtent(), segmentData);
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */ writeMultiPointGeometry_(feature, geometry) {
        const points = geometry.getCoordinates();
        for(let i = 0, ii = points.length; i < ii; ++i){
            const coordinates = points[i];
            /** @type {SegmentData} */ const segmentData = {
                feature: feature,
                geometry: geometry,
                depth: [
                    i
                ],
                index: i,
                segment: [
                    coordinates,
                    coordinates
                ]
            };
            this.rBush_.insert(geometry.getExtent(), segmentData);
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */ writeLineStringGeometry_(feature, geometry) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
            const segment = coordinates.slice(i, i + 2);
            /** @type {SegmentData} */ const segmentData = {
                feature: feature,
                geometry: geometry,
                index: i,
                segment: segment
            };
            this.rBush_.insert((0, _extentJs.boundingExtent)(segment), segmentData);
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */ writeMultiLineStringGeometry_(feature, geometry) {
        const lines = geometry.getCoordinates();
        for(let j = 0, jj = lines.length; j < jj; ++j){
            const coordinates = lines[j];
            for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
                const segment = coordinates.slice(i, i + 2);
                /** @type {SegmentData} */ const segmentData = {
                    feature: feature,
                    geometry: geometry,
                    depth: [
                        j
                    ],
                    index: i,
                    segment: segment
                };
                this.rBush_.insert((0, _extentJs.boundingExtent)(segment), segmentData);
            }
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */ writePolygonGeometry_(feature, geometry) {
        const rings = geometry.getCoordinates();
        for(let j = 0, jj = rings.length; j < jj; ++j){
            const coordinates = rings[j];
            for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
                const segment = coordinates.slice(i, i + 2);
                /** @type {SegmentData} */ const segmentData = {
                    feature: feature,
                    geometry: geometry,
                    depth: [
                        j
                    ],
                    index: i,
                    segment: segment
                };
                this.rBush_.insert((0, _extentJs.boundingExtent)(segment), segmentData);
            }
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */ writeMultiPolygonGeometry_(feature, geometry) {
        const polygons = geometry.getCoordinates();
        for(let k = 0, kk = polygons.length; k < kk; ++k){
            const rings = polygons[k];
            for(let j = 0, jj = rings.length; j < jj; ++j){
                const coordinates = rings[j];
                for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
                    const segment = coordinates.slice(i, i + 2);
                    /** @type {SegmentData} */ const segmentData = {
                        feature: feature,
                        geometry: geometry,
                        depth: [
                            j,
                            k
                        ],
                        index: i,
                        segment: segment
                    };
                    this.rBush_.insert((0, _extentJs.boundingExtent)(segment), segmentData);
                }
            }
        }
    }
    /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */ writeCircleGeometry_(feature, geometry) {
        const coordinates = geometry.getCenter();
        /** @type {SegmentData} */ const centerSegmentData = {
            feature: feature,
            geometry: geometry,
            index: CIRCLE_CENTER_INDEX,
            segment: [
                coordinates,
                coordinates
            ]
        };
        /** @type {SegmentData} */ const circumferenceSegmentData = {
            feature: feature,
            geometry: geometry,
            index: CIRCLE_CIRCUMFERENCE_INDEX,
            segment: [
                coordinates,
                coordinates
            ]
        };
        const featureSegments = [
            centerSegmentData,
            circumferenceSegmentData
        ];
        centerSegmentData.featureSegments = featureSegments;
        circumferenceSegmentData.featureSegments = featureSegments;
        this.rBush_.insert((0, _extentJs.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
        let circleGeometry = /** @type {import("../geom/Geometry.js").default} */ geometry;
        const userProjection = (0, _projJs.getUserProjection)();
        if (userProjection && this.getMap()) {
            const projection = this.getMap().getView().getProjection();
            circleGeometry = circleGeometry.clone().transform(userProjection, projection);
            circleGeometry = (0, _polygonJs.fromCircle)(/** @type {import("../geom/Circle.js").default} */ circleGeometry).transform(projection, userProjection);
        }
        this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */ writeGeometryCollectionGeometry_(feature, geometry) {
        const geometries = geometry.getGeometriesArray();
        for(let i = 0; i < geometries.length; ++i){
            const geometry = geometries[i];
            const writer = this.SEGMENT_WRITERS_[geometry.getType()];
            writer(feature, geometry);
        }
    }
    /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */ createOrUpdateVertexFeature_(coordinates, features, geometries) {
        let vertexFeature = this.vertexFeature_;
        if (!vertexFeature) {
            vertexFeature = new (0, _featureJsDefault.default)(new (0, _pointJsDefault.default)(coordinates));
            this.vertexFeature_ = vertexFeature;
            this.overlay_.getSource().addFeature(vertexFeature);
        } else {
            const geometry = vertexFeature.getGeometry();
            geometry.setCoordinates(coordinates);
        }
        vertexFeature.set('features', features);
        vertexFeature.set('geometries', geometries);
        return vertexFeature;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */ handleEvent(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) return true;
        this.lastPointerEvent_ = mapBrowserEvent;
        let handled;
        if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE && !this.handlingDownUpSequence) this.handlePointerMove_(mapBrowserEvent);
        if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
            if (mapBrowserEvent.type != (0, _mapBrowserEventTypeJsDefault.default).SINGLECLICK || !this.ignoreNextSingleClick_) handled = this.removePoint();
            else handled = true;
        }
        if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).SINGLECLICK) this.ignoreNextSingleClick_ = false;
        return super.handleEvent(mapBrowserEvent) && !handled;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */ handleDragEvent(evt) {
        this.ignoreNextSingleClick_ = false;
        this.willModifyFeatures_(evt, this.dragSegments_);
        const vertex = [
            evt.coordinate[0] + this.delta_[0],
            evt.coordinate[1] + this.delta_[1]
        ];
        const features = [];
        const geometries = [];
        for(let i = 0, ii = this.dragSegments_.length; i < ii; ++i){
            const dragSegment = this.dragSegments_[i];
            const segmentData = dragSegment[0];
            const feature = segmentData.feature;
            if (!features.includes(feature)) features.push(feature);
            const geometry = segmentData.geometry;
            if (!geometries.includes(geometry)) geometries.push(geometry);
            const depth = segmentData.depth;
            let coordinates;
            const segment = segmentData.segment;
            const index = dragSegment[1];
            while(vertex.length < geometry.getStride())vertex.push(segment[index][vertex.length]);
            switch(geometry.getType()){
                case 'Point':
                    coordinates = vertex;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    break;
                case 'MultiPoint':
                    coordinates = geometry.getCoordinates();
                    coordinates[segmentData.index] = vertex;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    break;
                case 'LineString':
                    coordinates = geometry.getCoordinates();
                    coordinates[segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'MultiLineString':
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'Polygon':
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'MultiPolygon':
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'Circle':
                    segment[0] = vertex;
                    segment[1] = vertex;
                    if (segmentData.index === CIRCLE_CENTER_INDEX) {
                        this.changingFeature_ = true;
                        geometry.setCenter(vertex);
                        this.changingFeature_ = false;
                    } else {
                        // We're dragging the circle's circumference:
                        this.changingFeature_ = true;
                        const projection = evt.map.getView().getProjection();
                        let radius = (0, _coordinateJs.distance)((0, _projJs.fromUserCoordinate)(geometry.getCenter(), projection), (0, _projJs.fromUserCoordinate)(vertex, projection));
                        const userProjection = (0, _projJs.getUserProjection)();
                        if (userProjection) {
                            const circleGeometry = geometry.clone().transform(userProjection, projection);
                            circleGeometry.setRadius(radius);
                            radius = circleGeometry.transform(projection, userProjection).getRadius();
                        }
                        geometry.setRadius(radius);
                        this.changingFeature_ = false;
                    }
                    break;
                default:
            }
            if (coordinates) this.setGeometryCoordinates_(geometry, coordinates);
        }
        this.createOrUpdateVertexFeature_(vertex, features, geometries);
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(evt) {
        if (!this.condition_(evt)) return false;
        const pixelCoordinate = evt.coordinate;
        this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
        this.dragSegments_.length = 0;
        this.featuresBeingModified_ = null;
        const vertexFeature = this.vertexFeature_;
        if (vertexFeature) {
            const projection = evt.map.getView().getProjection();
            const insertVertices = [];
            const vertex = vertexFeature.getGeometry().getCoordinates();
            const vertexExtent = (0, _extentJs.boundingExtent)([
                vertex
            ]);
            const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
            const componentSegments = {};
            segmentDataMatches.sort(compareIndexes);
            for(let i = 0, ii = segmentDataMatches.length; i < ii; ++i){
                const segmentDataMatch = segmentDataMatches[i];
                const segment = segmentDataMatch.segment;
                let uid = (0, _utilJs.getUid)(segmentDataMatch.geometry);
                const depth = segmentDataMatch.depth;
                if (depth) uid += '-' + depth.join('-'); // separate feature components
                if (!componentSegments[uid]) componentSegments[uid] = new Array(2);
                if (segmentDataMatch.geometry.getType() === 'Circle' && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                    const closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);
                    if ((0, _coordinateJs.equals)(closestVertex, vertex) && !componentSegments[uid][0]) {
                        this.dragSegments_.push([
                            segmentDataMatch,
                            0
                        ]);
                        componentSegments[uid][0] = segmentDataMatch;
                    }
                    continue;
                }
                if ((0, _coordinateJs.equals)(segment[0], vertex) && !componentSegments[uid][0]) {
                    this.dragSegments_.push([
                        segmentDataMatch,
                        0
                    ]);
                    componentSegments[uid][0] = segmentDataMatch;
                    continue;
                }
                if ((0, _coordinateJs.equals)(segment[1], vertex) && !componentSegments[uid][1]) {
                    if (componentSegments[uid][0] && componentSegments[uid][0].index === 0) {
                        let coordinates = segmentDataMatch.geometry.getCoordinates();
                        switch(segmentDataMatch.geometry.getType()){
                            // prevent dragging closed linestrings by the connecting node
                            case 'LineString':
                            case 'MultiLineString':
                                continue;
                            // if dragging the first vertex of a polygon, ensure the other segment
                            // belongs to the closing vertex of the linear ring
                            case 'MultiPolygon':
                                coordinates = coordinates[depth[1]];
                            /* falls through */ case 'Polygon':
                                if (segmentDataMatch.index !== coordinates[depth[0]].length - 2) continue;
                                break;
                            default:
                        }
                    }
                    this.dragSegments_.push([
                        segmentDataMatch,
                        1
                    ]);
                    componentSegments[uid][1] = segmentDataMatch;
                    continue;
                }
                if ((0, _utilJs.getUid)(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1] && this.insertVertexCondition_(evt)) insertVertices.push(segmentDataMatch);
            }
            if (insertVertices.length) this.willModifyFeatures_(evt, [
                insertVertices
            ]);
            for(let j = insertVertices.length - 1; j >= 0; --j)this.insertVertex_(insertVertices[j], vertex);
        }
        return !!this.vertexFeature_;
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(evt) {
        for(let i = this.dragSegments_.length - 1; i >= 0; --i){
            const segmentData = this.dragSegments_[i][0];
            const geometry = segmentData.geometry;
            if (geometry.getType() === 'Circle') {
                // Update a circle object in the R* bush:
                const coordinates = geometry.getCenter();
                const centerSegmentData = segmentData.featureSegments[0];
                const circumferenceSegmentData = segmentData.featureSegments[1];
                centerSegmentData.segment[0] = coordinates;
                centerSegmentData.segment[1] = coordinates;
                circumferenceSegmentData.segment[0] = coordinates;
                circumferenceSegmentData.segment[1] = coordinates;
                this.rBush_.update((0, _extentJs.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
                let circleGeometry = geometry;
                const userProjection = (0, _projJs.getUserProjection)();
                if (userProjection) {
                    const projection = evt.map.getView().getProjection();
                    circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                    circleGeometry = (0, _polygonJs.fromCircle)(circleGeometry).transform(projection, userProjection);
                }
                this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
            } else this.rBush_.update((0, _extentJs.boundingExtent)(segmentData.segment), segmentData);
        }
        if (this.featuresBeingModified_) {
            this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
            this.featuresBeingModified_ = null;
        }
        return false;
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */ handlePointerMove_(evt) {
        this.lastPixel_ = evt.pixel;
        this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
    }
    /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../Map.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate} [coordinate] The pixel Coordinate.
   * @private
   */ handlePointerAtPixel_(pixel, map, coordinate) {
        const pixelCoordinate = coordinate || map.getCoordinateFromPixel(pixel);
        const projection = map.getView().getProjection();
        const sortByDistance = function(a, b) {
            return projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection);
        };
        /** @type {Array<SegmentData>|undefined} */ let nodes;
        /** @type {Point|undefined} */ let hitPointGeometry;
        if (this.hitDetection_) {
            const layerFilter = typeof this.hitDetection_ === 'object' ? (layer)=>layer === this.hitDetection_ : undefined;
            map.forEachFeatureAtPixel(pixel, (feature, layer, geometry)=>{
                if (geometry && geometry.getType() === 'Point') geometry = new (0, _pointJsDefault.default)((0, _projJs.toUserCoordinate)(geometry.getCoordinates(), projection));
                const geom = geometry || feature.getGeometry();
                if (feature instanceof (0, _featureJsDefault.default) && this.features_.getArray().includes(feature)) {
                    hitPointGeometry = /** @type {Point} */ geom;
                    const coordinate = /** @type {Point} */ feature.getGeometry().getFlatCoordinates().slice(0, 2);
                    nodes = [
                        {
                            feature,
                            geometry: hitPointGeometry,
                            segment: [
                                coordinate,
                                coordinate
                            ]
                        }
                    ];
                }
                return true;
            }, {
                layerFilter
            });
        }
        if (!nodes) {
            const viewExtent = (0, _projJs.fromUserExtent)((0, _extentJs.createOrUpdateFromCoordinate)(pixelCoordinate, tempExtent), projection);
            const buffer = map.getView().getResolution() * this.pixelTolerance_;
            const box = (0, _projJs.toUserExtent)((0, _extentJs.buffer)(viewExtent, buffer, tempExtent), projection);
            nodes = this.rBush_.getInExtent(box);
        }
        if (nodes && nodes.length > 0) {
            const node = nodes.sort(sortByDistance)[0];
            const closestSegment = node.segment;
            let vertex = closestOnSegmentData(pixelCoordinate, node, projection);
            const vertexPixel = map.getPixelFromCoordinate(vertex);
            let dist = (0, _coordinateJs.distance)(pixel, vertexPixel);
            if (hitPointGeometry || dist <= this.pixelTolerance_) {
                /** @type {Object<string, boolean>} */ const vertexSegments = {};
                vertexSegments[(0, _utilJs.getUid)(closestSegment)] = true;
                if (!this.snapToPointer_) {
                    this.delta_[0] = vertex[0] - pixelCoordinate[0];
                    this.delta_[1] = vertex[1] - pixelCoordinate[1];
                }
                if (node.geometry.getType() === 'Circle' && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                    this.snappedToVertex_ = true;
                    this.createOrUpdateVertexFeature_(vertex, [
                        node.feature
                    ], [
                        node.geometry
                    ]);
                } else {
                    const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                    const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                    const squaredDist1 = (0, _coordinateJs.squaredDistance)(vertexPixel, pixel1);
                    const squaredDist2 = (0, _coordinateJs.squaredDistance)(vertexPixel, pixel2);
                    dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                    this.snappedToVertex_ = dist <= this.pixelTolerance_;
                    if (this.snappedToVertex_) vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                    this.createOrUpdateVertexFeature_(vertex, [
                        node.feature
                    ], [
                        node.geometry
                    ]);
                    const geometries = {};
                    geometries[(0, _utilJs.getUid)(node.geometry)] = true;
                    for(let i = 1, ii = nodes.length; i < ii; ++i){
                        const segment = nodes[i].segment;
                        if ((0, _coordinateJs.equals)(closestSegment[0], segment[0]) && (0, _coordinateJs.equals)(closestSegment[1], segment[1]) || (0, _coordinateJs.equals)(closestSegment[0], segment[1]) && (0, _coordinateJs.equals)(closestSegment[1], segment[0])) {
                            const geometryUid = (0, _utilJs.getUid)(nodes[i].geometry);
                            if (!(geometryUid in geometries)) {
                                geometries[geometryUid] = true;
                                vertexSegments[(0, _utilJs.getUid)(segment)] = true;
                            }
                        } else break;
                    }
                }
                this.vertexSegments_ = vertexSegments;
                return;
            }
        }
        if (this.vertexFeature_) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
    }
    /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */ insertVertex_(segmentData, vertex) {
        const segment = segmentData.segment;
        const feature = segmentData.feature;
        const geometry = segmentData.geometry;
        const depth = segmentData.depth;
        const index = segmentData.index;
        let coordinates;
        while(vertex.length < geometry.getStride())vertex.push(0);
        switch(geometry.getType()){
            case 'MultiLineString':
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
            case 'Polygon':
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
            case 'MultiPolygon':
                coordinates = geometry.getCoordinates();
                coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
                break;
            case 'LineString':
                coordinates = geometry.getCoordinates();
                coordinates.splice(index + 1, 0, vertex);
                break;
            default:
                return;
        }
        this.setGeometryCoordinates_(geometry, coordinates);
        const rTree = this.rBush_;
        rTree.remove(segmentData);
        this.updateSegmentIndices_(geometry, index, depth, 1);
        /** @type {SegmentData} */ const newSegmentData = {
            segment: [
                segment[0],
                vertex
            ],
            feature: feature,
            geometry: geometry,
            depth: depth,
            index: index
        };
        rTree.insert((0, _extentJs.boundingExtent)(newSegmentData.segment), newSegmentData);
        this.dragSegments_.push([
            newSegmentData,
            1
        ]);
        /** @type {SegmentData} */ const newSegmentData2 = {
            segment: [
                vertex,
                segment[1]
            ],
            feature: feature,
            geometry: geometry,
            depth: depth,
            index: index + 1
        };
        rTree.insert((0, _extentJs.boundingExtent)(newSegmentData2.segment), newSegmentData2);
        this.dragSegments_.push([
            newSegmentData2,
            0
        ]);
        this.ignoreNextSingleClick_ = true;
    }
    /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */ removePoint() {
        if (this.lastPointerEvent_ && this.lastPointerEvent_.type != (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG) {
            const evt = this.lastPointerEvent_;
            this.willModifyFeatures_(evt, this.dragSegments_);
            const removed = this.removeVertex_();
            if (this.featuresBeingModified_) this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
            this.featuresBeingModified_ = null;
            return removed;
        }
        return false;
    }
    /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */ removeVertex_() {
        const dragSegments = this.dragSegments_;
        const segmentsByFeature = {};
        let deleted = false;
        let component, coordinates, dragSegment, geometry, i, index, left;
        let newIndex, right, segmentData, uid;
        for(i = dragSegments.length - 1; i >= 0; --i){
            dragSegment = dragSegments[i];
            segmentData = dragSegment[0];
            uid = (0, _utilJs.getUid)(segmentData.feature);
            if (segmentData.depth) // separate feature components
            uid += '-' + segmentData.depth.join('-');
            if (!(uid in segmentsByFeature)) segmentsByFeature[uid] = {};
            if (dragSegment[1] === 0) {
                segmentsByFeature[uid].right = segmentData;
                segmentsByFeature[uid].index = segmentData.index;
            } else if (dragSegment[1] == 1) {
                segmentsByFeature[uid].left = segmentData;
                segmentsByFeature[uid].index = segmentData.index + 1;
            }
        }
        for(uid in segmentsByFeature){
            right = segmentsByFeature[uid].right;
            left = segmentsByFeature[uid].left;
            index = segmentsByFeature[uid].index;
            newIndex = index - 1;
            if (left !== undefined) segmentData = left;
            else segmentData = right;
            if (newIndex < 0) newIndex = 0;
            geometry = segmentData.geometry;
            coordinates = geometry.getCoordinates();
            component = coordinates;
            deleted = false;
            switch(geometry.getType()){
                case 'MultiLineString':
                    if (coordinates[segmentData.depth[0]].length > 2) {
                        coordinates[segmentData.depth[0]].splice(index, 1);
                        deleted = true;
                    }
                    break;
                case 'LineString':
                    if (coordinates.length > 2) {
                        coordinates.splice(index, 1);
                        deleted = true;
                    }
                    break;
                case 'MultiPolygon':
                    component = component[segmentData.depth[1]];
                /* falls through */ case 'Polygon':
                    component = component[segmentData.depth[0]];
                    if (component.length > 4) {
                        if (index == component.length - 1) index = 0;
                        component.splice(index, 1);
                        deleted = true;
                        if (index === 0) {
                            // close the ring again
                            component.pop();
                            component.push(component[0]);
                            newIndex = component.length - 1;
                        }
                    }
                    break;
                default:
            }
            if (deleted) {
                this.setGeometryCoordinates_(geometry, coordinates);
                const segments = [];
                if (left !== undefined) {
                    this.rBush_.remove(left);
                    segments.push(left.segment[0]);
                }
                if (right !== undefined) {
                    this.rBush_.remove(right);
                    segments.push(right.segment[1]);
                }
                if (left !== undefined && right !== undefined) {
                    /** @type {SegmentData} */ const newSegmentData = {
                        depth: segmentData.depth,
                        feature: segmentData.feature,
                        geometry: segmentData.geometry,
                        index: newIndex,
                        segment: segments
                    };
                    this.rBush_.insert((0, _extentJs.boundingExtent)(newSegmentData.segment), newSegmentData);
                }
                this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
                if (this.vertexFeature_) {
                    this.overlay_.getSource().removeFeature(this.vertexFeature_);
                    this.vertexFeature_ = null;
                }
                dragSegments.length = 0;
            }
        }
        return deleted;
    }
    /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */ setGeometryCoordinates_(geometry, coordinates) {
        this.changingFeature_ = true;
        geometry.setCoordinates(coordinates);
        this.changingFeature_ = false;
    }
    /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */ updateSegmentIndices_(geometry, index, depth, delta) {
        this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
            if (segmentDataMatch.geometry === geometry && (depth === undefined || segmentDataMatch.depth === undefined || (0, _arrayJs.equals)(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) segmentDataMatch.index += delta;
        });
    }
}
/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */ function compareIndexes(a, b) {
    return a.index - b.index;
}
/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {number} The square of the distance between a point and a line segment.
 */ function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
    const geometry = segmentData.geometry;
    if (geometry.getType() === 'Circle') {
        let circleGeometry = /** @type {import("../geom/Circle.js").default} */ geometry;
        if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
            const userProjection = (0, _projJs.getUserProjection)();
            if (userProjection) circleGeometry = /** @type {import("../geom/Circle.js").default} */ circleGeometry.clone().transform(userProjection, projection);
            const distanceToCenterSquared = (0, _coordinateJs.squaredDistance)(circleGeometry.getCenter(), (0, _projJs.fromUserCoordinate)(pointCoordinates, projection));
            const distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
            return distanceToCircumference * distanceToCircumference;
        }
    }
    const coordinate = (0, _projJs.fromUserCoordinate)(pointCoordinates, projection);
    tempSegment[0] = (0, _projJs.fromUserCoordinate)(segmentData.segment[0], projection);
    tempSegment[1] = (0, _projJs.fromUserCoordinate)(segmentData.segment[1], projection);
    return (0, _coordinateJs.squaredDistanceToSegment)(coordinate, tempSegment);
}
/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */ function closestOnSegmentData(pointCoordinates, segmentData, projection) {
    const geometry = segmentData.geometry;
    if (geometry.getType() === 'Circle' && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
        let circleGeometry = /** @type {import("../geom/Circle.js").default} */ geometry;
        const userProjection = (0, _projJs.getUserProjection)();
        if (userProjection) circleGeometry = /** @type {import("../geom/Circle.js").default} */ circleGeometry.clone().transform(userProjection, projection);
        return (0, _projJs.toUserCoordinate)(circleGeometry.getClosestPoint((0, _projJs.fromUserCoordinate)(pointCoordinates, projection)), projection);
    }
    const coordinate = (0, _projJs.fromUserCoordinate)(pointCoordinates, projection);
    tempSegment[0] = (0, _projJs.fromUserCoordinate)(segmentData.segment[0], projection);
    tempSegment[1] = (0, _projJs.fromUserCoordinate)(segmentData.segment[1], projection);
    return (0, _projJs.toUserCoordinate)((0, _coordinateJs.closestOnSegment)(coordinate, tempSegment), projection);
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    const style = (0, _styleJs.createEditingStyle)();
    return function(feature, resolution) {
        return style['Point'];
    };
}
exports.default = Modify;

},{"../Collection.js":"hzcJw","../CollectionEventType.js":"auN7R","../events/Event.js":"kooRA","../events/EventType.js":"3uT2C","../Feature.js":"3qocF","../MapBrowserEventType.js":"2Xhyu","../geom/Point.js":"6SybV","./Pointer.js":"a39IA","../structs/RBush.js":"hKwrW","../source/VectorEventType.js":"efeJd","../layer/Vector.js":"6bOIK","../source/Vector.js":"7wT1g","../events/condition.js":"gm0iA","../extent.js":"bGUel","../coordinate.js":"fqHXJ","../style/Style.js":"8opjn","../array.js":"hyet5","../geom/Polygon.js":"8Vwps","../proj.js":"8OK47","../util.js":"l1iPW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3IZ3n":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Snap
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _rbushJs = require("../structs/RBush.js");
var _rbushJsDefault = parcelHelpers.interopDefault(_rbushJs);
var _vectorEventTypeJs = require("../source/VectorEventType.js");
var _vectorEventTypeJsDefault = parcelHelpers.interopDefault(_vectorEventTypeJs);
var _functionsJs = require("../functions.js");
var _snapEventJs = require("../events/SnapEvent.js");
var _extentJs = require("../extent.js");
var _coordinateJs = require("../coordinate.js");
var _polygonJs = require("../geom/Polygon.js");
var _projJs = require("../proj.js");
var _utilJs = require("../util.js");
var _eventsJs = require("../events.js");
/**
 * @typedef {Object} Result
 * @property {import("../coordinate.js").Coordinate|null} vertex Vertex.
 * @property {import("../pixel.js").Pixel|null} vertexPixel VertexPixel.
 * @property {import("../Feature.js").default|null} feature Feature.
 * @property {Array<import("../coordinate.js").Coordinate>|null} segment Segment, or `null` if snapped to a vertex.
 */ /**
 * @typedef {Object} SegmentData
 * @property {import("../Feature.js").default} feature Feature.
 * @property {Array<import("../coordinate.js").Coordinate>} segment Segment.
 */ /**
 * @typedef {Object} Options
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features] Snap to these features. Either this option or source should be provided.
 * @property {boolean} [edge=true] Snap to edges.
 * @property {boolean} [vertex=true] Snap to vertices.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
 * vertex for snapping.
 * @property {import("../source/Vector.js").default} [source] Snap to features from this source. Either this option or features should be provided
 */ /**
 * @param  {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
 * @return {import("../Feature.js").default|null} Feature.
 */ function getFeatureFromEvent(evt) {
    if (/** @type {import("../source/Vector.js").VectorSourceEvent} */ evt.feature) return /** @type {import("../source/Vector.js").VectorSourceEvent} */ evt.feature;
    if (/** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */ evt.element) return /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */ evt.element;
    return null;
}
const tempSegment = [];
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'snap', SnapEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'snap', Return>} SnapOnSignature
 */ /**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Example:
 *
 *     import Snap from 'ol/interaction/Snap.js';
 *
 *     const snap = new Snap({
 *       source: source
 *     });
 *
 *     map.addInteraction(snap);
 *
 * @fires SnapEvent
 * @api
 */ class Snap extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const pointerOptions = /** @type {import("./Pointer.js").Options} */ options;
        if (!pointerOptions.handleDownEvent) pointerOptions.handleDownEvent = (0, _functionsJs.TRUE);
        if (!pointerOptions.stopDown) pointerOptions.stopDown = (0, _functionsJs.FALSE);
        super(pointerOptions);
        /***
     * @type {SnapOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {SnapOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {SnapOnSignature<void>}
     */ this.un;
        /**
     * @type {import("../source/Vector.js").default|null}
     * @private
     */ this.source_ = options.source ? options.source : null;
        /**
     * @private
     * @type {boolean}
     */ this.vertex_ = options.vertex !== undefined ? options.vertex : true;
        /**
     * @private
     * @type {boolean}
     */ this.edge_ = options.edge !== undefined ? options.edge : true;
        /**
     * @type {import("../Collection.js").default<import("../Feature.js").default>|null}
     * @private
     */ this.features_ = options.features ? options.features : null;
        /**
     * @type {Array<import("../events.js").EventsKey>}
     * @private
     */ this.featuresListenerKeys_ = [];
        /**
     * @type {Object<string, import("../events.js").EventsKey>}
     * @private
     */ this.featureChangeListenerKeys_ = {};
        /**
     * Extents are preserved so indexed segment can be quickly removed
     * when its feature geometry changes
     * @type {Object<string, import("../extent.js").Extent>}
     * @private
     */ this.indexedFeaturesExtents_ = {};
        /**
     * If a feature geometry changes while a pointer drag|move event occurs, the
     * feature doesn't get updated right away.  It will be at the next 'pointerup'
     * event fired.
     * @type {!Object<string, import("../Feature.js").default>}
     * @private
     */ this.pendingFeatures_ = {};
        /**
     * @type {number}
     * @private
     */ this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
        /**
     * Segment RTree for each layer
     * @type {import("../structs/RBush.js").default<SegmentData>}
     * @private
     */ this.rBush_ = new (0, _rbushJsDefault.default)();
        /**
     * @const
     * @private
     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import("../geom/Geometry.js").default): void>}
     */ this.GEOMETRY_SEGMENTERS_ = {
            'Point': this.segmentPointGeometry_.bind(this),
            'LineString': this.segmentLineStringGeometry_.bind(this),
            'LinearRing': this.segmentLineStringGeometry_.bind(this),
            'Polygon': this.segmentPolygonGeometry_.bind(this),
            'MultiPoint': this.segmentMultiPointGeometry_.bind(this),
            'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),
            'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),
            'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),
            'Circle': this.segmentCircleGeometry_.bind(this)
        };
    }
    /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean} [register] Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */ addFeature(feature, register) {
        register = register !== undefined ? register : true;
        const feature_uid = (0, _utilJs.getUid)(feature);
        const geometry = feature.getGeometry();
        if (geometry) {
            const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];
            if (segmenter) {
                this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent((0, _extentJs.createEmpty)());
                const segments = /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ [];
                segmenter(segments, geometry);
                if (segments.length === 1) this.rBush_.insert((0, _extentJs.boundingExtent)(segments[0]), {
                    feature: feature,
                    segment: segments[0]
                });
                else if (segments.length > 1) {
                    const extents = segments.map((s)=>(0, _extentJs.boundingExtent)(s));
                    const segmentsData = segments.map((segment)=>({
                            feature: feature,
                            segment: segment
                        }));
                    this.rBush_.load(extents, segmentsData);
                }
            }
        }
        if (register) this.featureChangeListenerKeys_[feature_uid] = (0, _eventsJs.listen)(feature, (0, _eventTypeJsDefault.default).CHANGE, this.handleFeatureChange_, this);
    }
    /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */ getFeatures_() {
        /** @type {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} */ let features;
        if (this.features_) features = this.features_;
        else if (this.source_) features = this.source_.getFeatures();
        return features;
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(evt) {
        const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
        if (result) {
            evt.coordinate = result.vertex.slice(0, 2);
            evt.pixel = result.vertexPixel;
            this.dispatchEvent(new (0, _snapEventJs.SnapEvent)((0, _snapEventJs.SnapEventType).SNAP, {
                vertex: evt.coordinate,
                vertexPixel: evt.pixel,
                feature: result.feature,
                segment: result.segment
            }));
        }
        return super.handleEvent(evt);
    }
    /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */ handleFeatureAdd_(evt) {
        const feature = getFeatureFromEvent(evt);
        if (feature) this.addFeature(feature);
    }
    /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */ handleFeatureRemove_(evt) {
        const feature = getFeatureFromEvent(evt);
        if (feature) this.removeFeature(feature);
    }
    /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */ handleFeatureChange_(evt) {
        const feature = /** @type {import("../Feature.js").default} */ evt.target;
        if (this.handlingDownUpSequence) {
            const uid = (0, _utilJs.getUid)(feature);
            if (!(uid in this.pendingFeatures_)) this.pendingFeatures_[uid] = feature;
        } else this.updateFeature_(feature);
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(evt) {
        const featuresToUpdate = Object.values(this.pendingFeatures_);
        if (featuresToUpdate.length) {
            featuresToUpdate.forEach(this.updateFeature_.bind(this));
            this.pendingFeatures_ = {};
        }
        return false;
    }
    /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean} [unlisten] Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */ removeFeature(feature, unlisten) {
        const unregister = unlisten !== undefined ? unlisten : true;
        const feature_uid = (0, _utilJs.getUid)(feature);
        const extent = this.indexedFeaturesExtents_[feature_uid];
        if (extent) {
            const rBush = this.rBush_;
            const nodesToRemove = [];
            rBush.forEachInExtent(extent, function(node) {
                if (feature === node.feature) nodesToRemove.push(node);
            });
            for(let i = nodesToRemove.length - 1; i >= 0; --i)rBush.remove(nodesToRemove[i]);
        }
        if (unregister) {
            (0, _eventsJs.unlistenByKey)(this.featureChangeListenerKeys_[feature_uid]);
            delete this.featureChangeListenerKeys_[feature_uid];
        }
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */ setMap(map) {
        const currentMap = this.getMap();
        const keys = this.featuresListenerKeys_;
        const features = /** @type {Array<import("../Feature.js").default>} */ this.getFeatures_();
        if (currentMap) {
            keys.forEach((0, _eventsJs.unlistenByKey));
            keys.length = 0;
            this.rBush_.clear();
            Object.values(this.featureChangeListenerKeys_).forEach((0, _eventsJs.unlistenByKey));
            this.featureChangeListenerKeys_ = {};
        }
        super.setMap(map);
        if (map) {
            if (this.features_) keys.push((0, _eventsJs.listen)(this.features_, (0, _collectionEventTypeJsDefault.default).ADD, this.handleFeatureAdd_, this), (0, _eventsJs.listen)(this.features_, (0, _collectionEventTypeJsDefault.default).REMOVE, this.handleFeatureRemove_, this));
            else if (this.source_) keys.push((0, _eventsJs.listen)(this.source_, (0, _vectorEventTypeJsDefault.default).ADDFEATURE, this.handleFeatureAdd_, this), (0, _eventsJs.listen)(this.source_, (0, _vectorEventTypeJsDefault.default).REMOVEFEATURE, this.handleFeatureRemove_, this));
            features.forEach((feature)=>this.addFeature(feature));
        }
    }
    /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../Map.js").default} map Map.
   * @return {Result|null} Snap result
   */ snapTo(pixel, pixelCoordinate, map) {
        const projection = map.getView().getProjection();
        const projectedCoordinate = (0, _projJs.fromUserCoordinate)(pixelCoordinate, projection);
        const box = (0, _projJs.toUserExtent)((0, _extentJs.buffer)((0, _extentJs.boundingExtent)([
            projectedCoordinate
        ]), map.getView().getResolution() * this.pixelTolerance_), projection);
        const segments = this.rBush_.getInExtent(box);
        const segmentsLength = segments.length;
        if (segmentsLength === 0) return null;
        let closestVertex;
        let minSquaredDistance = Infinity;
        let closestFeature;
        let closestSegment = null;
        const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;
        const getResult = ()=>{
            if (closestVertex) {
                const vertexPixel = map.getPixelFromCoordinate(closestVertex);
                const squaredPixelDistance = (0, _coordinateJs.squaredDistance)(pixel, vertexPixel);
                if (squaredPixelDistance <= squaredPixelTolerance) return {
                    vertex: closestVertex,
                    vertexPixel: [
                        Math.round(vertexPixel[0]),
                        Math.round(vertexPixel[1])
                    ],
                    feature: closestFeature,
                    segment: closestSegment
                };
            }
            return null;
        };
        if (this.vertex_) {
            for(let i = 0; i < segmentsLength; ++i){
                const segmentData = segments[i];
                if (segmentData.feature.getGeometry().getType() !== 'Circle') segmentData.segment.forEach((vertex)=>{
                    const tempVertexCoord = (0, _projJs.fromUserCoordinate)(vertex, projection);
                    const delta = (0, _coordinateJs.squaredDistance)(projectedCoordinate, tempVertexCoord);
                    if (delta < minSquaredDistance) {
                        closestVertex = vertex;
                        minSquaredDistance = delta;
                        closestFeature = segmentData.feature;
                    }
                });
            }
            const result = getResult();
            if (result) return result;
        }
        if (this.edge_) {
            for(let i = 0; i < segmentsLength; ++i){
                let vertex = null;
                const segmentData = segments[i];
                if (segmentData.feature.getGeometry().getType() === 'Circle') {
                    let circleGeometry = segmentData.feature.getGeometry();
                    const userProjection = (0, _projJs.getUserProjection)();
                    if (userProjection) circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                    vertex = (0, _coordinateJs.closestOnCircle)(projectedCoordinate, /** @type {import("../geom/Circle.js").default} */ circleGeometry);
                } else {
                    const [segmentStart, segmentEnd] = segmentData.segment;
                    // points have only one coordinate
                    if (segmentEnd) {
                        tempSegment[0] = (0, _projJs.fromUserCoordinate)(segmentStart, projection);
                        tempSegment[1] = (0, _projJs.fromUserCoordinate)(segmentEnd, projection);
                        vertex = (0, _coordinateJs.closestOnSegment)(projectedCoordinate, tempSegment);
                    }
                }
                if (vertex) {
                    const delta = (0, _coordinateJs.squaredDistance)(projectedCoordinate, vertex);
                    if (delta < minSquaredDistance) {
                        closestVertex = (0, _projJs.toUserCoordinate)(vertex, projection);
                        closestSegment = segmentData.feature.getGeometry().getType() === 'Circle' ? null : segmentData.segment;
                        minSquaredDistance = delta;
                    }
                }
            }
            const result = getResult();
            if (result) return result;
        }
        return null;
    }
    /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */ updateFeature_(feature) {
        this.removeFeature(feature, false);
        this.addFeature(feature, false);
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */ segmentCircleGeometry_(segments, geometry) {
        const projection = this.getMap().getView().getProjection();
        let circleGeometry = geometry;
        const userProjection = (0, _projJs.getUserProjection)();
        if (userProjection) circleGeometry = /** @type {import("../geom/Circle.js").default} */ circleGeometry.clone().transform(userProjection, projection);
        const polygon = (0, _polygonJs.fromCircle)(circleGeometry);
        if (userProjection) polygon.transform(projection, userProjection);
        const coordinates = polygon.getCoordinates()[0];
        for(let i = 0, ii = coordinates.length - 1; i < ii; ++i)segments.push(coordinates.slice(i, i + 2));
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */ segmentGeometryCollectionGeometry_(segments, geometry) {
        const geometries = geometry.getGeometriesArray();
        for(let i = 0; i < geometries.length; ++i){
            const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];
            if (segmenter) segmenter(segments, geometries[i]);
        }
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */ segmentLineStringGeometry_(segments, geometry) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length - 1; i < ii; ++i)segments.push(coordinates.slice(i, i + 2));
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */ segmentMultiLineStringGeometry_(segments, geometry) {
        const lines = geometry.getCoordinates();
        for(let j = 0, jj = lines.length; j < jj; ++j){
            const coordinates = lines[j];
            for(let i = 0, ii = coordinates.length - 1; i < ii; ++i)segments.push(coordinates.slice(i, i + 2));
        }
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */ segmentMultiPointGeometry_(segments, geometry) {
        geometry.getCoordinates().forEach((point)=>{
            segments.push([
                point
            ]);
        });
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */ segmentMultiPolygonGeometry_(segments, geometry) {
        const polygons = geometry.getCoordinates();
        for(let k = 0, kk = polygons.length; k < kk; ++k){
            const rings = polygons[k];
            for(let j = 0, jj = rings.length; j < jj; ++j){
                const coordinates = rings[j];
                for(let i = 0, ii = coordinates.length - 1; i < ii; ++i)segments.push(coordinates.slice(i, i + 2));
            }
        }
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */ segmentPointGeometry_(segments, geometry) {
        segments.push([
            geometry.getCoordinates()
        ]);
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */ segmentPolygonGeometry_(segments, geometry) {
        const rings = geometry.getCoordinates();
        for(let j = 0, jj = rings.length; j < jj; ++j){
            const coordinates = rings[j];
            for(let i = 0, ii = coordinates.length - 1; i < ii; ++i)segments.push(coordinates.slice(i, i + 2));
        }
    }
}
exports.default = Snap;

},{"../CollectionEventType.js":"auN7R","../events/EventType.js":"3uT2C","./Pointer.js":"a39IA","../structs/RBush.js":"hKwrW","../source/VectorEventType.js":"efeJd","../functions.js":"1QSsQ","../events/SnapEvent.js":"avwXI","../extent.js":"bGUel","../coordinate.js":"fqHXJ","../geom/Polygon.js":"8Vwps","../proj.js":"8OK47","../util.js":"l1iPW","../events.js":"lh4km","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"avwXI":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/SnapEvent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SnapEventType", ()=>SnapEventType);
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Snap~Snap} instances are instances of this
 */ parcelHelpers.export(exports, "SnapEvent", ()=>SnapEvent);
var _eventJs = require("./Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
const SnapEventType = {
    /**
   * Triggered upon snapping to vertex or edge
   * @event SnapEvent#snap
   * @api
   */ SNAP: 'snap'
};
class SnapEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {SnapEventType} type Type.
   * @param {Object} options Options.
   * @param {import("../coordinate.js").Coordinate} options.vertex The snapped vertex.
   * @param {import("../coordinate.js").Coordinate} options.vertexPixel The pixel of the snapped vertex.
   * @param {import("../Feature.js").default} options.feature The feature being snapped.
   * @param {Array<import("../coordinate.js").Coordinate>|null} options.segment Segment, or `null` if snapped to a vertex.
   */ constructor(type, options){
        super(type);
        /**
     * The Map coordinate of the snapped point.
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */ this.vertex = options.vertex;
        /**
     * The Map pixel of the snapped point.
     * @type {Array<number>&Array<number>}
     * @api
     */ this.vertexPixel = options.vertexPixel;
        /**
     * The feature closest to the snapped point.
     * @type {import("../Feature.js").default<import("../geom/Geometry.js").default>}
     * @api
     */ this.feature = options.feature;
        /**
     * The segment closest to the snapped point, if snapped to a segment.
     * @type {Array<import("../coordinate.js").Coordinate>|null}
     * @api
     */ this.segment = options.segment;
    }
}

},{"./Event.js":"kooRA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aLfQY":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Draw
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */ parcelHelpers.export(exports, "DrawEvent", ()=>DrawEvent);
/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of a
 * {@link import("../geom/Circle.js").Circle} geometry.
 * @param {number} [sides] Number of sides of the regular polygon.
 *     Default is 32.
 * @param {number} [angle] Angle of the first point in counter-clockwise
 *     radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a polygon.
 * @api
 */ parcelHelpers.export(exports, "createRegularPolygon", ()=>createRegularPolygon);
/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */ parcelHelpers.export(exports, "createBox", ()=>createBox);
var _circleJs = require("../geom/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geometryCollectionJs = require("../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _mapBrowserEventJs = require("../MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPointJs = require("../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _vectorJs = require("../layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _vectorJs1 = require("../source/Vector.js");
var _vectorJsDefault1 = parcelHelpers.interopDefault(_vectorJs1);
var _functionsJs = require("../functions.js");
var _conditionJs = require("../events/condition.js");
var _extentJs = require("../extent.js");
var _mathJs = require("../math.js");
var _styleJs = require("../style/Style.js");
var _coordinateJs = require("../coordinate.js");
var _projJs = require("../proj.js");
var _simpleGeometryJs = require("../geom/SimpleGeometry.js");
/**
 * @typedef {Object} Options
 * @property {import("../geom/Geometry.js").Type} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish. Must be greater than `0`.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished. Not used when drawing
 * POINT or MULTI_POINT geometries.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.
 * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.
 * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with
 * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.
 * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`
 * geometry that corresponds to the polygon between the already drawn points and the current cursor position
 * (note that this polygon has only two points if only one point is drawn).
 * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose
 * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean|import("../events/condition.js").Condition} [trace=false] Trace a portion of another geometry.
 * Ignored when in freehand mode.
 * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is
 * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with
 * either a `traceSource` or a `source`.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {import("../geom/Geometry.js").GeometryLayout} [geometryLayout='XY'] Layout of the
 * feature geometries created by the draw interaction.
 */ /**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */ /**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */ /**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */ /**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */ /**
 * @typedef {Object} TraceState
 * @property {boolean} active Tracing active.
 * @property {import("../pixel.js").Pixel} [startPx] The initially clicked pixel location.
 * @property {Array<TraceTarget>} [targets] Targets available for tracing.
 * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates
 * that no trace target is active.
 */ /**
 * @typedef {Object} TraceTarget
 * @property {Array<import("../coordinate.js").Coordinate>} coordinates Target coordinates.
 * @property {boolean} ring The target coordinates are a linear ring.
 * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an
 * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).
 * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.
 */ /**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default,
 *     import("../proj/Projection.js").default):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */ /**
 * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 */ /**
 * @enum {string}
 */ const DrawEventType = {
    /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */ DRAWSTART: 'drawstart',
    /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */ DRAWEND: 'drawend',
    /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */ DRAWABORT: 'drawabort'
};
class DrawEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */ constructor(type, feature){
        super(type);
        /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */ this.feature = feature;
    }
}
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {Array<Feature>} features The candidate features.
 * @return {Array<TraceTarget>} The trace targets.
 */ function getTraceTargets(coordinate, features) {
    /**
   * @type {Array<TraceTarget>}
   */ const targets = [];
    for(let i = 0; i < features.length; ++i){
        const feature = features[i];
        const geometry = feature.getGeometry();
        appendGeometryTraceTargets(coordinate, geometry, targets);
    }
    return targets;
}
/**
 * @param {import("../coordinate.js").Coordinate} a One coordinate.
 * @param {import("../coordinate.js").Coordinate} b Another coordinate.
 * @return {number} The squared distance between the two coordinates.
 */ function getSquaredDistance(a, b) {
    return (0, _mathJs.squaredDistance)(a[0], a[1], b[0], b[1]);
}
/**
 * @param {LineCoordType} coordinates The ring coordinates.
 * @param {number} index The index.  May be wrapped.
 * @return {import("../coordinate.js").Coordinate} The coordinate.
 */ function getCoordinate(coordinates, index) {
    const count = coordinates.length;
    if (index < 0) return coordinates[index + count];
    if (index >= count) return coordinates[index - count];
    return coordinates[index];
}
/**
 * Get the cumulative squared distance along a ring path.  The end index index may be "wrapped" and it may
 * be less than the start index to indicate the direction of travel.  The start and end index may have
 * a fractional part to indicate a point between two coordinates.
 * @param {LineCoordType} coordinates Ring coordinates.
 * @param {number} startIndex The start index.
 * @param {number} endIndex The end index.
 * @return {number} The cumulative squared distance along the ring path.
 */ function getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {
    let lowIndex, highIndex;
    if (startIndex < endIndex) {
        lowIndex = startIndex;
        highIndex = endIndex;
    } else {
        lowIndex = endIndex;
        highIndex = startIndex;
    }
    const lowWholeIndex = Math.ceil(lowIndex);
    const highWholeIndex = Math.floor(highIndex);
    if (lowWholeIndex > highWholeIndex) {
        // both start and end are on the same segment
        const start = interpolateCoordinate(coordinates, lowIndex);
        const end = interpolateCoordinate(coordinates, highIndex);
        return getSquaredDistance(start, end);
    }
    let sd = 0;
    if (lowIndex < lowWholeIndex) {
        const start = interpolateCoordinate(coordinates, lowIndex);
        const end = getCoordinate(coordinates, lowWholeIndex);
        sd += getSquaredDistance(start, end);
    }
    if (highWholeIndex < highIndex) {
        const start = getCoordinate(coordinates, highWholeIndex);
        const end = interpolateCoordinate(coordinates, highIndex);
        sd += getSquaredDistance(start, end);
    }
    for(let i = lowWholeIndex; i < highWholeIndex - 1; ++i){
        const start = getCoordinate(coordinates, i);
        const end = getCoordinate(coordinates, i + 1);
        sd += getSquaredDistance(start, end);
    }
    return sd;
}
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {import("../geom/Geometry.js").default} geometry The candidate geometry.
 * @param {Array<TraceTarget>} targets The trace targets.
 */ function appendGeometryTraceTargets(coordinate, geometry, targets) {
    if (geometry instanceof (0, _lineStringJsDefault.default)) {
        appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);
        return;
    }
    if (geometry instanceof (0, _multiLineStringJsDefault.default)) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length; i < ii; ++i)appendTraceTarget(coordinate, coordinates[i], false, targets);
        return;
    }
    if (geometry instanceof (0, _polygonJsDefault.default)) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length; i < ii; ++i)appendTraceTarget(coordinate, coordinates[i], true, targets);
        return;
    }
    if (geometry instanceof (0, _multiPolygonJsDefault.default)) {
        const polys = geometry.getCoordinates();
        for(let i = 0, ii = polys.length; i < ii; ++i){
            const coordinates = polys[i];
            for(let j = 0, jj = coordinates.length; j < jj; ++j)appendTraceTarget(coordinate, coordinates[j], true, targets);
        }
        return;
    }
    if (geometry instanceof (0, _geometryCollectionJsDefault.default)) {
        const geometries = geometry.getGeometries();
        for(let i = 0; i < geometries.length; ++i)appendGeometryTraceTargets(coordinate, geometries[i], targets);
        return;
    }
// other types cannot be traced
}
/**
 * @typedef {Object} TraceTargetUpdateInfo
 * @property {number} index The new target index.
 * @property {number} endIndex The new segment end index.
 */ /**
 * @type {TraceTargetUpdateInfo}
 */ const sharedUpdateInfo = {
    index: -1,
    endIndex: NaN
};
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {TraceState} traceState The trace state.
 * @param {import("../Map.js").default} map The map.
 * @param {number} snapTolerance The snap tolerance.
 * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned
 * object is reused between calls and must not be modified by the caller.
 */ function getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {
    const x = coordinate[0];
    const y = coordinate[1];
    let closestTargetDistance = Infinity;
    let newTargetIndex = -1;
    let newEndIndex = NaN;
    for(let targetIndex = 0; targetIndex < traceState.targets.length; ++targetIndex){
        const target = traceState.targets[targetIndex];
        const coordinates = target.coordinates;
        let minSegmentDistance = Infinity;
        let endIndex;
        for(let coordinateIndex = 0; coordinateIndex < coordinates.length - 1; ++coordinateIndex){
            const start = coordinates[coordinateIndex];
            const end = coordinates[coordinateIndex + 1];
            const rel = getPointSegmentRelationship(x, y, start, end);
            if (rel.squaredDistance < minSegmentDistance) {
                minSegmentDistance = rel.squaredDistance;
                endIndex = coordinateIndex + rel.along;
            }
        }
        if (minSegmentDistance < closestTargetDistance) {
            closestTargetDistance = minSegmentDistance;
            if (target.ring && traceState.targetIndex === targetIndex) {
                // same target, maintain the same trace direction
                if (target.endIndex > target.startIndex) // forward trace
                {
                    if (endIndex < target.startIndex) endIndex += coordinates.length;
                } else if (target.endIndex < target.startIndex) // reverse trace
                {
                    if (endIndex > target.startIndex) endIndex -= coordinates.length;
                }
            }
            newEndIndex = endIndex;
            newTargetIndex = targetIndex;
        }
    }
    const newTarget = traceState.targets[newTargetIndex];
    let considerBothDirections = newTarget.ring;
    if (traceState.targetIndex === newTargetIndex && considerBothDirections) {
        // only consider switching trace direction if close to the start
        const newCoordinate = interpolateCoordinate(newTarget.coordinates, newEndIndex);
        const pixel = map.getPixelFromCoordinate(newCoordinate);
        if ((0, _coordinateJs.distance)(pixel, traceState.startPx) > snapTolerance) considerBothDirections = false;
    }
    if (considerBothDirections) {
        const coordinates = newTarget.coordinates;
        const count = coordinates.length;
        const startIndex = newTarget.startIndex;
        const endIndex = newEndIndex;
        if (startIndex < endIndex) {
            const forwardDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex);
            const reverseDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex - count);
            if (reverseDistance < forwardDistance) newEndIndex -= count;
        } else {
            const reverseDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex);
            const forwardDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex + count);
            if (forwardDistance < reverseDistance) newEndIndex += count;
        }
    }
    sharedUpdateInfo.index = newTargetIndex;
    sharedUpdateInfo.endIndex = newEndIndex;
    return sharedUpdateInfo;
}
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The clicked coordinate.
 * @param {Array<import("../coordinate.js").Coordinate>} coordinates The geometry component coordinates.
 * @param {boolean} ring The coordinates represent a linear ring.
 * @param {Array<TraceTarget>} targets The trace targets.
 */ function appendTraceTarget(coordinate, coordinates, ring, targets) {
    const x = coordinate[0];
    const y = coordinate[1];
    for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
        const start = coordinates[i];
        const end = coordinates[i + 1];
        const rel = getPointSegmentRelationship(x, y, start, end);
        if (rel.squaredDistance === 0) {
            const index = i + rel.along;
            targets.push({
                coordinates: coordinates,
                ring: ring,
                startIndex: index,
                endIndex: index
            });
            return;
        }
    }
}
/**
 * @typedef {Object} PointSegmentRelationship
 * @property {number} along The closest point expressed as a fraction along the segment length.
 * @property {number} squaredDistance The squared distance of the point to the segment.
 */ /**
 * @type {PointSegmentRelationship}
 */ const sharedRel = {
    along: 0,
    squaredDistance: 0
};
/**
 * @param {number} x The point x.
 * @param {number} y The point y.
 * @param {import("../coordinate.js").Coordinate} start The segment start.
 * @param {import("../coordinate.js").Coordinate} end The segment end.
 * @return {PointSegmentRelationship} The point segment relationship.  The returned object is
 * shared between calls and must not be modified by the caller.
 */ function getPointSegmentRelationship(x, y, start, end) {
    const x1 = start[0];
    const y1 = start[1];
    const x2 = end[0];
    const y2 = end[1];
    const dx = x2 - x1;
    const dy = y2 - y1;
    let along = 0;
    let px = x1;
    let py = y1;
    if (dx !== 0 || dy !== 0) {
        along = (0, _mathJs.clamp)(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);
        px += dx * along;
        py += dy * along;
    }
    sharedRel.along = along;
    sharedRel.squaredDistance = (0, _mathJs.toFixed)((0, _mathJs.squaredDistance)(x, y, px, py), 10);
    return sharedRel;
}
/**
 * @param {LineCoordType} coordinates The coordinates.
 * @param {number} index The index.  May be fractional and may wrap.
 * @return {import("../coordinate.js").Coordinate} The interpolated coordinate.
 */ function interpolateCoordinate(coordinates, index) {
    const count = coordinates.length;
    let startIndex = Math.floor(index);
    const along = index - startIndex;
    if (startIndex >= count) startIndex -= count;
    else if (startIndex < 0) startIndex += count;
    let endIndex = startIndex + 1;
    if (endIndex >= count) endIndex -= count;
    const start = coordinates[startIndex];
    const x0 = start[0];
    const y0 = start[1];
    const end = coordinates[endIndex];
    const dx = end[0] - x0;
    const dy = end[1] - y0;
    return [
        x0 + dx * along,
        y0 + dy * along
    ];
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature
 */ /**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */ class Draw extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        const pointerOptions = /** @type {import("./Pointer.js").Options} */ options;
        if (!pointerOptions.stopDown) pointerOptions.stopDown = (0, _functionsJs.FALSE);
        super(pointerOptions);
        /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {DrawOnSignature<void>}
     */ this.un;
        /**
     * @type {boolean}
     * @private
     */ this.shouldHandle_ = false;
        /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */ this.downPx_ = null;
        /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */ this.downTimeout_;
        /**
     * @type {number|undefined}
     * @private
     */ this.lastDragTime_;
        /**
     * Pointer type of the last pointermove event
     * @type {string}
     * @private
     */ this.pointerType_;
        /**
     * @type {boolean}
     * @private
     */ this.freehand_ = false;
        /**
     * Target source for drawn features.
     * @type {VectorSource|null}
     * @private
     */ this.source_ = options.source ? options.source : null;
        /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>|null}
     * @private
     */ this.features_ = options.features ? options.features : null;
        /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */ this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
        /**
     * Geometry type.
     * @type {import("../geom/Geometry.js").Type}
     * @private
     */ this.type_ = /** @type {import("../geom/Geometry.js").Type} */ options.type;
        /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */ this.mode_ = getMode(this.type_);
        /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */ this.stopClick_ = !!options.stopClick;
        /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */ this.minPoints_ = options.minPoints ? options.minPoints : this.mode_ === 'Polygon' ? 3 : 2;
        /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */ this.maxPoints_ = this.mode_ === 'Circle' ? 2 : options.maxPoints ? options.maxPoints : Infinity;
        /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.finishCondition_ = options.finishCondition ? options.finishCondition : (0, _functionsJs.TRUE);
        /**
     * @private
     * @type {import("../geom/Geometry.js").GeometryLayout}
     */ this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : 'XY';
        let geometryFunction = options.geometryFunction;
        if (!geometryFunction) {
            const mode = this.mode_;
            if (mode === 'Circle') /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */ geometryFunction = function(coordinates, geometry, projection) {
                const circle = geometry ? /** @type {Circle} */ geometry : new (0, _circleJsDefault.default)([
                    NaN,
                    NaN
                ]);
                const center = (0, _projJs.fromUserCoordinate)(coordinates[0], projection);
                const squaredLength = (0, _coordinateJs.squaredDistance)(center, (0, _projJs.fromUserCoordinate)(coordinates[coordinates.length - 1], projection));
                circle.setCenterAndRadius(center, Math.sqrt(squaredLength), this.geometryLayout_);
                const userProjection = (0, _projJs.getUserProjection)();
                if (userProjection) circle.transform(projection, userProjection);
                return circle;
            };
            else {
                let Constructor;
                if (mode === 'Point') Constructor = (0, _pointJsDefault.default);
                else if (mode === 'LineString') Constructor = (0, _lineStringJsDefault.default);
                else if (mode === 'Polygon') Constructor = (0, _polygonJsDefault.default);
                /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */ geometryFunction = function(coordinates, geometry, projection) {
                    if (geometry) {
                        if (mode === 'Polygon') {
                            if (coordinates[0].length) // Add a closing coordinate to match the first
                            geometry.setCoordinates([
                                coordinates[0].concat([
                                    coordinates[0][0]
                                ])
                            ], this.geometryLayout_);
                            else geometry.setCoordinates([], this.geometryLayout_);
                        } else geometry.setCoordinates(coordinates, this.geometryLayout_);
                    } else geometry = new Constructor(coordinates, this.geometryLayout_);
                    return geometry;
                };
            }
        }
        /**
     * @type {GeometryFunction}
     * @private
     */ this.geometryFunction_ = geometryFunction;
        /**
     * @type {number}
     * @private
     */ this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;
        /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */ this.finishCoordinate_ = null;
        /**
     * Sketch feature.
     * @type {Feature<import('../geom/SimpleGeometry.js').default>}
     * @private
     */ this.sketchFeature_ = null;
        /**
     * Sketch point.
     * @type {Feature<Point>}
     * @private
     */ this.sketchPoint_ = null;
        /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */ this.sketchCoords_ = null;
        /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature<LineString>}
     * @private
     */ this.sketchLine_ = null;
        /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */ this.sketchLineCoords_ = null;
        /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */ this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
        /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */ this.overlay_ = new (0, _vectorJsDefault.default)({
            source: new (0, _vectorJsDefault1.default)({
                useSpatialIndex: false,
                wrapX: options.wrapX ? options.wrapX : false
            }),
            style: options.style ? options.style : getDefaultStyleFunction(),
            updateWhileInteracting: true
        });
        /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */ this.geometryName_ = options.geometryName;
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : (0, _conditionJs.noModifierKeys);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.freehandCondition_;
        if (options.freehand) this.freehandCondition_ = (0, _conditionJs.always);
        else this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : (0, _conditionJs.shiftKeyOnly);
        /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */ this.traceCondition_;
        this.setTrace(options.trace || false);
        /**
     * @type {TraceState}
     * @private
     */ this.traceState_ = {
            active: false
        };
        /**
     * @type {VectorSource|null}
     * @private
     */ this.traceSource_ = options.traceSource || options.source || null;
        this.addChangeListener((0, _propertyJsDefault.default).ACTIVE, this.updateState_);
    }
    /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */ setTrace(trace) {
        let condition;
        if (!trace) condition = (0, _conditionJs.never);
        else if (trace === true) condition = (0, _conditionJs.always);
        else condition = trace;
        this.traceCondition_ = condition;
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */ setMap(map) {
        super.setMap(map);
        this.updateState_();
    }
    /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */ getOverlay() {
        return this.overlay_;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(event) {
        if (event.originalEvent.type === (0, _eventTypeJsDefault.default).CONTEXTMENU) // Avoid context menu for long taps when drawing on mobile
        event.originalEvent.preventDefault();
        this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);
        let move = event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE;
        let pass = true;
        if (!this.freehand_ && this.lastDragTime_ && event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG) {
            const now = Date.now();
            if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
                this.downPx_ = event.pixel;
                this.shouldHandle_ = !this.freehand_;
                move = true;
            } else this.lastDragTime_ = undefined;
            if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = undefined;
            }
        }
        if (this.freehand_ && event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG && this.sketchFeature_ !== null) {
            this.addToDrawing_(event.coordinate);
            pass = false;
        } else if (this.freehand_ && event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERDOWN) pass = false;
        else if (move && this.getPointerCount() < 2) {
            pass = event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE;
            if (pass && this.freehand_) {
                this.handlePointerMove_(event);
                if (this.shouldHandle_) // Avoid page scrolling when freehand drawing on mobile
                event.originalEvent.preventDefault();
            } else if (event.originalEvent.pointerType === 'mouse' || event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG && this.downTimeout_ === undefined) this.handlePointerMove_(event);
        } else if (event.type === (0, _mapBrowserEventTypeJsDefault.default).DBLCLICK) pass = false;
        return super.handleEvent(event) && pass;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(event) {
        this.shouldHandle_ = !this.freehand_;
        if (this.freehand_) {
            this.downPx_ = event.pixel;
            if (!this.finishCoordinate_) this.startDrawing_(event.coordinate);
            return true;
        }
        if (!this.condition_(event)) {
            this.lastDragTime_ = undefined;
            return false;
        }
        this.lastDragTime_ = Date.now();
        this.downTimeout_ = setTimeout(()=>{
            this.handlePointerMove_(new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
        }, this.dragVertexDelay_);
        this.downPx_ = event.pixel;
        return true;
    }
    /**
   * @private
   */ deactivateTrace_() {
        this.traceState_ = {
            active: false
        };
    }
    /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */ toggleTraceState_(event) {
        if (!this.traceSource_ || !this.traceCondition_(event)) return;
        if (this.traceState_.active) {
            this.deactivateTrace_();
            return;
        }
        const map = this.getMap();
        const lowerLeft = map.getCoordinateFromPixel([
            event.pixel[0] - this.snapTolerance_,
            event.pixel[1] + this.snapTolerance_
        ]);
        const upperRight = map.getCoordinateFromPixel([
            event.pixel[0] + this.snapTolerance_,
            event.pixel[1] - this.snapTolerance_
        ]);
        const extent = (0, _extentJs.boundingExtent)([
            lowerLeft,
            upperRight
        ]);
        const features = this.traceSource_.getFeaturesInExtent(extent);
        if (features.length === 0) return;
        const targets = getTraceTargets(event.coordinate, features);
        if (targets.length) this.traceState_ = {
            active: true,
            startPx: event.pixel.slice(),
            targets: targets,
            targetIndex: -1
        };
    }
    /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */ addOrRemoveTracedCoordinates_(target, endIndex) {
        // three cases to handle:
        //  1. traced in the same direction and points need adding
        //  2. traced in the same direction and points need removing
        //  3. traced in a new direction
        const previouslyForward = target.startIndex <= target.endIndex;
        const currentlyForward = target.startIndex <= endIndex;
        if (previouslyForward === currentlyForward) {
            // same direction
            if (previouslyForward && endIndex > target.endIndex || !previouslyForward && endIndex < target.endIndex) // case 1 - add new points
            this.addTracedCoordinates_(target, target.endIndex, endIndex);
            else if (previouslyForward && endIndex < target.endIndex || !previouslyForward && endIndex > target.endIndex) // case 2 - remove old points
            this.removeTracedCoordinates_(endIndex, target.endIndex);
        } else {
            // case 3 - remove old points, add new points
            this.removeTracedCoordinates_(target.startIndex, target.endIndex);
            this.addTracedCoordinates_(target, target.startIndex, endIndex);
        }
    }
    /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */ removeTracedCoordinates_(fromIndex, toIndex) {
        if (fromIndex === toIndex) return;
        let remove = 0;
        if (fromIndex < toIndex) {
            const start = Math.ceil(fromIndex);
            let end = Math.floor(toIndex);
            if (end === toIndex) end -= 1;
            remove = end - start + 1;
        } else {
            const start = Math.floor(fromIndex);
            let end = Math.ceil(toIndex);
            if (end === toIndex) end += 1;
            remove = start - end + 1;
        }
        if (remove > 0) this.removeLastPoints_(remove);
    }
    /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */ addTracedCoordinates_(target, fromIndex, toIndex) {
        if (fromIndex === toIndex) return;
        const coordinates = [];
        if (fromIndex < toIndex) {
            // forward trace
            const start = Math.ceil(fromIndex);
            let end = Math.floor(toIndex);
            if (end === toIndex) // if end is snapped to a vertex, it will be added later
            end -= 1;
            for(let i = start; i <= end; ++i)coordinates.push(getCoordinate(target.coordinates, i));
        } else {
            // reverse trace
            const start = Math.floor(fromIndex);
            let end = Math.ceil(toIndex);
            if (end === toIndex) end += 1;
            for(let i = start; i >= end; --i)coordinates.push(getCoordinate(target.coordinates, i));
        }
        if (coordinates.length) this.appendCoordinates(coordinates);
    }
    /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */ updateTrace_(event) {
        const traceState = this.traceState_;
        if (!traceState.active) return;
        if (traceState.targetIndex === -1) {
            // check if we are ready to pick a target
            if ((0, _coordinateJs.distance)(traceState.startPx, event.pixel) < this.snapTolerance_) return;
        }
        const updatedTraceTarget = getTraceTargetUpdate(event.coordinate, traceState, this.getMap(), this.snapTolerance_);
        if (traceState.targetIndex !== updatedTraceTarget.index) {
            // target changed
            if (traceState.targetIndex !== -1) {
                // remove points added during previous trace
                const oldTarget = traceState.targets[traceState.targetIndex];
                this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);
            }
            // add points for the new target
            const newTarget = traceState.targets[updatedTraceTarget.index];
            this.addTracedCoordinates_(newTarget, newTarget.startIndex, updatedTraceTarget.endIndex);
        } else {
            // target stayed the same
            const target = traceState.targets[traceState.targetIndex];
            this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);
        }
        // modify the state with updated info
        traceState.targetIndex = updatedTraceTarget.index;
        const target = traceState.targets[traceState.targetIndex];
        target.endIndex = updatedTraceTarget.endIndex;
        // update event coordinate and pixel to match end point of final segment
        const coordinate = interpolateCoordinate(target.coordinates, target.endIndex);
        const pixel = this.getMap().getPixelFromCoordinate(coordinate);
        event.coordinate = coordinate;
        event.pixel = [
            Math.round(pixel[0]),
            Math.round(pixel[1])
        ];
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(event) {
        let pass = true;
        if (this.getPointerCount() === 0) {
            if (this.downTimeout_) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = undefined;
            }
            this.handlePointerMove_(event);
            const tracing = this.traceState_.active;
            this.toggleTraceState_(event);
            if (this.shouldHandle_) {
                const startingToDraw = !this.finishCoordinate_;
                if (startingToDraw) this.startDrawing_(event.coordinate);
                if (!startingToDraw && this.freehand_) this.finishDrawing();
                else if (!this.freehand_ && (!startingToDraw || this.mode_ === 'Point')) {
                    if (this.atFinish_(event.pixel, tracing)) {
                        if (this.finishCondition_(event)) this.finishDrawing();
                    } else this.addToDrawing_(event.coordinate);
                }
                pass = false;
            } else if (this.freehand_) this.abortDrawing();
        }
        if (!pass && this.stopClick_) event.preventDefault();
        return pass;
    }
    /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */ handlePointerMove_(event) {
        this.pointerType_ = event.originalEvent.pointerType;
        if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
            const downPx = this.downPx_;
            const clickPx = event.pixel;
            const dx = downPx[0] - clickPx[0];
            const dy = downPx[1] - clickPx[1];
            const squaredDistance = dx * dx + dy * dy;
            this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;
            if (!this.shouldHandle_) return;
        }
        if (!this.finishCoordinate_) {
            this.createOrUpdateSketchPoint_(event.coordinate.slice());
            return;
        }
        this.updateTrace_(event);
        this.modifyDrawing_(event.coordinate);
    }
    /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */ atFinish_(pixel, tracing) {
        let at = false;
        if (this.sketchFeature_) {
            let potentiallyDone = false;
            let potentiallyFinishCoordinates = [
                this.finishCoordinate_
            ];
            const mode = this.mode_;
            if (mode === 'Point') at = true;
            else if (mode === 'Circle') at = this.sketchCoords_.length === 2;
            else if (mode === 'LineString') potentiallyDone = !tracing && this.sketchCoords_.length > this.minPoints_;
            else if (mode === 'Polygon') {
                const sketchCoords = /** @type {PolyCoordType} */ this.sketchCoords_;
                potentiallyDone = sketchCoords[0].length > this.minPoints_;
                potentiallyFinishCoordinates = [
                    sketchCoords[0][0],
                    sketchCoords[0][sketchCoords[0].length - 2]
                ];
                if (tracing) potentiallyFinishCoordinates = [
                    sketchCoords[0][0]
                ];
                else potentiallyFinishCoordinates = [
                    sketchCoords[0][0],
                    sketchCoords[0][sketchCoords[0].length - 2]
                ];
            }
            if (potentiallyDone) {
                const map = this.getMap();
                for(let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++){
                    const finishCoordinate = potentiallyFinishCoordinates[i];
                    const finishPixel = map.getPixelFromCoordinate(finishCoordinate);
                    const dx = pixel[0] - finishPixel[0];
                    const dy = pixel[1] - finishPixel[1];
                    const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
                    at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
                    if (at) {
                        this.finishCoordinate_ = finishCoordinate;
                        break;
                    }
                }
            }
        }
        return at;
    }
    /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */ createOrUpdateSketchPoint_(coordinates) {
        if (!this.sketchPoint_) {
            this.sketchPoint_ = new (0, _featureJsDefault.default)(new (0, _pointJsDefault.default)(coordinates));
            this.updateSketchFeatures_();
        } else {
            const sketchPointGeom = this.sketchPoint_.getGeometry();
            sketchPointGeom.setCoordinates(coordinates);
        }
    }
    /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */ createOrUpdateCustomSketchLine_(geometry) {
        if (!this.sketchLine_) this.sketchLine_ = new (0, _featureJsDefault.default)();
        const ring = geometry.getLinearRing(0);
        let sketchLineGeom = this.sketchLine_.getGeometry();
        if (!sketchLineGeom) {
            sketchLineGeom = new (0, _lineStringJsDefault.default)(ring.getFlatCoordinates(), ring.getLayout());
            this.sketchLine_.setGeometry(sketchLineGeom);
        } else {
            sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
            sketchLineGeom.changed();
        }
    }
    /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */ startDrawing_(start) {
        const projection = this.getMap().getView().getProjection();
        const stride = (0, _simpleGeometryJs.getStrideForLayout)(this.geometryLayout_);
        while(start.length < stride)start.push(0);
        this.finishCoordinate_ = start;
        if (this.mode_ === 'Point') this.sketchCoords_ = start.slice();
        else if (this.mode_ === 'Polygon') {
            this.sketchCoords_ = [
                [
                    start.slice(),
                    start.slice()
                ]
            ];
            this.sketchLineCoords_ = this.sketchCoords_[0];
        } else this.sketchCoords_ = [
            start.slice(),
            start.slice()
        ];
        if (this.sketchLineCoords_) this.sketchLine_ = new (0, _featureJsDefault.default)(new (0, _lineStringJsDefault.default)(this.sketchLineCoords_));
        const geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);
        this.sketchFeature_ = new (0, _featureJsDefault.default)();
        if (this.geometryName_) this.sketchFeature_.setGeometryName(this.geometryName_);
        this.sketchFeature_.setGeometry(geometry);
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
    }
    /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */ modifyDrawing_(coordinate) {
        const map = this.getMap();
        const geometry = this.sketchFeature_.getGeometry();
        const projection = map.getView().getProjection();
        const stride = (0, _simpleGeometryJs.getStrideForLayout)(this.geometryLayout_);
        let coordinates, last;
        while(coordinate.length < stride)coordinate.push(0);
        if (this.mode_ === 'Point') last = this.sketchCoords_;
        else if (this.mode_ === 'Polygon') {
            coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
            last = coordinates[coordinates.length - 1];
            if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) // snap to finish
            coordinate = this.finishCoordinate_.slice();
        } else {
            coordinates = this.sketchCoords_;
            last = coordinates[coordinates.length - 1];
        }
        last[0] = coordinate[0];
        last[1] = coordinate[1];
        this.geometryFunction_(/** @type {!LineCoordType} */ this.sketchCoords_, geometry, projection);
        if (this.sketchPoint_) {
            const sketchPointGeom = this.sketchPoint_.getGeometry();
            sketchPointGeom.setCoordinates(coordinate);
        }
        if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ geometry);
        else if (this.sketchLineCoords_) {
            const sketchLineGeom = this.sketchLine_.getGeometry();
            sketchLineGeom.setCoordinates(this.sketchLineCoords_);
        }
        this.updateSketchFeatures_();
    }
    /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */ addToDrawing_(coordinate) {
        const geometry = this.sketchFeature_.getGeometry();
        const projection = this.getMap().getView().getProjection();
        let done;
        let coordinates;
        const mode = this.mode_;
        if (mode === 'LineString' || mode === 'Circle') {
            this.finishCoordinate_ = coordinate.slice();
            coordinates = /** @type {LineCoordType} */ this.sketchCoords_;
            if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) coordinates.pop();
                else done = true;
            }
            coordinates.push(coordinate.slice());
            this.geometryFunction_(coordinates, geometry, projection);
        } else if (mode === 'Polygon') {
            coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
            if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) coordinates.pop();
                else done = true;
            }
            coordinates.push(coordinate.slice());
            if (done) this.finishCoordinate_ = coordinates[0];
            this.geometryFunction_(this.sketchCoords_, geometry, projection);
        }
        this.createOrUpdateSketchPoint_(coordinate.slice());
        this.updateSketchFeatures_();
        if (done) this.finishDrawing();
    }
    /**
   * @param {number} n The number of points to remove.
   */ removeLastPoints_(n) {
        if (!this.sketchFeature_) return;
        const geometry = this.sketchFeature_.getGeometry();
        const projection = this.getMap().getView().getProjection();
        const mode = this.mode_;
        for(let i = 0; i < n; ++i){
            let coordinates;
            if (mode === 'LineString' || mode === 'Circle') {
                coordinates = /** @type {LineCoordType} */ this.sketchCoords_;
                coordinates.splice(-2, 1);
                if (coordinates.length >= 2) {
                    this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
                    const finishCoordinate = this.finishCoordinate_.slice();
                    coordinates[coordinates.length - 1] = finishCoordinate;
                    this.createOrUpdateSketchPoint_(finishCoordinate);
                }
                this.geometryFunction_(coordinates, geometry, projection);
                if (geometry.getType() === 'Polygon' && this.sketchLine_) this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ geometry);
            } else if (mode === 'Polygon') {
                coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
                coordinates.splice(-2, 1);
                const sketchLineGeom = this.sketchLine_.getGeometry();
                if (coordinates.length >= 2) {
                    const finishCoordinate = coordinates[coordinates.length - 2].slice();
                    coordinates[coordinates.length - 1] = finishCoordinate;
                    this.createOrUpdateSketchPoint_(finishCoordinate);
                }
                sketchLineGeom.setCoordinates(coordinates);
                this.geometryFunction_(this.sketchCoords_, geometry, projection);
            }
            if (coordinates.length === 1) {
                this.abortDrawing();
                break;
            }
        }
        this.updateSketchFeatures_();
    }
    /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */ removeLastPoint() {
        this.removeLastPoints_(1);
    }
    /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */ finishDrawing() {
        const sketchFeature = this.abortDrawing_();
        if (!sketchFeature) return;
        let coordinates = this.sketchCoords_;
        const geometry = sketchFeature.getGeometry();
        const projection = this.getMap().getView().getProjection();
        if (this.mode_ === 'LineString') {
            // remove the redundant last point
            coordinates.pop();
            this.geometryFunction_(coordinates, geometry, projection);
        } else if (this.mode_ === 'Polygon') {
            // remove the redundant last point in ring
            /** @type {PolyCoordType} */ coordinates[0].pop();
            this.geometryFunction_(coordinates, geometry, projection);
            coordinates = geometry.getCoordinates();
        }
        // cast multi-part geometries
        if (this.type_ === 'MultiPoint') sketchFeature.setGeometry(new (0, _multiPointJsDefault.default)([
            /** @type {PointCoordType} */ coordinates
        ]));
        else if (this.type_ === 'MultiLineString') sketchFeature.setGeometry(new (0, _multiLineStringJsDefault.default)([
            /** @type {LineCoordType} */ coordinates
        ]));
        else if (this.type_ === 'MultiPolygon') sketchFeature.setGeometry(new (0, _multiPolygonJsDefault.default)([
            /** @type {PolyCoordType} */ coordinates
        ]));
        // First dispatch event to allow full set up of feature
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));
        // Then insert feature
        if (this.features_) this.features_.push(sketchFeature);
        if (this.source_) this.source_.addFeature(sketchFeature);
    }
    /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */ abortDrawing_() {
        this.finishCoordinate_ = null;
        const sketchFeature = this.sketchFeature_;
        this.sketchFeature_ = null;
        this.sketchPoint_ = null;
        this.sketchLine_ = null;
        this.overlay_.getSource().clear(true);
        this.deactivateTrace_();
        return sketchFeature;
    }
    /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */ abortDrawing() {
        const sketchFeature = this.abortDrawing_();
        if (sketchFeature) this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
    }
    /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */ appendCoordinates(coordinates) {
        const mode = this.mode_;
        const newDrawing = !this.sketchFeature_;
        if (newDrawing) this.startDrawing_(coordinates[0]);
        /** @type {LineCoordType} */ let sketchCoords;
        if (mode === 'LineString' || mode === 'Circle') sketchCoords = /** @type {LineCoordType} */ this.sketchCoords_;
        else if (mode === 'Polygon') sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? /** @type {PolyCoordType} */ this.sketchCoords_[0] : [];
        else return;
        if (newDrawing) sketchCoords.shift();
        // Remove last coordinate from sketch drawing (this coordinate follows cursor position)
        sketchCoords.pop();
        // Append coordinate list
        for(let i = 0; i < coordinates.length; i++)this.addToDrawing_(coordinates[i]);
        const ending = coordinates[coordinates.length - 1];
        // Duplicate last coordinate for sketch drawing (cursor position)
        this.addToDrawing_(ending);
        this.modifyDrawing_(ending);
    }
    /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */ extend(feature) {
        const geometry = feature.getGeometry();
        const lineString = geometry;
        this.sketchFeature_ = feature;
        this.sketchCoords_ = lineString.getCoordinates();
        const last = this.sketchCoords_[this.sketchCoords_.length - 1];
        this.finishCoordinate_ = last.slice();
        this.sketchCoords_.push(last.slice());
        this.sketchPoint_ = new (0, _featureJsDefault.default)(new (0, _pointJsDefault.default)(last));
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
    }
    /**
   * Redraw the sketch features.
   * @private
   */ updateSketchFeatures_() {
        const sketchFeatures = [];
        if (this.sketchFeature_) sketchFeatures.push(this.sketchFeature_);
        if (this.sketchLine_) sketchFeatures.push(this.sketchLine_);
        if (this.sketchPoint_) sketchFeatures.push(this.sketchPoint_);
        const overlaySource = this.overlay_.getSource();
        overlaySource.clear(true);
        overlaySource.addFeatures(sketchFeatures);
    }
    /**
   * @private
   */ updateState_() {
        const map = this.getMap();
        const active = this.getActive();
        if (!map || !active) this.abortDrawing();
        this.overlay_.setMap(active ? map : null);
    }
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    const styles = (0, _styleJs.createEditingStyle)();
    return function(feature, resolution) {
        return styles[feature.getGeometry().getType()];
    };
}
function createRegularPolygon(sides, angle) {
    return function(coordinates, geometry, projection) {
        const center = (0, _projJs.fromUserCoordinate)(/** @type {LineCoordType} */ coordinates[0], projection);
        const end = (0, _projJs.fromUserCoordinate)(/** @type {LineCoordType} */ coordinates[coordinates.length - 1], projection);
        const radius = Math.sqrt((0, _coordinateJs.squaredDistance)(center, end));
        geometry = geometry || (0, _polygonJs.fromCircle)(new (0, _circleJsDefault.default)(center), sides);
        let internalAngle = angle;
        if (!angle && angle !== 0) {
            const x = end[0] - center[0];
            const y = end[1] - center[1];
            internalAngle = Math.atan2(y, x);
        }
        (0, _polygonJs.makeRegular)(/** @type {Polygon} */ geometry, center, radius, internalAngle);
        const userProjection = (0, _projJs.getUserProjection)();
        if (userProjection) geometry.transform(projection, userProjection);
        return geometry;
    };
}
function createBox() {
    return function(coordinates, geometry, projection) {
        const extent = (0, _extentJs.boundingExtent)(/** @type {LineCoordType} */ [
            coordinates[0],
            coordinates[coordinates.length - 1]
        ].map(function(coordinate) {
            return (0, _projJs.fromUserCoordinate)(coordinate, projection);
        }));
        const boxCoordinates = [
            [
                (0, _extentJs.getBottomLeft)(extent),
                (0, _extentJs.getBottomRight)(extent),
                (0, _extentJs.getTopRight)(extent),
                (0, _extentJs.getTopLeft)(extent),
                (0, _extentJs.getBottomLeft)(extent)
            ]
        ];
        if (geometry) geometry.setCoordinates(boxCoordinates);
        else geometry = new (0, _polygonJsDefault.default)(boxCoordinates);
        const userProjection = (0, _projJs.getUserProjection)();
        if (userProjection) geometry.transform(projection, userProjection);
        return geometry;
    };
}
/**
 * Get the drawing mode.  The mode for multi-part geometries is the same as for
 * their single-part cousins.
 * @param {import("../geom/Geometry.js").Type} type Geometry type.
 * @return {Mode} Drawing mode.
 */ function getMode(type) {
    switch(type){
        case 'Point':
        case 'MultiPoint':
            return 'Point';
        case 'LineString':
        case 'MultiLineString':
            return 'LineString';
        case 'Polygon':
        case 'MultiPolygon':
            return 'Polygon';
        case 'Circle':
            return 'Circle';
        default:
            throw new Error('Invalid type: ' + type);
    }
}
exports.default = Draw;

},{"../geom/Circle.js":"jRv80","../events/Event.js":"kooRA","../events/EventType.js":"3uT2C","../Feature.js":"3qocF","../geom/GeometryCollection.js":"6lIhA","./Property.js":"7pgVi","../geom/LineString.js":"gknRz","../MapBrowserEvent.js":"9dn5c","../MapBrowserEventType.js":"2Xhyu","../geom/MultiLineString.js":"4FjXg","../geom/MultiPoint.js":"gXgmP","../geom/MultiPolygon.js":"b4GDd","../geom/Point.js":"6SybV","./Pointer.js":"a39IA","../geom/Polygon.js":"8Vwps","../layer/Vector.js":"6bOIK","../source/Vector.js":"7wT1g","../functions.js":"1QSsQ","../events/condition.js":"gm0iA","../extent.js":"bGUel","../math.js":"d8zSj","../style/Style.js":"8opjn","../coordinate.js":"fqHXJ","../proj.js":"8OK47","../geom/SimpleGeometry.js":"iZYIt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7uIM7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transactWFS", ()=>transactWFS);
var _wfs = require("ol/format/WFS");
var _wfsDefault = parcelHelpers.interopDefault(_wfs);
function parseWFSResponse(xmlString) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
    // Check for Exception
    const exception = xmlDoc.querySelector('ows\\:Exception, Exception');
    if (exception) return {
        status: 'error',
        message: exception.textContent.trim()
    };
    // Parse TransactionSummary
    const summary = xmlDoc.querySelector('wfs\\:TransactionSummary, TransactionSummary');
    if (summary) {
        const inserted = summary.querySelector('wfs\\:totalInserted, totalInserted')?.textContent || '0';
        const updated = summary.querySelector('wfs\\:totalUpdated, totalUpdated')?.textContent || '0';
        const deleted = summary.querySelector('wfs\\:totalDeleted, totalDeleted')?.textContent || '0';
        const insertResults = xmlDoc.querySelectorAll('wfs\\:InsertResults wfs\\:Feature wfs\\:FeatureId, InsertResults Feature FeatureId');
        const fids = Array.from(insertResults).map((el)=>el.getAttribute('fid'));
        return {
            status: 'success',
            totalInserted: parseInt(inserted),
            totalUpdated: parseInt(updated),
            totalDeleted: parseInt(deleted),
            insertedFIDs: fids
        };
    }
    // Fallback if structure is unexpected
    return {
        status: 'unknown',
        raw: xmlString
    };
}
async function transactWFS(type, features, workspace, layerName, srs = 'EPSG:3857', user, password, geoserverURL) {
    const formatWFS = new (0, _wfsDefault.default)();
    const node = formatWFS.writeTransaction(type === 'insert' ? features : [], type === 'update' ? features : [], type === 'delete' ? features : [], {
        featureType: layerName,
        featureNS: 'https://www.naturalearthdata.com',
        srsName: srs,
        featurePrefix: workspace
    });
    const serializer = new XMLSerializer();
    const payload = serializer.serializeToString(node);
    try {
        const url = geoserverURL + '/wfs';
        const res = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'text/xml',
                'Authorization': 'Basic ' + btoa(`${user}:${password}`)
            },
            body: payload
        });
        const responseText = await res.text();
        if (!res.ok) throw new Error(`WFS-T ${type} failed with status ${res.status}: ${responseText}`);
        const jsonResponse = parseWFSResponse(responseText);
        return jsonResponse;
    } catch (error) {
        console.error('WFS-T error:', error);
        throw error;
    }
}

},{"ol/format/WFS":"bv3Sz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7JF0u":[function(require,module,exports,__globalThis) {
/**
 * @module ol
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Collection", ()=>(0, _collectionJsDefault.default));
parcelHelpers.export(exports, "Disposable", ()=>(0, _disposableJsDefault.default));
parcelHelpers.export(exports, "Feature", ()=>(0, _featureJsDefault.default));
parcelHelpers.export(exports, "Geolocation", ()=>(0, _geolocationJsDefault.default));
parcelHelpers.export(exports, "Graticule", ()=>(0, _graticuleJsDefault.default));
parcelHelpers.export(exports, "Image", ()=>(0, _imageJsDefault.default));
parcelHelpers.export(exports, "ImageWrapper", ()=>(0, _imageJsDefault.default));
parcelHelpers.export(exports, "ImageCanvas", ()=>(0, _imageCanvasJsDefault.default));
parcelHelpers.export(exports, "ImageTile", ()=>(0, _imageTileJsDefault.default));
parcelHelpers.export(exports, "Kinetic", ()=>(0, _kineticJsDefault.default));
parcelHelpers.export(exports, "Map", ()=>(0, _mapJsDefault.default));
parcelHelpers.export(exports, "MapBrowserEvent", ()=>(0, _mapBrowserEventJsDefault.default));
parcelHelpers.export(exports, "MapBrowserEventHandler", ()=>(0, _mapBrowserEventHandlerJsDefault.default));
parcelHelpers.export(exports, "MapEvent", ()=>(0, _mapEventJsDefault.default));
parcelHelpers.export(exports, "Object", ()=>(0, _objectJsDefault.default));
parcelHelpers.export(exports, "Observable", ()=>(0, _observableJsDefault.default));
parcelHelpers.export(exports, "Overlay", ()=>(0, _overlayJsDefault.default));
parcelHelpers.export(exports, "Tile", ()=>(0, _tileJsDefault.default));
parcelHelpers.export(exports, "TileCache", ()=>(0, _tileCacheJsDefault.default));
parcelHelpers.export(exports, "TileQueue", ()=>(0, _tileQueueJsDefault.default));
parcelHelpers.export(exports, "TileRange", ()=>(0, _tileRangeJsDefault.default));
parcelHelpers.export(exports, "VectorRenderTile", ()=>(0, _vectorRenderTileJsDefault.default));
parcelHelpers.export(exports, "VectorTile", ()=>(0, _vectorTileJsDefault.default));
parcelHelpers.export(exports, "View", ()=>(0, _viewJsDefault.default));
parcelHelpers.export(exports, "getUid", ()=>(0, _utilJs.getUid));
parcelHelpers.export(exports, "VERSION", ()=>(0, _utilJs.VERSION));
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _disposableJs = require("./Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _featureJs = require("./Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geolocationJs = require("./Geolocation.js");
var _geolocationJsDefault = parcelHelpers.interopDefault(_geolocationJs);
var _graticuleJs = require("./layer/Graticule.js");
var _graticuleJsDefault = parcelHelpers.interopDefault(_graticuleJs);
var _imageJs = require("./Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _imageCanvasJs = require("./ImageCanvas.js");
var _imageCanvasJsDefault = parcelHelpers.interopDefault(_imageCanvasJs);
var _imageTileJs = require("./ImageTile.js");
var _imageTileJsDefault = parcelHelpers.interopDefault(_imageTileJs);
var _kineticJs = require("./Kinetic.js");
var _kineticJsDefault = parcelHelpers.interopDefault(_kineticJs);
var _mapJs = require("./Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _mapBrowserEventJs = require("./MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventHandlerJs = require("./MapBrowserEventHandler.js");
var _mapBrowserEventHandlerJsDefault = parcelHelpers.interopDefault(_mapBrowserEventHandlerJs);
var _mapEventJs = require("./MapEvent.js");
var _mapEventJsDefault = parcelHelpers.interopDefault(_mapEventJs);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _observableJs = require("./Observable.js");
var _observableJsDefault = parcelHelpers.interopDefault(_observableJs);
var _overlayJs = require("./Overlay.js");
var _overlayJsDefault = parcelHelpers.interopDefault(_overlayJs);
var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileCacheJs = require("./TileCache.js");
var _tileCacheJsDefault = parcelHelpers.interopDefault(_tileCacheJs);
var _tileQueueJs = require("./TileQueue.js");
var _tileQueueJsDefault = parcelHelpers.interopDefault(_tileQueueJs);
var _tileRangeJs = require("./TileRange.js");
var _tileRangeJsDefault = parcelHelpers.interopDefault(_tileRangeJs);
var _vectorRenderTileJs = require("./VectorRenderTile.js");
var _vectorRenderTileJsDefault = parcelHelpers.interopDefault(_vectorRenderTileJs);
var _vectorTileJs = require("./VectorTile.js");
var _vectorTileJsDefault = parcelHelpers.interopDefault(_vectorTileJs);
var _viewJs = require("./View.js");
var _viewJsDefault = parcelHelpers.interopDefault(_viewJs);
var _utilJs = require("./util.js");

},{"./Collection.js":false,"./Disposable.js":false,"./Feature.js":"3qocF","./Geolocation.js":false,"./layer/Graticule.js":false,"./Image.js":false,"./ImageCanvas.js":false,"./ImageTile.js":false,"./Kinetic.js":false,"./Map.js":false,"./MapBrowserEvent.js":false,"./MapBrowserEventHandler.js":false,"./MapEvent.js":false,"./Object.js":false,"./Observable.js":false,"./Overlay.js":false,"./Tile.js":false,"./TileCache.js":false,"./TileQueue.js":false,"./TileRange.js":false,"./VectorRenderTile.js":false,"./VectorTile.js":false,"./View.js":false,"./util.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"98E40":[function(require,module,exports,__globalThis) {
/**
 * Show a popup message that automatically disappears
 * @param {string} message - The message to display
 * @param {string} type - Message type: 'success', 'error', 'warning', or 'info'
 * @param {number} duration - Duration in milliseconds before the message disappears
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showPopupMessage", ()=>showPopupMessage);
function showPopupMessage(message, type = 'info', duration = 5000) {
    // Create popup element
    const popup = document.createElement('div');
    popup.className = `popup-message ${type}`;
    popup.textContent = message;
    // Add to document
    document.body.appendChild(popup);
    // Remove after duration
    setTimeout(()=>{
        popup.style.opacity = '0';
        setTimeout(()=>{
            document.body.removeChild(popup);
        }, 500); // Wait for fade out animation
    }, duration);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1NdLK":[function(require,module,exports,__globalThis) {
/**
 * @module org/locationtech/jts/io/OL3Parser
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _geometryFactoryJs = require("../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
function p2c(p) {
    return [
        p.x,
        p.y
    ];
}
class OL3Parser {
    /**
   * OpenLayers Geometry parser and writer
   * @param {GeometryFactory} geometryFactory
   * @param {ol} olReference
   */ constructor(geometryFactory, olReference){
        this.geometryFactory = geometryFactory || new (0, _geometryFactoryJsDefault.default)();
        this.ol = olReference || typeof ol !== 'undefined' && ol;
    }
    /**
   * Inject OpenLayers geom classes
   */ inject(Point, LineString, LinearRing, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection) {
        this.ol = {
            geom: {
                Point,
                LineString,
                LinearRing,
                Polygon,
                MultiPoint,
                MultiLineString,
                MultiPolygon,
                GeometryCollection
            }
        };
    }
    /**
   * @param geometry {ol.geom.Geometry}
   * @return {Geometry}
   * @memberof module:org/locationtech/jts/io/OL3Parser#
   */ read(geometry) {
        const ol1 = this.ol;
        if (geometry instanceof ol1.geom.Point) return this.convertFromPoint(geometry);
        else if (geometry instanceof ol1.geom.LineString) return this.convertFromLineString(geometry);
        else if (geometry instanceof ol1.geom.LinearRing) return this.convertFromLinearRing(geometry);
        else if (geometry instanceof ol1.geom.Polygon) return this.convertFromPolygon(geometry);
        else if (geometry instanceof ol1.geom.MultiPoint) return this.convertFromMultiPoint(geometry);
        else if (geometry instanceof ol1.geom.MultiLineString) return this.convertFromMultiLineString(geometry);
        else if (geometry instanceof ol1.geom.MultiPolygon) return this.convertFromMultiPolygon(geometry);
        else if (geometry instanceof ol1.geom.GeometryCollection) return this.convertFromCollection(geometry);
    }
    convertFromPoint(point) {
        const coordinates = point.getCoordinates();
        return this.geometryFactory.createPoint(new (0, _coordinateJsDefault.default)(coordinates[0], coordinates[1]));
    }
    convertFromLineString(lineString) {
        return this.geometryFactory.createLineString(lineString.getCoordinates().map(function(coordinates) {
            return new (0, _coordinateJsDefault.default)(coordinates[0], coordinates[1]);
        }));
    }
    convertFromLinearRing(linearRing) {
        return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function(coordinates) {
            return new (0, _coordinateJsDefault.default)(coordinates[0], coordinates[1]);
        }));
    }
    convertFromPolygon(polygon) {
        const linearRings = polygon.getLinearRings();
        let shell = null;
        const holes = [];
        for(let i = 0; i < linearRings.length; i++){
            const linearRing = this.convertFromLinearRing(linearRings[i]);
            if (i === 0) shell = linearRing;
            else holes.push(linearRing);
        }
        return this.geometryFactory.createPolygon(shell, holes);
    }
    convertFromMultiPoint(multiPoint) {
        const points = multiPoint.getPoints().map(function(point) {
            return this.convertFromPoint(point);
        }, this);
        return this.geometryFactory.createMultiPoint(points);
    }
    convertFromMultiLineString(multiLineString) {
        const lineStrings = multiLineString.getLineStrings().map(function(lineString) {
            return this.convertFromLineString(lineString);
        }, this);
        return this.geometryFactory.createMultiLineString(lineStrings);
    }
    convertFromMultiPolygon(multiPolygon) {
        const polygons = multiPolygon.getPolygons().map(function(polygon) {
            return this.convertFromPolygon(polygon);
        }, this);
        return this.geometryFactory.createMultiPolygon(polygons);
    }
    convertFromCollection(collection) {
        const geometries = collection.getGeometries().map(function(geometry) {
            return this.read(geometry);
        }, this);
        return this.geometryFactory.createGeometryCollection(geometries);
    }
    /**
   * @param geometry
   *          {Geometry}
   * @return {ol.geom.Geometry}
   * @memberof module:org/locationtech/jts/io/OL3Parser#
   */ write(geometry) {
        if (geometry.getGeometryType() === 'Point') return this.convertToPoint(geometry.getCoordinate());
        else if (geometry.getGeometryType() === 'LineString') return this.convertToLineString(geometry);
        else if (geometry.getGeometryType() === 'LinearRing') return this.convertToLinearRing(geometry);
        else if (geometry.getGeometryType() === 'Polygon') return this.convertToPolygon(geometry);
        else if (geometry.getGeometryType() === 'MultiPoint') return this.convertToMultiPoint(geometry);
        else if (geometry.getGeometryType() === 'MultiLineString') return this.convertToMultiLineString(geometry);
        else if (geometry.getGeometryType() === 'MultiPolygon') return this.convertToMultiPolygon(geometry);
        else if (geometry.getGeometryType() === 'GeometryCollection') return this.convertToCollection(geometry);
    }
    convertToPoint(coordinate) {
        return new this.ol.geom.Point([
            coordinate.x,
            coordinate.y
        ]);
    }
    convertToLineString(lineString) {
        const points = lineString._points._coordinates.map(p2c);
        return new this.ol.geom.LineString(points);
    }
    convertToLinearRing(linearRing) {
        const points = linearRing._points._coordinates.map(p2c);
        return new this.ol.geom.LinearRing(points);
    }
    convertToPolygon(polygon) {
        const rings = [
            polygon._shell._points._coordinates.map(p2c)
        ];
        for(let i = 0; i < polygon._holes.length; i++)rings.push(polygon._holes[i]._points._coordinates.map(p2c));
        return new this.ol.geom.Polygon(rings);
    }
    convertToMultiPoint(multiPoint) {
        return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c));
    }
    convertToMultiLineString(multiLineString) {
        const lineStrings = [];
        for(let i = 0; i < multiLineString._geometries.length; i++)lineStrings.push(this.convertToLineString(multiLineString._geometries[i]).getCoordinates());
        return new this.ol.geom.MultiLineString(lineStrings);
    }
    convertToMultiPolygon(multiPolygon) {
        const polygons = [];
        for(let i = 0; i < multiPolygon._geometries.length; i++)polygons.push(this.convertToPolygon(multiPolygon._geometries[i]).getCoordinates());
        return new this.ol.geom.MultiPolygon(polygons);
    }
    convertToCollection(geometryCollection) {
        const geometries = [];
        for(let i = 0; i < geometryCollection._geometries.length; i++){
            const geometry = geometryCollection._geometries[i];
            geometries.push(this.write(geometry));
        }
        return new this.ol.geom.GeometryCollection(geometries);
    }
}
exports.default = OL3Parser;

},{"../geom/Coordinate.js":"ii2fh","../geom/GeometryFactory.js":"cGt0T","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ii2fh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _numberUtilJs = require("../util/NumberUtil.js");
var _numberUtilJsDefault = parcelHelpers.interopDefault(_numberUtilJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _cloneableJs = require("../../../../java/lang/Cloneable.js");
var _cloneableJsDefault = parcelHelpers.interopDefault(_cloneableJs);
var _comparatorJs = require("../../../../java/util/Comparator.js");
var _comparatorJsDefault = parcelHelpers.interopDefault(_comparatorJs);
const kBuf = new ArrayBuffer(8);
const kBufAsF64 = new Float64Array(kBuf);
const kBufAsI32 = new Int32Array(kBuf);
class Coordinate {
    constructor(){
        Coordinate.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.x = null;
        this.y = null;
        this.z = null;
        if (arguments.length === 0) Coordinate.constructor_.call(this, 0.0, 0.0);
        else if (arguments.length === 1) {
            const c = arguments[0];
            Coordinate.constructor_.call(this, c.x, c.y, c.getZ());
        } else if (arguments.length === 2) {
            const x = arguments[0], y = arguments[1];
            Coordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE);
        } else if (arguments.length === 3) {
            const x = arguments[0], y = arguments[1], z = arguments[2];
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }
    static hashCode(n) {
        kBufAsF64[0] = n;
        return kBufAsI32[0] ^ kBufAsI32[1];
    }
    equals2D() {
        if (arguments.length === 1) {
            const other = arguments[0];
            if (this.x !== other.x) return false;
            if (this.y !== other.y) return false;
            return true;
        } else if (arguments.length === 2) {
            const c = arguments[0], tolerance = arguments[1];
            if (!(0, _numberUtilJsDefault.default).equalsWithTolerance(this.x, c.x, tolerance)) return false;
            if (!(0, _numberUtilJsDefault.default).equalsWithTolerance(this.y, c.y, tolerance)) return false;
            return true;
        }
    }
    setM(m) {
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + Coordinate.M);
    }
    equals3D(other) {
        return this.x === other.x && this.y === other.y && (this.getZ() === other.getZ() || (0, _doubleJsDefault.default).isNaN(this.getZ()) && (0, _doubleJsDefault.default).isNaN(other.getZ()));
    }
    setX(x) {
        this.x = x;
    }
    compareTo(o) {
        const other = o;
        if (this.x < other.x) return -1;
        if (this.x > other.x) return 1;
        if (this.y < other.y) return -1;
        if (this.y > other.y) return 1;
        return 0;
    }
    getX() {
        return this.x;
    }
    copy() {
        return new Coordinate(this);
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ')';
    }
    distance3D(c) {
        const dx = this.x - c.x;
        const dy = this.y - c.y;
        const dz = this.getZ() - c.getZ();
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    getY() {
        return this.y;
    }
    getM() {
        return (0, _doubleJsDefault.default).NaN;
    }
    setOrdinate(ordinateIndex, value) {
        switch(ordinateIndex){
            case Coordinate.X:
                this.x = value;
                break;
            case Coordinate.Y:
                this.y = value;
                break;
            case Coordinate.Z:
                this.setZ(value);
                break;
            default:
                throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
        }
    }
    getZ() {
        return this.z;
    }
    getOrdinate(ordinateIndex) {
        switch(ordinateIndex){
            case Coordinate.X:
                return this.x;
            case Coordinate.Y:
                return this.y;
            case Coordinate.Z:
                return this.getZ();
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
    }
    equals(other) {
        if (!(other instanceof Coordinate)) return false;
        return this.equals2D(other);
    }
    equalInZ(c, tolerance) {
        return (0, _numberUtilJsDefault.default).equalsWithTolerance(this.getZ(), c.getZ(), tolerance);
    }
    setZ(z) {
        this.z = z;
    }
    clone() {
        try {
            const coord = null;
            return coord;
        } catch (e) {
            if (e instanceof CloneNotSupportedException) {
                (0, _assertJsDefault.default).shouldNeverReachHere('this shouldn\'t happen because this class is Cloneable');
                return null;
            } else throw e;
        } finally{}
    }
    setY(y) {
        this.y = y;
    }
    distance(c) {
        const dx = this.x - c.x;
        const dy = this.y - c.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    hashCode() {
        let result = 17;
        result = 37 * result + Coordinate.hashCode(this.x);
        result = 37 * result + Coordinate.hashCode(this.y);
        return result;
    }
    setCoordinate(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.getZ();
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default),
            (0, _cloneableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = Coordinate;
class DimensionalComparator {
    constructor(){
        DimensionalComparator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._dimensionsToTest = 2;
        if (arguments.length === 0) DimensionalComparator.constructor_.call(this, 2);
        else if (arguments.length === 1) {
            const dimensionsToTest = arguments[0];
            if (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new (0, _illegalArgumentExceptionJsDefault.default)('only 2 or 3 dimensions may be specified');
            this._dimensionsToTest = dimensionsToTest;
        }
    }
    static compare(a, b) {
        if (a < b) return -1;
        if (a > b) return 1;
        if ((0, _doubleJsDefault.default).isNaN(a)) {
            if ((0, _doubleJsDefault.default).isNaN(b)) return 0;
            return -1;
        }
        if ((0, _doubleJsDefault.default).isNaN(b)) return 1;
        return 0;
    }
    compare(c1, c2) {
        const compX = DimensionalComparator.compare(c1.x, c2.x);
        if (compX !== 0) return compX;
        const compY = DimensionalComparator.compare(c1.y, c2.y);
        if (compY !== 0) return compY;
        if (this._dimensionsToTest <= 2) return 0;
        const compZ = DimensionalComparator.compare(c1.getZ(), c2.getZ());
        return compZ;
    }
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
}
Coordinate.DimensionalComparator = DimensionalComparator;
Coordinate.NULL_ORDINATE = (0, _doubleJsDefault.default).NaN;
Coordinate.X = 0;
Coordinate.Y = 1;
Coordinate.Z = 2;
Coordinate.M = 3;

},{"../util/NumberUtil.js":"dzxUj","../../../../java/lang/IllegalArgumentException.js":"9ppVW","../../../../java/lang/Double.js":"clUxd","../../../../java/lang/Comparable.js":"WFeEu","../../../../java/io/Serializable.js":"5sRbw","../util/Assert.js":"1vSRy","../../../../java/lang/Cloneable.js":"kAAzr","../../../../java/util/Comparator.js":"hcSJ3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dzxUj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class NumberUtil {
    static equalsWithTolerance(x1, x2, tolerance) {
        return Math.abs(x1 - x2) <= tolerance;
    }
}
exports.default = NumberUtil;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9ppVW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("./Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class IllegalArgumentException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            IllegalArgumentException
        })[0];
    }
}
exports.default = IllegalArgumentException;

},{"./Exception.js":"8tbsL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8tbsL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Exception extends Error {
    constructor(message){
        super(message);
        this.name = Object.keys({
            Exception
        })[0];
    }
    toString() {
        return this.message;
    }
}
exports.default = Exception;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"clUxd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Double);
var _longJs = require("./Long.js");
var _longJsDefault = parcelHelpers.interopDefault(_longJs);
function Double() {}
Double.NaN = NaN;
Double.isNaN = (n)=>Number.isNaN(n);
Double.isInfinite = (n)=>!Number.isFinite(n);
Double.MAX_VALUE = Number.MAX_VALUE;
Double.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
Double.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
if (typeof Float64Array === 'function' && typeof Int32Array === 'function') // Simple and fast conversion between double and long bits
// using TypedArrays and ArrayViewBuffers.
(function() {
    const EXP_BIT_MASK = 0x7ff00000;
    const SIGNIF_BIT_MASK = 0xFFFFF;
    const f64buf = new Float64Array(1);
    const i32buf = new Int32Array(f64buf.buffer);
    Double.doubleToLongBits = function(value) {
        f64buf[0] = value;
        let low = i32buf[0] | 0;
        let high = i32buf[1] | 0;
        // Check for NaN based on values of bit fields, maximum
        // exponent and nonzero significand.
        if ((high & EXP_BIT_MASK) === EXP_BIT_MASK && (high & SIGNIF_BIT_MASK) !== 0 && low !== 0) {
            low = 0;
            high = 2146959360;
        }
        return new (0, _longJsDefault.default)(high, low);
    };
    Double.longBitsToDouble = function(bits) {
        i32buf[0] = bits.low;
        i32buf[1] = bits.high;
        return f64buf[0];
    };
})();
else // More complex and slower fallback implementation using
// math and the divide-by-two and multiply-by-two algorithms.
(function() {
    const BIAS = 1023;
    const log2 = Math.log2;
    const floor = Math.floor;
    const pow = Math.pow;
    const MAX_REL_BITS_INTEGER = function() {
        for(let i = 53; i > 0; i--){
            const bits = pow(2, i) - 1;
            if (floor(log2(bits)) + 1 === i) return bits;
        }
        return 0;
    }();
    Double.doubleToLongBits = function(value) {
        let x, y, f, bits, skip;
        let sign, exp, high, low;
        // Get the sign bit and absolute value.
        if (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {
            sign = -2147483648;
            value = -value;
        } else sign = 0;
        // Handle some special values.
        if (value === 0) {
            // Handle zeros (+/-0).
            low = 0;
            high = sign // exponent: 00..00, significand: 00..00
            ;
            return new (0, _longJsDefault.default)(high, low);
        }
        if (value === Infinity) {
            // Handle infinity (only positive values for value possible).
            low = 0;
            high = sign | 0x7ff00000 // exponent: 11..11, significand: 00..00
            ;
            return new (0, _longJsDefault.default)(high, low);
        }
        if (value !== value) {
            // Handle NaNs (boiled down to only one distinct NaN).
            low = 0;
            high = 0x7ff80000 // exponent: 11..11, significand: 10..00
            ;
            return new (0, _longJsDefault.default)(high, low);
        }
        // Preinitialize variables, that are not neccessarily set by
        // the algorithm.
        bits = 0;
        low = 0;
        // Get the (always positive) integer part of value.
        x = floor(value);
        // Process the integer part if it's greater than 1. Zero requires
        // no bits at all, 1 represents the implicit (hidden) leading bit,
        // which must not be written as well.
        if (x > 1) {
            // If we can reliably determine the number of bits required for
            // the integer part,
            if (x <= MAX_REL_BITS_INTEGER) {
                // get the number of bits required to represent it minus 1
                bits = floor(log2(x));
                /* + 1 - 1 */ // and simply copy/shift the integer bits into low and high.
                // That's much faster than the divide-by-two algorithm (saves
                // up to ~60%).
                // We always need to mask out the most significant bit, which
                // is the implicit (aka hidden) bit.
                if (bits <= 20) {
                    // The simple case in which the integer fits into the
                    // lower 20 bits of the high word is worth to be handled
                    // separately (saves ~25%).
                    low = 0;
                    high = x << 20 - bits & 0xfffff;
                } else {
                    // Here, the integer part is split into low and high.
                    // Since its value may require more than 32 bits, we
                    // cannot use bitwise operators (which implicitly cast
                    // to Int32), but use arithmetic operators % and / to
                    // get low and high parts. The uppper 20 bits go to high,
                    // the remaining bits (in f) to low.
                    f = bits - 20;
                    // Like (1 << f) but safe with even more than 32 bits.
                    y = pow(2, f);
                    low = x % y << 32 - f;
                    high = x / y & 0xfffff;
                }
            } else {
                // For greater values, we must use the much slower divide-by-two
                // algorithm. Bits are generated from right to left, that is from
                // least to most significant bit. For each bit, we left-shift both
                // low and high by one and carry bit #0 from high to #31 in low.
                // The next bit is then copied into bit #19 in high, the leftmost
                // bit of the double's significand.
                // Preserve x for later user, so work with f.
                f = x;
                low = 0;
                for(;;){
                    y = f / 2;
                    f = floor(y);
                    if (f === 0) break;
                    // Count this bit, shift low and carry bit #0 from high.
                    bits++;
                    low >>>= 1;
                    low |= (high & 0x1) << 31;
                    // Shift high.
                    high >>>= 1;
                    if (y !== f) // Copy the new bit into bit #19 in high (only required if 1).
                    high |= 0x80000;
                }
            }
        }
        // Bias the exponent.
        exp = bits + BIAS;
        // If the integer part is zero, we've not yet seen the implicit
        // leading bit. Variable skip is later used while processing the
        // fractional part (if any).
        skip = x === 0;
        // Get fraction only into x.
        x = value - x;
        // If some significand bits are still left to be filled and
        // the fractional part is not zero, convert the fraction using
        // the multiply-by-2 algorithm.
        if (bits < 52 && x !== 0) {
            // Initialize 'buffer' f, into which newly created bits get
            // shifted from right to left.
            f = 0;
            for(;;){
                y = x * 2;
                if (y >= 1) {
                    // This is a new 1-bit. Add and count this bit, if not
                    // prohibited by skip.
                    x = y - 1;
                    if (!skip) {
                        f <<= 1;
                        f |= 1;
                        bits++;
                    } else {
                        // Otherwise, decrement the exponent and unset
                        // skip, so that all following bits get written.
                        exp--;
                        skip = false;
                    }
                } else {
                    // This is a new 0-bit. Add and count this bit, if not
                    // prohibited by skip.
                    x = y;
                    if (!skip) {
                        f <<= 1;
                        bits++;
                    } else if (--exp === 0) {
                        // Otherwise we've just decremented the exponent. If the
                        // biased exponent is zero now (-1023), we process a
                        // subnormal number, which has no impled leading 1-bit.
                        // So, count this 0-bit and unset skip to write out
                        // all the following bits.
                        bits++;
                        skip = false;
                    }
                }
                if (bits === 20) {
                    // When 20 bits have been created in total, we're done with
                    // the high word. Copy the bits from 'buffer' f into high
                    // and reset 'buffer' f. Following bits will end up in the
                    // low word.
                    high |= f;
                    f = 0;
                } else if (bits === 52) {
                    // When 52 bits have been created in total, we're done with
                    // low word as well. Copy the bits from 'buffer' f into low
                    // and exit the loop.
                    low |= f;
                    break;
                }
                if (y === 1) {
                    // When y is exactly 1, there is no remainder and the process
                    // is complete (the number is finite). Copy the bits from
                    // 'buffer' f into either low or high and exit the loop.
                    if (bits < 20) high |= f << 20 - bits;
                    else if (bits < 52) low |= f << 52 - bits;
                    break;
                }
            }
        }
        // Copy/shift the exponent and sign bits into the high word.
        high |= exp << 20;
        high |= sign;
        return new (0, _longJsDefault.default)(high, low);
    };
    Double.longBitsToDouble = function(bits) {
        let i;
        let x, exp, fract;
        const high = bits.high;
        const low = bits.low;
        // Extract the sign.
        const sign = high & -2147483648 ? -1 : 1;
        // Extract the unbiased exponent.
        exp = ((high & 0x7ff00000) >> 20) - BIAS;
        // Calculate the fraction from left to right. Start
        // off with the 20 lower bits from the high word.
        fract = 0;
        x = 524288;
        for(i = 1; i <= 20; i++){
            if (high & x) fract += pow(2, -i);
            x >>>= 1;
        }
        // Continue with all 32 bits from the low word.
        x = -2147483648;
        for(i = 21; i <= 52; i++){
            if (low & x) fract += pow(2, -i);
            x >>>= 1;
        }
        // Handle special values.
        // Check for zero and subnormal values.
        if (exp === -BIAS) {
            if (fract === 0) // +/-1.0 * 0.0 => +/-0.0
            return sign * 0;
            exp = -1022;
        } else if (exp === BIAS + 1) {
            if (fract === 0) // +/-1.0 / 0.0 => +/-Infinity
            return sign / 0;
            return NaN;
        } else // Add the implicit leading bit (1*2^0).
        fract += 1;
        return sign * fract * pow(2, exp);
    };
})();

},{"./Long.js":"9ArwZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9ArwZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Long {
    constructor(high, low){
        this.low = low || 0;
        this.high = high || 0;
    }
    static toBinaryString(i) {
        let mask;
        let result = '';
        for(mask = 0x80000000; mask > 0; mask >>>= 1)result += (i.high & mask) === mask ? '1' : '0';
        for(mask = 0x80000000; mask > 0; mask >>>= 1)result += (i.low & mask) === mask ? '1' : '0';
        return result;
    }
}
exports.default = Long;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"WFeEu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Comparable);
function Comparable() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5sRbw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Serializable);
function Serializable() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1vSRy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assertionFailedExceptionJs = require("./AssertionFailedException.js");
var _assertionFailedExceptionJsDefault = parcelHelpers.interopDefault(_assertionFailedExceptionJs);
class Assert {
    static isTrue() {
        if (arguments.length === 1) {
            const assertion = arguments[0];
            Assert.isTrue(assertion, null);
        } else if (arguments.length === 2) {
            const assertion = arguments[0], message = arguments[1];
            if (!assertion) {
                if (message === null) throw new (0, _assertionFailedExceptionJsDefault.default)();
                else throw new (0, _assertionFailedExceptionJsDefault.default)(message);
            }
        }
    }
    static shouldNeverReachHere() {
        if (arguments.length === 0) Assert.shouldNeverReachHere(null);
        else if (arguments.length === 1) {
            const message = arguments[0];
            throw new (0, _assertionFailedExceptionJsDefault.default)('Should never reach here' + (message !== null ? ': ' + message : ''));
        }
    }
    static equals() {
        if (arguments.length === 2) {
            const expectedValue = arguments[0], actualValue = arguments[1];
            Assert.equals(expectedValue, actualValue, null);
        } else if (arguments.length === 3) {
            const expectedValue = arguments[0], actualValue = arguments[1], message = arguments[2];
            if (!actualValue.equals(expectedValue)) throw new (0, _assertionFailedExceptionJsDefault.default)('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''));
        }
    }
}
exports.default = Assert;

},{"./AssertionFailedException.js":"5OfAS","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5OfAS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _runtimeExceptionJs = require("../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
class AssertionFailedException extends (0, _runtimeExceptionJsDefault.default) {
    constructor(){
        super();
        AssertionFailedException.constructor_.apply(this, arguments);
    }
    static constructor_() {
        if (arguments.length === 0) (0, _runtimeExceptionJsDefault.default).constructor_.call(this);
        else if (arguments.length === 1) {
            const message = arguments[0];
            (0, _runtimeExceptionJsDefault.default).constructor_.call(this, message);
        }
    }
}
exports.default = AssertionFailedException;

},{"../../../../java/lang/RuntimeException.js":"3yvnL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3yvnL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("./Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class RuntimeException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            RuntimeException
        })[0];
    }
}
exports.default = RuntimeException;

},{"./Exception.js":"8tbsL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kAAzr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Clonable);
function Clonable() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hcSJ3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Comparator);
function Comparator() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cGt0T":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _linearRingJs = require("./LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _coordinateArraySequenceFactoryJs = require("./impl/CoordinateArraySequenceFactory.js");
var _coordinateArraySequenceFactoryJsDefault = parcelHelpers.interopDefault(_coordinateArraySequenceFactoryJs);
var _multiPolygonJs = require("./MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _coordinateSequencesJs = require("./CoordinateSequences.js");
var _coordinateSequencesJsDefault = parcelHelpers.interopDefault(_coordinateSequencesJs);
var _precisionModelJs = require("./PrecisionModel.js");
var _precisionModelJsDefault = parcelHelpers.interopDefault(_precisionModelJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _multiLineStringJs = require("./MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _coordinateSequenceFactoryJs = require("./CoordinateSequenceFactory.js");
var _coordinateSequenceFactoryJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFactoryJs);
var _lineStringJs = require("./LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _pointJs = require("./Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("./Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _multiPointJs = require("./MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _coordinateSequenceJs = require("./CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
var _geometryCollectionJs = require("./GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
class GeometryFactory {
    constructor(){
        GeometryFactory.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._precisionModel = null;
        this._coordinateSequenceFactory = null;
        this._SRID = null;
        if (arguments.length === 0) GeometryFactory.constructor_.call(this, new (0, _precisionModelJsDefault.default)(), 0);
        else if (arguments.length === 1) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceFactoryJsDefault.default))) {
                const coordinateSequenceFactory = arguments[0];
                GeometryFactory.constructor_.call(this, new (0, _precisionModelJsDefault.default)(), 0, coordinateSequenceFactory);
            } else if (arguments[0] instanceof (0, _precisionModelJsDefault.default)) {
                const precisionModel = arguments[0];
                GeometryFactory.constructor_.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());
            }
        } else if (arguments.length === 2) {
            const precisionModel = arguments[0], SRID = arguments[1];
            GeometryFactory.constructor_.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());
        } else if (arguments.length === 3) {
            const precisionModel = arguments[0], SRID = arguments[1], coordinateSequenceFactory = arguments[2];
            this._precisionModel = precisionModel;
            this._coordinateSequenceFactory = coordinateSequenceFactory;
            this._SRID = SRID;
        }
    }
    static toMultiPolygonArray(multiPolygons) {
        const multiPolygonArray = new Array(multiPolygons.size()).fill(null);
        return multiPolygons.toArray(multiPolygonArray);
    }
    static toGeometryArray(geometries) {
        if (geometries === null) return null;
        const geometryArray = new Array(geometries.size()).fill(null);
        return geometries.toArray(geometryArray);
    }
    static getDefaultCoordinateSequenceFactory() {
        return (0, _coordinateArraySequenceFactoryJsDefault.default).instance();
    }
    static toMultiLineStringArray(multiLineStrings) {
        const multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
        return multiLineStrings.toArray(multiLineStringArray);
    }
    static toLineStringArray(lineStrings) {
        const lineStringArray = new Array(lineStrings.size()).fill(null);
        return lineStrings.toArray(lineStringArray);
    }
    static toMultiPointArray(multiPoints) {
        const multiPointArray = new Array(multiPoints.size()).fill(null);
        return multiPoints.toArray(multiPointArray);
    }
    static toLinearRingArray(linearRings) {
        const linearRingArray = new Array(linearRings.size()).fill(null);
        return linearRings.toArray(linearRingArray);
    }
    static toPointArray(points) {
        const pointArray = new Array(points.size()).fill(null);
        return points.toArray(pointArray);
    }
    static toPolygonArray(polygons) {
        const polygonArray = new Array(polygons.size()).fill(null);
        return polygons.toArray(polygonArray);
    }
    static createPointFromInternalCoord(coord, exemplar) {
        exemplar.getPrecisionModel().makePrecise(coord);
        return exemplar.getFactory().createPoint(coord);
    }
    createEmpty(dimension) {
        switch(dimension){
            case -1:
                return this.createGeometryCollection();
            case 0:
                return this.createPoint();
            case 1:
                return this.createLineString();
            case 2:
                return this.createPolygon();
            default:
                throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid dimension: ' + dimension);
        }
    }
    toGeometry(envelope) {
        if (envelope.isNull()) return this.createPoint();
        if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) return this.createPoint(new (0, _coordinateJsDefault.default)(envelope.getMinX(), envelope.getMinY()));
        if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) return this.createLineString([
            new (0, _coordinateJsDefault.default)(envelope.getMinX(), envelope.getMinY()),
            new (0, _coordinateJsDefault.default)(envelope.getMaxX(), envelope.getMaxY())
        ]);
        return this.createPolygon(this.createLinearRing([
            new (0, _coordinateJsDefault.default)(envelope.getMinX(), envelope.getMinY()),
            new (0, _coordinateJsDefault.default)(envelope.getMinX(), envelope.getMaxY()),
            new (0, _coordinateJsDefault.default)(envelope.getMaxX(), envelope.getMaxY()),
            new (0, _coordinateJsDefault.default)(envelope.getMaxX(), envelope.getMinY()),
            new (0, _coordinateJsDefault.default)(envelope.getMinX(), envelope.getMinY())
        ]), null);
    }
    createLineString() {
        if (arguments.length === 0) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
        else if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const coordinates = arguments[0];
                return this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordinates = arguments[0];
                return new (0, _lineStringJsDefault.default)(coordinates, this);
            }
        }
    }
    createMultiLineString() {
        if (arguments.length === 0) return new (0, _multiLineStringJsDefault.default)(null, this);
        else if (arguments.length === 1) {
            const lineStrings = arguments[0];
            return new (0, _multiLineStringJsDefault.default)(lineStrings, this);
        }
    }
    createPolygon() {
        if (arguments.length === 0) return this.createPolygon(null, null);
        else if (arguments.length === 1) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const shell = arguments[0];
                return this.createPolygon(this.createLinearRing(shell));
            } else if (arguments[0] instanceof Array) {
                const shell = arguments[0];
                return this.createPolygon(this.createLinearRing(shell));
            } else if (arguments[0] instanceof (0, _linearRingJsDefault.default)) {
                const shell = arguments[0];
                return this.createPolygon(shell, null);
            }
        } else if (arguments.length === 2) {
            const shell = arguments[0], holes = arguments[1];
            return new (0, _polygonJsDefault.default)(shell, holes, this);
        }
    }
    getSRID() {
        return this._SRID;
    }
    createGeometryCollection() {
        if (arguments.length === 0) return new (0, _geometryCollectionJsDefault.default)(null, this);
        else if (arguments.length === 1) {
            const geometries = arguments[0];
            return new (0, _geometryCollectionJsDefault.default)(geometries, this);
        }
    }
    getPrecisionModel() {
        return this._precisionModel;
    }
    createLinearRing() {
        if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
        else if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const coordinates = arguments[0];
                return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordinates = arguments[0];
                return new (0, _linearRingJsDefault.default)(coordinates, this);
            }
        }
    }
    createMultiPolygon() {
        if (arguments.length === 0) return new (0, _multiPolygonJsDefault.default)(null, this);
        else if (arguments.length === 1) {
            const polygons = arguments[0];
            return new (0, _multiPolygonJsDefault.default)(polygons, this);
        }
    }
    createMultiPoint() {
        if (arguments.length === 0) return new (0, _multiPointJsDefault.default)(null, this);
        else if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const point = arguments[0];
                return new (0, _multiPointJsDefault.default)(point, this);
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordinates = arguments[0];
                if (coordinates === null) return this.createMultiPoint(new Array(0).fill(null));
                const points = new Array(coordinates.size()).fill(null);
                for(let i = 0; i < coordinates.size(); i++){
                    const ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension(), coordinates.getMeasures());
                    (0, _coordinateSequencesJsDefault.default).copy(coordinates, i, ptSeq, 0, 1);
                    points[i] = this.createPoint(ptSeq);
                }
                return this.createMultiPoint(points);
            }
        }
    }
    buildGeometry(geomList) {
        let geomType = null;
        let isHeterogeneous = false;
        let hasGeometryCollection = false;
        for(let i = geomList.iterator(); i.hasNext();){
            const geom = i.next();
            const partType = geom.getTypeCode();
            if (geomType === null) geomType = partType;
            if (partType !== geomType) isHeterogeneous = true;
            if (geom instanceof (0, _geometryCollectionJsDefault.default)) hasGeometryCollection = true;
        }
        if (geomType === null) return this.createGeometryCollection();
        if (isHeterogeneous || hasGeometryCollection) return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));
        const geom0 = geomList.iterator().next();
        const isCollection = geomList.size() > 1;
        if (isCollection) {
            if (geom0 instanceof (0, _polygonJsDefault.default)) return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));
            else if (geom0 instanceof (0, _lineStringJsDefault.default)) return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));
            else if (geom0 instanceof (0, _pointJsDefault.default)) return this.createMultiPoint(GeometryFactory.toPointArray(geomList));
            (0, _assertJsDefault.default).shouldNeverReachHere('Unhandled geometry type: ' + geom0.getGeometryType());
        }
        return geom0;
    }
    createMultiPointFromCoords(coordinates) {
        return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
    }
    createPoint() {
        if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
        else if (arguments.length === 1) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const coordinate = arguments[0];
                return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([
                    coordinate
                ]) : null);
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordinates = arguments[0];
                return new (0, _pointJsDefault.default)(coordinates, this);
            }
        }
    }
    getCoordinateSequenceFactory() {
        return this._coordinateSequenceFactory;
    }
    get interfaces_() {
        return [
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = GeometryFactory;

},{"../../../../hasInterface.js":"5bpze","./LinearRing.js":"2x4Ym","./impl/CoordinateArraySequenceFactory.js":"dgF5W","./MultiPolygon.js":"6Hrab","./CoordinateSequences.js":"iGxeo","./PrecisionModel.js":"9XxRL","../../../../java/io/Serializable.js":"5sRbw","../util/Assert.js":"1vSRy","./MultiLineString.js":"5UyOx","./CoordinateSequenceFactory.js":"gg8AJ","./LineString.js":"4eIEg","./Coordinate.js":"ii2fh","../../../../java/lang/IllegalArgumentException.js":"9ppVW","./Point.js":"lwZpO","./Polygon.js":"kpOA5","./MultiPoint.js":"5w2To","./CoordinateSequence.js":"aDXS8","./GeometryCollection.js":"6RJQO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5bpze":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>function(o, i) {
        return o.interfaces_ && o.interfaces_.indexOf(i) > -1;
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2x4Ym":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("./LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _coordinateSequencesJs = require("./CoordinateSequences.js");
var _coordinateSequencesJsDefault = parcelHelpers.interopDefault(_coordinateSequencesJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
class LinearRing extends (0, _lineStringJsDefault.default) {
    constructor(){
        super();
        LinearRing.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const points = arguments[0], factory = arguments[1];
        (0, _lineStringJsDefault.default).constructor_.call(this, points, factory);
        this.validateConstruction();
    }
    copyInternal() {
        return new LinearRing(this._points.copy(), this._factory);
    }
    getBoundaryDimension() {
        return (0, _dimensionJsDefault.default).FALSE;
    }
    isClosed() {
        if (this.isEmpty()) return true;
        return super.isClosed.call(this);
    }
    reverseInternal() {
        const seq = this._points.copy();
        (0, _coordinateSequencesJsDefault.default).reverse(seq);
        return this.getFactory().createLinearRing(seq);
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_LINEARRING;
    }
    validateConstruction() {
        if (!this.isEmpty() && !super.isClosed.call(this)) throw new (0, _illegalArgumentExceptionJsDefault.default)('Points of LinearRing do not form a closed linestring');
        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)');
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_LINEARRING;
    }
}
exports.default = LinearRing;
LinearRing.MINIMUM_VALID_SIZE = 4;

},{"./LineString.js":"4eIEg","./Geometry.js":"9DSzO","../../../../java/lang/IllegalArgumentException.js":"9ppVW","./CoordinateSequences.js":"iGxeo","./Dimension.js":"kWqD0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4eIEg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _lengthJs = require("../algorithm/Length.js");
var _lengthJsDefault = parcelHelpers.interopDefault(_lengthJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _geometryComponentFilterJs = require("./GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _unsupportedOperationExceptionJs = require("../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
var _coordinateArraysJs = require("./CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _envelopeJs = require("./Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _coordinateFilterJs = require("./CoordinateFilter.js");
var _coordinateFilterJsDefault = parcelHelpers.interopDefault(_coordinateFilterJs);
var _linealJs = require("./Lineal.js");
var _linealJsDefault = parcelHelpers.interopDefault(_linealJs);
var _coordinateSequencesJs = require("./CoordinateSequences.js");
var _coordinateSequencesJsDefault = parcelHelpers.interopDefault(_coordinateSequencesJs);
var _geometryFilterJs = require("./GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
var _coordinateSequenceFilterJs = require("./CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
class LineString extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        LineString.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._points = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 2) {
            const points = arguments[0], factory = arguments[1];
            (0, _geometryJsDefault.default).constructor_.call(this, factory);
            this.init(points);
        }
    }
    computeEnvelopeInternal() {
        if (this.isEmpty()) return new (0, _envelopeJsDefault.default)();
        return this._points.expandEnvelope(new (0, _envelopeJsDefault.default)());
    }
    isRing() {
        return this.isClosed() && (0, _coordinateArraysJsDefault.default).isRing(this.getCoordinates());
    }
    getCoordinates() {
        return this._points.toCoordinateArray();
    }
    copyInternal() {
        return new LineString(this._points.copy(), this._factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            const otherLineString = other;
            if (this._points.size() !== otherLineString._points.size()) return false;
            for(let i = 0; i < this._points.size(); i++)if (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) return false;
            return true;
        } else return super.equalsExact.apply(this, arguments);
    }
    isClosed() {
        if (this.isEmpty()) return false;
        return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
    }
    reverseInternal() {
        const seq = this._points.copy();
        (0, _coordinateSequencesJsDefault.default).reverse(seq);
        return this.getFactory().createLineString(seq);
    }
    getEndPoint() {
        if (this.isEmpty()) return null;
        return this.getPointN(this.getNumPoints() - 1);
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_LINESTRING;
    }
    getDimension() {
        return 1;
    }
    getBoundary() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
    isEquivalentClass(other) {
        return other instanceof LineString;
    }
    getCoordinateSequence() {
        return this._points;
    }
    getPointN(n) {
        return this.getFactory().createPoint(this._points.getCoordinate(n));
    }
    normalize() {
        for(let i = 0; i < Math.trunc(this._points.size() / 2); i++){
            const j = this._points.size() - 1 - i;
            if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {
                if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {
                    const copy = this._points.copy();
                    (0, _coordinateSequencesJsDefault.default).reverse(copy);
                    this._points = copy;
                }
                return null;
            }
        }
    }
    getCoordinate() {
        if (this.isEmpty()) return null;
        return this._points.getCoordinate(0);
    }
    getBoundaryDimension() {
        if (this.isClosed()) return (0, _dimensionJsDefault.default).FALSE;
        return 0;
    }
    getLength() {
        return (0, _lengthJsDefault.default).ofLine(this._points);
    }
    getNumPoints() {
        return this._points.size();
    }
    compareToSameClass() {
        if (arguments.length === 1) {
            const o = arguments[0];
            const line = o;
            let i = 0;
            let j = 0;
            while(i < this._points.size() && j < line._points.size()){
                const comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
                if (comparison !== 0) return comparison;
                i++;
                j++;
            }
            if (i < this._points.size()) return 1;
            if (j < line._points.size()) return -1;
            return 0;
        } else if (arguments.length === 2) {
            const o = arguments[0], comp = arguments[1];
            const line = o;
            return comp.compare(this._points, line._points);
        }
    }
    apply() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateFilterJsDefault.default))) {
            const filter = arguments[0];
            for(let i = 0; i < this._points.size(); i++)filter.filter(this._points.getCoordinate(i));
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceFilterJsDefault.default))) {
            const filter = arguments[0];
            if (this._points.size() === 0) return null;
            for(let i = 0; i < this._points.size(); i++){
                filter.filter(this._points, i);
                if (filter.isDone()) break;
            }
            if (filter.isGeometryChanged()) this.geometryChanged();
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryComponentFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
        }
    }
    getCoordinateN(n) {
        return this._points.getCoordinate(n);
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_LINESTRING;
    }
    isEmpty() {
        return this._points.size() === 0;
    }
    init(points) {
        if (points === null) points = this.getFactory().getCoordinateSequenceFactory().create([]);
        if (points.size() === 1) throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)');
        this._points = points;
    }
    isCoordinate(pt) {
        for(let i = 0; i < this._points.size(); i++)if (this._points.getCoordinate(i).equals(pt)) return true;
        return false;
    }
    getStartPoint() {
        if (this.isEmpty()) return null;
        return this.getPointN(0);
    }
    get interfaces_() {
        return [
            (0, _linealJsDefault.default)
        ];
    }
}
exports.default = LineString;

},{"../../../../hasInterface.js":"5bpze","../algorithm/Length.js":"5cpmq","../../../../java/lang/IllegalArgumentException.js":"9ppVW","./GeometryComponentFilter.js":"lqE9C","../../../../java/lang/UnsupportedOperationException.js":"dV3kx","./CoordinateArrays.js":"lncg4","./Dimension.js":"kWqD0","./Envelope.js":"h2zeM","./Geometry.js":"9DSzO","./CoordinateFilter.js":"cr8Rt","./Lineal.js":"51JJJ","./CoordinateSequences.js":"iGxeo","./GeometryFilter.js":"fZPJo","./CoordinateSequenceFilter.js":"8MSah","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5cpmq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
class Length {
    static ofLine(pts) {
        const n = pts.size();
        if (n <= 1) return 0.0;
        let len = 0.0;
        const p = new (0, _coordinateJsDefault.default)();
        pts.getCoordinate(0, p);
        let x0 = p.x;
        let y0 = p.y;
        for(let i = 1; i < n; i++){
            pts.getCoordinate(i, p);
            const x1 = p.x;
            const y1 = p.y;
            const dx = x1 - x0;
            const dy = y1 - y0;
            len += Math.sqrt(dx * dx + dy * dy);
            x0 = x1;
            y0 = y1;
        }
        return len;
    }
}
exports.default = Length;

},{"../geom/Coordinate.js":"ii2fh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lqE9C":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class GeometryComponentFilter {
    filter(geom) {}
}
exports.default = GeometryComponentFilter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dV3kx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("./Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class UnsupportedOperationException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            UnsupportedOperationException
        })[0];
    }
}
exports.default = UnsupportedOperationException;

},{"./Exception.js":"8tbsL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lncg4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateListJs = require("./CoordinateList.js");
var _coordinateListJsDefault = parcelHelpers.interopDefault(_coordinateListJs);
var _coordinatesJs = require("./Coordinates.js");
var _coordinatesJsDefault = parcelHelpers.interopDefault(_coordinatesJs);
var _mathUtilJs = require("../math/MathUtil.js");
var _mathUtilJsDefault = parcelHelpers.interopDefault(_mathUtilJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _comparatorJs = require("../../../../java/util/Comparator.js");
var _comparatorJsDefault = parcelHelpers.interopDefault(_comparatorJs);
var _envelopeJs = require("./Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class CoordinateArrays {
    static scroll(coordinates, firstCoordinate) {
        const i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
        if (i < 0) return null;
        const newCoordinates = new Array(coordinates.length).fill(null);
        (0, _systemJsDefault.default).arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
        (0, _systemJsDefault.default).arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
        (0, _systemJsDefault.default).arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
    }
    static removeRepeatedPoints(coord) {
        if (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;
        const coordList = new (0, _coordinateListJsDefault.default)(coord, false);
        return coordList.toCoordinateArray();
    }
    static reverse(coord) {
        const last = coord.length - 1;
        const mid = Math.trunc(last / 2);
        for(let i = 0; i <= mid; i++){
            const tmp = coord[i];
            coord[i] = coord[last - i];
            coord[last - i] = tmp;
        }
    }
    static removeNull(coord) {
        let nonNull = 0;
        for(let i = 0; i < coord.length; i++)if (coord[i] !== null) nonNull++;
        const newCoord = new Array(nonNull).fill(null);
        if (nonNull === 0) return newCoord;
        let j = 0;
        for(let i = 0; i < coord.length; i++)if (coord[i] !== null) newCoord[j++] = coord[i];
        return newCoord;
    }
    static copyDeep() {
        if (arguments.length === 1) {
            const coordinates = arguments[0];
            const copy = new Array(coordinates.length).fill(null);
            for(let i = 0; i < coordinates.length; i++)copy[i] = coordinates[i].copy();
            return copy;
        } else if (arguments.length === 5) {
            const src = arguments[0], srcStart = arguments[1], dest = arguments[2], destStart = arguments[3], length = arguments[4];
            for(let i = 0; i < length; i++)dest[destStart + i] = src[srcStart + i].copy();
        }
    }
    static isEqualReversed(pts1, pts2) {
        for(let i = 0; i < pts1.length; i++){
            const p1 = pts1[i];
            const p2 = pts2[pts1.length - i - 1];
            if (p1.compareTo(p2) !== 0) return false;
        }
        return true;
    }
    static envelope(coordinates) {
        const env = new (0, _envelopeJsDefault.default)();
        for(let i = 0; i < coordinates.length; i++)env.expandToInclude(coordinates[i]);
        return env;
    }
    static extract(pts, start, end) {
        start = (0, _mathUtilJsDefault.default).clamp(start, 0, pts.length);
        end = (0, _mathUtilJsDefault.default).clamp(end, -1, pts.length);
        let npts = end - start + 1;
        if (end < 0) npts = 0;
        if (start >= pts.length) npts = 0;
        if (end < start) npts = 0;
        const extractPts = new Array(npts).fill(null);
        if (npts === 0) return extractPts;
        let iPts = 0;
        for(let i = start; i <= end; i++)extractPts[iPts++] = pts[i];
        return extractPts;
    }
    static isRing(pts) {
        if (pts.length < 4) return false;
        if (!pts[0].equals2D(pts[pts.length - 1])) return false;
        return true;
    }
    static ptNotInList(testPts, pts) {
        for(let i = 0; i < testPts.length; i++){
            const testPt = testPts[i];
            if (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;
        }
        return null;
    }
    static equals() {
        if (arguments.length === 2) {
            const coord1 = arguments[0], coord2 = arguments[1];
            if (coord1 === coord2) return true;
            if (coord1 === null || coord2 === null) return false;
            if (coord1.length !== coord2.length) return false;
            for(let i = 0; i < coord1.length; i++)if (!coord1[i].equals(coord2[i])) return false;
            return true;
        } else if (arguments.length === 3) {
            const coord1 = arguments[0], coord2 = arguments[1], coordinateComparator = arguments[2];
            if (coord1 === coord2) return true;
            if (coord1 === null || coord2 === null) return false;
            if (coord1.length !== coord2.length) return false;
            for(let i = 0; i < coord1.length; i++)if (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;
            return true;
        }
    }
    static intersection(coordinates, env) {
        const coordList = new (0, _coordinateListJsDefault.default)();
        for(let i = 0; i < coordinates.length; i++)if (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);
        return coordList.toCoordinateArray();
    }
    static measures(pts) {
        if (pts === null || pts.length === 0) return 0;
        let measures = 0;
        for (const coordinate of pts)measures = Math.max(measures, (0, _coordinatesJsDefault.default).measures(coordinate));
        return measures;
    }
    static hasRepeatedPoints(coord) {
        for(let i = 1; i < coord.length; i++)if (coord[i - 1].equals(coord[i])) return true;
        return false;
    }
    static toCoordinateArray(coordList) {
        return coordList.toArray(CoordinateArrays.coordArrayType);
    }
    static dimension(pts) {
        if (pts === null || pts.length === 0) return 3;
        let dimension = 0;
        for (const coordinate of pts)dimension = Math.max(dimension, (0, _coordinatesJsDefault.default).dimension(coordinate));
        return dimension;
    }
    static atLeastNCoordinatesOrNothing(n, c) {
        return c.length >= n ? c : [];
    }
    static indexOf(coordinate, coordinates) {
        for(let i = 0; i < coordinates.length; i++)if (coordinate.equals(coordinates[i])) return i;
        return -1;
    }
    static increasingDirection(pts) {
        for(let i = 0; i < Math.trunc(pts.length / 2); i++){
            const j = pts.length - 1 - i;
            const comp = pts[i].compareTo(pts[j]);
            if (comp !== 0) return comp;
        }
        return 1;
    }
    static compare(pts1, pts2) {
        let i = 0;
        while(i < pts1.length && i < pts2.length){
            const compare = pts1[i].compareTo(pts2[i]);
            if (compare !== 0) return compare;
            i++;
        }
        if (i < pts2.length) return -1;
        if (i < pts1.length) return 1;
        return 0;
    }
    static minCoordinate(coordinates) {
        let minCoord = null;
        for(let i = 0; i < coordinates.length; i++)if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) minCoord = coordinates[i];
        return minCoord;
    }
}
exports.default = CoordinateArrays;
class ForwardComparator {
    compare(o1, o2) {
        const pts1 = o1;
        const pts2 = o2;
        return CoordinateArrays.compare(pts1, pts2);
    }
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
}
class BidirectionalComparator {
    compare(o1, o2) {
        const pts1 = o1;
        const pts2 = o2;
        if (pts1.length < pts2.length) return -1;
        if (pts1.length > pts2.length) return 1;
        if (pts1.length === 0) return 0;
        const forwardComp = CoordinateArrays.compare(pts1, pts2);
        const isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
        if (isEqualRev) return 0;
        return forwardComp;
    }
    OLDcompare(o1, o2) {
        const pts1 = o1;
        const pts2 = o2;
        if (pts1.length < pts2.length) return -1;
        if (pts1.length > pts2.length) return 1;
        if (pts1.length === 0) return 0;
        const dir1 = CoordinateArrays.increasingDirection(pts1);
        const dir2 = CoordinateArrays.increasingDirection(pts2);
        let i1 = dir1 > 0 ? 0 : pts1.length - 1;
        let i2 = dir2 > 0 ? 0 : pts1.length - 1;
        for(let i = 0; i < pts1.length; i++){
            const comparePt = pts1[i1].compareTo(pts2[i2]);
            if (comparePt !== 0) return comparePt;
            i1 += dir1;
            i2 += dir2;
        }
        return 0;
    }
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
}
CoordinateArrays.ForwardComparator = ForwardComparator;
CoordinateArrays.BidirectionalComparator = BidirectionalComparator;
CoordinateArrays.coordArrayType = new Array(0).fill(null);

},{"./CoordinateList.js":"ibs54","./Coordinates.js":"58TVg","../math/MathUtil.js":"432sT","../../../../java/lang/System.js":"dYmTx","../../../../java/util/Comparator.js":"hcSJ3","./Envelope.js":"h2zeM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ibs54":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _collectionJs = require("../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class CoordinateList extends (0, _arrayListJsDefault.default) {
    constructor(){
        super();
        CoordinateList.constructor_.apply(this, arguments);
    }
    static constructor_() {
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const coord = arguments[0];
            this.ensureCapacity(coord.length);
            this.add(coord, true);
        } else if (arguments.length === 2) {
            const coord = arguments[0], allowRepeated = arguments[1];
            this.ensureCapacity(coord.length);
            this.add(coord, allowRepeated);
        }
    }
    getCoordinate(i) {
        return this.get(i);
    }
    addAll() {
        if (arguments.length === 2 && typeof arguments[1] === 'boolean' && (0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const coll = arguments[0], allowRepeated = arguments[1];
            let isChanged = false;
            for(let i = coll.iterator(); i.hasNext();){
                this.add(i.next(), allowRepeated);
                isChanged = true;
            }
            return isChanged;
        } else return super.addAll.apply(this, arguments);
    }
    clone() {
        const clone = super.clone.call(this);
        for(let i = 0; i < this.size(); i++)clone.add(i, this.get(i).clone());
        return clone;
    }
    closeRing() {
        if (this.size() > 0) {
            const duplicate = this.get(0).copy();
            this.add(duplicate, false);
        }
    }
    toCoordinateArray() {
        if (arguments.length === 0) return this.toArray(CoordinateList.coordArrayType);
        else if (arguments.length === 1) {
            const isForward = arguments[0];
            if (isForward) return this.toArray(CoordinateList.coordArrayType);
            const size = this.size();
            const pts = new Array(size).fill(null);
            for(let i = 0; i < size; i++)pts[i] = this.get(size - i - 1);
            return pts;
        }
    }
    add() {
        if (arguments.length === 1) {
            const coord = arguments[0];
            return super.add.call(this, coord);
        } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {
                const coord = arguments[0], allowRepeated = arguments[1];
                this.add(coord, allowRepeated, true);
                return true;
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && typeof arguments[1] === 'boolean') {
                const coord = arguments[0], allowRepeated = arguments[1];
                if (!allowRepeated) {
                    if (this.size() >= 1) {
                        const last = this.get(this.size() - 1);
                        if (last.equals2D(coord)) return null;
                    }
                }
                super.add.call(this, coord);
            } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {
                const obj = arguments[0], allowRepeated = arguments[1];
                this.add(obj, allowRepeated);
                return true;
            }
        } else if (arguments.length === 3) {
            if (typeof arguments[2] === 'boolean' && arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {
                const coord = arguments[0], allowRepeated = arguments[1], direction = arguments[2];
                if (direction) for(let i = 0; i < coord.length; i++)this.add(coord[i], allowRepeated);
                else for(let i = coord.length - 1; i >= 0; i--)this.add(coord[i], allowRepeated);
                return true;
            } else if (typeof arguments[2] === 'boolean' && Number.isInteger(arguments[0]) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
                const i = arguments[0], coord = arguments[1], allowRepeated = arguments[2];
                if (!allowRepeated) {
                    const size = this.size();
                    if (size > 0) {
                        if (i > 0) {
                            const prev = this.get(i - 1);
                            if (prev.equals2D(coord)) return null;
                        }
                        if (i < size) {
                            const next = this.get(i);
                            if (next.equals2D(coord)) return null;
                        }
                    }
                }
                super.add.call(this, i, coord);
            }
        } else if (arguments.length === 4) {
            const coord = arguments[0], allowRepeated = arguments[1], start = arguments[2], end = arguments[3];
            let inc = 1;
            if (start > end) inc = -1;
            for(let i = start; i !== end; i += inc)this.add(coord[i], allowRepeated);
            return true;
        }
    }
}
exports.default = CoordinateList;
CoordinateList.coordArrayType = new Array(0).fill(null);

},{"../../../../hasInterface.js":"5bpze","../../../../java/util/Collection.js":"cggki","./Coordinate.js":"ii2fh","../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cggki":[function(require,module,exports,__globalThis) {
/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Collection {
    /**
     * Ensures that this collection contains the specified element (optional
     * operation).
     * @param {Object} e
     * @return {boolean}
     */ add() {}
    /**
     * Appends all of the elements in the specified collection to the end of this
     * list, in the order that they are returned by the specified collection's
     * iterator (optional operation).
     * @param {javascript.util.Collection} c
     * @return {boolean}
     */ addAll() {}
    /**
     * Returns true if this collection contains no elements.
     * @return {boolean}
     */ isEmpty() {}
    /**
     * Returns an iterator over the elements in this collection.
     * @return {javascript.util.Iterator}
     */ iterator() {}
    /**
     * Returns an iterator over the elements in this collection.
     * @return {number}
     */ size() {}
    /**
     * Returns an array containing all of the elements in this collection.
     * @return {Array}
     */ toArray() {}
    /**
     * Removes a single instance of the specified element from this collection if it
     * is present. (optional)
     * @param {Object} e
     * @return {boolean}
     */ remove() {}
}
exports.default = Collection;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gGAQZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _indexOutOfBoundsExceptionJs = require("../lang/IndexOutOfBoundsException.js");
var _indexOutOfBoundsExceptionJsDefault = parcelHelpers.interopDefault(_indexOutOfBoundsExceptionJs);
var _listJs = require("./List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
var _noSuchElementExceptionJs = require("./NoSuchElementException.js");
var _noSuchElementExceptionJsDefault = parcelHelpers.interopDefault(_noSuchElementExceptionJs);
class ArrayList extends (0, _listJsDefault.default) {
    constructor(o){
        super();
        this.array = [];
        if (o instanceof (0, _collectionJsDefault.default)) this.addAll(o);
    }
    get interfaces_() {
        return [
            (0, _listJsDefault.default),
            (0, _collectionJsDefault.default)
        ];
    }
    ensureCapacity() {}
    add(e) {
        if (arguments.length === 1) this.array.push(e);
        else this.array.splice(arguments[0], 0, arguments[1]);
        return true;
    }
    clear() {
        this.array = [];
    }
    addAll(c) {
        for (const e of c)this.array.push(e);
    }
    set(index, element) {
        const oldElement = this.array[index];
        this.array[index] = element;
        return oldElement;
    }
    iterator() {
        return new Iterator(this);
    }
    get(index) {
        if (index < 0 || index >= this.size()) throw new (0, _indexOutOfBoundsExceptionJsDefault.default)();
        return this.array[index];
    }
    isEmpty() {
        return this.array.length === 0;
    }
    sort(comparator) {
        if (comparator) this.array.sort((a, b)=>comparator.compare(a, b));
        else this.array.sort();
    }
    size() {
        return this.array.length;
    }
    toArray() {
        return this.array.slice();
    }
    remove(o) {
        for(let i = 0, len = this.array.length; i < len; i++)if (this.array[i] === o) return !!this.array.splice(i, 1);
        return false;
    }
    [Symbol.iterator]() {
        return this.array.values();
    }
}
exports.default = ArrayList;
class Iterator {
    constructor(arrayList){
        this.arrayList = arrayList;
        this.position = 0;
    }
    next() {
        if (this.position === this.arrayList.size()) throw new (0, _noSuchElementExceptionJsDefault.default)();
        return this.arrayList.get(this.position++);
    }
    hasNext() {
        return this.position < this.arrayList.size();
    }
    set(element) {
        return this.arrayList.set(this.position - 1, element);
    }
    remove() {
        this.arrayList.remove(this.arrayList.get(this.position));
    }
}

},{"./Collection.js":"cggki","../lang/IndexOutOfBoundsException.js":"bQ4AR","./List.js":"7jAhK","./NoSuchElementException.js":"8ozww","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bQ4AR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("./Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class IndexOutOfBoundsException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            IndexOutOfBoundsException
        })[0];
    }
}
exports.default = IndexOutOfBoundsException;

},{"./Exception.js":"8tbsL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7jAhK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
class List extends (0, _collectionJsDefault.default) {
    /**
     * Returns the element at the specified position in this list.
     * @param {number} index
     * @return {Object}
     */ get() {}
    /**
     * Replaces the element at the specified position in this list with the
     * specified element (optional operation).
     * @param {number} index
     * @param {Object} e
     * @return {Object}
     */ set() {}
    /**
     * Returns true if this collection contains no elements.
     * @return {boolean}
     */ isEmpty() {}
}
exports.default = List;

},{"./Collection.js":"cggki","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8ozww":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("../lang/Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class NoSuchElementException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            NoSuchElementException
        })[0];
    }
}
exports.default = NoSuchElementException;

},{"../lang/Exception.js":"8tbsL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"58TVg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateXYJs = require("./CoordinateXY.js");
var _coordinateXYJsDefault = parcelHelpers.interopDefault(_coordinateXYJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _coordinateXYMJs = require("./CoordinateXYM.js");
var _coordinateXYMJsDefault = parcelHelpers.interopDefault(_coordinateXYMJs);
var _coordinateXYZMJs = require("./CoordinateXYZM.js");
var _coordinateXYZMJsDefault = parcelHelpers.interopDefault(_coordinateXYZMJs);
class Coordinates {
    static measures(coordinate) {
        if (coordinate instanceof (0, _coordinateXYJsDefault.default)) return 0;
        else if (coordinate instanceof (0, _coordinateXYMJsDefault.default)) return 1;
        else if (coordinate instanceof (0, _coordinateXYZMJsDefault.default)) return 1;
        else if (coordinate instanceof (0, _coordinateJsDefault.default)) return 0;
        return 0;
    }
    static create() {
        if (arguments.length === 1) {
            const dimension = arguments[0];
            return Coordinates.create(dimension, 0);
        } else if (arguments.length === 2) {
            const dimension = arguments[0], measures = arguments[1];
            if (dimension === 2) return new (0, _coordinateXYJsDefault.default)();
            else if (dimension === 3 && measures === 0) return new (0, _coordinateJsDefault.default)();
            else if (dimension === 3 && measures === 1) return new (0, _coordinateXYMJsDefault.default)();
            else if (dimension === 4 && measures === 1) return new (0, _coordinateXYZMJsDefault.default)();
            return new (0, _coordinateJsDefault.default)();
        }
    }
    static dimension(coordinate) {
        if (coordinate instanceof (0, _coordinateXYJsDefault.default)) return 2;
        else if (coordinate instanceof (0, _coordinateXYMJsDefault.default)) return 3;
        else if (coordinate instanceof (0, _coordinateXYZMJsDefault.default)) return 4;
        else if (coordinate instanceof (0, _coordinateJsDefault.default)) return 3;
        return 3;
    }
}
exports.default = Coordinates;

},{"./CoordinateXY.js":"fS8cy","./Coordinate.js":"ii2fh","./CoordinateXYM.js":"jc6F0","./CoordinateXYZM.js":"b2wgN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fS8cy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class CoordinateXY extends (0, _coordinateJsDefault.default) {
    constructor(){
        super();
        CoordinateXY.constructor_.apply(this, arguments);
    }
    static constructor_() {
        if (arguments.length === 0) (0, _coordinateJsDefault.default).constructor_.call(this);
        else if (arguments.length === 1) {
            if (arguments[0] instanceof CoordinateXY) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord.x, coord.y);
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord.x, coord.y);
            }
        } else if (arguments.length === 2) {
            const x = arguments[0], y = arguments[1];
            (0, _coordinateJsDefault.default).constructor_.call(this, x, y, (0, _coordinateJsDefault.default).NULL_ORDINATE);
        }
    }
    setOrdinate(ordinateIndex, value) {
        switch(ordinateIndex){
            case CoordinateXY.X:
                this.x = value;
                break;
            case CoordinateXY.Y:
                this.y = value;
                break;
            default:
                throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
        }
    }
    setZ(z) {
        throw new (0, _illegalArgumentExceptionJsDefault.default)('CoordinateXY dimension 2 does not support z-ordinate');
    }
    copy() {
        return new CoordinateXY(this);
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ')';
    }
    setCoordinate(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.getZ();
    }
    getZ() {
        return (0, _coordinateJsDefault.default).NULL_ORDINATE;
    }
    getOrdinate(ordinateIndex) {
        switch(ordinateIndex){
            case CoordinateXY.X:
                return this.x;
            case CoordinateXY.Y:
                return this.y;
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
    }
}
exports.default = CoordinateXY;
CoordinateXY.X = 0;
CoordinateXY.Y = 1;
CoordinateXY.Z = -1;
CoordinateXY.M = -1;

},{"./Coordinate.js":"ii2fh","../../../../java/lang/IllegalArgumentException.js":"9ppVW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jc6F0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class CoordinateXYM extends (0, _coordinateJsDefault.default) {
    constructor(){
        super();
        CoordinateXYM.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._m = null;
        if (arguments.length === 0) {
            (0, _coordinateJsDefault.default).constructor_.call(this);
            this._m = 0.0;
        } else if (arguments.length === 1) {
            if (arguments[0] instanceof CoordinateXYM) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord.x, coord.y);
                this._m = coord._m;
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord.x, coord.y);
                this._m = this.getM();
            }
        } else if (arguments.length === 3) {
            const x = arguments[0], y = arguments[1], m = arguments[2];
            (0, _coordinateJsDefault.default).constructor_.call(this, x, y, (0, _coordinateJsDefault.default).NULL_ORDINATE);
            this._m = m;
        }
    }
    setM(m) {
        this._m = m;
    }
    setZ(z) {
        throw new (0, _illegalArgumentExceptionJsDefault.default)('CoordinateXY dimension 2 does not support z-ordinate');
    }
    copy() {
        return new CoordinateXYM(this);
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ' m=' + this.getM() + ')';
    }
    setCoordinate(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.getZ();
        this._m = other.getM();
    }
    getM() {
        return this._m;
    }
    setOrdinate(ordinateIndex, value) {
        switch(ordinateIndex){
            case CoordinateXYM.X:
                this.x = value;
                break;
            case CoordinateXYM.Y:
                this.y = value;
                break;
            case CoordinateXYM.M:
                this._m = value;
                break;
            default:
                throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
        }
    }
    getZ() {
        return (0, _coordinateJsDefault.default).NULL_ORDINATE;
    }
    getOrdinate(ordinateIndex) {
        switch(ordinateIndex){
            case CoordinateXYM.X:
                return this.x;
            case CoordinateXYM.Y:
                return this.y;
            case CoordinateXYM.M:
                return this._m;
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
    }
}
exports.default = CoordinateXYM;
CoordinateXYM.X = 0;
CoordinateXYM.Y = 1;
CoordinateXYM.Z = -1;
CoordinateXYM.M = 2;

},{"./Coordinate.js":"ii2fh","../../../../java/lang/IllegalArgumentException.js":"9ppVW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b2wgN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class CoordinateXYZM extends (0, _coordinateJsDefault.default) {
    constructor(){
        super();
        CoordinateXYZM.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._m = null;
        if (arguments.length === 0) {
            (0, _coordinateJsDefault.default).constructor_.call(this);
            this._m = 0.0;
        } else if (arguments.length === 1) {
            if (arguments[0] instanceof CoordinateXYZM) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord);
                this._m = coord._m;
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord);
                this._m = this.getM();
            }
        } else if (arguments.length === 4) {
            const x = arguments[0], y = arguments[1], z = arguments[2], m = arguments[3];
            (0, _coordinateJsDefault.default).constructor_.call(this, x, y, z);
            this._m = m;
        }
    }
    setM(m) {
        this._m = m;
    }
    getOrdinate(ordinateIndex) {
        switch(ordinateIndex){
            case (0, _coordinateJsDefault.default).X:
                return this.x;
            case (0, _coordinateJsDefault.default).Y:
                return this.y;
            case (0, _coordinateJsDefault.default).Z:
                return this.getZ();
            case (0, _coordinateJsDefault.default).M:
                return this.getM();
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
    }
    copy() {
        return new CoordinateXYZM(this);
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ' m=' + this.getM() + ')';
    }
    setCoordinate(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.getZ();
        this._m = other.getM();
    }
    getM() {
        return this._m;
    }
    setOrdinate(ordinateIndex, value) {
        switch(ordinateIndex){
            case (0, _coordinateJsDefault.default).X:
                this.x = value;
                break;
            case (0, _coordinateJsDefault.default).Y:
                this.y = value;
                break;
            case (0, _coordinateJsDefault.default).Z:
                this.z = value;
                break;
            case (0, _coordinateJsDefault.default).M:
                this._m = value;
                break;
            default:
                throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
        }
    }
}
exports.default = CoordinateXYZM;

},{"./Coordinate.js":"ii2fh","../../../../java/lang/IllegalArgumentException.js":"9ppVW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"432sT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
class MathUtil {
    static log10(x) {
        const ln = Math.log(x);
        if ((0, _doubleJsDefault.default).isInfinite(ln)) return ln;
        if ((0, _doubleJsDefault.default).isNaN(ln)) return ln;
        return ln / MathUtil.LOG_10;
    }
    static min(v1, v2, v3, v4) {
        let min = v1;
        if (v2 < min) min = v2;
        if (v3 < min) min = v3;
        if (v4 < min) min = v4;
        return min;
    }
    static clamp() {
        if (typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            const x = arguments[0], min = arguments[1], max = arguments[2];
            if (x < min) return min;
            if (x > max) return max;
            return x;
        } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            const x = arguments[0], min = arguments[1], max = arguments[2];
            if (x < min) return min;
            if (x > max) return max;
            return x;
        }
    }
    static average(x1, x2) {
        return (x1 + x2) / 2.0;
    }
    static wrap(index, max) {
        if (index < 0) return max - -index % max;
        return index % max;
    }
    static max() {
        if (arguments.length === 3) {
            const v1 = arguments[0], v2 = arguments[1], v3 = arguments[2];
            let max = v1;
            if (v2 > max) max = v2;
            if (v3 > max) max = v3;
            return max;
        } else if (arguments.length === 4) {
            const v1 = arguments[0], v2 = arguments[1], v3 = arguments[2], v4 = arguments[3];
            let max = v1;
            if (v2 > max) max = v2;
            if (v3 > max) max = v3;
            if (v4 > max) max = v4;
            return max;
        }
    }
}
exports.default = MathUtil;
MathUtil.LOG_10 = Math.log(10);

},{"../../../../java/lang/Double.js":"clUxd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dYmTx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class System {
    static arraycopy(src, srcPos, dest, destPos, len) {
        let c = 0;
        for(let i = srcPos; i < srcPos + len; i++){
            dest[destPos + c] = src[i];
            c++;
        }
    }
    static getProperty(name) {
        return ({
            'line.separator': '\n'
        })[name];
    }
}
exports.default = System;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h2zeM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
class Envelope {
    constructor(){
        Envelope.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._minx = null;
        this._maxx = null;
        this._miny = null;
        this._maxy = null;
        if (arguments.length === 0) this.init();
        else if (arguments.length === 1) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                this.init(p.x, p.x, p.y, p.y);
            } else if (arguments[0] instanceof Envelope) {
                const env = arguments[0];
                this.init(env);
            }
        } else if (arguments.length === 2) {
            const p1 = arguments[0], p2 = arguments[1];
            this.init(p1.x, p2.x, p1.y, p2.y);
        } else if (arguments.length === 4) {
            const x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];
            this.init(x1, x2, y1, y2);
        }
    }
    static intersects() {
        if (arguments.length === 3) {
            const p1 = arguments[0], p2 = arguments[1], q = arguments[2];
            if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y)) return true;
            return false;
        } else if (arguments.length === 4) {
            const p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];
            let minq = Math.min(q1.x, q2.x);
            let maxq = Math.max(q1.x, q2.x);
            let minp = Math.min(p1.x, p2.x);
            let maxp = Math.max(p1.x, p2.x);
            if (minp > maxq) return false;
            if (maxp < minq) return false;
            minq = Math.min(q1.y, q2.y);
            maxq = Math.max(q1.y, q2.y);
            minp = Math.min(p1.y, p2.y);
            maxp = Math.max(p1.y, p2.y);
            if (minp > maxq) return false;
            if (maxp < minq) return false;
            return true;
        }
    }
    getArea() {
        return this.getWidth() * this.getHeight();
    }
    getMinX() {
        return this._minx;
    }
    expandToInclude() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                this.expandToInclude(p.x, p.y);
            } else if (arguments[0] instanceof Envelope) {
                const other = arguments[0];
                if (other.isNull()) return null;
                if (this.isNull()) {
                    this._minx = other.getMinX();
                    this._maxx = other.getMaxX();
                    this._miny = other.getMinY();
                    this._maxy = other.getMaxY();
                } else {
                    if (other._minx < this._minx) this._minx = other._minx;
                    if (other._maxx > this._maxx) this._maxx = other._maxx;
                    if (other._miny < this._miny) this._miny = other._miny;
                    if (other._maxy > this._maxy) this._maxy = other._maxy;
                }
            }
        } else if (arguments.length === 2) {
            const x = arguments[0], y = arguments[1];
            if (this.isNull()) {
                this._minx = x;
                this._maxx = x;
                this._miny = y;
                this._maxy = y;
            } else {
                if (x < this._minx) this._minx = x;
                if (x > this._maxx) this._maxx = x;
                if (y < this._miny) this._miny = y;
                if (y > this._maxy) this._maxy = y;
            }
        }
    }
    compareTo(o) {
        const env = o;
        if (this.isNull()) {
            if (env.isNull()) return 0;
            return -1;
        } else {
            if (env.isNull()) return 1;
        }
        if (this._minx < env._minx) return -1;
        if (this._minx > env._minx) return 1;
        if (this._miny < env._miny) return -1;
        if (this._miny > env._miny) return 1;
        if (this._maxx < env._maxx) return -1;
        if (this._maxx > env._maxx) return 1;
        if (this._maxy < env._maxy) return -1;
        if (this._maxy > env._maxy) return 1;
        return 0;
    }
    translate(transX, transY) {
        if (this.isNull()) return null;
        this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
    }
    copy() {
        return new Envelope(this);
    }
    expandBy() {
        if (arguments.length === 1) {
            const distance = arguments[0];
            this.expandBy(distance, distance);
        } else if (arguments.length === 2) {
            const deltaX = arguments[0], deltaY = arguments[1];
            if (this.isNull()) return null;
            this._minx -= deltaX;
            this._maxx += deltaX;
            this._miny -= deltaY;
            this._maxy += deltaY;
            if (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();
        }
    }
    contains() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Envelope) {
                const other = arguments[0];
                return this.covers(other);
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                return this.covers(p);
            }
        } else if (arguments.length === 2) {
            const x = arguments[0], y = arguments[1];
            return this.covers(x, y);
        }
    }
    hashCode() {
        let result = 17;
        result = 37 * result + (0, _coordinateJsDefault.default).hashCode(this._minx);
        result = 37 * result + (0, _coordinateJsDefault.default).hashCode(this._maxx);
        result = 37 * result + (0, _coordinateJsDefault.default).hashCode(this._miny);
        result = 37 * result + (0, _coordinateJsDefault.default).hashCode(this._maxy);
        return result;
    }
    equals(other) {
        if (!(other instanceof Envelope)) return false;
        const otherEnvelope = other;
        if (this.isNull()) return otherEnvelope.isNull();
        return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();
    }
    intersection(env) {
        if (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();
        const intMinX = this._minx > env._minx ? this._minx : env._minx;
        const intMinY = this._miny > env._miny ? this._miny : env._miny;
        const intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
        const intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
        return new Envelope(intMinX, intMaxX, intMinY, intMaxY);
    }
    isNull() {
        return this._maxx < this._minx;
    }
    getMaxX() {
        return this._maxx;
    }
    covers() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                return this.covers(p.x, p.y);
            } else if (arguments[0] instanceof Envelope) {
                const other = arguments[0];
                if (this.isNull() || other.isNull()) return false;
                return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;
            }
        } else if (arguments.length === 2) {
            const x = arguments[0], y = arguments[1];
            if (this.isNull()) return false;
            return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;
        }
    }
    intersects() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Envelope) {
                const other = arguments[0];
                if (this.isNull() || other.isNull()) return false;
                return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                return this.intersects(p.x, p.y);
            }
        } else if (arguments.length === 2) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
                const a = arguments[0], b = arguments[1];
                if (this.isNull()) return false;
                const envminx = a.x < b.x ? a.x : b.x;
                if (envminx > this._maxx) return false;
                const envmaxx = a.x > b.x ? a.x : b.x;
                if (envmaxx < this._minx) return false;
                const envminy = a.y < b.y ? a.y : b.y;
                if (envminy > this._maxy) return false;
                const envmaxy = a.y > b.y ? a.y : b.y;
                if (envmaxy < this._miny) return false;
                return true;
            } else if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
                const x = arguments[0], y = arguments[1];
                if (this.isNull()) return false;
                return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);
            }
        }
    }
    getMinY() {
        return this._miny;
    }
    getDiameter() {
        if (this.isNull()) return 0;
        const w = this.getWidth();
        const h = this.getHeight();
        return Math.sqrt(w * w + h * h);
    }
    minExtent() {
        if (this.isNull()) return 0.0;
        const w = this.getWidth();
        const h = this.getHeight();
        if (w < h) return w;
        return h;
    }
    getWidth() {
        if (this.isNull()) return 0;
        return this._maxx - this._minx;
    }
    toString() {
        return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']';
    }
    setToNull() {
        this._minx = 0;
        this._maxx = -1;
        this._miny = 0;
        this._maxy = -1;
    }
    disjoint(other) {
        if (this.isNull() || other.isNull()) return true;
        return other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny;
    }
    getHeight() {
        if (this.isNull()) return 0;
        return this._maxy - this._miny;
    }
    maxExtent() {
        if (this.isNull()) return 0.0;
        const w = this.getWidth();
        const h = this.getHeight();
        if (w > h) return w;
        return h;
    }
    centre() {
        if (this.isNull()) return null;
        return new (0, _coordinateJsDefault.default)((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);
    }
    init() {
        if (arguments.length === 0) this.setToNull();
        else if (arguments.length === 1) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                this.init(p.x, p.x, p.y, p.y);
            } else if (arguments[0] instanceof Envelope) {
                const env = arguments[0];
                this._minx = env._minx;
                this._maxx = env._maxx;
                this._miny = env._miny;
                this._maxy = env._maxy;
            }
        } else if (arguments.length === 2) {
            const p1 = arguments[0], p2 = arguments[1];
            this.init(p1.x, p2.x, p1.y, p2.y);
        } else if (arguments.length === 4) {
            const x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];
            if (x1 < x2) {
                this._minx = x1;
                this._maxx = x2;
            } else {
                this._minx = x2;
                this._maxx = x1;
            }
            if (y1 < y2) {
                this._miny = y1;
                this._maxy = y2;
            } else {
                this._miny = y2;
                this._maxy = y1;
            }
        }
    }
    getMaxY() {
        return this._maxy;
    }
    distance(env) {
        if (this.intersects(env)) return 0;
        let dx = 0.0;
        if (this._maxx < env._minx) dx = env._minx - this._maxx;
        else if (this._minx > env._maxx) dx = this._minx - env._maxx;
        let dy = 0.0;
        if (this._maxy < env._miny) dy = env._miny - this._maxy;
        else if (this._miny > env._maxy) dy = this._miny - env._maxy;
        if (dx === 0.0) return dy;
        if (dy === 0.0) return dx;
        return Math.sqrt(dx * dx + dy * dy);
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = Envelope;

},{"./Coordinate.js":"ii2fh","../../../../java/lang/Comparable.js":"WFeEu","../../../../java/io/Serializable.js":"5sRbw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kWqD0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _characterJs = require("../../../../java/lang/Character.js");
var _characterJsDefault = parcelHelpers.interopDefault(_characterJs);
class Dimension {
    static toDimensionSymbol(dimensionValue) {
        switch(dimensionValue){
            case Dimension.FALSE:
                return Dimension.SYM_FALSE;
            case Dimension.TRUE:
                return Dimension.SYM_TRUE;
            case Dimension.DONTCARE:
                return Dimension.SYM_DONTCARE;
            case Dimension.P:
                return Dimension.SYM_P;
            case Dimension.L:
                return Dimension.SYM_L;
            case Dimension.A:
                return Dimension.SYM_A;
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Unknown dimension value: ' + dimensionValue);
    }
    static toDimensionValue(dimensionSymbol) {
        switch((0, _characterJsDefault.default).toUpperCase(dimensionSymbol)){
            case Dimension.SYM_FALSE:
                return Dimension.FALSE;
            case Dimension.SYM_TRUE:
                return Dimension.TRUE;
            case Dimension.SYM_DONTCARE:
                return Dimension.DONTCARE;
            case Dimension.SYM_P:
                return Dimension.P;
            case Dimension.SYM_L:
                return Dimension.L;
            case Dimension.SYM_A:
                return Dimension.A;
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Unknown dimension symbol: ' + dimensionSymbol);
    }
}
exports.default = Dimension;
Dimension.P = 0;
Dimension.L = 1;
Dimension.A = 2;
Dimension.FALSE = -1;
Dimension.TRUE = -2;
Dimension.DONTCARE = -3;
Dimension.SYM_FALSE = 'F';
Dimension.SYM_TRUE = 'T';
Dimension.SYM_DONTCARE = '*';
Dimension.SYM_P = '0';
Dimension.SYM_L = '1';
Dimension.SYM_A = '2';

},{"../../../../java/lang/IllegalArgumentException.js":"9ppVW","../../../../java/lang/Character.js":"8KnaG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8KnaG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Character {
    static isWhitespace(c) {
        return c <= 32 && c >= 0 || c === 127;
    }
    static toUpperCase(c) {
        return c.toUpperCase();
    }
}
exports.default = Character;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9DSzO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _geometryComponentFilterJs = require("./GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _cloneableJs = require("../../../../java/lang/Cloneable.js");
var _cloneableJsDefault = parcelHelpers.interopDefault(_cloneableJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _envelopeJs = require("./Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class Geometry {
    constructor(){
        Geometry.constructor_.apply(this, arguments);
    }
    isGeometryCollection() {
        return this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION;
    }
    getFactory() {
        return this._factory;
    }
    getGeometryN(n) {
        return this;
    }
    getArea() {
        return 0.0;
    }
    isRectangle() {
        return false;
    }
    equalsExact(other) {
        return this === other || this.equalsExact(other, 0);
    }
    geometryChanged() {
        this.apply(Geometry.geometryChangedFilter);
    }
    geometryChangedAction() {
        this._envelope = null;
    }
    equalsNorm(g) {
        if (g === null) return false;
        return this.norm().equalsExact(g.norm());
    }
    getLength() {
        return 0.0;
    }
    getNumGeometries() {
        return 1;
    }
    compareTo() {
        let other;
        if (arguments.length === 1) {
            const o = arguments[0];
            other = o;
            if (this.getTypeCode() !== other.getTypeCode()) return this.getTypeCode() - other.getTypeCode();
            if (this.isEmpty() && other.isEmpty()) return 0;
            if (this.isEmpty()) return -1;
            if (other.isEmpty()) return 1;
            return this.compareToSameClass(o);
        } else if (arguments.length === 2) {
            const o = arguments[0];
            const comp = arguments[1];
            other = o;
            if (this.getTypeCode() !== other.getTypeCode()) return this.getTypeCode() - other.getTypeCode();
            if (this.isEmpty() && other.isEmpty()) return 0;
            if (this.isEmpty()) return -1;
            if (other.isEmpty()) return 1;
            return this.compareToSameClass(o, comp);
        }
    }
    getUserData() {
        return this._userData;
    }
    getSRID() {
        return this._SRID;
    }
    getEnvelope() {
        return this.getFactory().toGeometry(this.getEnvelopeInternal());
    }
    static checkNotGeometryCollection(g) {
        if (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) throw new (0, _illegalArgumentExceptionJsDefault.default)('This method does not support GeometryCollection arguments');
    }
    equal(a, b, tolerance) {
        if (tolerance === 0) return a.equals(b);
        return a.distance(b) <= tolerance;
    }
    norm() {
        const copy = this.copy();
        copy.normalize();
        return copy;
    }
    reverse() {
        const res = this.reverseInternal();
        if (this.envelope != null) res.envelope = this.envelope.copy();
        res.setSRID(this.getSRID());
        return res;
    }
    copy() {
        const copy = this.copyInternal();
        copy.envelope = this._envelope == null ? null : this._envelope.copy();
        copy._SRID = this._SRID;
        copy._userData = this._userData;
        return copy;
    }
    getPrecisionModel() {
        return this._factory.getPrecisionModel();
    }
    getEnvelopeInternal() {
        if (this._envelope === null) this._envelope = this.computeEnvelopeInternal();
        return new (0, _envelopeJsDefault.default)(this._envelope);
    }
    setSRID(SRID) {
        this._SRID = SRID;
    }
    setUserData(userData) {
        this._userData = userData;
    }
    compare(a, b) {
        const i = a.iterator();
        const j = b.iterator();
        while(i.hasNext() && j.hasNext()){
            const aElement = i.next();
            const bElement = j.next();
            const comparison = aElement.compareTo(bElement);
            if (comparison !== 0) return comparison;
        }
        if (i.hasNext()) return 1;
        if (j.hasNext()) return -1;
        return 0;
    }
    hashCode() {
        return this.getEnvelopeInternal().hashCode();
    }
    isEquivalentClass(other) {
        return this.getTypeCode() == other.getTypeCode();
    }
    get interfaces_() {
        return [
            (0, _cloneableJsDefault.default),
            (0, _comparableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
    getClass() {
        return Geometry;
    }
    static hasNonEmptyElements(geometries) {
        for(let i = 0; i < geometries.length; i++)if (!geometries[i].isEmpty()) return true;
        return false;
    }
    static hasNullElements(array) {
        for(let i = 0; i < array.length; i++)if (array[i] === null) return true;
        return false;
    }
}
exports.default = Geometry;
Geometry.constructor_ = function(factory) {
    if (!factory) return;
    this._envelope = null;
    this._userData = null;
    this._factory = factory;
    this._SRID = factory.getSRID();
};
Geometry.TYPECODE_POINT = 0;
Geometry.TYPECODE_MULTIPOINT = 1;
Geometry.TYPECODE_LINESTRING = 2;
Geometry.TYPECODE_LINEARRING = 3;
Geometry.TYPECODE_MULTILINESTRING = 4;
Geometry.TYPECODE_POLYGON = 5;
Geometry.TYPECODE_MULTIPOLYGON = 6;
Geometry.TYPECODE_GEOMETRYCOLLECTION = 7;
Geometry.TYPENAME_POINT = 'Point';
Geometry.TYPENAME_MULTIPOINT = 'MultiPoint';
Geometry.TYPENAME_LINESTRING = 'LineString';
Geometry.TYPENAME_LINEARRING = 'LinearRing';
Geometry.TYPENAME_MULTILINESTRING = 'MultiLineString';
Geometry.TYPENAME_POLYGON = 'Polygon';
Geometry.TYPENAME_MULTIPOLYGON = 'MultiPolygon';
Geometry.TYPENAME_GEOMETRYCOLLECTION = 'GeometryCollection';
Geometry.geometryChangedFilter = {
    get interfaces_ () {
        return [
            (0, _geometryComponentFilterJsDefault.default)
        ];
    },
    filter (geom) {
        geom.geometryChangedAction();
    }
};

},{"../../../../java/lang/IllegalArgumentException.js":"9ppVW","./GeometryComponentFilter.js":"lqE9C","../../../../java/lang/Comparable.js":"WFeEu","../../../../java/lang/Cloneable.js":"kAAzr","../../../../java/io/Serializable.js":"5sRbw","./Envelope.js":"h2zeM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cr8Rt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class CoordinateFilter {
    filter(coord) {}
}
exports.default = CoordinateFilter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"51JJJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Lineal {
}
exports.default = Lineal;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iGxeo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _coordinateSequenceJs = require("./CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
class CoordinateSequences {
    static scroll() {
        if (arguments.length === 2) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default)) && Number.isInteger(arguments[1])) {
                const seq = arguments[0], indexOfFirstCoordinate = arguments[1];
                CoordinateSequences.scroll(seq, indexOfFirstCoordinate, CoordinateSequences.isRing(seq));
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default)) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
                const seq = arguments[0], firstCoordinate = arguments[1];
                const i = CoordinateSequences.indexOf(firstCoordinate, seq);
                if (i <= 0) return null;
                CoordinateSequences.scroll(seq, i);
            }
        } else if (arguments.length === 3) {
            const seq = arguments[0], indexOfFirstCoordinate = arguments[1], ensureRing = arguments[2];
            const i = indexOfFirstCoordinate;
            if (i <= 0) return null;
            const copy = seq.copy();
            const last = ensureRing ? seq.size() - 1 : seq.size();
            for(let j = 0; j < last; j++)for(let k = 0; k < seq.getDimension(); k++)seq.setOrdinate(j, k, copy.getOrdinate((indexOfFirstCoordinate + j) % last, k));
            if (ensureRing) for(let k = 0; k < seq.getDimension(); k++)seq.setOrdinate(last, k, seq.getOrdinate(0, k));
        }
    }
    static isEqual(cs1, cs2) {
        const cs1Size = cs1.size();
        const cs2Size = cs2.size();
        if (cs1Size !== cs2Size) return false;
        const dim = Math.min(cs1.getDimension(), cs2.getDimension());
        for(let i = 0; i < cs1Size; i++)for(let d = 0; d < dim; d++){
            const v1 = cs1.getOrdinate(i, d);
            const v2 = cs2.getOrdinate(i, d);
            if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;
            if ((0, _doubleJsDefault.default).isNaN(v1) && (0, _doubleJsDefault.default).isNaN(v2)) continue;
            return false;
        }
        return true;
    }
    static minCoordinateIndex() {
        if (arguments.length === 1) {
            const seq = arguments[0];
            return CoordinateSequences.minCoordinateIndex(seq, 0, seq.size() - 1);
        } else if (arguments.length === 3) {
            const seq = arguments[0], from = arguments[1], to = arguments[2];
            let minCoordIndex = -1;
            let minCoord = null;
            for(let i = from; i <= to; i++){
                const testCoord = seq.getCoordinate(i);
                if (minCoord === null || minCoord.compareTo(testCoord) > 0) {
                    minCoord = testCoord;
                    minCoordIndex = i;
                }
            }
            return minCoordIndex;
        }
    }
    static extend(fact, seq, size) {
        const newseq = fact.create(size, seq.getDimension());
        const n = seq.size();
        CoordinateSequences.copy(seq, 0, newseq, 0, n);
        if (n > 0) for(let i = n; i < size; i++)CoordinateSequences.copy(seq, n - 1, newseq, i, 1);
        return newseq;
    }
    static reverse(seq) {
        const last = seq.size() - 1;
        const mid = Math.trunc(last / 2);
        for(let i = 0; i <= mid; i++)CoordinateSequences.swap(seq, i, last - i);
    }
    static ensureValidRing(fact, seq) {
        const n = seq.size();
        if (n === 0) return seq;
        if (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);
        const isClosed = seq.getOrdinate(0, (0, _coordinateSequenceJsDefault.default).X) === seq.getOrdinate(n - 1, (0, _coordinateSequenceJsDefault.default).X) && seq.getOrdinate(0, (0, _coordinateSequenceJsDefault.default).Y) === seq.getOrdinate(n - 1, (0, _coordinateSequenceJsDefault.default).Y);
        if (isClosed) return seq;
        return CoordinateSequences.createClosedRing(fact, seq, n + 1);
    }
    static minCoordinate(seq) {
        let minCoord = null;
        for(let i = 0; i < seq.size(); i++){
            const testCoord = seq.getCoordinate(i);
            if (minCoord === null || minCoord.compareTo(testCoord) > 0) minCoord = testCoord;
        }
        return minCoord;
    }
    static copyCoord(src, srcPos, dest, destPos) {
        const minDim = Math.min(src.getDimension(), dest.getDimension());
        for(let dim = 0; dim < minDim; dim++)dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
    }
    static isRing(seq) {
        const n = seq.size();
        if (n === 0) return true;
        if (n <= 3) return false;
        return seq.getOrdinate(0, (0, _coordinateSequenceJsDefault.default).X) === seq.getOrdinate(n - 1, (0, _coordinateSequenceJsDefault.default).X) && seq.getOrdinate(0, (0, _coordinateSequenceJsDefault.default).Y) === seq.getOrdinate(n - 1, (0, _coordinateSequenceJsDefault.default).Y);
    }
    static swap(seq, i, j) {
        if (i === j) return null;
        for(let dim = 0; dim < seq.getDimension(); dim++){
            const tmp = seq.getOrdinate(i, dim);
            seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
            seq.setOrdinate(j, dim, tmp);
        }
    }
    static copy(src, srcPos, dest, destPos, length) {
        for(let i = 0; i < length; i++)CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
    }
    static indexOf(coordinate, seq) {
        for(let i = 0; i < seq.size(); i++)if (coordinate.x === seq.getOrdinate(i, (0, _coordinateSequenceJsDefault.default).X) && coordinate.y === seq.getOrdinate(i, (0, _coordinateSequenceJsDefault.default).Y)) return i;
        return -1;
    }
    static createClosedRing(fact, seq, size) {
        const newseq = fact.create(size, seq.getDimension());
        const n = seq.size();
        CoordinateSequences.copy(seq, 0, newseq, 0, n);
        for(let i = n; i < size; i++)CoordinateSequences.copy(seq, 0, newseq, i, 1);
        return newseq;
    }
}
exports.default = CoordinateSequences;

},{"../../../../hasInterface.js":"5bpze","./Coordinate.js":"ii2fh","../../../../java/lang/Double.js":"clUxd","./CoordinateSequence.js":"aDXS8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aDXS8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _cloneableJs = require("../../../../java/lang/Cloneable.js");
var _cloneableJsDefault = parcelHelpers.interopDefault(_cloneableJs);
class CoordinateSequence {
    getCoordinate() {
        if (arguments.length === 1) {
            const i = arguments[0];
        } else if (arguments.length === 2) {
            const index = arguments[0], coord = arguments[1];
        }
    }
    getCoordinateCopy(i) {}
    createCoordinate() {}
    getDimension() {}
    hasM() {
        return this.getMeasures() > 0;
    }
    getX(index) {}
    hasZ() {
        return this.getDimension() - this.getMeasures() > 2;
    }
    getMeasures() {
        return 0;
    }
    expandEnvelope(env) {}
    copy() {}
    getY(index) {}
    toCoordinateArray() {}
    getM(index) {
        if (this.hasM()) {
            const mIndex = this.getDimension() - this.getMeasures();
            return this.getOrdinate(index, mIndex);
        } else return (0, _doubleJsDefault.default).NaN;
    }
    setOrdinate(index, ordinateIndex, value) {}
    getZ(index) {
        if (this.hasZ()) return this.getOrdinate(index, 2);
        else return (0, _doubleJsDefault.default).NaN;
    }
    size() {}
    getOrdinate(index, ordinateIndex) {}
    get interfaces_() {
        return [
            (0, _cloneableJsDefault.default)
        ];
    }
}
exports.default = CoordinateSequence;
CoordinateSequence.X = 0;
CoordinateSequence.Y = 1;
CoordinateSequence.Z = 2;
CoordinateSequence.M = 3;

},{"../../../../java/lang/Double.js":"clUxd","../../../../java/lang/Cloneable.js":"kAAzr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fZPJo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class GeometryFilter {
    filter(geom) {}
}
exports.default = GeometryFilter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8MSah":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class CoordinateSequenceFilter {
    filter(seq, i) {}
    isGeometryChanged() {}
    isDone() {}
}
exports.default = CoordinateSequenceFilter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dgF5W":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateSequenceFactoryJs = require("../CoordinateSequenceFactory.js");
var _coordinateSequenceFactoryJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFactoryJs);
var _coordinateSequenceJs = require("../CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateArraySequenceJs = require("./CoordinateArraySequence.js");
var _coordinateArraySequenceJsDefault = parcelHelpers.interopDefault(_coordinateArraySequenceJs);
class CoordinateArraySequenceFactory {
    static instance() {
        return CoordinateArraySequenceFactory.instanceObject;
    }
    readResolve() {
        return CoordinateArraySequenceFactory.instance();
    }
    create() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const coordinates = arguments[0];
                return new (0, _coordinateArraySequenceJsDefault.default)(coordinates);
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordSeq = arguments[0];
                return new (0, _coordinateArraySequenceJsDefault.default)(coordSeq);
            }
        } else if (arguments.length === 2) {
            let size = arguments[0], dimension = arguments[1];
            if (dimension > 3) dimension = 3;
            if (dimension < 2) dimension = 2;
            return new (0, _coordinateArraySequenceJsDefault.default)(size, dimension);
        } else if (arguments.length === 3) {
            let size = arguments[0], dimension = arguments[1], measures = arguments[2];
            let spatial = dimension - measures;
            if (measures > 1) measures = 1;
            if (spatial > 3) spatial = 3;
            if (spatial < 2) spatial = 2;
            return new (0, _coordinateArraySequenceJsDefault.default)(size, spatial + measures, measures);
        }
    }
    get interfaces_() {
        return [
            (0, _coordinateSequenceFactoryJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = CoordinateArraySequenceFactory;
CoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();

},{"../CoordinateSequenceFactory.js":"gg8AJ","../CoordinateSequence.js":"aDXS8","../../../../../java/io/Serializable.js":"5sRbw","../../../../../hasInterface.js":"5bpze","./CoordinateArraySequence.js":"grBJo","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gg8AJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateSequenceJs = require("./CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
class CoordinateSequenceFactory {
    create() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const coordinates = arguments[0];
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordSeq = arguments[0];
            }
        } else if (arguments.length === 2) {
            const size = arguments[0], dimension = arguments[1];
        } else if (arguments.length === 3) {
            const size = arguments[0], dimension = arguments[1], measures = arguments[2];
            return this.create(size, dimension);
        }
    }
}
exports.default = CoordinateSequenceFactory;

},{"../../../../hasInterface.js":"5bpze","./CoordinateSequence.js":"aDXS8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"grBJo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("../Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _coordinatesJs = require("../Coordinates.js");
var _coordinatesJsDefault = parcelHelpers.interopDefault(_coordinatesJs);
var _coordinateSequenceJs = require("../CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
var _coordinateArraysJs = require("../CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _stringBuilderJs = require("../../../../../java/lang/StringBuilder.js");
var _stringBuilderJsDefault = parcelHelpers.interopDefault(_stringBuilderJs);
class CoordinateArraySequence {
    constructor(){
        CoordinateArraySequence.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._dimension = 3;
        this._measures = 0;
        this._coordinates = null;
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const coordinates = arguments[0];
                CoordinateArraySequence.constructor_.call(this, coordinates, (0, _coordinateArraysJsDefault.default).dimension(coordinates), (0, _coordinateArraysJsDefault.default).measures(coordinates));
            } else if (Number.isInteger(arguments[0])) {
                const size = arguments[0];
                this._coordinates = new Array(size).fill(null);
                for(let i = 0; i < size; i++)this._coordinates[i] = new (0, _coordinateJsDefault.default)();
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordSeq = arguments[0];
                if (coordSeq === null) {
                    this._coordinates = new Array(0).fill(null);
                    return null;
                }
                this._dimension = coordSeq.getDimension();
                this._measures = coordSeq.getMeasures();
                this._coordinates = new Array(coordSeq.size()).fill(null);
                for(let i = 0; i < this._coordinates.length; i++)this._coordinates[i] = coordSeq.getCoordinateCopy(i);
            }
        } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                const coordinates = arguments[0], dimension = arguments[1];
                CoordinateArraySequence.constructor_.call(this, coordinates, dimension, (0, _coordinateArraysJsDefault.default).measures(coordinates));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                const size = arguments[0], dimension = arguments[1];
                this._coordinates = new Array(size).fill(null);
                this._dimension = dimension;
                for(let i = 0; i < size; i++)this._coordinates[i] = (0, _coordinatesJsDefault.default).create(dimension);
            }
        } else if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                const coordinates = arguments[0], dimension = arguments[1], measures = arguments[2];
                this._dimension = dimension;
                this._measures = measures;
                if (coordinates === null) this._coordinates = new Array(0).fill(null);
                else this._coordinates = coordinates;
            } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                const size = arguments[0], dimension = arguments[1], measures = arguments[2];
                this._coordinates = new Array(size).fill(null);
                this._dimension = dimension;
                this._measures = measures;
                for(let i = 0; i < size; i++)this._coordinates[i] = this.createCoordinate();
            }
        }
    }
    getCoordinate() {
        if (arguments.length === 1) {
            const i = arguments[0];
            return this._coordinates[i];
        } else if (arguments.length === 2) {
            const index = arguments[0], coord = arguments[1];
            coord.setCoordinate(this._coordinates[index]);
        }
    }
    getCoordinateCopy(i) {
        const copy = this.createCoordinate();
        copy.setCoordinate(this._coordinates[i]);
        return copy;
    }
    createCoordinate() {
        return (0, _coordinatesJsDefault.default).create(this.getDimension(), this.getMeasures());
    }
    getDimension() {
        return this._dimension;
    }
    getX(index) {
        return this._coordinates[index].x;
    }
    getMeasures() {
        return this._measures;
    }
    expandEnvelope(env) {
        for(let i = 0; i < this._coordinates.length; i++)env.expandToInclude(this._coordinates[i]);
        return env;
    }
    copy() {
        const cloneCoordinates = new Array(this.size()).fill(null);
        for(let i = 0; i < this._coordinates.length; i++){
            const duplicate = this.createCoordinate();
            duplicate.setCoordinate(this._coordinates[i]);
            cloneCoordinates[i] = duplicate;
        }
        return new CoordinateArraySequence(cloneCoordinates, this._dimension, this._measures);
    }
    toString() {
        if (this._coordinates.length > 0) {
            const strBuilder = new (0, _stringBuilderJsDefault.default)(17 * this._coordinates.length);
            strBuilder.append('(');
            strBuilder.append(this._coordinates[0]);
            for(let i = 1; i < this._coordinates.length; i++){
                strBuilder.append(', ');
                strBuilder.append(this._coordinates[i]);
            }
            strBuilder.append(')');
            return strBuilder.toString();
        } else return '()';
    }
    getY(index) {
        return this._coordinates[index].y;
    }
    toCoordinateArray() {
        return this._coordinates;
    }
    getM(index) {
        if (this.hasM()) return this._coordinates[index].getM();
        else return (0, _doubleJsDefault.default).NaN;
    }
    setOrdinate(index, ordinateIndex, value) {
        switch(ordinateIndex){
            case (0, _coordinateSequenceJsDefault.default).X:
                this._coordinates[index].x = value;
                break;
            case (0, _coordinateSequenceJsDefault.default).Y:
                this._coordinates[index].y = value;
                break;
            default:
                this._coordinates[index].setOrdinate(ordinateIndex, value);
        }
    }
    getZ(index) {
        if (this.hasZ()) return this._coordinates[index].getZ();
        else return (0, _doubleJsDefault.default).NaN;
    }
    size() {
        return this._coordinates.length;
    }
    getOrdinate(index, ordinateIndex) {
        switch(ordinateIndex){
            case (0, _coordinateSequenceJsDefault.default).X:
                return this._coordinates[index].x;
            case (0, _coordinateSequenceJsDefault.default).Y:
                return this._coordinates[index].y;
            default:
                return this._coordinates[index].getOrdinate(ordinateIndex);
        }
    }
    get interfaces_() {
        return [
            (0, _coordinateSequenceJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = CoordinateArraySequence;

},{"../../../../../hasInterface.js":"5bpze","../Coordinate.js":"ii2fh","../../../../../java/lang/Double.js":"clUxd","../Coordinates.js":"58TVg","../CoordinateSequence.js":"aDXS8","../CoordinateArrays.js":"lncg4","../../../../../java/io/Serializable.js":"5sRbw","../../../../../java/lang/StringBuilder.js":"30Zhx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"30Zhx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class StringBuilder {
    constructor(str){
        this.str = str;
    }
    append(e) {
        this.str += e;
    }
    setCharAt(i, c) {
        this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
    }
    toString() {
        return this.str;
    }
}
exports.default = StringBuilder;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6Hrab":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _geometryCollectionJs = require("./GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _polygonalJs = require("./Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class MultiPolygon extends (0, _geometryCollectionJsDefault.default) {
    constructor(){
        super();
        MultiPolygon.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const polygons = arguments[0], factory = arguments[1];
        (0, _geometryCollectionJsDefault.default).constructor_.call(this, polygons, factory);
    }
    copyInternal() {
        const polygons = new Array(this._geometries.length).fill(null);
        for(let i = 0; i < polygons.length; i++)polygons[i] = this._geometries[i].copy();
        return new MultiPolygon(polygons, this._factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            return super.equalsExact.call(this, other, tolerance);
        } else return super.equalsExact.apply(this, arguments);
    }
    getBoundaryDimension() {
        return 1;
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_MULTIPOLYGON;
    }
    getDimension() {
        return 2;
    }
    getBoundary() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        const allRings = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < this._geometries.length; i++){
            const polygon = this._geometries[i];
            const rings = polygon.getBoundary();
            for(let j = 0; j < rings.getNumGeometries(); j++)allRings.add(rings.getGeometryN(j));
        }
        const allRingsArray = new Array(allRings.size()).fill(null);
        return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_MULTIPOLYGON;
    }
    get interfaces_() {
        return [
            (0, _polygonalJsDefault.default)
        ];
    }
}
exports.default = MultiPolygon;

},{"./Geometry.js":"9DSzO","./GeometryCollection.js":"6RJQO","./Polygonal.js":"jIBid","../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6RJQO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _treeSetJs = require("../../../../java/util/TreeSet.js");
var _treeSetJsDefault = parcelHelpers.interopDefault(_treeSetJs);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _geometryComponentFilterJs = require("./GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _arraysJs = require("../../../../java/util/Arrays.js");
var _arraysJsDefault = parcelHelpers.interopDefault(_arraysJs);
var _coordinateFilterJs = require("./CoordinateFilter.js");
var _coordinateFilterJsDefault = parcelHelpers.interopDefault(_coordinateFilterJs);
var _geometryFilterJs = require("./GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
var _coordinateSequenceFilterJs = require("./CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
var _envelopeJs = require("./Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class GeometryCollection extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        GeometryCollection.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geometries = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 2) {
            let geometries = arguments[0], factory = arguments[1];
            (0, _geometryJsDefault.default).constructor_.call(this, factory);
            if (geometries === null) geometries = [];
            if ((0, _geometryJsDefault.default).hasNullElements(geometries)) throw new (0, _illegalArgumentExceptionJsDefault.default)('geometries must not contain null elements');
            this._geometries = geometries;
        }
    }
    computeEnvelopeInternal() {
        const envelope = new (0, _envelopeJsDefault.default)();
        for(let i = 0; i < this._geometries.length; i++)envelope.expandToInclude(this._geometries[i].getEnvelopeInternal());
        return envelope;
    }
    getGeometryN(n) {
        return this._geometries[n];
    }
    getCoordinates() {
        const coordinates = new Array(this.getNumPoints()).fill(null);
        let k = -1;
        for(let i = 0; i < this._geometries.length; i++){
            const childCoordinates = this._geometries[i].getCoordinates();
            for(let j = 0; j < childCoordinates.length; j++){
                k++;
                coordinates[k] = childCoordinates[j];
            }
        }
        return coordinates;
    }
    getArea() {
        let area = 0.0;
        for(let i = 0; i < this._geometries.length; i++)area += this._geometries[i].getArea();
        return area;
    }
    copyInternal() {
        const geometries = new Array(this._geometries.length).fill(null);
        for(let i = 0; i < geometries.length; i++)geometries[i] = this._geometries[i].copy();
        return new GeometryCollection(geometries, this._factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            const otherCollection = other;
            if (this._geometries.length !== otherCollection._geometries.length) return false;
            for(let i = 0; i < this._geometries.length; i++)if (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) return false;
            return true;
        } else return super.equalsExact.apply(this, arguments);
    }
    reverseInternal() {
        const numGeometries = this._geometries.length;
        const reversed = new (0, _arrayListJsDefault.default)(numGeometries);
        for(let i = 0; i < numGeometries; i++)reversed.add(this._geometries[i].reverse());
        return this.getFactory().buildGeometry(reversed);
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_GEOMETRYCOLLECTION;
    }
    getDimension() {
        let dimension = (0, _dimensionJsDefault.default).FALSE;
        for(let i = 0; i < this._geometries.length; i++)dimension = Math.max(dimension, this._geometries[i].getDimension());
        return dimension;
    }
    getNumGeometries() {
        return this._geometries.length;
    }
    getBoundary() {
        (0, _geometryJsDefault.default).checkNotGeometryCollection(this);
        (0, _assertJsDefault.default).shouldNeverReachHere();
        return null;
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_GEOMETRYCOLLECTION;
    }
    isEmpty() {
        for(let i = 0; i < this._geometries.length; i++)if (!this._geometries[i].isEmpty()) return false;
        return true;
    }
    normalize() {
        for(let i = 0; i < this._geometries.length; i++)this._geometries[i].normalize();
        (0, _arraysJsDefault.default).sort(this._geometries);
    }
    getCoordinate() {
        if (this.isEmpty()) return null;
        return this._geometries[0].getCoordinate();
    }
    getBoundaryDimension() {
        let dimension = (0, _dimensionJsDefault.default).FALSE;
        for(let i = 0; i < this._geometries.length; i++)dimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());
        return dimension;
    }
    getLength() {
        let sum = 0.0;
        for(let i = 0; i < this._geometries.length; i++)sum += this._geometries[i].getLength();
        return sum;
    }
    getNumPoints() {
        let numPoints = 0;
        for(let i = 0; i < this._geometries.length; i++)numPoints += this._geometries[i].getNumPoints();
        return numPoints;
    }
    compareToSameClass() {
        if (arguments.length === 1) {
            const o = arguments[0];
            const theseElements = new (0, _treeSetJsDefault.default)((0, _arraysJsDefault.default).asList(this._geometries));
            const otherElements = new (0, _treeSetJsDefault.default)((0, _arraysJsDefault.default).asList(o._geometries));
            return this.compare(theseElements, otherElements);
        } else if (arguments.length === 2) {
            const o = arguments[0], comp = arguments[1];
            const gc = o;
            const n1 = this.getNumGeometries();
            const n2 = gc.getNumGeometries();
            let i = 0;
            while(i < n1 && i < n2){
                const thisGeom = this.getGeometryN(i);
                const otherGeom = gc.getGeometryN(i);
                const holeComp = thisGeom.compareToSameClass(otherGeom, comp);
                if (holeComp !== 0) return holeComp;
                i++;
            }
            if (i < n1) return 1;
            if (i < n2) return -1;
            return 0;
        }
    }
    apply() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateFilterJsDefault.default))) {
            const filter = arguments[0];
            for(let i = 0; i < this._geometries.length; i++)this._geometries[i].apply(filter);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceFilterJsDefault.default))) {
            const filter = arguments[0];
            if (this._geometries.length === 0) return null;
            for(let i = 0; i < this._geometries.length; i++){
                this._geometries[i].apply(filter);
                if (filter.isDone()) break;
            }
            if (filter.isGeometryChanged()) this.geometryChanged();
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
            for(let i = 0; i < this._geometries.length; i++)this._geometries[i].apply(filter);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryComponentFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
            for(let i = 0; i < this._geometries.length; i++)this._geometries[i].apply(filter);
        }
    }
}
exports.default = GeometryCollection;

},{"../../../../java/util/TreeSet.js":"is5ah","../../../../hasInterface.js":"5bpze","../../../../java/lang/IllegalArgumentException.js":"9ppVW","./GeometryComponentFilter.js":"lqE9C","./Dimension.js":"kWqD0","../../../../java/util/ArrayList.js":"gGAQZ","./Geometry.js":"9DSzO","../../../../java/util/Arrays.js":"a6V8H","./CoordinateFilter.js":"cr8Rt","./GeometryFilter.js":"fZPJo","./CoordinateSequenceFilter.js":"8MSah","./Envelope.js":"h2zeM","../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"is5ah":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _noSuchElementExceptionJs = require("./NoSuchElementException.js");
var _noSuchElementExceptionJsDefault = parcelHelpers.interopDefault(_noSuchElementExceptionJs);
var _unsupportedOperationExceptionJs = require("../lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
var _sortedSetJs = require("./SortedSet.js");
var _sortedSetJsDefault = parcelHelpers.interopDefault(_sortedSetJs);
class TreeSet extends (0, _sortedSetJsDefault.default) {
    constructor(o){
        super();
        this.array = [];
        if (o instanceof (0, _collectionJsDefault.default)) this.addAll(o);
    }
    contains(o) {
        for (const e of this.array)if (e.compareTo(o) === 0) return true;
        return false;
    }
    add(o) {
        if (this.contains(o)) return false;
        for(let i = 0, len = this.array.length; i < len; i++){
            const e = this.array[i];
            if (e.compareTo(o) === 1) return !!this.array.splice(i, 0, o);
        }
        this.array.push(o);
        return true;
    }
    addAll(c) {
        for (const e of c)this.add(e);
        return true;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
    size() {
        return this.array.length;
    }
    isEmpty() {
        return this.array.length === 0;
    }
    toArray() {
        return this.array.slice();
    }
    iterator() {
        return new Iterator(this.array);
    }
}
exports.default = TreeSet;
class Iterator {
    constructor(array){
        this.array = array;
        this.position = 0;
    }
    next() {
        if (this.position === this.array.length) throw new (0, _noSuchElementExceptionJsDefault.default)();
        return this.array[this.position++];
    }
    hasNext() {
        return this.position < this.array.length;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
}

},{"./Collection.js":"cggki","./NoSuchElementException.js":"8ozww","../lang/UnsupportedOperationException.js":"dV3kx","./SortedSet.js":"8F4qy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8F4qy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setJs = require("./Set.js");
var _setJsDefault = parcelHelpers.interopDefault(_setJs);
class SortedSet extends (0, _setJsDefault.default) {
}
exports.default = SortedSet;

},{"./Set.js":"7uTsS","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7uTsS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
class Set extends (0, _collectionJsDefault.default) {
    /**
   * Returns true if this set contains the specified element. More formally,
   * returns true if and only if this set contains an element e such that (o==null ?
   * e==null : o.equals(e)).
   * @param {Object} e
   * @return {boolean}
   */ contains() {}
}
exports.default = Set;

},{"./Collection.js":"cggki","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a6V8H":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("./ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class Arrays {
    static sort() {
        const a = arguments[0];
        if (arguments.length === 1) a.sort((a, b)=>a.compareTo(b));
        else if (arguments.length === 2) a.sort((a, b)=>arguments[1].compare(a, b));
        else if (arguments.length === 3) {
            const t = a.slice(arguments[1], arguments[2]);
            t.sort();
            const r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
            a.splice(0, a.length);
            for (const e of r)a.push(e);
        } else if (arguments.length === 4) {
            const t = a.slice(arguments[1], arguments[2]);
            t.sort((a, b)=>arguments[3].compare(a, b));
            const r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
            a.splice(0, a.length);
            for (const e of r)a.push(e);
        }
    }
    /**
   * @param {Array} array
   * @return {ArrayList}
   */ static asList(array) {
        const arrayList = new (0, _arrayListJsDefault.default)();
        for (const e of array)arrayList.add(e);
        return arrayList;
    }
    static copyOf(original, newLength) {
        return original.slice(0, newLength);
    }
}
exports.default = Arrays;

},{"./ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jIBid":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Polygonal {
}
exports.default = Polygonal;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9XxRL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashMapJs = require("../../../../java/util/HashMap.js");
var _hashMapJsDefault = parcelHelpers.interopDefault(_hashMapJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _integerJs = require("../../../../java/lang/Integer.js");
var _integerJsDefault = parcelHelpers.interopDefault(_integerJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
class PrecisionModel {
    constructor(){
        PrecisionModel.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._modelType = null;
        this._scale = null;
        if (arguments.length === 0) this._modelType = PrecisionModel.FLOATING;
        else if (arguments.length === 1) {
            if (arguments[0] instanceof Type) {
                const modelType = arguments[0];
                this._modelType = modelType;
                if (modelType === PrecisionModel.FIXED) this.setScale(1.0);
            } else if (typeof arguments[0] === 'number') {
                const scale = arguments[0];
                this._modelType = PrecisionModel.FIXED;
                this.setScale(scale);
            } else if (arguments[0] instanceof PrecisionModel) {
                const pm = arguments[0];
                this._modelType = pm._modelType;
                this._scale = pm._scale;
            }
        }
    }
    static mostPrecise(pm1, pm2) {
        if (pm1.compareTo(pm2) >= 0) return pm1;
        return pm2;
    }
    equals(other) {
        if (!(other instanceof PrecisionModel)) return false;
        const otherPrecisionModel = other;
        return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;
    }
    compareTo(o) {
        const other = o;
        const sigDigits = this.getMaximumSignificantDigits();
        const otherSigDigits = other.getMaximumSignificantDigits();
        return (0, _integerJsDefault.default).compare(sigDigits, otherSigDigits);
    }
    getType() {
        return this._modelType;
    }
    toString() {
        let description = 'UNKNOWN';
        if (this._modelType === PrecisionModel.FLOATING) description = 'Floating';
        else if (this._modelType === PrecisionModel.FLOATING_SINGLE) description = 'Floating-Single';
        else if (this._modelType === PrecisionModel.FIXED) description = 'Fixed (Scale=' + this.getScale() + ')';
        return description;
    }
    makePrecise() {
        if (typeof arguments[0] === 'number') {
            const val = arguments[0];
            if ((0, _doubleJsDefault.default).isNaN(val)) return val;
            if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
                const floatSingleVal = val;
                return floatSingleVal;
            }
            if (this._modelType === PrecisionModel.FIXED) return Math.round(val * this._scale) / this._scale;
            return val;
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const coord = arguments[0];
            if (this._modelType === PrecisionModel.FLOATING) return null;
            coord.x = this.makePrecise(coord.x);
            coord.y = this.makePrecise(coord.y);
        }
    }
    getMaximumSignificantDigits() {
        let maxSigDigits = 16;
        if (this._modelType === PrecisionModel.FLOATING) maxSigDigits = 16;
        else if (this._modelType === PrecisionModel.FLOATING_SINGLE) maxSigDigits = 6;
        else if (this._modelType === PrecisionModel.FIXED) maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
        return maxSigDigits;
    }
    setScale(scale) {
        this._scale = Math.abs(scale);
    }
    getScale() {
        return this._scale;
    }
    isFloating() {
        return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;
    }
    get interfaces_() {
        return [
            (0, _serializableJsDefault.default),
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = PrecisionModel;
class Type {
    constructor(){
        Type.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._name = null;
        const name = arguments[0];
        this._name = name;
        Type.nameToTypeMap.put(name, this);
    }
    readResolve() {
        return Type.nameToTypeMap.get(this._name);
    }
    toString() {
        return this._name;
    }
    get interfaces_() {
        return [
            (0, _serializableJsDefault.default)
        ];
    }
}
Type.nameToTypeMap = new (0, _hashMapJsDefault.default)();
PrecisionModel.Type = Type;
PrecisionModel.FIXED = new Type('FIXED');
PrecisionModel.FLOATING = new Type('FLOATING');
PrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');
PrecisionModel.maximumPreciseValue = 9007199254740992.0;

},{"../../../../java/util/HashMap.js":"40yYo","./Coordinate.js":"ii2fh","../../../../java/lang/Double.js":"clUxd","../../../../java/lang/Integer.js":"b3mDP","../../../../java/lang/Comparable.js":"WFeEu","../../../../java/io/Serializable.js":"5sRbw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"40yYo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("./ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _mapJs = require("./Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _hashSetJs = require("./HashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
class HashMap extends (0, _mapJsDefault.default) {
    constructor(){
        super();
        this.map = new Map();
    }
    get(key) {
        return this.map.get(key) || null;
    }
    put(key, value) {
        this.map.set(key, value);
        return value;
    }
    values() {
        const arrayList = new (0, _arrayListJsDefault.default)();
        const it = this.map.values();
        let o = it.next();
        while(!o.done){
            arrayList.add(o.value);
            o = it.next();
        }
        return arrayList;
    }
    entrySet() {
        const hashSet = new (0, _hashSetJsDefault.default)();
        this.map.entries().forEach((entry)=>hashSet.add(entry));
        return hashSet;
    }
    size() {
        return this.map.size();
    }
}
exports.default = HashMap;

},{"./ArrayList.js":"gGAQZ","./Map.js":"8kUbt","./HashSet.js":"a1U62","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8kUbt":[function(require,module,exports,__globalThis) {
/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Map {
    /**
     * Returns the value to which the specified key is mapped, or null if this map
     * contains no mapping for the key.
     * @param {Object} key
     * @return {Object}
     */ get() {}
    /**
     * Associates the specified value with the specified key in this map (optional
     * operation).
     * @param {Object} key
     * @param {Object} value
     * @return {Object}
     */ put() {}
    /**
     * Returns the number of key-value mappings in this map.
     * @return {number}
     */ size() {}
    /**
     * Returns a Collection view of the values contained in this map.
     * @return {javascript.util.Collection}
     */ values() {}
    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator's own <tt>remove</tt> operation, or through the
     * <tt>setValue</tt> operation on a map entry returned by the
     * iterator) the results of the iteration are undefined.  The set
     * supports element removal, which removes the corresponding
     * mapping from the map, via the <tt>Iterator.remove</tt>,
     * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
     * <tt>clear</tt> operations.  It does not support the
     * <tt>add</tt> or <tt>addAll</tt> operations.
     *
     * @return {Set} a set view of the mappings contained in this map
     */ entrySet() {}
}
exports.default = Map;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a1U62":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _noSuchElementExceptionJs = require("./NoSuchElementException.js");
var _noSuchElementExceptionJsDefault = parcelHelpers.interopDefault(_noSuchElementExceptionJs);
var _unsupportedOperationExceptionJs = require("../lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
var _setJs = require("./Set.js");
var _setJsDefault = parcelHelpers.interopDefault(_setJs);
class HashSet extends (0, _setJsDefault.default) {
    constructor(o){
        super();
        this.map = new Map();
        if (o instanceof (0, _collectionJsDefault.default)) this.addAll(o);
    }
    contains(o) {
        const hashCode = o.hashCode ? o.hashCode() : o;
        if (this.map.has(hashCode)) return true;
        return false;
    }
    add(o) {
        const hashCode = o.hashCode ? o.hashCode() : o;
        if (this.map.has(hashCode)) return false;
        return !!this.map.set(hashCode, o);
    }
    addAll(c) {
        for (const e of c)this.add(e);
        return true;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
    size() {
        return this.map.size;
    }
    isEmpty() {
        return this.map.size === 0;
    }
    toArray() {
        return Array.from(this.map.values());
    }
    iterator() {
        return new Iterator(this.map);
    }
    [Symbol.iterator]() {
        return this.map;
    }
}
exports.default = HashSet;
class Iterator {
    constructor(map){
        this.iterator = map.values();
        const { done, value } = this.iterator.next();
        this.done = done;
        this.value = value;
    }
    next() {
        if (this.done) throw new (0, _noSuchElementExceptionJsDefault.default)();
        const current = this.value;
        const { done, value } = this.iterator.next();
        this.done = done;
        this.value = value;
        return current;
    }
    hasNext() {
        return !this.done;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
}

},{"./Collection.js":"cggki","./NoSuchElementException.js":"8ozww","../lang/UnsupportedOperationException.js":"dV3kx","./Set.js":"7uTsS","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b3mDP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Integer {
    constructor(value){
        this.value = value;
    }
    intValue() {
        return this.value;
    }
    compareTo(o) {
        if (this.value < o) return -1;
        if (this.value > o) return 1;
        return 0;
    }
    static compare(x, y) {
        if (x < y) return -1;
        if (x > y) return 1;
        return 0;
    }
    static isNan(n) {
        return Number.isNaN(n);
    }
    static valueOf(value) {
        return new Integer(value);
    }
}
exports.default = Integer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5UyOx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _linealJs = require("./Lineal.js");
var _linealJsDefault = parcelHelpers.interopDefault(_linealJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _geometryCollectionJs = require("./GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _unsupportedOperationExceptionJs = require("../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
class MultiLineString extends (0, _geometryCollectionJsDefault.default) {
    constructor(){
        super();
        MultiLineString.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const lineStrings = arguments[0], factory = arguments[1];
        (0, _geometryCollectionJsDefault.default).constructor_.call(this, lineStrings, factory);
    }
    copyInternal() {
        const lineStrings = new Array(this._geometries.length).fill(null);
        for(let i = 0; i < lineStrings.length; i++)lineStrings[i] = this._geometries[i].copy();
        return new MultiLineString(lineStrings, this._factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            return super.equalsExact.call(this, other, tolerance);
        } else return super.equalsExact.apply(this, arguments);
    }
    getBoundaryDimension() {
        if (this.isClosed()) return (0, _dimensionJsDefault.default).FALSE;
        return 0;
    }
    isClosed() {
        if (this.isEmpty()) return false;
        for(let i = 0; i < this._geometries.length; i++)if (!this._geometries[i].isClosed()) return false;
        return true;
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_MULTILINESTRING;
    }
    getDimension() {
        return 1;
    }
    getBoundary() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_MULTILINESTRING;
    }
    get interfaces_() {
        return [
            (0, _linealJsDefault.default)
        ];
    }
}
exports.default = MultiLineString;

},{"./Geometry.js":"9DSzO","./Lineal.js":"51JJJ","./Dimension.js":"kWqD0","./GeometryCollection.js":"6RJQO","../../../../java/lang/UnsupportedOperationException.js":"dV3kx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lwZpO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _geometryComponentFilterJs = require("./GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _puntalJs = require("./Puntal.js");
var _puntalJsDefault = parcelHelpers.interopDefault(_puntalJs);
var _illegalStateExceptionJs = require("../../../../java/lang/IllegalStateException.js");
var _illegalStateExceptionJsDefault = parcelHelpers.interopDefault(_illegalStateExceptionJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _coordinateFilterJs = require("./CoordinateFilter.js");
var _coordinateFilterJsDefault = parcelHelpers.interopDefault(_coordinateFilterJs);
var _geometryFilterJs = require("./GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
var _coordinateSequenceFilterJs = require("./CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
var _envelopeJs = require("./Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class Point extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        Point.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._coordinates = null;
        const coordinates = arguments[0], factory = arguments[1];
        (0, _geometryJsDefault.default).constructor_.call(this, factory);
        this.init(coordinates);
    }
    computeEnvelopeInternal() {
        if (this.isEmpty()) return new (0, _envelopeJsDefault.default)();
        const env = new (0, _envelopeJsDefault.default)();
        env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
        return env;
    }
    getCoordinates() {
        return this.isEmpty() ? [] : [
            this.getCoordinate()
        ];
    }
    copyInternal() {
        return new Point(this._coordinates.copy(), this._factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            if (this.isEmpty() && other.isEmpty()) return true;
            if (this.isEmpty() !== other.isEmpty()) return false;
            return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);
        } else return super.equalsExact.apply(this, arguments);
    }
    reverseInternal() {
        return this.getFactory().createPoint(this._coordinates.copy());
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_POINT;
    }
    getDimension() {
        return 0;
    }
    getNumPoints() {
        return this.isEmpty() ? 0 : 1;
    }
    getX() {
        if (this.getCoordinate() === null) throw new (0, _illegalStateExceptionJsDefault.default)('getX called on empty Point');
        return this.getCoordinate().x;
    }
    getBoundary() {
        return this.getFactory().createGeometryCollection();
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_POINT;
    }
    getCoordinateSequence() {
        return this._coordinates;
    }
    getY() {
        if (this.getCoordinate() === null) throw new (0, _illegalStateExceptionJsDefault.default)('getY called on empty Point');
        return this.getCoordinate().y;
    }
    isSimple() {
        return true;
    }
    normalize() {}
    getCoordinate() {
        return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
    }
    getBoundaryDimension() {
        return (0, _dimensionJsDefault.default).FALSE;
    }
    compareToSameClass() {
        if (arguments.length === 1) {
            const other = arguments[0];
            const point = other;
            return this.getCoordinate().compareTo(point.getCoordinate());
        } else if (arguments.length === 2) {
            const other = arguments[0], comp = arguments[1];
            const point = other;
            return comp.compare(this._coordinates, point._coordinates);
        }
    }
    apply() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateFilterJsDefault.default))) {
            const filter = arguments[0];
            if (this.isEmpty()) return null;
            filter.filter(this.getCoordinate());
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceFilterJsDefault.default))) {
            const filter = arguments[0];
            if (this.isEmpty()) return null;
            filter.filter(this._coordinates, 0);
            if (filter.isGeometryChanged()) this.geometryChanged();
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryComponentFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
        }
    }
    isEmpty() {
        return this._coordinates.size() === 0;
    }
    init(coordinates) {
        if (coordinates === null) coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
        (0, _assertJsDefault.default).isTrue(coordinates.size() <= 1);
        this._coordinates = coordinates;
    }
    get interfaces_() {
        return [
            (0, _puntalJsDefault.default)
        ];
    }
}
exports.default = Point;

},{"../../../../hasInterface.js":"5bpze","./GeometryComponentFilter.js":"lqE9C","./Dimension.js":"kWqD0","./Puntal.js":"e8hBl","../../../../java/lang/IllegalStateException.js":"efv6w","./Geometry.js":"9DSzO","./CoordinateFilter.js":"cr8Rt","./GeometryFilter.js":"fZPJo","./CoordinateSequenceFilter.js":"8MSah","./Envelope.js":"h2zeM","../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e8hBl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Puntal {
}
exports.default = Puntal;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"efv6w":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("./Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class IllegalStateException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            IllegalStateException
        })[0];
    }
}
exports.default = IllegalStateException;

},{"./Exception.js":"8tbsL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kpOA5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _areaJs = require("../algorithm/Area.js");
var _areaJsDefault = parcelHelpers.interopDefault(_areaJs);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _coordinateSequencesJs = require("./CoordinateSequences.js");
var _coordinateSequencesJsDefault = parcelHelpers.interopDefault(_coordinateSequencesJs);
var _geometryComponentFilterJs = require("./GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _polygonalJs = require("./Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _arraysJs = require("../../../../java/util/Arrays.js");
var _arraysJsDefault = parcelHelpers.interopDefault(_arraysJs);
var _coordinateFilterJs = require("./CoordinateFilter.js");
var _coordinateFilterJsDefault = parcelHelpers.interopDefault(_coordinateFilterJs);
var _geometryFilterJs = require("./GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
var _coordinateSequenceFilterJs = require("./CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
class Polygon extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        Polygon.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._shell = null;
        this._holes = null;
        let shell = arguments[0], holes = arguments[1], factory = arguments[2];
        (0, _geometryJsDefault.default).constructor_.call(this, factory);
        if (shell === null) shell = this.getFactory().createLinearRing();
        if (holes === null) holes = [];
        if ((0, _geometryJsDefault.default).hasNullElements(holes)) throw new (0, _illegalArgumentExceptionJsDefault.default)('holes must not contain null elements');
        if (shell.isEmpty() && (0, _geometryJsDefault.default).hasNonEmptyElements(holes)) throw new (0, _illegalArgumentExceptionJsDefault.default)('shell is empty but holes are not');
        this._shell = shell;
        this._holes = holes;
    }
    computeEnvelopeInternal() {
        return this._shell.getEnvelopeInternal();
    }
    getCoordinates() {
        if (this.isEmpty()) return [];
        const coordinates = new Array(this.getNumPoints()).fill(null);
        let k = -1;
        const shellCoordinates = this._shell.getCoordinates();
        for(let x = 0; x < shellCoordinates.length; x++){
            k++;
            coordinates[k] = shellCoordinates[x];
        }
        for(let i = 0; i < this._holes.length; i++){
            const childCoordinates = this._holes[i].getCoordinates();
            for(let j = 0; j < childCoordinates.length; j++){
                k++;
                coordinates[k] = childCoordinates[j];
            }
        }
        return coordinates;
    }
    getArea() {
        let area = 0.0;
        area += (0, _areaJsDefault.default).ofRing(this._shell.getCoordinateSequence());
        for(let i = 0; i < this._holes.length; i++)area -= (0, _areaJsDefault.default).ofRing(this._holes[i].getCoordinateSequence());
        return area;
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            const otherPolygon = other;
            const thisShell = this._shell;
            const otherPolygonShell = otherPolygon._shell;
            if (!thisShell.equalsExact(otherPolygonShell, tolerance)) return false;
            if (this._holes.length !== otherPolygon._holes.length) return false;
            for(let i = 0; i < this._holes.length; i++)if (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) return false;
            return true;
        } else return super.equalsExact.apply(this, arguments);
    }
    reverseInternal() {
        const shell = this.getExteriorRing().reverse();
        const holes = new Array(this.getNumInteriorRing()).fill(null);
        for(let i = 0; i < holes.length; i++)holes[i] = this.getInteriorRingN(i).reverse();
        return this.getFactory().createPolygon(shell, holes);
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_POLYGON;
    }
    getDimension() {
        return 2;
    }
    getBoundary() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        const rings = new Array(this._holes.length + 1).fill(null);
        rings[0] = this._shell;
        for(let i = 0; i < this._holes.length; i++)rings[i + 1] = this._holes[i];
        if (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());
        return this.getFactory().createMultiLineString(rings);
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_POLYGON;
    }
    getExteriorRing() {
        return this._shell;
    }
    copyInternal() {
        const shellCopy = this._shell.copy();
        const holeCopies = new Array(this._holes.length).fill(null);
        for(let i = 0; i < this._holes.length; i++)holeCopies[i] = this._holes[i].copy();
        return new Polygon(shellCopy, holeCopies, this._factory);
    }
    isRectangle() {
        if (this.getNumInteriorRing() !== 0) return false;
        if (this._shell === null) return false;
        if (this._shell.getNumPoints() !== 5) return false;
        const seq = this._shell.getCoordinateSequence();
        const env = this.getEnvelopeInternal();
        for(let i = 0; i < 5; i++){
            const x = seq.getX(i);
            if (!(x === env.getMinX() || x === env.getMaxX())) return false;
            const y = seq.getY(i);
            if (!(y === env.getMinY() || y === env.getMaxY())) return false;
        }
        let prevX = seq.getX(0);
        let prevY = seq.getY(0);
        for(let i = 1; i <= 4; i++){
            const x = seq.getX(i);
            const y = seq.getY(i);
            const xChanged = x !== prevX;
            const yChanged = y !== prevY;
            if (xChanged === yChanged) return false;
            prevX = x;
            prevY = y;
        }
        return true;
    }
    normalize() {
        if (arguments.length === 0) {
            this._shell = this.normalized(this._shell, true);
            for(let i = 0; i < this._holes.length; i++)this._holes[i] = this.normalized(this._holes[i], false);
            (0, _arraysJsDefault.default).sort(this._holes);
        } else if (arguments.length === 2) {
            const ring = arguments[0], clockwise = arguments[1];
            if (ring.isEmpty()) return null;
            const seq = ring.getCoordinateSequence();
            const minCoordinateIndex = (0, _coordinateSequencesJsDefault.default).minCoordinateIndex(seq, 0, seq.size() - 2);
            (0, _coordinateSequencesJsDefault.default).scroll(seq, minCoordinateIndex, true);
            if ((0, _orientationJsDefault.default).isCCW(seq) === clockwise) (0, _coordinateSequencesJsDefault.default).reverse(seq);
        }
    }
    getCoordinate() {
        return this._shell.getCoordinate();
    }
    getNumInteriorRing() {
        return this._holes.length;
    }
    getBoundaryDimension() {
        return 1;
    }
    getLength() {
        let len = 0.0;
        len += this._shell.getLength();
        for(let i = 0; i < this._holes.length; i++)len += this._holes[i].getLength();
        return len;
    }
    getNumPoints() {
        let numPoints = this._shell.getNumPoints();
        for(let i = 0; i < this._holes.length; i++)numPoints += this._holes[i].getNumPoints();
        return numPoints;
    }
    convexHull() {
        return this.getExteriorRing().convexHull();
    }
    normalized(ring, clockwise) {
        const res = ring.copy();
        this.normalize(res, clockwise);
        return res;
    }
    compareToSameClass() {
        if (arguments.length === 1) {
            const o = arguments[0];
            const thisShell = this._shell;
            const otherShell = o._shell;
            return thisShell.compareToSameClass(otherShell);
        } else if (arguments.length === 2) {
            const o = arguments[0], comp = arguments[1];
            const poly = o;
            const thisShell = this._shell;
            const otherShell = poly._shell;
            const shellComp = thisShell.compareToSameClass(otherShell, comp);
            if (shellComp !== 0) return shellComp;
            const nHole1 = this.getNumInteriorRing();
            const nHole2 = poly.getNumInteriorRing();
            let i = 0;
            while(i < nHole1 && i < nHole2){
                const thisHole = this.getInteriorRingN(i);
                const otherHole = poly.getInteriorRingN(i);
                const holeComp = thisHole.compareToSameClass(otherHole, comp);
                if (holeComp !== 0) return holeComp;
                i++;
            }
            if (i < nHole1) return 1;
            if (i < nHole2) return -1;
            return 0;
        }
    }
    apply() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateFilterJsDefault.default))) {
            const filter = arguments[0];
            this._shell.apply(filter);
            for(let i = 0; i < this._holes.length; i++)this._holes[i].apply(filter);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceFilterJsDefault.default))) {
            const filter = arguments[0];
            this._shell.apply(filter);
            if (!filter.isDone()) for(let i = 0; i < this._holes.length; i++){
                this._holes[i].apply(filter);
                if (filter.isDone()) break;
            }
            if (filter.isGeometryChanged()) this.geometryChanged();
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryComponentFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
            this._shell.apply(filter);
            for(let i = 0; i < this._holes.length; i++)this._holes[i].apply(filter);
        }
    }
    isEmpty() {
        return this._shell.isEmpty();
    }
    getInteriorRingN(n) {
        return this._holes[n];
    }
    get interfaces_() {
        return [
            (0, _polygonalJsDefault.default)
        ];
    }
}
exports.default = Polygon;

},{"../algorithm/Area.js":"84f44","../../../../hasInterface.js":"5bpze","../../../../java/lang/IllegalArgumentException.js":"9ppVW","../algorithm/Orientation.js":"avl08","./CoordinateSequences.js":"iGxeo","./GeometryComponentFilter.js":"lqE9C","./Polygonal.js":"jIBid","./Geometry.js":"9DSzO","../../../../java/util/Arrays.js":"a6V8H","./CoordinateFilter.js":"cr8Rt","./GeometryFilter.js":"fZPJo","./CoordinateSequenceFilter.js":"8MSah","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"84f44":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _coordinateSequenceJs = require("../geom/CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
class Area {
    static ofRingSigned() {
        if (arguments[0] instanceof Array) {
            const ring = arguments[0];
            if (ring.length < 3) return 0.0;
            let sum = 0.0;
            const x0 = ring[0].x;
            for(let i = 1; i < ring.length - 1; i++){
                const x = ring[i].x - x0;
                const y1 = ring[i + 1].y;
                const y2 = ring[i - 1].y;
                sum += x * (y2 - y1);
            }
            return sum / 2.0;
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
            const ring = arguments[0];
            const n = ring.size();
            if (n < 3) return 0.0;
            const p0 = new (0, _coordinateJsDefault.default)();
            const p1 = new (0, _coordinateJsDefault.default)();
            const p2 = new (0, _coordinateJsDefault.default)();
            ring.getCoordinate(0, p1);
            ring.getCoordinate(1, p2);
            const x0 = p1.x;
            p2.x -= x0;
            let sum = 0.0;
            for(let i = 1; i < n - 1; i++){
                p0.y = p1.y;
                p1.x = p2.x;
                p1.y = p2.y;
                ring.getCoordinate(i + 1, p2);
                p2.x -= x0;
                sum += p1.x * (p0.y - p2.y);
            }
            return sum / 2.0;
        }
    }
    static ofRing() {
        if (arguments[0] instanceof Array) {
            const ring = arguments[0];
            return Math.abs(Area.ofRingSigned(ring));
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
            const ring = arguments[0];
            return Math.abs(Area.ofRingSigned(ring));
        }
    }
}
exports.default = Area;

},{"../../../../hasInterface.js":"5bpze","../geom/Coordinate.js":"ii2fh","../geom/CoordinateSequence.js":"aDXS8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"avl08":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _cgalgorithmsDDJs = require("./CGAlgorithmsDD.js");
var _cgalgorithmsDDJsDefault = parcelHelpers.interopDefault(_cgalgorithmsDDJs);
var _coordinateSequenceJs = require("../geom/CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
class Orientation {
    static isCCW() {
        if (arguments[0] instanceof Array) {
            const ring = arguments[0];
            const nPts = ring.length - 1;
            if (nPts < 3) throw new (0, _illegalArgumentExceptionJsDefault.default)('Ring has fewer than 4 points, so orientation cannot be determined');
            let hiPt = ring[0];
            let hiIndex = 0;
            for(let i = 1; i <= nPts; i++){
                const p = ring[i];
                if (p.y > hiPt.y) {
                    hiPt = p;
                    hiIndex = i;
                }
            }
            let iPrev = hiIndex;
            do {
                iPrev = iPrev - 1;
                if (iPrev < 0) iPrev = nPts;
            }while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);
            let iNext = hiIndex;
            do iNext = (iNext + 1) % nPts;
            while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);
            const prev = ring[iPrev];
            const next = ring[iNext];
            if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;
            const disc = Orientation.index(prev, hiPt, next);
            let isCCW = null;
            if (disc === 0) isCCW = prev.x > next.x;
            else isCCW = disc > 0;
            return isCCW;
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
            const ring = arguments[0];
            const nPts = ring.size() - 1;
            if (nPts < 3) throw new (0, _illegalArgumentExceptionJsDefault.default)('Ring has fewer than 4 points, so orientation cannot be determined');
            let hiPt = ring.getCoordinate(0);
            let hiIndex = 0;
            for(let i = 1; i <= nPts; i++){
                const p = ring.getCoordinate(i);
                if (p.y > hiPt.y) {
                    hiPt = p;
                    hiIndex = i;
                }
            }
            let prev = null;
            let iPrev = hiIndex;
            do {
                iPrev = iPrev - 1;
                if (iPrev < 0) iPrev = nPts;
                prev = ring.getCoordinate(iPrev);
            }while (prev.equals2D(hiPt) && iPrev !== hiIndex);
            let next = null;
            let iNext = hiIndex;
            do {
                iNext = (iNext + 1) % nPts;
                next = ring.getCoordinate(iNext);
            }while (next.equals2D(hiPt) && iNext !== hiIndex);
            if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;
            const disc = Orientation.index(prev, hiPt, next);
            let isCCW = null;
            if (disc === 0) isCCW = prev.x > next.x;
            else isCCW = disc > 0;
            return isCCW;
        }
    }
    static index(p1, p2, q) {
        return (0, _cgalgorithmsDDJsDefault.default).orientationIndex(p1, p2, q);
    }
}
exports.default = Orientation;
Orientation.CLOCKWISE = -1;
Orientation.RIGHT = Orientation.CLOCKWISE;
Orientation.COUNTERCLOCKWISE = 1;
Orientation.LEFT = Orientation.COUNTERCLOCKWISE;
Orientation.COLLINEAR = 0;
Orientation.STRAIGHT = Orientation.COLLINEAR;

},{"../../../../hasInterface.js":"5bpze","../../../../java/lang/IllegalArgumentException.js":"9ppVW","./CGAlgorithmsDD.js":"hasH7","../geom/CoordinateSequence.js":"aDXS8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hasH7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _ddJs = require("../math/DD.js");
var _ddJsDefault = parcelHelpers.interopDefault(_ddJs);
class CGAlgorithmsDD {
    static orientationIndex(p1, p2, q) {
        const index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
        if (index <= 1) return index;
        const dx1 = (0, _ddJsDefault.default).valueOf(p2.x).selfAdd(-p1.x);
        const dy1 = (0, _ddJsDefault.default).valueOf(p2.y).selfAdd(-p1.y);
        const dx2 = (0, _ddJsDefault.default).valueOf(q.x).selfAdd(-p2.x);
        const dy2 = (0, _ddJsDefault.default).valueOf(q.y).selfAdd(-p2.y);
        return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();
    }
    static signOfDet2x2() {
        if (arguments[3] instanceof (0, _ddJsDefault.default) && arguments[2] instanceof (0, _ddJsDefault.default) && arguments[0] instanceof (0, _ddJsDefault.default) && arguments[1] instanceof (0, _ddJsDefault.default)) {
            const x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3];
            const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
            return det.signum();
        } else if (typeof arguments[3] === 'number' && typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            const dx1 = arguments[0], dy1 = arguments[1], dx2 = arguments[2], dy2 = arguments[3];
            const x1 = (0, _ddJsDefault.default).valueOf(dx1);
            const y1 = (0, _ddJsDefault.default).valueOf(dy1);
            const x2 = (0, _ddJsDefault.default).valueOf(dx2);
            const y2 = (0, _ddJsDefault.default).valueOf(dy2);
            const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
            return det.signum();
        }
    }
    static intersection(p1, p2, q1, q2) {
        const px = new (0, _ddJsDefault.default)(p1.y).selfSubtract(p2.y);
        const py = new (0, _ddJsDefault.default)(p2.x).selfSubtract(p1.x);
        const pw = new (0, _ddJsDefault.default)(p1.x).selfMultiply(p2.y).selfSubtract(new (0, _ddJsDefault.default)(p2.x).selfMultiply(p1.y));
        const qx = new (0, _ddJsDefault.default)(q1.y).selfSubtract(q2.y);
        const qy = new (0, _ddJsDefault.default)(q2.x).selfSubtract(q1.x);
        const qw = new (0, _ddJsDefault.default)(q1.x).selfMultiply(q2.y).selfSubtract(new (0, _ddJsDefault.default)(q2.x).selfMultiply(q1.y));
        const x = py.multiply(qw).selfSubtract(qy.multiply(pw));
        const y = qx.multiply(pw).selfSubtract(px.multiply(qw));
        const w = px.multiply(qy).selfSubtract(qx.multiply(py));
        const xInt = x.selfDivide(w).doubleValue();
        const yInt = y.selfDivide(w).doubleValue();
        if ((0, _doubleJsDefault.default).isNaN(xInt) || (0, _doubleJsDefault.default).isInfinite(xInt) || (0, _doubleJsDefault.default).isNaN(yInt) || (0, _doubleJsDefault.default).isInfinite(yInt)) return null;
        return new (0, _coordinateJsDefault.default)(xInt, yInt);
    }
    static orientationIndexFilter(pa, pb, pc) {
        let detsum = null;
        const detleft = (pa.x - pc.x) * (pb.y - pc.y);
        const detright = (pa.y - pc.y) * (pb.x - pc.x);
        const det = detleft - detright;
        if (detleft > 0.0) {
            if (detright <= 0.0) return CGAlgorithmsDD.signum(det);
            else detsum = detleft + detright;
        } else if (detleft < 0.0) {
            if (detright >= 0.0) return CGAlgorithmsDD.signum(det);
            else detsum = -detleft - detright;
        } else return CGAlgorithmsDD.signum(det);
        const errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
        if (det >= errbound || -det >= errbound) return CGAlgorithmsDD.signum(det);
        return 2;
    }
    static signum(x) {
        if (x > 0) return 1;
        if (x < 0) return -1;
        return 0;
    }
}
exports.default = CGAlgorithmsDD;
CGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;

},{"../geom/Coordinate.js":"ii2fh","../../../../java/lang/Double.js":"clUxd","../math/DD.js":"12omc","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"12omc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stringBufferJs = require("../../../../java/lang/StringBuffer.js");
var _stringBufferJsDefault = parcelHelpers.interopDefault(_stringBufferJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _integerJs = require("../../../../java/lang/Integer.js");
var _integerJsDefault = parcelHelpers.interopDefault(_integerJs);
var _characterJs = require("../../../../java/lang/Character.js");
var _characterJsDefault = parcelHelpers.interopDefault(_characterJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _cloneableJs = require("../../../../java/lang/Cloneable.js");
var _cloneableJsDefault = parcelHelpers.interopDefault(_cloneableJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _illegalStateExceptionJs = require("../../../../java/lang/IllegalStateException.js");
var _illegalStateExceptionJsDefault = parcelHelpers.interopDefault(_illegalStateExceptionJs);
class DD {
    constructor(){
        DD.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._hi = 0.0;
        this._lo = 0.0;
        if (arguments.length === 0) this.init(0.0);
        else if (arguments.length === 1) {
            if (typeof arguments[0] === 'number') {
                const x = arguments[0];
                this.init(x);
            } else if (arguments[0] instanceof DD) {
                const dd = arguments[0];
                this.init(dd);
            } else if (typeof arguments[0] === 'string') {
                const str = arguments[0];
                DD.constructor_.call(this, DD.parse(str));
            }
        } else if (arguments.length === 2) {
            const hi = arguments[0], lo = arguments[1];
            this.init(hi, lo);
        }
    }
    static determinant() {
        if (typeof arguments[3] === 'number' && typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            const x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3];
            return DD.determinant(DD.valueOf(x1), DD.valueOf(y1), DD.valueOf(x2), DD.valueOf(y2));
        } else if (arguments[3] instanceof DD && arguments[2] instanceof DD && arguments[0] instanceof DD && arguments[1] instanceof DD) {
            const x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3];
            const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
            return det;
        }
    }
    static sqr(x) {
        return DD.valueOf(x).selfMultiply(x);
    }
    static valueOf() {
        if (typeof arguments[0] === 'string') {
            const str = arguments[0];
            return DD.parse(str);
        } else if (typeof arguments[0] === 'number') {
            const x = arguments[0];
            return new DD(x);
        }
    }
    static sqrt(x) {
        return DD.valueOf(x).sqrt();
    }
    static parse(str) {
        let i = 0;
        const strlen = str.length;
        while((0, _characterJsDefault.default).isWhitespace(str.charAt(i)))i++;
        let isNegative = false;
        if (i < strlen) {
            const signCh = str.charAt(i);
            if (signCh === '-' || signCh === '+') {
                i++;
                if (signCh === '-') isNegative = true;
            }
        }
        const val = new DD();
        let numDigits = 0;
        let numBeforeDec = 0;
        let exp = 0;
        let hasDecimalChar = false;
        while(true){
            if (i >= strlen) break;
            const ch = str.charAt(i);
            i++;
            if ((0, _characterJsDefault.default).isDigit(ch)) {
                const d = ch - '0';
                val.selfMultiply(DD.TEN);
                val.selfAdd(d);
                numDigits++;
                continue;
            }
            if (ch === '.') {
                numBeforeDec = numDigits;
                hasDecimalChar = true;
                continue;
            }
            if (ch === 'e' || ch === 'E') {
                const expStr = str.substring(i);
                try {
                    exp = (0, _integerJsDefault.default).parseInt(expStr);
                } catch (ex) {
                    if (ex instanceof NumberFormatException) throw new NumberFormatException('Invalid exponent ' + expStr + ' in string ' + str);
                    else throw ex;
                } finally{}
                break;
            }
            throw new NumberFormatException('Unexpected character \'' + ch + '\' at position ' + i + ' in string ' + str);
        }
        let val2 = val;
        if (!hasDecimalChar) numBeforeDec = numDigits;
        const numDecPlaces = numDigits - numBeforeDec - exp;
        if (numDecPlaces === 0) val2 = val;
        else if (numDecPlaces > 0) {
            const scale = DD.TEN.pow(numDecPlaces);
            val2 = val.divide(scale);
        } else if (numDecPlaces < 0) {
            const scale = DD.TEN.pow(-numDecPlaces);
            val2 = val.multiply(scale);
        }
        if (isNegative) return val2.negate();
        return val2;
    }
    static createNaN() {
        return new DD((0, _doubleJsDefault.default).NaN, (0, _doubleJsDefault.default).NaN);
    }
    static copy(dd) {
        return new DD(dd);
    }
    static magnitude(x) {
        const xAbs = Math.abs(x);
        const xLog10 = Math.log(xAbs) / Math.log(10);
        let xMag = Math.trunc(Math.floor(xLog10));
        const xApprox = Math.pow(10, xMag);
        if (xApprox * 10 <= xAbs) xMag += 1;
        return xMag;
    }
    static stringOfChar(ch, len) {
        const buf = new (0, _stringBufferJsDefault.default)();
        for(let i = 0; i < len; i++)buf.append(ch);
        return buf.toString();
    }
    le(y) {
        return this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;
    }
    extractSignificantDigits(insertDecimalPoint, magnitude) {
        let y = this.abs();
        let mag = DD.magnitude(y._hi);
        const scale = DD.TEN.pow(mag);
        y = y.divide(scale);
        if (y.gt(DD.TEN)) {
            y = y.divide(DD.TEN);
            mag += 1;
        } else if (y.lt(DD.ONE)) {
            y = y.multiply(DD.TEN);
            mag -= 1;
        }
        const decimalPointPos = mag + 1;
        const buf = new (0, _stringBufferJsDefault.default)();
        const numDigits = DD.MAX_PRINT_DIGITS - 1;
        for(let i = 0; i <= numDigits; i++){
            if (insertDecimalPoint && i === decimalPointPos) buf.append('.');
            const digit = Math.trunc(y._hi);
            digit < 0 || digit;
            if (digit < 0) break;
            let rebiasBy10 = false;
            let digitChar = 0;
            if (digit > 9) {
                rebiasBy10 = true;
                digitChar = '9';
            } else digitChar = '0' + digit;
            buf.append(digitChar);
            y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);
            if (rebiasBy10) y.selfAdd(DD.TEN);
            let continueExtractingDigits = true;
            const remMag = DD.magnitude(y._hi);
            if (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;
            if (!continueExtractingDigits) break;
        }
        magnitude[0] = mag;
        return buf.toString();
    }
    sqr() {
        return this.multiply(this);
    }
    getSpecialNumberString() {
        if (this.isZero()) return '0.0';
        if (this.isNaN()) return 'NaN ';
        return null;
    }
    setValue() {
        if (arguments[0] instanceof DD) {
            const value = arguments[0];
            this.init(value);
            return this;
        } else if (typeof arguments[0] === 'number') {
            const value = arguments[0];
            this.init(value);
            return this;
        }
    }
    multiply() {
        if (arguments[0] instanceof DD) {
            const y = arguments[0];
            if (y.isNaN()) return DD.createNaN();
            return DD.copy(this).selfMultiply(y);
        } else if (typeof arguments[0] === 'number') {
            const y = arguments[0];
            if ((0, _doubleJsDefault.default).isNaN(y)) return DD.createNaN();
            return DD.copy(this).selfMultiply(y, 0.0);
        }
    }
    isNaN() {
        return (0, _doubleJsDefault.default).isNaN(this._hi);
    }
    reciprocal() {
        let hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;
        C = 1.0 / this._hi;
        c = DD.SPLIT * C;
        hc = c - C;
        u = DD.SPLIT * this._hi;
        hc = c - hc;
        tc = C - hc;
        hy = u - this._hi;
        U = C * this._hi;
        hy = u - hy;
        ty = this._hi - hy;
        u = hc * hy - U + hc * ty + tc * hy + tc * ty;
        c = (1.0 - U - u - C * this._lo) / this._hi;
        const zhi = C + c;
        const zlo = C - zhi + c;
        return new DD(zhi, zlo);
    }
    doubleValue() {
        return this._hi + this._lo;
    }
    subtract() {
        if (arguments[0] instanceof DD) {
            const y = arguments[0];
            return this.add(y.negate());
        } else if (typeof arguments[0] === 'number') {
            const y = arguments[0];
            return this.add(-y);
        }
    }
    equals() {
        if (arguments.length === 1 && arguments[0] instanceof DD) {
            const y = arguments[0];
            return this._hi === y._hi && this._lo === y._lo;
        }
    }
    isZero() {
        return this._hi === 0.0 && this._lo === 0.0;
    }
    selfSubtract() {
        if (arguments[0] instanceof DD) {
            const y = arguments[0];
            if (this.isNaN()) return this;
            return this.selfAdd(-y._hi, -y._lo);
        } else if (typeof arguments[0] === 'number') {
            const y = arguments[0];
            if (this.isNaN()) return this;
            return this.selfAdd(-y, 0.0);
        }
    }
    min(x) {
        if (this.le(x)) return this;
        else return x;
    }
    selfDivide() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof DD) {
                const y = arguments[0];
                return this.selfDivide(y._hi, y._lo);
            } else if (typeof arguments[0] === 'number') {
                const y = arguments[0];
                return this.selfDivide(y, 0.0);
            }
        } else if (arguments.length === 2) {
            const yhi = arguments[0], ylo = arguments[1];
            let hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;
            C = this._hi / yhi;
            c = DD.SPLIT * C;
            hc = c - C;
            u = DD.SPLIT * yhi;
            hc = c - hc;
            tc = C - hc;
            hy = u - yhi;
            U = C * yhi;
            hy = u - hy;
            ty = yhi - hy;
            u = hc * hy - U + hc * ty + tc * hy + tc * ty;
            c = (this._hi - U - u + this._lo - C * ylo) / yhi;
            u = C + c;
            this._hi = u;
            this._lo = C - u + c;
            return this;
        }
    }
    dump() {
        return 'DD<' + this._hi + ', ' + this._lo + '>';
    }
    divide() {
        if (arguments[0] instanceof DD) {
            const y = arguments[0];
            let hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;
            C = this._hi / y._hi;
            c = DD.SPLIT * C;
            hc = c - C;
            u = DD.SPLIT * y._hi;
            hc = c - hc;
            tc = C - hc;
            hy = u - y._hi;
            U = C * y._hi;
            hy = u - hy;
            ty = y._hi - hy;
            u = hc * hy - U + hc * ty + tc * hy + tc * ty;
            c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;
            u = C + c;
            const zhi = u;
            const zlo = C - u + c;
            return new DD(zhi, zlo);
        } else if (typeof arguments[0] === 'number') {
            const y = arguments[0];
            if ((0, _doubleJsDefault.default).isNaN(y)) return DD.createNaN();
            return DD.copy(this).selfDivide(y, 0.0);
        }
    }
    ge(y) {
        return this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;
    }
    pow(exp) {
        if (exp === 0.0) return DD.valueOf(1.0);
        let r = new DD(this);
        let s = DD.valueOf(1.0);
        let n = Math.abs(exp);
        if (n > 1) while(n > 0){
            if (n % 2 === 1) s.selfMultiply(r);
            n /= 2;
            if (n > 0) r = r.sqr();
        }
        else s = r;
        if (exp < 0) return s.reciprocal();
        return s;
    }
    ceil() {
        if (this.isNaN()) return DD.NaN;
        const fhi = Math.ceil(this._hi);
        let flo = 0.0;
        if (fhi === this._hi) flo = Math.ceil(this._lo);
        return new DD(fhi, flo);
    }
    compareTo(o) {
        const other = o;
        if (this._hi < other._hi) return -1;
        if (this._hi > other._hi) return 1;
        if (this._lo < other._lo) return -1;
        if (this._lo > other._lo) return 1;
        return 0;
    }
    rint() {
        if (this.isNaN()) return this;
        const plus5 = this.add(0.5);
        return plus5.floor();
    }
    max(x) {
        if (this.ge(x)) return this;
        else return x;
    }
    sqrt() {
        if (this.isZero()) return DD.valueOf(0.0);
        if (this.isNegative()) return DD.NaN;
        const x = 1.0 / Math.sqrt(this._hi);
        const ax = this._hi * x;
        const axdd = DD.valueOf(ax);
        const diffSq = this.subtract(axdd.sqr());
        const d2 = diffSq._hi * (x * 0.5);
        return axdd.add(d2);
    }
    selfAdd() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof DD) {
                const y = arguments[0];
                return this.selfAdd(y._hi, y._lo);
            } else if (typeof arguments[0] === 'number') {
                const y = arguments[0];
                let H = null, h = null, S = null, s = null, e = null, f = null;
                S = this._hi + y;
                e = S - this._hi;
                s = S - e;
                s = y - e + (this._hi - s);
                f = s + this._lo;
                H = S + f;
                h = f + (S - H);
                this._hi = H + h;
                this._lo = h + (H - this._hi);
                return this;
            }
        } else if (arguments.length === 2) {
            const yhi = arguments[0], ylo = arguments[1];
            let H = null, h = null, T = null, t = null, S = null, s = null, e = null, f = null;
            S = this._hi + yhi;
            T = this._lo + ylo;
            e = S - this._hi;
            f = T - this._lo;
            s = S - e;
            t = T - f;
            s = yhi - e + (this._hi - s);
            t = ylo - f + (this._lo - t);
            e = s + T;
            H = S + e;
            h = e + (S - H);
            e = t + h;
            const zhi = H + e;
            const zlo = e + (H - zhi);
            this._hi = zhi;
            this._lo = zlo;
            return this;
        }
    }
    selfMultiply() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof DD) {
                const y = arguments[0];
                return this.selfMultiply(y._hi, y._lo);
            } else if (typeof arguments[0] === 'number') {
                const y = arguments[0];
                return this.selfMultiply(y, 0.0);
            }
        } else if (arguments.length === 2) {
            const yhi = arguments[0], ylo = arguments[1];
            let hx = null, tx = null, hy = null, ty = null, C = null, c = null;
            C = DD.SPLIT * this._hi;
            hx = C - this._hi;
            c = DD.SPLIT * yhi;
            hx = C - hx;
            tx = this._hi - hx;
            hy = c - yhi;
            C = this._hi * yhi;
            hy = c - hy;
            ty = yhi - hy;
            c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
            const zhi = C + c;
            hx = C - zhi;
            const zlo = c + hx;
            this._hi = zhi;
            this._lo = zlo;
            return this;
        }
    }
    selfSqr() {
        return this.selfMultiply(this);
    }
    floor() {
        if (this.isNaN()) return DD.NaN;
        const fhi = Math.floor(this._hi);
        let flo = 0.0;
        if (fhi === this._hi) flo = Math.floor(this._lo);
        return new DD(fhi, flo);
    }
    negate() {
        if (this.isNaN()) return this;
        return new DD(-this._hi, -this._lo);
    }
    clone() {
        try {
            return null;
        } catch (ex) {
            if (ex instanceof CloneNotSupportedException) return null;
            else throw ex;
        } finally{}
    }
    intValue() {
        return Math.trunc(this._hi);
    }
    toString() {
        const mag = DD.magnitude(this._hi);
        if (mag >= -3 && mag <= 20) return this.toStandardNotation();
        return this.toSciNotation();
    }
    toStandardNotation() {
        const specialStr = this.getSpecialNumberString();
        if (specialStr !== null) return specialStr;
        const magnitude = new Array(1).fill(null);
        const sigDigits = this.extractSignificantDigits(true, magnitude);
        const decimalPointPos = magnitude[0] + 1;
        let num = sigDigits;
        if (sigDigits.charAt(0) === '.') num = '0' + sigDigits;
        else if (decimalPointPos < 0) num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;
        else if (sigDigits.indexOf('.') === -1) {
            const numZeroes = decimalPointPos - sigDigits.length;
            const zeroes = DD.stringOfChar('0', numZeroes);
            num = sigDigits + zeroes + '.0';
        }
        if (this.isNegative()) return '-' + num;
        return num;
    }
    toSciNotation() {
        if (this.isZero()) return DD.SCI_NOT_ZERO;
        const specialStr = this.getSpecialNumberString();
        if (specialStr !== null) return specialStr;
        const magnitude = new Array(1).fill(null);
        const digits = this.extractSignificantDigits(false, magnitude);
        const expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];
        if (digits.charAt(0) === '0') throw new (0, _illegalStateExceptionJsDefault.default)('Found leading zero: ' + digits);
        let trailingDigits = '';
        if (digits.length > 1) trailingDigits = digits.substring(1);
        const digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;
        if (this.isNegative()) return '-' + digitsWithDecimal + expStr;
        return digitsWithDecimal + expStr;
    }
    abs() {
        if (this.isNaN()) return DD.NaN;
        if (this.isNegative()) return this.negate();
        return new DD(this);
    }
    isPositive() {
        return this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;
    }
    lt(y) {
        return this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;
    }
    add() {
        if (arguments[0] instanceof DD) {
            const y = arguments[0];
            return DD.copy(this).selfAdd(y);
        } else if (typeof arguments[0] === 'number') {
            const y = arguments[0];
            return DD.copy(this).selfAdd(y);
        }
    }
    init() {
        if (arguments.length === 1) {
            if (typeof arguments[0] === 'number') {
                const x = arguments[0];
                this._hi = x;
                this._lo = 0.0;
            } else if (arguments[0] instanceof DD) {
                const dd = arguments[0];
                this._hi = dd._hi;
                this._lo = dd._lo;
            }
        } else if (arguments.length === 2) {
            const hi = arguments[0], lo = arguments[1];
            this._hi = hi;
            this._lo = lo;
        }
    }
    gt(y) {
        return this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;
    }
    isNegative() {
        return this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;
    }
    trunc() {
        if (this.isNaN()) return DD.NaN;
        if (this.isPositive()) return this.floor();
        else return this.ceil();
    }
    signum() {
        if (this._hi > 0) return 1;
        if (this._hi < 0) return -1;
        if (this._lo > 0) return 1;
        if (this._lo < 0) return -1;
        return 0;
    }
    get interfaces_() {
        return [
            (0, _serializableJsDefault.default),
            (0, _comparableJsDefault.default),
            (0, _cloneableJsDefault.default)
        ];
    }
}
exports.default = DD;
DD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);
DD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);
DD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);
DD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);
DD.NaN = new DD((0, _doubleJsDefault.default).NaN, (0, _doubleJsDefault.default).NaN);
DD.EPS = 1.23259516440783e-32;
DD.SPLIT = 134217729.0;
DD.MAX_PRINT_DIGITS = 32;
DD.TEN = DD.valueOf(10.0);
DD.ONE = DD.valueOf(1.0);
DD.SCI_NOT_EXPONENT_CHAR = 'E';
DD.SCI_NOT_ZERO = '0.0E0';

},{"../../../../java/lang/StringBuffer.js":"98maG","../../../../java/lang/Double.js":"clUxd","../../../../java/lang/Integer.js":"b3mDP","../../../../java/lang/Character.js":"8KnaG","../../../../java/lang/Comparable.js":"WFeEu","../../../../java/lang/Cloneable.js":"kAAzr","../../../../java/io/Serializable.js":"5sRbw","../../../../java/lang/IllegalStateException.js":"efv6w","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"98maG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class StringBuffer {
    constructor(str){
        this.str = str;
    }
    append(e) {
        this.str += e;
    }
    setCharAt(i, c) {
        this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
    }
    toString() {
        return this.str;
    }
}
exports.default = StringBuffer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5w2To":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _geometryCollectionJs = require("./GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _puntalJs = require("./Puntal.js");
var _puntalJsDefault = parcelHelpers.interopDefault(_puntalJs);
class MultiPoint extends (0, _geometryCollectionJsDefault.default) {
    constructor(){
        super();
        MultiPoint.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const points = arguments[0], factory = arguments[1];
        (0, _geometryCollectionJsDefault.default).constructor_.call(this, points, factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            return super.equalsExact.call(this, other, tolerance);
        } else return super.equalsExact.apply(this, arguments);
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_MULTIPOINT;
    }
    getDimension() {
        return 0;
    }
    getBoundary() {
        return this.getFactory().createGeometryCollection();
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_MULTIPOINT;
    }
    copyInternal() {
        const points = new Array(this._geometries.length).fill(null);
        for(let i = 0; i < points.length; i++)points[i] = this._geometries[i].copy();
        return new MultiPoint(points, this._factory);
    }
    isValid() {
        return true;
    }
    getCoordinate() {
        if (arguments.length === 1 && Number.isInteger(arguments[0])) {
            const n = arguments[0];
            return this._geometries[n].getCoordinate();
        } else return super.getCoordinate.apply(this, arguments);
    }
    getBoundaryDimension() {
        return (0, _dimensionJsDefault.default).FALSE;
    }
    get interfaces_() {
        return [
            (0, _puntalJsDefault.default)
        ];
    }
}
exports.default = MultiPoint;

},{"./Geometry.js":"9DSzO","./GeometryCollection.js":"6RJQO","./Dimension.js":"kWqD0","./Puntal.js":"e8hBl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lomLd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RelateOp", ()=>(0, _relateOpJsDefault.default));
var _relateOpJs = require("./relate/RelateOp.js");
var _relateOpJsDefault = parcelHelpers.interopDefault(_relateOpJs);

},{"./relate/RelateOp.js":"eho3r","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eho3r":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _relateComputerJs = require("./RelateComputer.js");
var _relateComputerJsDefault = parcelHelpers.interopDefault(_relateComputerJs);
var _geometryGraphOperationJs = require("../GeometryGraphOperation.js");
var _geometryGraphOperationJsDefault = parcelHelpers.interopDefault(_geometryGraphOperationJs);
var _rectangleContainsJs = require("../predicate/RectangleContains.js");
var _rectangleContainsJsDefault = parcelHelpers.interopDefault(_rectangleContainsJs);
var _rectangleIntersectsJs = require("../predicate/RectangleIntersects.js");
var _rectangleIntersectsJsDefault = parcelHelpers.interopDefault(_rectangleIntersectsJs);
class RelateOp extends (0, _geometryGraphOperationJsDefault.default) {
    constructor(){
        super();
        RelateOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._relate = null;
        if (arguments.length === 2) {
            const g0 = arguments[0], g1 = arguments[1];
            (0, _geometryGraphOperationJsDefault.default).constructor_.call(this, g0, g1);
            this._relate = new (0, _relateComputerJsDefault.default)(this._arg);
        } else if (arguments.length === 3) {
            const g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];
            (0, _geometryGraphOperationJsDefault.default).constructor_.call(this, g0, g1, boundaryNodeRule);
            this._relate = new (0, _relateComputerJsDefault.default)(this._arg);
        }
    }
    static equalsTopo(g1, g2) {
        if (!g1.getEnvelopeInternal().equals(g2.getEnvelopeInternal())) return false;
        return RelateOp.relate(g1, g2).isEquals(g1.getDimension(), g2.getDimension());
    }
    static relate() {
        if (arguments.length === 2) {
            const a = arguments[0], b = arguments[1];
            const relOp = new RelateOp(a, b);
            const im = relOp.getIntersectionMatrix();
            return im;
        } else if (arguments.length === 3) {
            const a = arguments[0], b = arguments[1], boundaryNodeRule = arguments[2];
            const relOp = new RelateOp(a, b, boundaryNodeRule);
            const im = relOp.getIntersectionMatrix();
            return im;
        }
    }
    static overlaps(g1, g2) {
        if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
        return new RelateOp(g1, g2).getIntersectionMatrix().isOverlaps(g1.getDimension(), g2.getDimension());
    }
    static disjoint(g1, g2) {
        return !RelateOp.intersects(g1, g2);
    }
    static covers(g1, g2) {
        if (g2.getDimension() === 2 && g1.getDimension() < 2) return false;
        if (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) return false;
        if (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;
        if (g1.isRectangle()) return true;
        return new RelateOp(g1, g2).getIntersectionMatrix().isCovers();
    }
    static intersects(g1, g2) {
        if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
        if (g1.isRectangle()) return (0, _rectangleIntersectsJsDefault.default).intersects(g1, g2);
        if (g2.isRectangle()) return (0, _rectangleIntersectsJsDefault.default).intersects(g2, g1);
        if (g1.isGeometryCollection() || g2.isGeometryCollection()) {
            const r = false;
            for(let i = 0; i < g1.getNumGeometries(); i++)for(let j = 0; j < g2.getNumGeometries(); j++)if (RelateOp.intersects(g1.getGeometryN(i), g2.getGeometryN(j))) return true;
            return false;
        }
        return new RelateOp(g1, g2).getIntersectionMatrix().isIntersects();
    }
    static touches(g1, g2) {
        if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
        return new RelateOp(g1, g2).getIntersectionMatrix().isTouches(g1.getDimension(), g2.getDimension());
    }
    static crosses(g1, g2) {
        if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
        return new RelateOp(g1, g2).getIntersectionMatrix().isCrosses(g1.getDimension(), g2.getDimension());
    }
    static contains(g1, g2) {
        if (g2.getDimension() === 2 && g1.getDimension() < 2) return false;
        if (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) return false;
        if (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;
        if (g1.isRectangle()) return (0, _rectangleContainsJsDefault.default).contains(g1, g2);
        return new RelateOp(g1, g2).getIntersectionMatrix().isContains();
    }
    getIntersectionMatrix() {
        return this._relate.computeIM();
    }
}
exports.default = RelateOp;

},{"./RelateComputer.js":"3gKRh","../GeometryGraphOperation.js":"3eQ0s","../predicate/RectangleContains.js":"61hKF","../predicate/RectangleIntersects.js":"eB5Iy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3gKRh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _intersectionMatrixJs = require("../../geom/IntersectionMatrix.js");
var _intersectionMatrixJsDefault = parcelHelpers.interopDefault(_intersectionMatrixJs);
var _edgeEndBuilderJs = require("./EdgeEndBuilder.js");
var _edgeEndBuilderJsDefault = parcelHelpers.interopDefault(_edgeEndBuilderJs);
var _nodeMapJs = require("../../geomgraph/NodeMap.js");
var _nodeMapJsDefault = parcelHelpers.interopDefault(_nodeMapJs);
var _relateNodeFactoryJs = require("./RelateNodeFactory.js");
var _relateNodeFactoryJsDefault = parcelHelpers.interopDefault(_relateNodeFactoryJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _pointLocatorJs = require("../../algorithm/PointLocator.js");
var _pointLocatorJsDefault = parcelHelpers.interopDefault(_pointLocatorJs);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _robustLineIntersectorJs = require("../../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
class RelateComputer {
    constructor(){
        RelateComputer.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._ptLocator = new (0, _pointLocatorJsDefault.default)();
        this._arg = null;
        this._nodes = new (0, _nodeMapJsDefault.default)(new (0, _relateNodeFactoryJsDefault.default)());
        this._im = null;
        this._isolatedEdges = new (0, _arrayListJsDefault.default)();
        this._invalidPoint = null;
        const arg = arguments[0];
        this._arg = arg;
    }
    insertEdgeEnds(ee) {
        for(let i = ee.iterator(); i.hasNext();){
            const e = i.next();
            this._nodes.add(e);
        }
    }
    computeProperIntersectionIM(intersector, im) {
        const dimA = this._arg[0].getGeometry().getDimension();
        const dimB = this._arg[1].getGeometry().getDimension();
        const hasProper = intersector.hasProperIntersection();
        const hasProperInterior = intersector.hasProperInteriorIntersection();
        if (dimA === 2 && dimB === 2) {
            if (hasProper) im.setAtLeast('212101212');
        } else if (dimA === 2 && dimB === 1) {
            if (hasProper) im.setAtLeast('FFF0FFFF2');
            if (hasProperInterior) im.setAtLeast('1FFFFF1FF');
        } else if (dimA === 1 && dimB === 2) {
            if (hasProper) im.setAtLeast('F0FFFFFF2');
            if (hasProperInterior) im.setAtLeast('1F1FFFFFF');
        } else if (dimA === 1 && dimB === 1) {
            if (hasProperInterior) im.setAtLeast('0FFFFFFFF');
        }
    }
    labelIsolatedEdges(thisIndex, targetIndex) {
        for(let ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext();){
            const e = ei.next();
            if (e.isIsolated()) {
                this.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());
                this._isolatedEdges.add(e);
            }
        }
    }
    labelIsolatedEdge(e, targetIndex, target) {
        if (target.getDimension() > 0) {
            const loc = this._ptLocator.locate(e.getCoordinate(), target);
            e.getLabel().setAllLocations(targetIndex, loc);
        } else e.getLabel().setAllLocations(targetIndex, (0, _locationJsDefault.default).EXTERIOR);
    }
    computeIM() {
        const im = new (0, _intersectionMatrixJsDefault.default)();
        im.set((0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).EXTERIOR, 2);
        if (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {
            this.computeDisjointIM(im);
            return im;
        }
        this._arg[0].computeSelfNodes(this._li, false);
        this._arg[1].computeSelfNodes(this._li, false);
        const intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);
        this.computeIntersectionNodes(0);
        this.computeIntersectionNodes(1);
        this.copyNodesAndLabels(0);
        this.copyNodesAndLabels(1);
        this.labelIsolatedNodes();
        this.computeProperIntersectionIM(intersector, im);
        const eeBuilder = new (0, _edgeEndBuilderJsDefault.default)();
        const ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());
        this.insertEdgeEnds(ee0);
        const ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());
        this.insertEdgeEnds(ee1);
        this.labelNodeEdges();
        this.labelIsolatedEdges(0, 1);
        this.labelIsolatedEdges(1, 0);
        this.updateIM(im);
        return im;
    }
    labelNodeEdges() {
        for(let ni = this._nodes.iterator(); ni.hasNext();){
            const node = ni.next();
            node.getEdges().computeLabelling(this._arg);
        }
    }
    copyNodesAndLabels(argIndex) {
        for(let i = this._arg[argIndex].getNodeIterator(); i.hasNext();){
            const graphNode = i.next();
            const newNode = this._nodes.addNode(graphNode.getCoordinate());
            newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
        }
    }
    labelIntersectionNodes(argIndex) {
        for(let i = this._arg[argIndex].getEdgeIterator(); i.hasNext();){
            const e = i.next();
            const eLoc = e.getLabel().getLocation(argIndex);
            for(let eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();){
                const ei = eiIt.next();
                const n = this._nodes.find(ei.coord);
                if (n.getLabel().isNull(argIndex)) {
                    if (eLoc === (0, _locationJsDefault.default).BOUNDARY) n.setLabelBoundary(argIndex);
                    else n.setLabel(argIndex, (0, _locationJsDefault.default).INTERIOR);
                }
            }
        }
    }
    labelIsolatedNode(n, targetIndex) {
        const loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
        n.getLabel().setAllLocations(targetIndex, loc);
    }
    computeIntersectionNodes(argIndex) {
        for(let i = this._arg[argIndex].getEdgeIterator(); i.hasNext();){
            const e = i.next();
            const eLoc = e.getLabel().getLocation(argIndex);
            for(let eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();){
                const ei = eiIt.next();
                const n = this._nodes.addNode(ei.coord);
                if (eLoc === (0, _locationJsDefault.default).BOUNDARY) n.setLabelBoundary(argIndex);
                else if (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, (0, _locationJsDefault.default).INTERIOR);
            }
        }
    }
    labelIsolatedNodes() {
        for(let ni = this._nodes.iterator(); ni.hasNext();){
            const n = ni.next();
            const label = n.getLabel();
            (0, _assertJsDefault.default).isTrue(label.getGeometryCount() > 0, 'node with empty label found');
            if (n.isIsolated()) {
                if (label.isNull(0)) this.labelIsolatedNode(n, 0);
                else this.labelIsolatedNode(n, 1);
            }
        }
    }
    updateIM(im) {
        for(let ei = this._isolatedEdges.iterator(); ei.hasNext();){
            const e = ei.next();
            e.updateIM(im);
        }
        for(let ni = this._nodes.iterator(); ni.hasNext();){
            const node = ni.next();
            node.updateIM(im);
            node.updateIMFromEdges(im);
        }
    }
    computeDisjointIM(im) {
        const ga = this._arg[0].getGeometry();
        if (!ga.isEmpty()) {
            im.set((0, _locationJsDefault.default).INTERIOR, (0, _locationJsDefault.default).EXTERIOR, ga.getDimension());
            im.set((0, _locationJsDefault.default).BOUNDARY, (0, _locationJsDefault.default).EXTERIOR, ga.getBoundaryDimension());
        }
        const gb = this._arg[1].getGeometry();
        if (!gb.isEmpty()) {
            im.set((0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR, gb.getDimension());
            im.set((0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).BOUNDARY, gb.getBoundaryDimension());
        }
    }
}
exports.default = RelateComputer;

},{"../../geom/IntersectionMatrix.js":"7t1VF","./EdgeEndBuilder.js":"jC95Q","../../geomgraph/NodeMap.js":"2ZFXA","./RelateNodeFactory.js":"7Dxyv","../../util/Assert.js":"1vSRy","../../algorithm/PointLocator.js":"lFmUP","../../geom/Location.js":"9aPCX","../../../../../java/util/ArrayList.js":"gGAQZ","../../algorithm/RobustLineIntersector.js":"kLdG9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7t1VF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("./Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _cloneableJs = require("../../../../java/lang/Cloneable.js");
var _cloneableJsDefault = parcelHelpers.interopDefault(_cloneableJs);
var _stringBuilderJs = require("../../../../java/lang/StringBuilder.js");
var _stringBuilderJsDefault = parcelHelpers.interopDefault(_stringBuilderJs);
class IntersectionMatrix {
    constructor(){
        IntersectionMatrix.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._matrix = null;
        if (arguments.length === 0) {
            this._matrix = Array(3).fill().map(()=>Array(3));
            this.setAll((0, _dimensionJsDefault.default).FALSE);
        } else if (arguments.length === 1) {
            if (typeof arguments[0] === 'string') {
                const elements = arguments[0];
                IntersectionMatrix.constructor_.call(this);
                this.set(elements);
            } else if (arguments[0] instanceof IntersectionMatrix) {
                const other = arguments[0];
                IntersectionMatrix.constructor_.call(this);
                this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR] = other._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR];
                this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY] = other._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY];
                this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR] = other._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR];
                this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR] = other._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR];
                this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY] = other._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY];
                this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).EXTERIOR] = other._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).EXTERIOR];
                this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR] = other._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR];
                this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).BOUNDARY] = other._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).BOUNDARY];
                this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).EXTERIOR] = other._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).EXTERIOR];
            }
        }
    }
    static isTrue(actualDimensionValue) {
        if (actualDimensionValue >= 0 || actualDimensionValue === (0, _dimensionJsDefault.default).TRUE) return true;
        return false;
    }
    static matches() {
        if (Number.isInteger(arguments[0]) && typeof arguments[1] === 'string') {
            const actualDimensionValue = arguments[0], requiredDimensionSymbol = arguments[1];
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_DONTCARE) return true;
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === (0, _dimensionJsDefault.default).TRUE)) return true;
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_FALSE && actualDimensionValue === (0, _dimensionJsDefault.default).FALSE) return true;
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_P && actualDimensionValue === (0, _dimensionJsDefault.default).P) return true;
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_L && actualDimensionValue === (0, _dimensionJsDefault.default).L) return true;
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_A && actualDimensionValue === (0, _dimensionJsDefault.default).A) return true;
            return false;
        } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'string') {
            const actualDimensionSymbols = arguments[0], requiredDimensionSymbols = arguments[1];
            const m = new IntersectionMatrix(actualDimensionSymbols);
            return m.matches(requiredDimensionSymbols);
        }
    }
    isIntersects() {
        return !this.isDisjoint();
    }
    set() {
        if (arguments.length === 1) {
            const dimensionSymbols = arguments[0];
            for(let i = 0; i < dimensionSymbols.length; i++){
                const row = Math.trunc(i / 3);
                const col = i % 3;
                this._matrix[row][col] = (0, _dimensionJsDefault.default).toDimensionValue(dimensionSymbols.charAt(i));
            }
        } else if (arguments.length === 3) {
            const row = arguments[0], column = arguments[1], dimensionValue = arguments[2];
            this._matrix[row][column] = dimensionValue;
        }
    }
    isContains() {
        return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).BOUNDARY] === (0, _dimensionJsDefault.default).FALSE;
    }
    isWithin() {
        return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE;
    }
    isTouches(dimensionOfGeometryA, dimensionOfGeometryB) {
        if (dimensionOfGeometryA > dimensionOfGeometryB) return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).A && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A || dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L || dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A || dimensionOfGeometryA === (0, _dimensionJsDefault.default).P && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A || dimensionOfGeometryA === (0, _dimensionJsDefault.default).P && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L) return this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && (IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY]));
        return false;
    }
    isOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).P && dimensionOfGeometryB === (0, _dimensionJsDefault.default).P || dimensionOfGeometryA === (0, _dimensionJsDefault.default).A && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A) return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR]);
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L) return this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR]);
        return false;
    }
    isEquals(dimensionOfGeometryA, dimensionOfGeometryB) {
        if (dimensionOfGeometryA !== dimensionOfGeometryB) return false;
        return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).BOUNDARY] === (0, _dimensionJsDefault.default).FALSE;
    }
    matches(requiredDimensionSymbols) {
        if (requiredDimensionSymbols.length !== 9) throw new (0, _illegalArgumentExceptionJsDefault.default)('Should be length 9: ' + requiredDimensionSymbols);
        for(let ai = 0; ai < 3; ai++)for(let bi = 0; bi < 3; bi++)if (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) return false;
        return true;
    }
    add(im) {
        for(let i = 0; i < 3; i++)for(let j = 0; j < 3; j++)this.setAtLeast(i, j, im.get(i, j));
    }
    isDisjoint() {
        return this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY] === (0, _dimensionJsDefault.default).FALSE;
    }
    isCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).P && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L || dimensionOfGeometryA === (0, _dimensionJsDefault.default).P && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A || dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A) return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR]);
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).P || dimensionOfGeometryA === (0, _dimensionJsDefault.default).A && dimensionOfGeometryB === (0, _dimensionJsDefault.default).P || dimensionOfGeometryA === (0, _dimensionJsDefault.default).A && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L) return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR]);
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L) return this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR] === 0;
        return false;
    }
    isCovers() {
        const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY]);
        return hasPointInCommon && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).BOUNDARY] === (0, _dimensionJsDefault.default).FALSE;
    }
    isCoveredBy() {
        const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY]);
        return hasPointInCommon && this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE;
    }
    setAtLeast() {
        if (arguments.length === 1) {
            const minimumDimensionSymbols = arguments[0];
            for(let i = 0; i < minimumDimensionSymbols.length; i++){
                const row = Math.trunc(i / 3);
                const col = i % 3;
                this.setAtLeast(row, col, (0, _dimensionJsDefault.default).toDimensionValue(minimumDimensionSymbols.charAt(i)));
            }
        } else if (arguments.length === 3) {
            const row = arguments[0], column = arguments[1], minimumDimensionValue = arguments[2];
            if (this._matrix[row][column] < minimumDimensionValue) this._matrix[row][column] = minimumDimensionValue;
        }
    }
    setAtLeastIfValid(row, column, minimumDimensionValue) {
        if (row >= 0 && column >= 0) this.setAtLeast(row, column, minimumDimensionValue);
    }
    toString() {
        const builder = new (0, _stringBuilderJsDefault.default)('123456789');
        for(let ai = 0; ai < 3; ai++)for(let bi = 0; bi < 3; bi++)builder.setCharAt(3 * ai + bi, (0, _dimensionJsDefault.default).toDimensionSymbol(this._matrix[ai][bi]));
        return builder.toString();
    }
    setAll(dimensionValue) {
        for(let ai = 0; ai < 3; ai++)for(let bi = 0; bi < 3; bi++)this._matrix[ai][bi] = dimensionValue;
    }
    get(row, column) {
        return this._matrix[row][column];
    }
    transpose() {
        let temp = this._matrix[1][0];
        this._matrix[1][0] = this._matrix[0][1];
        this._matrix[0][1] = temp;
        temp = this._matrix[2][0];
        this._matrix[2][0] = this._matrix[0][2];
        this._matrix[0][2] = temp;
        temp = this._matrix[2][1];
        this._matrix[2][1] = this._matrix[1][2];
        this._matrix[1][2] = temp;
        return this;
    }
    get interfaces_() {
        return [
            (0, _cloneableJsDefault.default)
        ];
    }
}
exports.default = IntersectionMatrix;

},{"./Location.js":"9aPCX","../../../../java/lang/IllegalArgumentException.js":"9ppVW","./Dimension.js":"kWqD0","../../../../java/lang/Cloneable.js":"kAAzr","../../../../java/lang/StringBuilder.js":"30Zhx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9aPCX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class Location {
    static toLocationSymbol(locationValue) {
        switch(locationValue){
            case Location.EXTERIOR:
                return 'e';
            case Location.BOUNDARY:
                return 'b';
            case Location.INTERIOR:
                return 'i';
            case Location.NONE:
                return '-';
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Unknown location value: ' + locationValue);
    }
}
exports.default = Location;
Location.INTERIOR = 0;
Location.BOUNDARY = 1;
Location.EXTERIOR = 2;
Location.NONE = -1;

},{"../../../../java/lang/IllegalArgumentException.js":"9ppVW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jC95Q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeEndJs = require("../../geomgraph/EdgeEnd.js");
var _edgeEndJsDefault = parcelHelpers.interopDefault(_edgeEndJs);
var _labelJs = require("../../geomgraph/Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class EdgeEndBuilder {
    computeEdgeEnds() {
        if (arguments.length === 1) {
            const edges = arguments[0];
            const l = new (0, _arrayListJsDefault.default)();
            for(let i = edges; i.hasNext();){
                const e = i.next();
                this.computeEdgeEnds(e, l);
            }
            return l;
        } else if (arguments.length === 2) {
            const edge = arguments[0], l = arguments[1];
            const eiList = edge.getEdgeIntersectionList();
            eiList.addEndpoints();
            const it = eiList.iterator();
            let eiPrev = null;
            let eiCurr = null;
            if (!it.hasNext()) return null;
            let eiNext = it.next();
            do {
                eiPrev = eiCurr;
                eiCurr = eiNext;
                eiNext = null;
                if (it.hasNext()) eiNext = it.next();
                if (eiCurr !== null) {
                    this.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);
                    this.createEdgeEndForNext(edge, l, eiCurr, eiNext);
                }
            }while (eiCurr !== null);
        }
    }
    createEdgeEndForNext(edge, l, eiCurr, eiNext) {
        const iNext = eiCurr.segmentIndex + 1;
        if (iNext >= edge.getNumPoints() && eiNext === null) return null;
        let pNext = edge.getCoordinate(iNext);
        if (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;
        const e = new (0, _edgeEndJsDefault.default)(edge, eiCurr.coord, pNext, new (0, _labelJsDefault.default)(edge.getLabel()));
        l.add(e);
    }
    createEdgeEndForPrev(edge, l, eiCurr, eiPrev) {
        let iPrev = eiCurr.segmentIndex;
        if (eiCurr.dist === 0.0) {
            if (iPrev === 0) return null;
            iPrev--;
        }
        let pPrev = edge.getCoordinate(iPrev);
        if (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;
        const label = new (0, _labelJsDefault.default)(edge.getLabel());
        label.flip();
        const e = new (0, _edgeEndJsDefault.default)(edge, eiCurr.coord, pPrev, label);
        l.add(e);
    }
}
exports.default = EdgeEndBuilder;

},{"../../geomgraph/EdgeEnd.js":"5lYIw","../../geomgraph/Label.js":"dJJOo","../../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5lYIw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _quadrantJs = require("./Quadrant.js");
var _quadrantJsDefault = parcelHelpers.interopDefault(_quadrantJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class EdgeEnd {
    constructor(){
        EdgeEnd.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._edge = null;
        this._label = null;
        this._node = null;
        this._p0 = null;
        this._p1 = null;
        this._dx = null;
        this._dy = null;
        this._quadrant = null;
        if (arguments.length === 1) {
            const edge = arguments[0];
            this._edge = edge;
        } else if (arguments.length === 3) {
            const edge = arguments[0], p0 = arguments[1], p1 = arguments[2];
            EdgeEnd.constructor_.call(this, edge, p0, p1, null);
        } else if (arguments.length === 4) {
            const edge = arguments[0], p0 = arguments[1], p1 = arguments[2], label = arguments[3];
            EdgeEnd.constructor_.call(this, edge);
            this.init(p0, p1);
            this._label = label;
        }
    }
    compareDirection(e) {
        if (this._dx === e._dx && this._dy === e._dy) return 0;
        if (this._quadrant > e._quadrant) return 1;
        if (this._quadrant < e._quadrant) return -1;
        return (0, _orientationJsDefault.default).index(e._p0, e._p1, this._p1);
    }
    getDy() {
        return this._dy;
    }
    print(out) {
        const angle = Math.atan2(this._dy, this._dx);
        const className = this.getClass().getName();
        const lastDotPos = className.lastIndexOf('.');
        const name = className.substring(lastDotPos + 1);
        out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);
    }
    getLabel() {
        return this._label;
    }
    getEdge() {
        return this._edge;
    }
    toString() {
        const angle = Math.atan2(this._dy, this._dx);
        const className = this.getClass().getName();
        const lastDotPos = className.lastIndexOf('.');
        const name = className.substring(lastDotPos + 1);
        return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label;
    }
    computeLabel(boundaryNodeRule) {}
    init(p0, p1) {
        this._p0 = p0;
        this._p1 = p1;
        this._dx = p1.x - p0.x;
        this._dy = p1.y - p0.y;
        this._quadrant = (0, _quadrantJsDefault.default).quadrant(this._dx, this._dy);
        (0, _assertJsDefault.default).isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');
    }
    getCoordinate() {
        return this._p0;
    }
    setNode(node) {
        this._node = node;
    }
    compareTo(obj) {
        const e = obj;
        return this.compareDirection(e);
    }
    getDirectedCoordinate() {
        return this._p1;
    }
    getDx() {
        return this._dx;
    }
    getQuadrant() {
        return this._quadrant;
    }
    getNode() {
        return this._node;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = EdgeEnd;

},{"../algorithm/Orientation.js":"avl08","../../../../java/lang/Comparable.js":"WFeEu","./Quadrant.js":"86Qmh","../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"86Qmh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class Quadrant {
    static isNorthern(quad) {
        return quad === Quadrant.NE || quad === Quadrant.NW;
    }
    static isOpposite(quad1, quad2) {
        if (quad1 === quad2) return false;
        const diff = (quad1 - quad2 + 4) % 4;
        if (diff === 2) return true;
        return false;
    }
    static commonHalfPlane(quad1, quad2) {
        if (quad1 === quad2) return quad1;
        const diff = (quad1 - quad2 + 4) % 4;
        if (diff === 2) return -1;
        const min = quad1 < quad2 ? quad1 : quad2;
        const max = quad1 > quad2 ? quad1 : quad2;
        if (min === 0 && max === 3) return 3;
        return min;
    }
    static isInHalfPlane(quad, halfPlane) {
        if (halfPlane === Quadrant.SE) return quad === Quadrant.SE || quad === Quadrant.SW;
        return quad === halfPlane || quad === halfPlane + 1;
    }
    static quadrant() {
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            const dx = arguments[0], dy = arguments[1];
            if (dx === 0.0 && dy === 0.0) throw new (0, _illegalArgumentExceptionJsDefault.default)('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )');
            if (dx >= 0.0) {
                if (dy >= 0.0) return Quadrant.NE;
                else return Quadrant.SE;
            } else if (dy >= 0.0) return Quadrant.NW;
            else return Quadrant.SW;
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
            const p0 = arguments[0], p1 = arguments[1];
            if (p1.x === p0.x && p1.y === p0.y) throw new (0, _illegalArgumentExceptionJsDefault.default)('Cannot compute the quadrant for two identical points ' + p0);
            if (p1.x >= p0.x) {
                if (p1.y >= p0.y) return Quadrant.NE;
                else return Quadrant.SE;
            } else if (p1.y >= p0.y) return Quadrant.NW;
            else return Quadrant.SW;
        }
    }
}
exports.default = Quadrant;
Quadrant.NE = 0;
Quadrant.NW = 1;
Quadrant.SW = 2;
Quadrant.SE = 3;

},{"../geom/Coordinate.js":"ii2fh","../../../../java/lang/IllegalArgumentException.js":"9ppVW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dJJOo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stringBufferJs = require("../../../../java/lang/StringBuffer.js");
var _stringBufferJsDefault = parcelHelpers.interopDefault(_stringBufferJs);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _topologyLocationJs = require("./TopologyLocation.js");
var _topologyLocationJsDefault = parcelHelpers.interopDefault(_topologyLocationJs);
class Label {
    constructor(){
        Label.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.elt = new Array(2).fill(null);
        if (arguments.length === 1) {
            if (Number.isInteger(arguments[0])) {
                const onLoc = arguments[0];
                this.elt[0] = new (0, _topologyLocationJsDefault.default)(onLoc);
                this.elt[1] = new (0, _topologyLocationJsDefault.default)(onLoc);
            } else if (arguments[0] instanceof Label) {
                const lbl = arguments[0];
                this.elt[0] = new (0, _topologyLocationJsDefault.default)(lbl.elt[0]);
                this.elt[1] = new (0, _topologyLocationJsDefault.default)(lbl.elt[1]);
            }
        } else if (arguments.length === 2) {
            const geomIndex = arguments[0], onLoc = arguments[1];
            this.elt[0] = new (0, _topologyLocationJsDefault.default)((0, _locationJsDefault.default).NONE);
            this.elt[1] = new (0, _topologyLocationJsDefault.default)((0, _locationJsDefault.default).NONE);
            this.elt[geomIndex].setLocation(onLoc);
        } else if (arguments.length === 3) {
            const onLoc = arguments[0], leftLoc = arguments[1], rightLoc = arguments[2];
            this.elt[0] = new (0, _topologyLocationJsDefault.default)(onLoc, leftLoc, rightLoc);
            this.elt[1] = new (0, _topologyLocationJsDefault.default)(onLoc, leftLoc, rightLoc);
        } else if (arguments.length === 4) {
            const geomIndex = arguments[0], onLoc = arguments[1], leftLoc = arguments[2], rightLoc = arguments[3];
            this.elt[0] = new (0, _topologyLocationJsDefault.default)((0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE);
            this.elt[1] = new (0, _topologyLocationJsDefault.default)((0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE);
            this.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);
        }
    }
    static toLineLabel(label) {
        const lineLabel = new Label((0, _locationJsDefault.default).NONE);
        for(let i = 0; i < 2; i++)lineLabel.setLocation(i, label.getLocation(i));
        return lineLabel;
    }
    getGeometryCount() {
        let count = 0;
        if (!this.elt[0].isNull()) count++;
        if (!this.elt[1].isNull()) count++;
        return count;
    }
    setAllLocations(geomIndex, location) {
        this.elt[geomIndex].setAllLocations(location);
    }
    isNull(geomIndex) {
        return this.elt[geomIndex].isNull();
    }
    setAllLocationsIfNull() {
        if (arguments.length === 1) {
            const location = arguments[0];
            this.setAllLocationsIfNull(0, location);
            this.setAllLocationsIfNull(1, location);
        } else if (arguments.length === 2) {
            const geomIndex = arguments[0], location = arguments[1];
            this.elt[geomIndex].setAllLocationsIfNull(location);
        }
    }
    isLine(geomIndex) {
        return this.elt[geomIndex].isLine();
    }
    merge(lbl) {
        for(let i = 0; i < 2; i++)if (this.elt[i] === null && lbl.elt[i] !== null) this.elt[i] = new (0, _topologyLocationJsDefault.default)(lbl.elt[i]);
        else this.elt[i].merge(lbl.elt[i]);
    }
    flip() {
        this.elt[0].flip();
        this.elt[1].flip();
    }
    getLocation() {
        if (arguments.length === 1) {
            const geomIndex = arguments[0];
            return this.elt[geomIndex].get((0, _positionJsDefault.default).ON);
        } else if (arguments.length === 2) {
            const geomIndex = arguments[0], posIndex = arguments[1];
            return this.elt[geomIndex].get(posIndex);
        }
    }
    toString() {
        const buf = new (0, _stringBufferJsDefault.default)();
        if (this.elt[0] !== null) {
            buf.append('A:');
            buf.append(this.elt[0].toString());
        }
        if (this.elt[1] !== null) {
            buf.append(' B:');
            buf.append(this.elt[1].toString());
        }
        return buf.toString();
    }
    setLocation() {
        if (arguments.length === 2) {
            const geomIndex = arguments[0], location = arguments[1];
            this.elt[geomIndex].setLocation((0, _positionJsDefault.default).ON, location);
        } else if (arguments.length === 3) {
            const geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];
            this.elt[geomIndex].setLocation(posIndex, location);
        }
    }
    isEqualOnSide(lbl, side) {
        return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);
    }
    allPositionsEqual(geomIndex, loc) {
        return this.elt[geomIndex].allPositionsEqual(loc);
    }
    toLine(geomIndex) {
        if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new (0, _topologyLocationJsDefault.default)(this.elt[geomIndex].location[0]);
    }
    isArea() {
        if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea();
        else if (arguments.length === 1) {
            const geomIndex = arguments[0];
            return this.elt[geomIndex].isArea();
        }
    }
    isAnyNull(geomIndex) {
        return this.elt[geomIndex].isAnyNull();
    }
}
exports.default = Label;

},{"../../../../java/lang/StringBuffer.js":"98maG","../geom/Location.js":"9aPCX","./Position.js":"13raO","./TopologyLocation.js":"8HJrP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"13raO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Position {
    static opposite(position) {
        if (position === Position.LEFT) return Position.RIGHT;
        if (position === Position.RIGHT) return Position.LEFT;
        return position;
    }
}
exports.default = Position;
Position.ON = 0;
Position.LEFT = 1;
Position.RIGHT = 2;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8HJrP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stringBufferJs = require("../../../../java/lang/StringBuffer.js");
var _stringBufferJsDefault = parcelHelpers.interopDefault(_stringBufferJs);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
class TopologyLocation {
    constructor(){
        TopologyLocation.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.location = null;
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const location = arguments[0];
                this.init(location.length);
            } else if (Number.isInteger(arguments[0])) {
                const on = arguments[0];
                this.init(1);
                this.location[(0, _positionJsDefault.default).ON] = on;
            } else if (arguments[0] instanceof TopologyLocation) {
                const gl = arguments[0];
                this.init(gl.location.length);
                if (gl !== null) for(let i = 0; i < this.location.length; i++)this.location[i] = gl.location[i];
            }
        } else if (arguments.length === 3) {
            const on = arguments[0], left = arguments[1], right = arguments[2];
            this.init(3);
            this.location[(0, _positionJsDefault.default).ON] = on;
            this.location[(0, _positionJsDefault.default).LEFT] = left;
            this.location[(0, _positionJsDefault.default).RIGHT] = right;
        }
    }
    setAllLocations(locValue) {
        for(let i = 0; i < this.location.length; i++)this.location[i] = locValue;
    }
    isNull() {
        for(let i = 0; i < this.location.length; i++)if (this.location[i] !== (0, _locationJsDefault.default).NONE) return false;
        return true;
    }
    setAllLocationsIfNull(locValue) {
        for(let i = 0; i < this.location.length; i++)if (this.location[i] === (0, _locationJsDefault.default).NONE) this.location[i] = locValue;
    }
    isLine() {
        return this.location.length === 1;
    }
    merge(gl) {
        if (gl.location.length > this.location.length) {
            const newLoc = new Array(3).fill(null);
            newLoc[(0, _positionJsDefault.default).ON] = this.location[(0, _positionJsDefault.default).ON];
            newLoc[(0, _positionJsDefault.default).LEFT] = (0, _locationJsDefault.default).NONE;
            newLoc[(0, _positionJsDefault.default).RIGHT] = (0, _locationJsDefault.default).NONE;
            this.location = newLoc;
        }
        for(let i = 0; i < this.location.length; i++)if (this.location[i] === (0, _locationJsDefault.default).NONE && i < gl.location.length) this.location[i] = gl.location[i];
    }
    getLocations() {
        return this.location;
    }
    flip() {
        if (this.location.length <= 1) return null;
        const temp = this.location[(0, _positionJsDefault.default).LEFT];
        this.location[(0, _positionJsDefault.default).LEFT] = this.location[(0, _positionJsDefault.default).RIGHT];
        this.location[(0, _positionJsDefault.default).RIGHT] = temp;
    }
    get(posIndex) {
        if (posIndex < this.location.length) return this.location[posIndex];
        return (0, _locationJsDefault.default).NONE;
    }
    isEqualOnSide(le, locIndex) {
        return this.location[locIndex] === le.location[locIndex];
    }
    allPositionsEqual(loc) {
        for(let i = 0; i < this.location.length; i++)if (this.location[i] !== loc) return false;
        return true;
    }
    toString() {
        const buf = new (0, _stringBufferJsDefault.default)();
        if (this.location.length > 1) buf.append((0, _locationJsDefault.default).toLocationSymbol(this.location[(0, _positionJsDefault.default).LEFT]));
        buf.append((0, _locationJsDefault.default).toLocationSymbol(this.location[(0, _positionJsDefault.default).ON]));
        if (this.location.length > 1) buf.append((0, _locationJsDefault.default).toLocationSymbol(this.location[(0, _positionJsDefault.default).RIGHT]));
        return buf.toString();
    }
    setLocations(on, left, right) {
        this.location[(0, _positionJsDefault.default).ON] = on;
        this.location[(0, _positionJsDefault.default).LEFT] = left;
        this.location[(0, _positionJsDefault.default).RIGHT] = right;
    }
    isArea() {
        return this.location.length > 1;
    }
    isAnyNull() {
        for(let i = 0; i < this.location.length; i++)if (this.location[i] === (0, _locationJsDefault.default).NONE) return true;
        return false;
    }
    setLocation() {
        if (arguments.length === 1) {
            const locValue = arguments[0];
            this.setLocation((0, _positionJsDefault.default).ON, locValue);
        } else if (arguments.length === 2) {
            const locIndex = arguments[0], locValue = arguments[1];
            this.location[locIndex] = locValue;
        }
    }
    init(size) {
        this.location = new Array(size).fill(null);
        this.setAllLocations((0, _locationJsDefault.default).NONE);
    }
}
exports.default = TopologyLocation;

},{"../../../../java/lang/StringBuffer.js":"98maG","../geom/Location.js":"9aPCX","./Position.js":"13raO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2ZFXA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _nodeJs = require("./Node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _treeMapJs = require("../../../../java/util/TreeMap.js");
var _treeMapJsDefault = parcelHelpers.interopDefault(_treeMapJs);
class NodeMap {
    constructor(){
        NodeMap.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.nodeMap = new (0, _treeMapJsDefault.default)();
        this.nodeFact = null;
        const nodeFact = arguments[0];
        this.nodeFact = nodeFact;
    }
    print(out) {
        for(let it = this.iterator(); it.hasNext();){
            const n = it.next();
            n.print(out);
        }
    }
    iterator() {
        return this.nodeMap.values().iterator();
    }
    values() {
        return this.nodeMap.values();
    }
    getBoundaryNodes(geomIndex) {
        const bdyNodes = new (0, _arrayListJsDefault.default)();
        for(let i = this.iterator(); i.hasNext();){
            const node = i.next();
            if (node.getLabel().getLocation(geomIndex) === (0, _locationJsDefault.default).BOUNDARY) bdyNodes.add(node);
        }
        return bdyNodes;
    }
    add(e) {
        const p = e.getCoordinate();
        const n = this.addNode(p);
        n.add(e);
    }
    find(coord) {
        return this.nodeMap.get(coord);
    }
    addNode() {
        if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const coord = arguments[0];
            let node = this.nodeMap.get(coord);
            if (node === null) {
                node = this.nodeFact.createNode(coord);
                this.nodeMap.put(coord, node);
            }
            return node;
        } else if (arguments[0] instanceof (0, _nodeJsDefault.default)) {
            const n = arguments[0];
            const node = this.nodeMap.get(n.getCoordinate());
            if (node === null) {
                this.nodeMap.put(n.getCoordinate(), n);
                return n;
            }
            node.mergeLabel(n);
            return node;
        }
    }
}
exports.default = NodeMap;

},{"../geom/Location.js":"9aPCX","../geom/Coordinate.js":"ii2fh","./Node.js":"azV0J","../../../../java/util/ArrayList.js":"gGAQZ","../../../../java/util/TreeMap.js":"dQNYS","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"azV0J":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _graphComponentJs = require("./GraphComponent.js");
var _graphComponentJsDefault = parcelHelpers.interopDefault(_graphComponentJs);
class Node extends (0, _graphComponentJsDefault.default) {
    constructor(){
        super();
        Node.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._coord = null;
        this._edges = null;
        const coord = arguments[0], edges = arguments[1];
        this._coord = coord;
        this._edges = edges;
        this._label = new (0, _labelJsDefault.default)(0, (0, _locationJsDefault.default).NONE);
    }
    isIncidentEdgeInResult() {
        for(let it = this.getEdges().getEdges().iterator(); it.hasNext();){
            const de = it.next();
            if (de.getEdge().isInResult()) return true;
        }
        return false;
    }
    isIsolated() {
        return this._label.getGeometryCount() === 1;
    }
    getCoordinate() {
        return this._coord;
    }
    computeMergedLocation(label2, eltIndex) {
        let loc = (0, _locationJsDefault.default).NONE;
        loc = this._label.getLocation(eltIndex);
        if (!label2.isNull(eltIndex)) {
            const nLoc = label2.getLocation(eltIndex);
            if (loc !== (0, _locationJsDefault.default).BOUNDARY) loc = nLoc;
        }
        return loc;
    }
    setLabel() {
        if (arguments.length === 2 && Number.isInteger(arguments[1]) && Number.isInteger(arguments[0])) {
            const argIndex = arguments[0], onLocation = arguments[1];
            if (this._label === null) this._label = new (0, _labelJsDefault.default)(argIndex, onLocation);
            else this._label.setLocation(argIndex, onLocation);
        } else return super.setLabel.apply(this, arguments);
    }
    getEdges() {
        return this._edges;
    }
    mergeLabel() {
        if (arguments[0] instanceof Node) {
            const n = arguments[0];
            this.mergeLabel(n._label);
        } else if (arguments[0] instanceof (0, _labelJsDefault.default)) {
            const label2 = arguments[0];
            for(let i = 0; i < 2; i++){
                const loc = this.computeMergedLocation(label2, i);
                const thisLoc = this._label.getLocation(i);
                if (thisLoc === (0, _locationJsDefault.default).NONE) this._label.setLocation(i, loc);
            }
        }
    }
    add(e) {
        this._edges.insert(e);
        e.setNode(this);
    }
    setLabelBoundary(argIndex) {
        if (this._label === null) return null;
        let loc = (0, _locationJsDefault.default).NONE;
        if (this._label !== null) loc = this._label.getLocation(argIndex);
        let newLoc = null;
        switch(loc){
            case (0, _locationJsDefault.default).BOUNDARY:
                newLoc = (0, _locationJsDefault.default).INTERIOR;
                break;
            case (0, _locationJsDefault.default).INTERIOR:
                newLoc = (0, _locationJsDefault.default).BOUNDARY;
                break;
            default:
                newLoc = (0, _locationJsDefault.default).BOUNDARY;
                break;
        }
        this._label.setLocation(argIndex, newLoc);
    }
    print(out) {
        out.println('node ' + this._coord + ' lbl: ' + this._label);
    }
    computeIM(im) {}
}
exports.default = Node;

},{"../geom/Location.js":"9aPCX","./Label.js":"dJJOo","./GraphComponent.js":"1jRLn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1jRLn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class GraphComponent {
    constructor(){
        GraphComponent.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._label = null;
        this._isInResult = false;
        this._isCovered = false;
        this._isCoveredSet = false;
        this._isVisited = false;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const label = arguments[0];
            this._label = label;
        }
    }
    setVisited(isVisited) {
        this._isVisited = isVisited;
    }
    setInResult(isInResult) {
        this._isInResult = isInResult;
    }
    setLabel(label) {
        this._label = label;
    }
    getLabel() {
        return this._label;
    }
    setCovered(isCovered) {
        this._isCovered = isCovered;
        this._isCoveredSet = true;
    }
    updateIM(im) {
        (0, _assertJsDefault.default).isTrue(this._label.getGeometryCount() >= 2, 'found partial label');
        this.computeIM(im);
    }
    isCovered() {
        return this._isCovered;
    }
    isCoveredSet() {
        return this._isCoveredSet;
    }
    isInResult() {
        return this._isInResult;
    }
    isVisited() {
        return this._isVisited;
    }
}
exports.default = GraphComponent;

},{"../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dQNYS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("./ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _sortedMapJs = require("./SortedMap.js");
var _sortedMapJsDefault = parcelHelpers.interopDefault(_sortedMapJs);
var _hashSetJs = require("./HashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
const BLACK = 0;
const RED = 1;
function colorOf(p) {
    return p == null ? BLACK : p.color;
}
function parentOf(p) {
    return p == null ? null : p.parent;
}
function setColor(p, c) {
    if (p !== null) p.color = c;
}
function leftOf(p) {
    return p == null ? null : p.left;
}
function rightOf(p) {
    return p == null ? null : p.right;
}
class TreeMap extends (0, _sortedMapJsDefault.default) {
    constructor(){
        super();
        this.root_ = null;
        this.size_ = 0;
    }
    get(key) {
        let p = this.root_;
        while(p !== null){
            const cmp = key.compareTo(p.key);
            if (cmp < 0) p = p.left;
            else if (cmp > 0) p = p.right;
            else return p.value;
        }
        return null;
    }
    put(key, value) {
        if (this.root_ === null) {
            this.root_ = {
                key: key,
                value: value,
                left: null,
                right: null,
                parent: null,
                color: BLACK,
                getValue () {
                    return this.value;
                },
                getKey () {
                    return this.key;
                }
            };
            this.size_ = 1;
            return null;
        }
        let t = this.root_;
        let parent;
        let cmp;
        do {
            parent = t;
            cmp = key.compareTo(t.key);
            if (cmp < 0) t = t.left;
            else if (cmp > 0) t = t.right;
            else {
                const oldValue = t.value;
                t.value = value;
                return oldValue;
            }
        }while (t !== null);
        const e = {
            key: key,
            left: null,
            right: null,
            value: value,
            parent: parent,
            color: BLACK,
            getValue () {
                return this.value;
            },
            getKey () {
                return this.key;
            }
        };
        if (cmp < 0) parent.left = e;
        else parent.right = e;
        this.fixAfterInsertion(e);
        this.size_++;
        return null;
    }
    /**
   * @param {Object} x
   */ fixAfterInsertion(x) {
        let y;
        x.color = RED;
        while(x != null && x !== this.root_ && x.parent.color === RED)if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {
            y = rightOf(parentOf(parentOf(x)));
            if (colorOf(y) === RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x === rightOf(parentOf(x))) {
                    x = parentOf(x);
                    this.rotateLeft(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                this.rotateRight(parentOf(parentOf(x)));
            }
        } else {
            y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) === RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x === leftOf(parentOf(x))) {
                    x = parentOf(x);
                    this.rotateRight(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                this.rotateLeft(parentOf(parentOf(x)));
            }
        }
        this.root_.color = BLACK;
    }
    values() {
        const arrayList = new (0, _arrayListJsDefault.default)();
        let p = this.getFirstEntry();
        if (p !== null) {
            arrayList.add(p.value);
            while((p = TreeMap.successor(p)) !== null)arrayList.add(p.value);
        }
        return arrayList;
    }
    entrySet() {
        const hashSet = new (0, _hashSetJsDefault.default)();
        let p = this.getFirstEntry();
        if (p !== null) {
            hashSet.add(p);
            while((p = TreeMap.successor(p)) !== null)hashSet.add(p);
        }
        return hashSet;
    }
    /**
   * @param {Object} p
   */ rotateLeft(p) {
        if (p != null) {
            const r = p.right;
            p.right = r.left;
            if (r.left != null) r.left.parent = p;
            r.parent = p.parent;
            if (p.parent == null) this.root_ = r;
            else if (p.parent.left === p) p.parent.left = r;
            else p.parent.right = r;
            r.left = p;
            p.parent = r;
        }
    }
    /**
   * @param {Object} p
   */ rotateRight(p) {
        if (p != null) {
            const l = p.left;
            p.left = l.right;
            if (l.right != null) l.right.parent = p;
            l.parent = p.parent;
            if (p.parent == null) this.root_ = l;
            else if (p.parent.right === p) p.parent.right = l;
            else p.parent.left = l;
            l.right = p;
            p.parent = l;
        }
    }
    /**
   * @return {Object}
   */ getFirstEntry() {
        let p = this.root_;
        if (p != null) while(p.left != null)p = p.left;
        return p;
    }
    /**
   * @param {Object} t
   * @return {Object}
   * @private
   */ static successor(t) {
        let p;
        if (t === null) return null;
        else if (t.right !== null) {
            p = t.right;
            while(p.left !== null)p = p.left;
            return p;
        } else {
            p = t.parent;
            let ch = t;
            while(p !== null && ch === p.right){
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }
    size() {
        return this.size_;
    }
    containsKey(key) {
        let p = this.root_;
        while(p !== null){
            const cmp = key.compareTo(p.key);
            if (cmp < 0) p = p.left;
            else if (cmp > 0) p = p.right;
            else return true;
        }
        return false;
    }
}
exports.default = TreeMap;

},{"./ArrayList.js":"gGAQZ","./SortedMap.js":"fVWdV","./HashSet.js":"a1U62","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fVWdV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapJs = require("./Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
class SortedMap extends (0, _mapJsDefault.default) {
}
exports.default = SortedMap;

},{"./Map.js":"8kUbt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7Dxyv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeEndBundleStarJs = require("./EdgeEndBundleStar.js");
var _edgeEndBundleStarJsDefault = parcelHelpers.interopDefault(_edgeEndBundleStarJs);
var _relateNodeJs = require("./RelateNode.js");
var _relateNodeJsDefault = parcelHelpers.interopDefault(_relateNodeJs);
var _nodeFactoryJs = require("../../geomgraph/NodeFactory.js");
var _nodeFactoryJsDefault = parcelHelpers.interopDefault(_nodeFactoryJs);
class RelateNodeFactory extends (0, _nodeFactoryJsDefault.default) {
    constructor(){
        super();
    }
    createNode(coord) {
        return new (0, _relateNodeJsDefault.default)(coord, new (0, _edgeEndBundleStarJsDefault.default)());
    }
}
exports.default = RelateNodeFactory;

},{"./EdgeEndBundleStar.js":"6nj14","./RelateNode.js":"a4b3P","../../geomgraph/NodeFactory.js":"5wP5U","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6nj14":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeEndStarJs = require("../../geomgraph/EdgeEndStar.js");
var _edgeEndStarJsDefault = parcelHelpers.interopDefault(_edgeEndStarJs);
var _edgeEndBundleJs = require("./EdgeEndBundle.js");
var _edgeEndBundleJsDefault = parcelHelpers.interopDefault(_edgeEndBundleJs);
class EdgeEndBundleStar extends (0, _edgeEndStarJsDefault.default) {
    constructor(){
        super();
    }
    updateIM(im) {
        for(let it = this.iterator(); it.hasNext();){
            const esb = it.next();
            esb.updateIM(im);
        }
    }
    insert(e) {
        let eb = this._edgeMap.get(e);
        if (eb === null) {
            eb = new (0, _edgeEndBundleJsDefault.default)(e);
            this.insertEdgeEnd(e, eb);
        } else eb.insert(e);
    }
}
exports.default = EdgeEndBundleStar;

},{"../../geomgraph/EdgeEndStar.js":"lc382","./EdgeEndBundle.js":"1BZa0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lc382":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stringBufferJs = require("../../../../java/lang/StringBuffer.js");
var _stringBufferJsDefault = parcelHelpers.interopDefault(_stringBufferJs);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _topologyExceptionJs = require("../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _simplePointInAreaLocatorJs = require("../algorithm/locate/SimplePointInAreaLocator.js");
var _simplePointInAreaLocatorJsDefault = parcelHelpers.interopDefault(_simplePointInAreaLocatorJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _treeMapJs = require("../../../../java/util/TreeMap.js");
var _treeMapJsDefault = parcelHelpers.interopDefault(_treeMapJs);
class EdgeEndStar {
    constructor(){
        EdgeEndStar.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._edgeMap = new (0, _treeMapJsDefault.default)();
        this._edgeList = null;
        this._ptInAreaLocation = [
            (0, _locationJsDefault.default).NONE,
            (0, _locationJsDefault.default).NONE
        ];
    }
    getNextCW(ee) {
        this.getEdges();
        const i = this._edgeList.indexOf(ee);
        let iNextCW = i - 1;
        if (i === 0) iNextCW = this._edgeList.size() - 1;
        return this._edgeList.get(iNextCW);
    }
    propagateSideLabels(geomIndex) {
        let startLoc = (0, _locationJsDefault.default).NONE;
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            if (label.isArea(geomIndex) && label.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT) !== (0, _locationJsDefault.default).NONE) startLoc = label.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT);
        }
        if (startLoc === (0, _locationJsDefault.default).NONE) return null;
        let currLoc = startLoc;
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            if (label.getLocation(geomIndex, (0, _positionJsDefault.default).ON) === (0, _locationJsDefault.default).NONE) label.setLocation(geomIndex, (0, _positionJsDefault.default).ON, currLoc);
            if (label.isArea(geomIndex)) {
                const leftLoc = label.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT);
                const rightLoc = label.getLocation(geomIndex, (0, _positionJsDefault.default).RIGHT);
                if (rightLoc !== (0, _locationJsDefault.default).NONE) {
                    if (rightLoc !== currLoc) throw new (0, _topologyExceptionJsDefault.default)('side location conflict', e.getCoordinate());
                    if (leftLoc === (0, _locationJsDefault.default).NONE) (0, _assertJsDefault.default).shouldNeverReachHere('found single null side (at ' + e.getCoordinate() + ')');
                    currLoc = leftLoc;
                } else {
                    (0, _assertJsDefault.default).isTrue(label.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT) === (0, _locationJsDefault.default).NONE, 'found single null side');
                    label.setLocation(geomIndex, (0, _positionJsDefault.default).RIGHT, currLoc);
                    label.setLocation(geomIndex, (0, _positionJsDefault.default).LEFT, currLoc);
                }
            }
        }
    }
    getCoordinate() {
        const it = this.iterator();
        if (!it.hasNext()) return null;
        const e = it.next();
        return e.getCoordinate();
    }
    checkAreaLabelsConsistent(geomIndex) {
        const edges = this.getEdges();
        if (edges.size() <= 0) return true;
        const lastEdgeIndex = edges.size() - 1;
        const startLabel = edges.get(lastEdgeIndex).getLabel();
        const startLoc = startLabel.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT);
        (0, _assertJsDefault.default).isTrue(startLoc !== (0, _locationJsDefault.default).NONE, 'Found unlabelled area edge');
        let currLoc = startLoc;
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            (0, _assertJsDefault.default).isTrue(label.isArea(geomIndex), 'Found non-area edge');
            const leftLoc = label.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT);
            const rightLoc = label.getLocation(geomIndex, (0, _positionJsDefault.default).RIGHT);
            if (leftLoc === rightLoc) return false;
            if (rightLoc !== currLoc) return false;
            currLoc = leftLoc;
        }
        return true;
    }
    findIndex(eSearch) {
        this.iterator();
        for(let i = 0; i < this._edgeList.size(); i++){
            const e = this._edgeList.get(i);
            if (e === eSearch) return i;
        }
        return -1;
    }
    iterator() {
        return this.getEdges().iterator();
    }
    getEdges() {
        if (this._edgeList === null) this._edgeList = new (0, _arrayListJsDefault.default)(this._edgeMap.values());
        return this._edgeList;
    }
    getLocation(geomIndex, p, geom) {
        if (this._ptInAreaLocation[geomIndex] === (0, _locationJsDefault.default).NONE) this._ptInAreaLocation[geomIndex] = (0, _simplePointInAreaLocatorJsDefault.default).locate(p, geom[geomIndex].getGeometry());
        return this._ptInAreaLocation[geomIndex];
    }
    toString() {
        const buf = new (0, _stringBufferJsDefault.default)();
        buf.append('EdgeEndStar:   ' + this.getCoordinate());
        buf.append('\n');
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            buf.append(e);
            buf.append('\n');
        }
        return buf.toString();
    }
    computeEdgeEndLabels(boundaryNodeRule) {
        for(let it = this.iterator(); it.hasNext();){
            const ee = it.next();
            ee.computeLabel(boundaryNodeRule);
        }
    }
    computeLabelling(geomGraph) {
        this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
        this.propagateSideLabels(0);
        this.propagateSideLabels(1);
        const hasDimensionalCollapseEdge = [
            false,
            false
        ];
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            for(let geomi = 0; geomi < 2; geomi++)if (label.isLine(geomi) && label.getLocation(geomi) === (0, _locationJsDefault.default).BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;
        }
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            for(let geomi = 0; geomi < 2; geomi++)if (label.isAnyNull(geomi)) {
                let loc = (0, _locationJsDefault.default).NONE;
                if (hasDimensionalCollapseEdge[geomi]) loc = (0, _locationJsDefault.default).EXTERIOR;
                else {
                    const p = e.getCoordinate();
                    loc = this.getLocation(geomi, p, geomGraph);
                }
                label.setAllLocationsIfNull(geomi, loc);
            }
        }
    }
    getDegree() {
        return this._edgeMap.size();
    }
    insertEdgeEnd(e, obj) {
        this._edgeMap.put(e, obj);
        this._edgeList = null;
    }
    print(out) {
        (0, _systemJsDefault.default).out.println('EdgeEndStar:   ' + this.getCoordinate());
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            e.print(out);
        }
    }
    isAreaLabelsConsistent(geomGraph) {
        this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
        return this.checkAreaLabelsConsistent(0);
    }
}
exports.default = EdgeEndStar;

},{"../../../../java/lang/StringBuffer.js":"98maG","../geom/Location.js":"9aPCX","./Position.js":"13raO","../geom/TopologyException.js":"bOVA5","../../../../java/lang/System.js":"dYmTx","../algorithm/locate/SimplePointInAreaLocator.js":"agQck","../../../../java/util/ArrayList.js":"gGAQZ","../util/Assert.js":"1vSRy","../../../../java/util/TreeMap.js":"dQNYS","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bOVA5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _runtimeExceptionJs = require("../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
class TopologyException extends (0, _runtimeExceptionJsDefault.default) {
    constructor(msg, pt){
        super(pt ? msg + ' [ ' + pt + ' ]' : msg);
        this.pt = pt ? new (0, _coordinateJsDefault.default)(pt) : undefined;
        this.name = Object.keys({
            TopologyException
        })[0];
    }
    getCoordinate() {
        return this.pt;
    }
}
exports.default = TopologyException;

},{"./Coordinate.js":"ii2fh","../../../../java/lang/RuntimeException.js":"3yvnL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"agQck":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _polygonJs = require("../../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _pointLocationJs = require("../PointLocation.js");
var _pointLocationJsDefault = parcelHelpers.interopDefault(_pointLocationJs);
var _pointOnGeometryLocatorJs = require("./PointOnGeometryLocator.js");
var _pointOnGeometryLocatorJsDefault = parcelHelpers.interopDefault(_pointOnGeometryLocatorJs);
var _geometryCollectionIteratorJs = require("../../geom/GeometryCollectionIterator.js");
var _geometryCollectionIteratorJsDefault = parcelHelpers.interopDefault(_geometryCollectionIteratorJs);
var _geometryCollectionJs = require("../../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
class SimplePointInAreaLocator {
    constructor(){
        SimplePointInAreaLocator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geom = null;
        const geom = arguments[0];
        this._geom = geom;
    }
    static locatePointInPolygon(p, poly) {
        if (poly.isEmpty()) return (0, _locationJsDefault.default).EXTERIOR;
        const shell = poly.getExteriorRing();
        const shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell);
        if (shellLoc !== (0, _locationJsDefault.default).INTERIOR) return shellLoc;
        for(let i = 0; i < poly.getNumInteriorRing(); i++){
            const hole = poly.getInteriorRingN(i);
            const holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole);
            if (holeLoc === (0, _locationJsDefault.default).BOUNDARY) return (0, _locationJsDefault.default).BOUNDARY;
            if (holeLoc === (0, _locationJsDefault.default).INTERIOR) return (0, _locationJsDefault.default).EXTERIOR;
        }
        return (0, _locationJsDefault.default).INTERIOR;
    }
    static locatePointInRing(p, ring) {
        if (!ring.getEnvelopeInternal().intersects(p)) return (0, _locationJsDefault.default).EXTERIOR;
        return (0, _pointLocationJsDefault.default).locateInRing(p, ring.getCoordinates());
    }
    static isContained(p, geom) {
        return (0, _locationJsDefault.default).EXTERIOR !== SimplePointInAreaLocator.locate(p, geom);
    }
    static locate(p, geom) {
        if (geom.isEmpty()) return (0, _locationJsDefault.default).EXTERIOR;
        if (!geom.getEnvelopeInternal().intersects(p)) return (0, _locationJsDefault.default).EXTERIOR;
        return SimplePointInAreaLocator.locateInGeometry(p, geom);
    }
    static containsPointInPolygon(p, poly) {
        return (0, _locationJsDefault.default).EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly);
    }
    static locateInGeometry(p, geom) {
        if (geom instanceof (0, _polygonJsDefault.default)) return SimplePointInAreaLocator.locatePointInPolygon(p, geom);
        if (geom instanceof (0, _geometryCollectionJsDefault.default)) {
            const geomi = new (0, _geometryCollectionIteratorJsDefault.default)(geom);
            while(geomi.hasNext()){
                const g2 = geomi.next();
                if (g2 !== geom) {
                    const loc = SimplePointInAreaLocator.locateInGeometry(p, g2);
                    if (loc !== (0, _locationJsDefault.default).EXTERIOR) return loc;
                }
            }
        }
        return (0, _locationJsDefault.default).EXTERIOR;
    }
    locate(p) {
        return SimplePointInAreaLocator.locate(p, this._geom);
    }
    get interfaces_() {
        return [
            (0, _pointOnGeometryLocatorJsDefault.default)
        ];
    }
}
exports.default = SimplePointInAreaLocator;

},{"../../geom/Location.js":"9aPCX","../../geom/Polygon.js":"kpOA5","../PointLocation.js":"l7FlP","./PointOnGeometryLocator.js":"aJaNX","../../geom/GeometryCollectionIterator.js":"8NoVw","../../geom/GeometryCollection.js":"6RJQO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l7FlP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _coordinateSequenceJs = require("../geom/CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
var _robustLineIntersectorJs = require("./RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _rayCrossingCounterJs = require("./RayCrossingCounter.js");
var _rayCrossingCounterJsDefault = parcelHelpers.interopDefault(_rayCrossingCounterJs);
class PointLocation {
    static isInRing(p, ring) {
        return PointLocation.locateInRing(p, ring) !== (0, _locationJsDefault.default).EXTERIOR;
    }
    static locateInRing(p, ring) {
        return (0, _rayCrossingCounterJsDefault.default).locatePointInRing(p, ring);
    }
    static isOnLine() {
        if (arguments[0] instanceof (0, _coordinateJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _coordinateSequenceJsDefault.default))) {
            const p = arguments[0], line = arguments[1];
            const lineIntersector = new (0, _robustLineIntersectorJsDefault.default)();
            const p0 = new (0, _coordinateJsDefault.default)();
            const p1 = new (0, _coordinateJsDefault.default)();
            const n = line.size();
            for(let i = 1; i < n; i++){
                line.getCoordinate(i - 1, p0);
                line.getCoordinate(i, p1);
                lineIntersector.computeIntersection(p, p0, p1);
                if (lineIntersector.hasIntersection()) return true;
            }
            return false;
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof Array) {
            const p = arguments[0], line = arguments[1];
            const lineIntersector = new (0, _robustLineIntersectorJsDefault.default)();
            for(let i = 1; i < line.length; i++){
                const p0 = line[i - 1];
                const p1 = line[i];
                lineIntersector.computeIntersection(p, p0, p1);
                if (lineIntersector.hasIntersection()) return true;
            }
            return false;
        }
    }
}
exports.default = PointLocation;

},{"../geom/Location.js":"9aPCX","../../../../hasInterface.js":"5bpze","../geom/Coordinate.js":"ii2fh","../geom/CoordinateSequence.js":"aDXS8","./RobustLineIntersector.js":"kLdG9","./RayCrossingCounter.js":"g16hB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kLdG9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _envelopeJs = require("../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _orientationJs = require("./Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _intersectionJs = require("./Intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
var _cgalgorithmsDDJs = require("./CGAlgorithmsDD.js");
var _cgalgorithmsDDJsDefault = parcelHelpers.interopDefault(_cgalgorithmsDDJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _distanceJs = require("./Distance.js");
var _distanceJsDefault = parcelHelpers.interopDefault(_distanceJs);
var _lineIntersectorJs = require("./LineIntersector.js");
var _lineIntersectorJsDefault = parcelHelpers.interopDefault(_lineIntersectorJs);
class RobustLineIntersector extends (0, _lineIntersectorJsDefault.default) {
    constructor(){
        super();
    }
    static nearestEndpoint(p1, p2, q1, q2) {
        let nearestPt = p1;
        let minDist = (0, _distanceJsDefault.default).pointToSegment(p1, q1, q2);
        let dist = (0, _distanceJsDefault.default).pointToSegment(p2, q1, q2);
        if (dist < minDist) {
            minDist = dist;
            nearestPt = p2;
        }
        dist = (0, _distanceJsDefault.default).pointToSegment(q1, p1, p2);
        if (dist < minDist) {
            minDist = dist;
            nearestPt = q1;
        }
        dist = (0, _distanceJsDefault.default).pointToSegment(q2, p1, p2);
        if (dist < minDist) {
            minDist = dist;
            nearestPt = q2;
        }
        return nearestPt;
    }
    isInSegmentEnvelopes(intPt) {
        const env0 = new (0, _envelopeJsDefault.default)(this._inputLines[0][0], this._inputLines[0][1]);
        const env1 = new (0, _envelopeJsDefault.default)(this._inputLines[1][0], this._inputLines[1][1]);
        return env0.contains(intPt) && env1.contains(intPt);
    }
    computeIntersection() {
        if (arguments.length === 3) {
            const p = arguments[0], p1 = arguments[1], p2 = arguments[2];
            this._isProper = false;
            if ((0, _envelopeJsDefault.default).intersects(p1, p2, p)) {
                if ((0, _orientationJsDefault.default).index(p1, p2, p) === 0 && (0, _orientationJsDefault.default).index(p2, p1, p) === 0) {
                    this._isProper = true;
                    if (p.equals(p1) || p.equals(p2)) this._isProper = false;
                    this._result = (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION;
                    return null;
                }
            }
            this._result = (0, _lineIntersectorJsDefault.default).NO_INTERSECTION;
        } else return super.computeIntersection.apply(this, arguments);
    }
    intersection(p1, p2, q1, q2) {
        let intPt = this.intersectionSafe(p1, p2, q1, q2);
        if (!this.isInSegmentEnvelopes(intPt)) intPt = new (0, _coordinateJsDefault.default)(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));
        if (this._precisionModel !== null) this._precisionModel.makePrecise(intPt);
        return intPt;
    }
    checkDD(p1, p2, q1, q2, intPt) {
        const intPtDD = (0, _cgalgorithmsDDJsDefault.default).intersection(p1, p2, q1, q2);
        const isIn = this.isInSegmentEnvelopes(intPtDD);
        (0, _systemJsDefault.default).out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);
        if (intPt.distance(intPtDD) > 0.0001) (0, _systemJsDefault.default).out.println('Distance = ' + intPt.distance(intPtDD));
    }
    intersectionSafe(p1, p2, q1, q2) {
        let intPt = (0, _intersectionJsDefault.default).intersection(p1, p2, q1, q2);
        if (intPt === null) intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);
        return intPt;
    }
    computeCollinearIntersection(p1, p2, q1, q2) {
        const p1q1p2 = (0, _envelopeJsDefault.default).intersects(p1, p2, q1);
        const p1q2p2 = (0, _envelopeJsDefault.default).intersects(p1, p2, q2);
        const q1p1q2 = (0, _envelopeJsDefault.default).intersects(q1, q2, p1);
        const q1p2q2 = (0, _envelopeJsDefault.default).intersects(q1, q2, p2);
        if (p1q1p2 && p1q2p2) {
            this._intPt[0] = q1;
            this._intPt[1] = q2;
            return (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        if (q1p1q2 && q1p2q2) {
            this._intPt[0] = p1;
            this._intPt[1] = p2;
            return (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        if (p1q1p2 && q1p1q2) {
            this._intPt[0] = q1;
            this._intPt[1] = p1;
            return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION : (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        if (p1q1p2 && q1p2q2) {
            this._intPt[0] = q1;
            this._intPt[1] = p2;
            return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION : (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        if (p1q2p2 && q1p1q2) {
            this._intPt[0] = q2;
            this._intPt[1] = p1;
            return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION : (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        if (p1q2p2 && q1p2q2) {
            this._intPt[0] = q2;
            this._intPt[1] = p2;
            return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION : (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        return (0, _lineIntersectorJsDefault.default).NO_INTERSECTION;
    }
    computeIntersect(p1, p2, q1, q2) {
        this._isProper = false;
        if (!(0, _envelopeJsDefault.default).intersects(p1, p2, q1, q2)) return (0, _lineIntersectorJsDefault.default).NO_INTERSECTION;
        const Pq1 = (0, _orientationJsDefault.default).index(p1, p2, q1);
        const Pq2 = (0, _orientationJsDefault.default).index(p1, p2, q2);
        if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) return (0, _lineIntersectorJsDefault.default).NO_INTERSECTION;
        const Qp1 = (0, _orientationJsDefault.default).index(q1, q2, p1);
        const Qp2 = (0, _orientationJsDefault.default).index(q1, q2, p2);
        if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) return (0, _lineIntersectorJsDefault.default).NO_INTERSECTION;
        const collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
        if (collinear) return this.computeCollinearIntersection(p1, p2, q1, q2);
        if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
            this._isProper = false;
            if (p1.equals2D(q1) || p1.equals2D(q2)) this._intPt[0] = p1;
            else if (p2.equals2D(q1) || p2.equals2D(q2)) this._intPt[0] = p2;
            else if (Pq1 === 0) this._intPt[0] = new (0, _coordinateJsDefault.default)(q1);
            else if (Pq2 === 0) this._intPt[0] = new (0, _coordinateJsDefault.default)(q2);
            else if (Qp1 === 0) this._intPt[0] = new (0, _coordinateJsDefault.default)(p1);
            else if (Qp2 === 0) this._intPt[0] = new (0, _coordinateJsDefault.default)(p2);
        } else {
            this._isProper = true;
            this._intPt[0] = this.intersection(p1, p2, q1, q2);
        }
        return (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION;
    }
}
exports.default = RobustLineIntersector;

},{"../geom/Coordinate.js":"ii2fh","../geom/Envelope.js":"h2zeM","./Orientation.js":"avl08","./Intersection.js":"bynFG","./CGAlgorithmsDD.js":"hasH7","../../../../java/lang/System.js":"dYmTx","./Distance.js":"4ZaWr","./LineIntersector.js":"loV0W","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bynFG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
class Intersection {
    static intersection(p1, p2, q1, q2) {
        const minX0 = p1.x < p2.x ? p1.x : p2.x;
        const minY0 = p1.y < p2.y ? p1.y : p2.y;
        const maxX0 = p1.x > p2.x ? p1.x : p2.x;
        const maxY0 = p1.y > p2.y ? p1.y : p2.y;
        const minX1 = q1.x < q2.x ? q1.x : q2.x;
        const minY1 = q1.y < q2.y ? q1.y : q2.y;
        const maxX1 = q1.x > q2.x ? q1.x : q2.x;
        const maxY1 = q1.y > q2.y ? q1.y : q2.y;
        const intMinX = minX0 > minX1 ? minX0 : minX1;
        const intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
        const intMinY = minY0 > minY1 ? minY0 : minY1;
        const intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
        const midx = (intMinX + intMaxX) / 2.0;
        const midy = (intMinY + intMaxY) / 2.0;
        const p1x = p1.x - midx;
        const p1y = p1.y - midy;
        const p2x = p2.x - midx;
        const p2y = p2.y - midy;
        const q1x = q1.x - midx;
        const q1y = q1.y - midy;
        const q2x = q2.x - midx;
        const q2y = q2.y - midy;
        const px = p1y - p2y;
        const py = p2x - p1x;
        const pw = p1x * p2y - p2x * p1y;
        const qx = q1y - q2y;
        const qy = q2x - q1x;
        const qw = q1x * q2y - q2x * q1y;
        const x = py * qw - qy * pw;
        const y = qx * pw - px * qw;
        const w = px * qy - qx * py;
        const xInt = x / w;
        const yInt = y / w;
        if ((0, _doubleJsDefault.default).isNaN(xInt) || (0, _doubleJsDefault.default).isInfinite(xInt) || (0, _doubleJsDefault.default).isNaN(yInt) || (0, _doubleJsDefault.default).isInfinite(yInt)) return null;
        return new (0, _coordinateJsDefault.default)(xInt + midx, yInt + midy);
    }
}
exports.default = Intersection;

},{"../geom/Coordinate.js":"ii2fh","../../../../java/lang/Double.js":"clUxd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4ZaWr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _mathUtilJs = require("../math/MathUtil.js");
var _mathUtilJsDefault = parcelHelpers.interopDefault(_mathUtilJs);
var _envelopeJs = require("../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class Distance {
    static pointToSegmentString(p, line) {
        if (line.length === 0) throw new (0, _illegalArgumentExceptionJsDefault.default)('Line array must contain at least one vertex');
        let minDistance = p.distance(line[0]);
        for(let i = 0; i < line.length - 1; i++){
            const dist = Distance.pointToSegment(p, line[i], line[i + 1]);
            if (dist < minDistance) minDistance = dist;
        }
        return minDistance;
    }
    static segmentToSegment(A, B, C, D) {
        if (A.equals(B)) return Distance.pointToSegment(A, C, D);
        if (C.equals(D)) return Distance.pointToSegment(D, A, B);
        let noIntersection = false;
        if (!(0, _envelopeJsDefault.default).intersects(A, B, C, D)) noIntersection = true;
        else {
            const denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
            if (denom === 0) noIntersection = true;
            else {
                const r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
                const s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
                const s = s_num / denom;
                const r = r_num / denom;
                if (r < 0 || r > 1 || s < 0 || s > 1) noIntersection = true;
            }
        }
        if (noIntersection) return (0, _mathUtilJsDefault.default).min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B));
        return 0.0;
    }
    static pointToLinePerpendicular(p, A, B) {
        const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
        const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
        return Math.abs(s) * Math.sqrt(len2);
    }
    static pointToSegment(p, A, B) {
        if (A.x === B.x && A.y === B.y) return p.distance(A);
        const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
        const r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;
        if (r <= 0.0) return p.distance(A);
        if (r >= 1.0) return p.distance(B);
        const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
        return Math.abs(s) * Math.sqrt(len2);
    }
}
exports.default = Distance;

},{"../../../../java/lang/IllegalArgumentException.js":"9ppVW","../math/MathUtil.js":"432sT","../geom/Envelope.js":"h2zeM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"loV0W":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktwriterJs = require("../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _stringBuilderJs = require("../../../../java/lang/StringBuilder.js");
var _stringBuilderJsDefault = parcelHelpers.interopDefault(_stringBuilderJs);
class LineIntersector {
    constructor(){
        LineIntersector.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._result = null;
        this._inputLines = Array(2).fill().map(()=>Array(2));
        this._intPt = new Array(2).fill(null);
        this._intLineIndex = null;
        this._isProper = null;
        this._pa = null;
        this._pb = null;
        this._precisionModel = null;
        this._intPt[0] = new (0, _coordinateJsDefault.default)();
        this._intPt[1] = new (0, _coordinateJsDefault.default)();
        this._pa = this._intPt[0];
        this._pb = this._intPt[1];
        this._result = 0;
    }
    static nonRobustComputeEdgeDistance(p, p1, p2) {
        const dx = p.x - p1.x;
        const dy = p.y - p1.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        (0, _assertJsDefault.default).isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');
        return dist;
    }
    static computeEdgeDistance(p, p0, p1) {
        const dx = Math.abs(p1.x - p0.x);
        const dy = Math.abs(p1.y - p0.y);
        let dist = -1;
        if (p.equals(p0)) dist = 0.0;
        else if (p.equals(p1)) {
            if (dx > dy) dist = dx;
            else dist = dy;
        } else {
            const pdx = Math.abs(p.x - p0.x);
            const pdy = Math.abs(p.y - p0.y);
            if (dx > dy) dist = pdx;
            else dist = pdy;
            if (dist === 0.0 && !p.equals(p0)) dist = Math.max(pdx, pdy);
        }
        (0, _assertJsDefault.default).isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');
        return dist;
    }
    computeIntersection(p1, p2, p3, p4) {
        this._inputLines[0][0] = p1;
        this._inputLines[0][1] = p2;
        this._inputLines[1][0] = p3;
        this._inputLines[1][1] = p4;
        this._result = this.computeIntersect(p1, p2, p3, p4);
    }
    getIntersectionNum() {
        return this._result;
    }
    computeIntLineIndex() {
        if (arguments.length === 0) {
            if (this._intLineIndex === null) {
                this._intLineIndex = Array(2).fill().map(()=>Array(2));
                this.computeIntLineIndex(0);
                this.computeIntLineIndex(1);
            }
        } else if (arguments.length === 1) {
            const segmentIndex = arguments[0];
            const dist0 = this.getEdgeDistance(segmentIndex, 0);
            const dist1 = this.getEdgeDistance(segmentIndex, 1);
            if (dist0 > dist1) {
                this._intLineIndex[segmentIndex][0] = 0;
                this._intLineIndex[segmentIndex][1] = 1;
            } else {
                this._intLineIndex[segmentIndex][0] = 1;
                this._intLineIndex[segmentIndex][1] = 0;
            }
        }
    }
    isInteriorIntersection() {
        if (arguments.length === 0) {
            if (this.isInteriorIntersection(0)) return true;
            if (this.isInteriorIntersection(1)) return true;
            return false;
        } else if (arguments.length === 1) {
            const inputLineIndex = arguments[0];
            for(let i = 0; i < this._result; i++)if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) return true;
            return false;
        }
    }
    getIntersection(intIndex) {
        return this._intPt[intIndex];
    }
    getEdgeDistance(segmentIndex, intIndex) {
        const dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
        return dist;
    }
    isCollinear() {
        return this._result === LineIntersector.COLLINEAR_INTERSECTION;
    }
    toString() {
        return (0, _wktwriterJsDefault.default).toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + (0, _wktwriterJsDefault.default).toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
    }
    getEndpoint(segmentIndex, ptIndex) {
        return this._inputLines[segmentIndex][ptIndex];
    }
    getIndexAlongSegment(segmentIndex, intIndex) {
        this.computeIntLineIndex();
        return this._intLineIndex[segmentIndex][intIndex];
    }
    getTopologySummary() {
        const catBuilder = new (0, _stringBuilderJsDefault.default)();
        if (this.isEndPoint()) catBuilder.append(' endpoint');
        if (this._isProper) catBuilder.append(' proper');
        if (this.isCollinear()) catBuilder.append(' collinear');
        return catBuilder.toString();
    }
    isProper() {
        return this.hasIntersection() && this._isProper;
    }
    setPrecisionModel(precisionModel) {
        this._precisionModel = precisionModel;
    }
    isEndPoint() {
        return this.hasIntersection() && !this._isProper;
    }
    hasIntersection() {
        return this._result !== LineIntersector.NO_INTERSECTION;
    }
    isIntersection(pt) {
        for(let i = 0; i < this._result; i++)if (this._intPt[i].equals2D(pt)) return true;
        return false;
    }
    getIntersectionAlongSegment(segmentIndex, intIndex) {
        this.computeIntLineIndex();
        return this._intPt[this._intLineIndex[segmentIndex][intIndex]];
    }
}
exports.default = LineIntersector;
LineIntersector.DONT_INTERSECT = 0;
LineIntersector.DO_INTERSECT = 1;
LineIntersector.COLLINEAR = 2;
LineIntersector.NO_INTERSECTION = 0;
LineIntersector.POINT_INTERSECTION = 1;
LineIntersector.COLLINEAR_INTERSECTION = 2;

},{"../io/WKTWriter.js":"1WLaw","../geom/Coordinate.js":"ii2fh","../util/Assert.js":"1vSRy","../../../../java/lang/StringBuilder.js":"30Zhx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1WLaw":[function(require,module,exports,__globalThis) {
/**
 * @module org/locationtech/jts/io/WKTWriter
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktparserJs = require("./WKTParser.js");
var _wktparserJsDefault = parcelHelpers.interopDefault(_wktparserJs);
class WKTWriter {
    /**
   * @param {GeometryFactory} geometryFactory
   */ constructor(geometryFactory){
        this.parser = new (0, _wktparserJsDefault.default)(geometryFactory);
    }
    /**
   * Converts a <code>Geometry</code> to its Well-known Text representation.
   *
   * @param {Geometry} geometry a <code>Geometry</code> to process.
   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple
   *         Features Specification).
   * @memberof module:org/locationtech/jts/io/WKTWriter#
   */ write(geometry) {
        return this.parser.write(geometry);
    }
    /**
   * Generates the WKT for a <tt>LINESTRING</tt> specified by two
   * {@link Coordinate}s.
   *
   * @param p0 the first coordinate.
   * @param p1 the second coordinate.
   *
   * @return the WKT.
   * @private
   */ static toLineString(p0, p1) {
        if (arguments.length !== 2) throw new Error('Not implemented');
        return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )';
    }
}
exports.default = WKTWriter;

},{"./WKTParser.js":"kHl0W","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kHl0W":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _geometryFactoryJs = require("../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */ const GeometryLayout = {
    XY: 'XY',
    XYZ: 'XYZ',
    XYM: 'XYM',
    XYZM: 'XYZM'
};
/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */ const GeometryType = {
    POINT: 'Point',
    LINE_STRING: 'LineString',
    LINEAR_RING: 'LinearRing',
    POLYGON: 'Polygon',
    MULTI_POINT: 'MultiPoint',
    MULTI_LINE_STRING: 'MultiLineString',
    MULTI_POLYGON: 'MultiPolygon',
    GEOMETRY_COLLECTION: 'GeometryCollection',
    CIRCLE: 'Circle'
};
/**
 * @typedef {Object} Options
 * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into
 * multiple features on reading.
 */ /**
 * @typedef {Object} Token
 * @property {number} type
 * @property {number|string} [value]
 * @property {number} position
 */ /**
 * @const
 * @type {string}
 */ const EMPTY = 'EMPTY';
/**
 * @const
 * @type {string}
 */ const Z = 'Z';
/**
 * @const
 * @type {string}
 */ const M = 'M';
/**
 * @const
 * @type {string}
 */ const ZM = 'ZM';
/**
 * @const
 * @enum {number}
 */ const TokenType = {
    TEXT: 1,
    LEFT_PAREN: 2,
    RIGHT_PAREN: 3,
    NUMBER: 4,
    COMMA: 5,
    EOF: 6
};
/**
 * @const
 * @type {Object<string, string>}
 */ const WKTGeometryType = {};
for(const type in GeometryType)WKTGeometryType[type] = GeometryType[type].toUpperCase();
/**
 * Class to tokenize a WKT string.
 */ class Lexer {
    /**
   * @param {string} wkt WKT string.
   */ constructor(wkt){
        /**
     * @type {string}
     */ this.wkt = wkt;
        /**
     * @type {number}
     * @private
     */ this.index_ = -1;
    }
    /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is alphabetic.
   * @private
   */ isAlpha_(c) {
        return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
    }
    /**
   * @param {string} c Character.
   * @param {boolean=} opt_decimal Whether the string number
   *     contains a dot, i.e. is a decimal number.
   * @return {boolean} Whether the character is numeric.
   * @private
   */ isNumeric_(c, opt_decimal) {
        const decimal = opt_decimal !== undefined ? opt_decimal : false;
        return c >= '0' && c <= '9' || c == '.' && !decimal;
    }
    /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is whitespace.
   * @private
   */ isWhiteSpace_(c) {
        return c == ' ' || c == '\t' || c == '\r' || c == '\n';
    }
    /**
   * @return {string} Next string character.
   * @private
   */ nextChar_() {
        return this.wkt.charAt(++this.index_);
    }
    /**
   * Fetch and return the next token.
   * @return {!Token} Next string token.
   */ nextToken() {
        const c = this.nextChar_();
        const position = this.index_;
        /** @type {number|string} */ let value = c;
        let type;
        if (c == '(') type = TokenType.LEFT_PAREN;
        else if (c == ',') type = TokenType.COMMA;
        else if (c == ')') type = TokenType.RIGHT_PAREN;
        else if (this.isNumeric_(c) || c == '-') {
            type = TokenType.NUMBER;
            value = this.readNumber_();
        } else if (this.isAlpha_(c)) {
            type = TokenType.TEXT;
            value = this.readText_();
        } else if (this.isWhiteSpace_(c)) return this.nextToken();
        else if (c === '') type = TokenType.EOF;
        else throw new Error('Unexpected character: ' + c);
        return {
            position: position,
            value: value,
            type: type
        };
    }
    /**
   * @return {number} Numeric token value.
   * @private
   */ readNumber_() {
        let c;
        const index = this.index_;
        let decimal = false;
        let scientificNotation = false;
        do {
            if (c == '.') decimal = true;
            else if (c == 'e' || c == 'E') scientificNotation = true;
            c = this.nextChar_();
        }while (this.isNumeric_(c, decimal) || // if we haven't detected a scientific number before, 'e' or 'E'
        // hint that we should continue to read
        !scientificNotation && (c == 'e' || c == 'E') || // once we know that we have a scientific number, both '-' and '+'
        // are allowed
        scientificNotation && (c == '-' || c == '+'));
        return parseFloat(this.wkt.substring(index, this.index_--));
    }
    /**
   * @return {string} String token value.
   * @private
   */ readText_() {
        let c;
        const index = this.index_;
        do c = this.nextChar_();
        while (this.isAlpha_(c));
        return this.wkt.substring(index, this.index_--).toUpperCase();
    }
}
/**
 * Class to parse the tokens from the WKT string.
 */ class Parser {
    /**
   * @param {Lexer} lexer The lexer.
   */ constructor(lexer, factory){
        /**
     * @type {Lexer}
     * @private
     */ this.lexer_ = lexer;
        /**
     * @type {Token}
     * @private
     */ this.token_;
        /**
     * @type {import("../geom/GeometryLayout.js").default}
     * @private
     */ this.layout_ = GeometryLayout.XY;
        this.factory = factory;
    }
    /**
   * Fetch the next token form the lexer and replace the active token.
   * @private
   */ consume_() {
        this.token_ = this.lexer_.nextToken();
    }
    /**
   * Tests if the given type matches the type of the current token.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */ isTokenType(type) {
        const isMatch = this.token_.type == type;
        return isMatch;
    }
    /**
   * If the given type matches the current token, consume it.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */ match(type) {
        const isMatch = this.isTokenType(type);
        if (isMatch) this.consume_();
        return isMatch;
    }
    /**
   * Try to parse the tokens provided by the lexer.
   * @return {import("../geom/Geometry.js").default} The geometry.
   */ parse() {
        this.consume_();
        const geometry = this.parseGeometry_();
        return geometry;
    }
    /**
   * Try to parse the dimensional info.
   * @return {import("../geom/GeometryLayout.js").default} The layout.
   * @private
   */ parseGeometryLayout_() {
        let layout = GeometryLayout.XY;
        const dimToken = this.token_;
        if (this.isTokenType(TokenType.TEXT)) {
            const dimInfo = dimToken.value;
            if (dimInfo === Z) layout = GeometryLayout.XYZ;
            else if (dimInfo === M) layout = GeometryLayout.XYM;
            else if (dimInfo === ZM) layout = GeometryLayout.XYZM;
            if (layout !== GeometryLayout.XY) this.consume_();
        }
        return layout;
    }
    /**
   * @return {!Array<import("../geom/Geometry.js").default>} A collection of geometries.
   * @private
   */ parseGeometryCollectionText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const geometries = [];
            do geometries.push(this.parseGeometry_());
            while (this.match(TokenType.COMMA));
            if (this.match(TokenType.RIGHT_PAREN)) return geometries;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {Array<number>} All values in a point.
   * @private
   */ parsePointText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const coordinates = this.parsePoint_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return null;
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<number>>} All points in a linestring.
   * @private
   */ parseLineStringText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const coordinates = this.parsePointList_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<!Array<number>>>} All points in a polygon.
   * @private
   */ parsePolygonText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const coordinates = this.parseLineStringTextList_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<number>>} All points in a multipoint.
   * @private
   */ parseMultiPointText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            let coordinates;
            if (this.token_.type == TokenType.LEFT_PAREN) coordinates = this.parsePointTextList_();
            else coordinates = this.parsePointList_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<!Array<number>>>} All linestring points
   *                                          in a multilinestring.
   * @private
   */ parseMultiLineStringText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const coordinates = this.parseLineStringTextList_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<!Array<!Array<number>>>>} All polygon points in a multipolygon.
   * @private
   */ parseMultiPolygonText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const coordinates = this.parsePolygonTextList_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<number>} A point.
   * @private
   */ parsePoint_() {
        const coordinates = [];
        const dimensions = this.layout_.length;
        for(let i = 0; i < dimensions; ++i){
            const token = this.token_;
            if (this.match(TokenType.NUMBER)) coordinates.push(/** @type {number} */ token.value);
            else break;
        }
        if (coordinates.length == dimensions) return coordinates;
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<number>>} An array of points.
   * @private
   */ parsePointList_() {
        const coordinates = [
            this.parsePoint_()
        ];
        while(this.match(TokenType.COMMA))coordinates.push(this.parsePoint_());
        return coordinates;
    }
    /**
   * @return {!Array<!Array<number>>} An array of points.
   * @private
   */ parsePointTextList_() {
        const coordinates = [
            this.parsePointText_()
        ];
        while(this.match(TokenType.COMMA))coordinates.push(this.parsePointText_());
        return coordinates;
    }
    /**
   * @return {!Array<!Array<!Array<number>>>} An array of points.
   * @private
   */ parseLineStringTextList_() {
        const coordinates = [
            this.parseLineStringText_()
        ];
        while(this.match(TokenType.COMMA))coordinates.push(this.parseLineStringText_());
        return coordinates;
    }
    /**
   * @return {!Array<!Array<!Array<!Array<number>>>>} An array of points.
   * @private
   */ parsePolygonTextList_() {
        const coordinates = [
            this.parsePolygonText_()
        ];
        while(this.match(TokenType.COMMA))coordinates.push(this.parsePolygonText_());
        return coordinates;
    }
    /**
   * @return {boolean} Whether the token implies an empty geometry.
   * @private
   */ isEmptyGeometry_() {
        const isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;
        if (isEmpty) this.consume_();
        return isEmpty;
    }
    /**
   * Create an error message for an unexpected token error.
   * @return {string} Error message.
   * @private
   */ formatErrorMessage_() {
        return 'Unexpected `' + this.token_.value + '` at position ' + this.token_.position + ' in `' + this.lexer_.wkt + '`';
    }
    /**
   * @return {!import("../geom/Geometry.js").default} The geometry.
   * @private
   */ parseGeometry_() {
        const factory = this.factory;
        const o2c = (ordinates)=>ordinates ? new (0, _coordinateJsDefault.default)(...ordinates) : new (0, _coordinateJsDefault.default)();
        const ca2p = (coordinates)=>{
            const rings = coordinates.map((a)=>factory.createLinearRing(a.map(o2c)));
            if (rings.length > 1) return factory.createPolygon(rings[0], rings.slice(1));
            else if (rings.length === 1) return factory.createPolygon(rings[0]);
            else return factory.createPolygon();
        };
        const token = this.token_;
        if (this.match(TokenType.TEXT)) {
            const geomType = token.value;
            this.layout_ = this.parseGeometryLayout_();
            if (geomType == 'GEOMETRYCOLLECTION') {
                const geometries = this.parseGeometryCollectionText_();
                return factory.createGeometryCollection(geometries);
            } else switch(geomType){
                case 'POINT':
                    {
                        const ordinates = this.parsePointText_();
                        if (!ordinates) return factory.createPoint();
                        return factory.createPoint(new (0, _coordinateJsDefault.default)(...ordinates));
                    }
                case 'LINESTRING':
                    {
                        const coordinates = this.parseLineStringText_();
                        const components = coordinates.map(o2c);
                        return factory.createLineString(components);
                    }
                case 'LINEARRING':
                    {
                        const coordinates = this.parseLineStringText_();
                        const components = coordinates.map(o2c);
                        return factory.createLinearRing(components);
                    }
                case 'POLYGON':
                    {
                        const coordinates = this.parsePolygonText_();
                        if (!coordinates || coordinates.length === 0) return factory.createPolygon();
                        return ca2p(coordinates);
                    }
                case 'MULTIPOINT':
                    {
                        const coordinates = this.parseMultiPointText_();
                        if (!coordinates || coordinates.length === 0) return factory.createMultiPoint();
                        const components = coordinates.map(o2c).map((c)=>factory.createPoint(c));
                        return factory.createMultiPoint(components);
                    }
                case 'MULTILINESTRING':
                    {
                        const coordinates = this.parseMultiLineStringText_();
                        const components = coordinates.map((a)=>factory.createLineString(a.map(o2c)));
                        return factory.createMultiLineString(components);
                    }
                case 'MULTIPOLYGON':
                    {
                        const coordinates = this.parseMultiPolygonText_();
                        if (!coordinates || coordinates.length === 0) return factory.createMultiPolygon();
                        const polygons = coordinates.map(ca2p);
                        return factory.createMultiPolygon(polygons);
                    }
                default:
                    throw new Error('Invalid geometry type: ' + geomType);
            }
        }
        throw new Error(this.formatErrorMessage_());
    }
}
/**
 * @param {Point} geom Point geometry.
 * @return {string} Coordinates part of Point as WKT.
 */ function encodePointGeometry(geom) {
    if (geom.isEmpty()) return '';
    const c = geom.getCoordinate();
    const cs = [
        c.x,
        c.y
    ];
    if (c.z !== undefined && !Number.isNaN(c.z)) cs.push(c.z);
    if (c.m !== undefined && !Number.isNaN(c.m)) cs.push(c.m);
    return cs.join(' ');
}
/**
 * @param {MultiPoint} geom MultiPoint geometry.
 * @return {string} Coordinates part of MultiPoint as WKT.
 */ function encodeMultiPointGeometry(geom) {
    const array = [];
    for(let i = 0, ii = geom.getNumGeometries(); i < ii; ++i)array.push('(' + encodePointGeometry(geom.getGeometryN(i)) + ')');
    return array.join(', ');
}
/**
 * @param {GeometryCollection} geom GeometryCollection geometry.
 * @return {string} Coordinates part of GeometryCollection as WKT.
 */ function encodeGeometryCollectionGeometry(geom) {
    const array = [];
    for(let i = 0, ii = geom.getNumGeometries(); i < ii; ++i)array.push(encode(geom.getGeometryN(i)));
    return array.join(', ');
}
/**
 * @param {LineString|import("../geom/LinearRing.js").default} geom LineString geometry.
 * @return {string} Coordinates part of LineString as WKT.
 */ function encodeLineStringGeometry(geom) {
    const coordinates = geom.getCoordinates().map((c)=>{
        const a = [
            c.x,
            c.y
        ];
        if (c.z !== undefined && !Number.isNaN(c.z)) a.push(c.z);
        if (c.m !== undefined && !Number.isNaN(c.m)) a.push(c.m);
        return a;
    });
    const array = [];
    for(let i = 0, ii = coordinates.length; i < ii; ++i)array.push(coordinates[i].join(' '));
    return array.join(', ');
}
/**
 * @param {MultiLineString} geom MultiLineString geometry.
 * @return {string} Coordinates part of MultiLineString as WKT.
 */ function encodeMultiLineStringGeometry(geom) {
    const array = [];
    for(let i = 0, ii = geom.getNumGeometries(); i < ii; ++i)array.push('(' + encodeLineStringGeometry(geom.getGeometryN(i)) + ')');
    return array.join(', ');
}
/**
 * @param {Polygon} geom Polygon geometry.
 * @return {string} Coordinates part of Polygon as WKT.
 */ function encodePolygonGeometry(geom) {
    const array = [];
    array.push('(' + encodeLineStringGeometry(geom.getExteriorRing()) + ')');
    for(let i = 0, ii = geom.getNumInteriorRing(); i < ii; ++i)array.push('(' + encodeLineStringGeometry(geom.getInteriorRingN(i)) + ')');
    return array.join(', ');
}
/**
 * @param {MultiPolygon} geom MultiPolygon geometry.
 * @return {string} Coordinates part of MultiPolygon as WKT.
 */ function encodeMultiPolygonGeometry(geom) {
    const array = [];
    for(let i = 0, ii = geom.getNumGeometries(); i < ii; ++i)array.push('(' + encodePolygonGeometry(geom.getGeometryN(i)) + ')');
    return array.join(', ');
}
/**
 * @param {Geometry} geom Geometry geometry.
 * @return {string} Potential dimensional information for WKT type.
 */ function encodeGeometryLayout(geom) {
    let dimInfo = '';
    if (geom.isEmpty()) return dimInfo;
    const c = geom.getCoordinate();
    if (c.z !== undefined && !Number.isNaN(c.z)) dimInfo += Z;
    if (c.m !== undefined && !Number.isNaN(c.m)) dimInfo += M;
    return dimInfo;
}
/**
 * @const
 * @type {Object<string, function(import("../geom/Geometry.js").default): string>}
 */ const GeometryEncoder = {
    'Point': encodePointGeometry,
    'LineString': encodeLineStringGeometry,
    'LinearRing': encodeLineStringGeometry,
    'Polygon': encodePolygonGeometry,
    'MultiPoint': encodeMultiPointGeometry,
    'MultiLineString': encodeMultiLineStringGeometry,
    'MultiPolygon': encodeMultiPolygonGeometry,
    'GeometryCollection': encodeGeometryCollectionGeometry
};
/**
 * Encode a geometry as WKT.
 * @param {!import("../geom/Geometry.js").default} geom The geometry to encode.
 * @return {string} WKT string for the geometry.
 */ function encode(geom) {
    let type = geom.getGeometryType();
    const geometryEncoder = GeometryEncoder[type];
    type = type.toUpperCase();
    const dimInfo = encodeGeometryLayout(geom);
    if (dimInfo.length > 0) type += ' ' + dimInfo;
    if (geom.isEmpty()) return type + ' ' + EMPTY;
    const enc = geometryEncoder(geom);
    return type + ' (' + enc + ')';
}
class WKTParser {
    /** Create a new parser for WKT
   *
   * @param {GeometryFactory} geometryFactory
   * @return An instance of WKTParser.
   * @private
   */ constructor(geometryFactory){
        this.geometryFactory = geometryFactory || new (0, _geometryFactoryJsDefault.default)();
        this.precisionModel = this.geometryFactory.getPrecisionModel();
    }
    /**
   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,
   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,
   * and GEOMETRYCOLLECTION.
   *
   * @param {String} wkt A WKT string.
   * @return {Geometry} A geometry instance.
   * @private
   */ read(wkt) {
        const lexer = new Lexer(wkt);
        const parser = new Parser(lexer, this.geometryFactory);
        const geometry = parser.parse();
        return geometry;
    }
    /**
   * Serialize a geometry into a WKT string.
   *
   * @param {Geometry} geometry A feature or array of features.
   * @return {String} The WKT string representation of the input geometries.
   * @private
   */ write(geometry) {
        return encode(geometry);
    }
}
exports.default = WKTParser;

},{"../geom/Coordinate.js":"ii2fh","../geom/GeometryFactory.js":"cGt0T","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g16hB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _orientationJs = require("./Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _coordinateSequenceJs = require("../geom/CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
class RayCrossingCounter {
    constructor(){
        RayCrossingCounter.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._p = null;
        this._crossingCount = 0;
        this._isPointOnSegment = false;
        const p = arguments[0];
        this._p = p;
    }
    static locatePointInRing() {
        if (arguments[0] instanceof (0, _coordinateJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _coordinateSequenceJsDefault.default))) {
            const p = arguments[0], ring = arguments[1];
            const counter = new RayCrossingCounter(p);
            const p1 = new (0, _coordinateJsDefault.default)();
            const p2 = new (0, _coordinateJsDefault.default)();
            for(let i = 1; i < ring.size(); i++){
                ring.getCoordinate(i, p1);
                ring.getCoordinate(i - 1, p2);
                counter.countSegment(p1, p2);
                if (counter.isOnSegment()) return counter.getLocation();
            }
            return counter.getLocation();
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof Array) {
            const p = arguments[0], ring = arguments[1];
            const counter = new RayCrossingCounter(p);
            for(let i = 1; i < ring.length; i++){
                const p1 = ring[i];
                const p2 = ring[i - 1];
                counter.countSegment(p1, p2);
                if (counter.isOnSegment()) return counter.getLocation();
            }
            return counter.getLocation();
        }
    }
    getLocation() {
        if (this._isPointOnSegment) return (0, _locationJsDefault.default).BOUNDARY;
        if (this._crossingCount % 2 === 1) return (0, _locationJsDefault.default).INTERIOR;
        return (0, _locationJsDefault.default).EXTERIOR;
    }
    isPointInPolygon() {
        return this.getLocation() !== (0, _locationJsDefault.default).EXTERIOR;
    }
    isOnSegment() {
        return this._isPointOnSegment;
    }
    countSegment(p1, p2) {
        if (p1.x < this._p.x && p2.x < this._p.x) return null;
        if (this._p.x === p2.x && this._p.y === p2.y) {
            this._isPointOnSegment = true;
            return null;
        }
        if (p1.y === this._p.y && p2.y === this._p.y) {
            let minx = p1.x;
            let maxx = p2.x;
            if (minx > maxx) {
                minx = p2.x;
                maxx = p1.x;
            }
            if (this._p.x >= minx && this._p.x <= maxx) this._isPointOnSegment = true;
            return null;
        }
        if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {
            let orient = (0, _orientationJsDefault.default).index(p1, p2, this._p);
            if (orient === (0, _orientationJsDefault.default).COLLINEAR) {
                this._isPointOnSegment = true;
                return null;
            }
            if (p2.y < p1.y) orient = -orient;
            if (orient === (0, _orientationJsDefault.default).LEFT) this._crossingCount++;
        }
    }
}
exports.default = RayCrossingCounter;

},{"../geom/Location.js":"9aPCX","../../../../hasInterface.js":"5bpze","../geom/Coordinate.js":"ii2fh","./Orientation.js":"avl08","../geom/CoordinateSequence.js":"aDXS8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aJaNX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class PointOnGeometryLocator {
    locate(p) {}
}
exports.default = PointOnGeometryLocator;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8NoVw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _iteratorJs = require("../../../../java/util/Iterator.js");
var _iteratorJsDefault = parcelHelpers.interopDefault(_iteratorJs);
var _noSuchElementExceptionJs = require("../../../../java/util/NoSuchElementException.js");
var _noSuchElementExceptionJsDefault = parcelHelpers.interopDefault(_noSuchElementExceptionJs);
var _geometryCollectionJs = require("./GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _unsupportedOperationExceptionJs = require("../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
class GeometryCollectionIterator {
    constructor(){
        GeometryCollectionIterator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._parent = null;
        this._atStart = null;
        this._max = null;
        this._index = null;
        this._subcollectionIterator = null;
        const parent = arguments[0];
        this._parent = parent;
        this._atStart = true;
        this._index = 0;
        this._max = parent.getNumGeometries();
    }
    static isAtomic(geom) {
        return !(geom instanceof (0, _geometryCollectionJsDefault.default));
    }
    next() {
        if (this._atStart) {
            this._atStart = false;
            if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;
            return this._parent;
        }
        if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
            else this._subcollectionIterator = null;
        }
        if (this._index >= this._max) throw new (0, _noSuchElementExceptionJsDefault.default)();
        const obj = this._parent.getGeometryN(this._index++);
        if (obj instanceof (0, _geometryCollectionJsDefault.default)) {
            this._subcollectionIterator = new GeometryCollectionIterator(obj);
            return this._subcollectionIterator.next();
        }
        return obj;
    }
    hasNext() {
        if (this._atStart) return true;
        if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return true;
            this._subcollectionIterator = null;
        }
        if (this._index >= this._max) return false;
        return true;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)(this.getClass().getName());
    }
    get interfaces_() {
        return [
            (0, _iteratorJsDefault.default)
        ];
    }
}
exports.default = GeometryCollectionIterator;

},{"../../../../java/util/Iterator.js":"zp5SP","../../../../java/util/NoSuchElementException.js":"8ozww","./GeometryCollection.js":"6RJQO","../../../../java/lang/UnsupportedOperationException.js":"dV3kx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"zp5SP":[function(require,module,exports,__globalThis) {
/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html
 * @constructor
 * @private
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Iterator {
    /**
     * Returns true if the iteration has more elements.
     * @return {boolean}
     */ hasNext() {}
    /**
     * Returns the next element in the iteration.
     * @return {Object}
     */ next() {}
    /**
     * Removes from the underlying collection the last element returned by the
     * iterator (optional operation).
     */ remove() {}
}
exports.default = Iterator;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1BZa0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _edgeEndJs = require("../../geomgraph/EdgeEnd.js");
var _edgeEndJsDefault = parcelHelpers.interopDefault(_edgeEndJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _geometryGraphJs = require("../../geomgraph/GeometryGraph.js");
var _geometryGraphJsDefault = parcelHelpers.interopDefault(_geometryGraphJs);
var _labelJs = require("../../geomgraph/Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _edgeJs = require("../../geomgraph/Edge.js");
var _edgeJsDefault = parcelHelpers.interopDefault(_edgeJs);
class EdgeEndBundle extends (0, _edgeEndJsDefault.default) {
    constructor(){
        super();
        EdgeEndBundle.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._edgeEnds = new (0, _arrayListJsDefault.default)();
        if (arguments.length === 1) {
            const e = arguments[0];
            EdgeEndBundle.constructor_.call(this, null, e);
        } else if (arguments.length === 2) {
            const boundaryNodeRule = arguments[0], e = arguments[1];
            (0, _edgeEndJsDefault.default).constructor_.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new (0, _labelJsDefault.default)(e.getLabel()));
            this.insert(e);
        }
    }
    insert(e) {
        this._edgeEnds.add(e);
    }
    print(out) {
        out.println('EdgeEndBundle--> Label: ' + this._label);
        for(let it = this.iterator(); it.hasNext();){
            const ee = it.next();
            ee.print(out);
            out.println();
        }
    }
    iterator() {
        return this._edgeEnds.iterator();
    }
    getEdgeEnds() {
        return this._edgeEnds;
    }
    computeLabelOn(geomIndex, boundaryNodeRule) {
        let boundaryCount = 0;
        let foundInterior = false;
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const loc = e.getLabel().getLocation(geomIndex);
            if (loc === (0, _locationJsDefault.default).BOUNDARY) boundaryCount++;
            if (loc === (0, _locationJsDefault.default).INTERIOR) foundInterior = true;
        }
        let loc = (0, _locationJsDefault.default).NONE;
        if (foundInterior) loc = (0, _locationJsDefault.default).INTERIOR;
        if (boundaryCount > 0) loc = (0, _geometryGraphJsDefault.default).determineBoundary(boundaryNodeRule, boundaryCount);
        this._label.setLocation(geomIndex, loc);
    }
    computeLabelSide(geomIndex, side) {
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            if (e.getLabel().isArea()) {
                const loc = e.getLabel().getLocation(geomIndex, side);
                if (loc === (0, _locationJsDefault.default).INTERIOR) {
                    this._label.setLocation(geomIndex, side, (0, _locationJsDefault.default).INTERIOR);
                    return null;
                } else if (loc === (0, _locationJsDefault.default).EXTERIOR) this._label.setLocation(geomIndex, side, (0, _locationJsDefault.default).EXTERIOR);
            }
        }
    }
    getLabel() {
        return this._label;
    }
    computeLabelSides(geomIndex) {
        this.computeLabelSide(geomIndex, (0, _positionJsDefault.default).LEFT);
        this.computeLabelSide(geomIndex, (0, _positionJsDefault.default).RIGHT);
    }
    updateIM(im) {
        (0, _edgeJsDefault.default).updateIM(this._label, im);
    }
    computeLabel(boundaryNodeRule) {
        let isArea = false;
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            if (e.getLabel().isArea()) isArea = true;
        }
        if (isArea) this._label = new (0, _labelJsDefault.default)((0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE);
        else this._label = new (0, _labelJsDefault.default)((0, _locationJsDefault.default).NONE);
        for(let i = 0; i < 2; i++){
            this.computeLabelOn(i, boundaryNodeRule);
            if (isArea) this.computeLabelSides(i);
        }
    }
}
exports.default = EdgeEndBundle;

},{"../../geom/Location.js":"9aPCX","../../geomgraph/EdgeEnd.js":"5lYIw","../../geomgraph/Position.js":"13raO","../../geomgraph/GeometryGraph.js":"eMT6T","../../geomgraph/Label.js":"dJJOo","../../../../../java/util/ArrayList.js":"gGAQZ","../../geomgraph/Edge.js":"gQhhu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eMT6T":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _hashMapJs = require("../../../../java/util/HashMap.js");
var _hashMapJsDefault = parcelHelpers.interopDefault(_hashMapJs);
var _geometryJs = require("../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _simpleMCSweepLineIntersectorJs = require("./index/SimpleMCSweepLineIntersector.js");
var _simpleMCSweepLineIntersectorJsDefault = parcelHelpers.interopDefault(_simpleMCSweepLineIntersectorJs);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _coordinateArraysJs = require("../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _polygonalJs = require("../geom/Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _planarGraphJs = require("./PlanarGraph.js");
var _planarGraphJsDefault = parcelHelpers.interopDefault(_planarGraphJs);
var _pointLocatorJs = require("../algorithm/PointLocator.js");
var _pointLocatorJsDefault = parcelHelpers.interopDefault(_pointLocatorJs);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _multiPointJs = require("../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _linearRingJs = require("../geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _boundaryNodeRuleJs = require("../algorithm/BoundaryNodeRule.js");
var _boundaryNodeRuleJsDefault = parcelHelpers.interopDefault(_boundaryNodeRuleJs);
var _segmentIntersectorJs = require("./index/SegmentIntersector.js");
var _segmentIntersectorJsDefault = parcelHelpers.interopDefault(_segmentIntersectorJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _geometryCollectionJs = require("../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _unsupportedOperationExceptionJs = require("../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
var _indexedPointInAreaLocatorJs = require("../algorithm/locate/IndexedPointInAreaLocator.js");
var _indexedPointInAreaLocatorJsDefault = parcelHelpers.interopDefault(_indexedPointInAreaLocatorJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _edgeJs = require("./Edge.js");
var _edgeJsDefault = parcelHelpers.interopDefault(_edgeJs);
class GeometryGraph extends (0, _planarGraphJsDefault.default) {
    constructor(){
        super();
        GeometryGraph.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._parentGeom = null;
        this._lineEdgeMap = new (0, _hashMapJsDefault.default)();
        this._boundaryNodeRule = null;
        this._useBoundaryDeterminationRule = true;
        this._argIndex = null;
        this._boundaryNodes = null;
        this._hasTooFewPoints = false;
        this._invalidPoint = null;
        this._areaPtLocator = null;
        this._ptLocator = new (0, _pointLocatorJsDefault.default)();
        if (arguments.length === 2) {
            const argIndex = arguments[0], parentGeom = arguments[1];
            GeometryGraph.constructor_.call(this, argIndex, parentGeom, (0, _boundaryNodeRuleJsDefault.default).OGC_SFS_BOUNDARY_RULE);
        } else if (arguments.length === 3) {
            const argIndex = arguments[0], parentGeom = arguments[1], boundaryNodeRule = arguments[2];
            this._argIndex = argIndex;
            this._parentGeom = parentGeom;
            this._boundaryNodeRule = boundaryNodeRule;
            if (parentGeom !== null) this.add(parentGeom);
        }
    }
    static determineBoundary(boundaryNodeRule, boundaryCount) {
        return boundaryNodeRule.isInBoundary(boundaryCount) ? (0, _locationJsDefault.default).BOUNDARY : (0, _locationJsDefault.default).INTERIOR;
    }
    insertBoundaryPoint(argIndex, coord) {
        const n = this._nodes.addNode(coord);
        const lbl = n.getLabel();
        let boundaryCount = 1;
        let loc = (0, _locationJsDefault.default).NONE;
        loc = lbl.getLocation(argIndex, (0, _positionJsDefault.default).ON);
        if (loc === (0, _locationJsDefault.default).BOUNDARY) boundaryCount++;
        const newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);
        lbl.setLocation(argIndex, newLoc);
    }
    computeSelfNodes() {
        if (arguments.length === 2) {
            const li = arguments[0], computeRingSelfNodes = arguments[1];
            return this.computeSelfNodes(li, computeRingSelfNodes, false);
        } else if (arguments.length === 3) {
            const li = arguments[0], computeRingSelfNodes = arguments[1], isDoneIfProperInt = arguments[2];
            const si = new (0, _segmentIntersectorJsDefault.default)(li, true, false);
            si.setIsDoneIfProperInt(isDoneIfProperInt);
            const esi = this.createEdgeSetIntersector();
            const isRings = this._parentGeom instanceof (0, _linearRingJsDefault.default) || this._parentGeom instanceof (0, _polygonJsDefault.default) || this._parentGeom instanceof (0, _multiPolygonJsDefault.default);
            const computeAllSegments = computeRingSelfNodes || !isRings;
            esi.computeIntersections(this._edges, si, computeAllSegments);
            this.addSelfIntersectionNodes(this._argIndex);
            return si;
        }
    }
    addPolygon(p) {
        this.addPolygonRing(p.getExteriorRing(), (0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR);
        for(let i = 0; i < p.getNumInteriorRing(); i++){
            const hole = p.getInteriorRingN(i);
            this.addPolygonRing(hole, (0, _locationJsDefault.default).INTERIOR, (0, _locationJsDefault.default).EXTERIOR);
        }
    }
    addEdge(e) {
        this.insertEdge(e);
        const coord = e.getCoordinates();
        this.insertPoint(this._argIndex, coord[0], (0, _locationJsDefault.default).BOUNDARY);
        this.insertPoint(this._argIndex, coord[coord.length - 1], (0, _locationJsDefault.default).BOUNDARY);
    }
    addLineString(line) {
        const coord = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(line.getCoordinates());
        if (coord.length < 2) {
            this._hasTooFewPoints = true;
            this._invalidPoint = coord[0];
            return null;
        }
        const e = new (0, _edgeJsDefault.default)(coord, new (0, _labelJsDefault.default)(this._argIndex, (0, _locationJsDefault.default).INTERIOR));
        this._lineEdgeMap.put(line, e);
        this.insertEdge(e);
        (0, _assertJsDefault.default).isTrue(coord.length >= 2, 'found LineString with single point');
        this.insertBoundaryPoint(this._argIndex, coord[0]);
        this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
    }
    getInvalidPoint() {
        return this._invalidPoint;
    }
    getBoundaryPoints() {
        const coll = this.getBoundaryNodes();
        const pts = new Array(coll.size()).fill(null);
        let i = 0;
        for(let it = coll.iterator(); it.hasNext();){
            const node = it.next();
            pts[i++] = node.getCoordinate().copy();
        }
        return pts;
    }
    addSelfIntersectionNodes(argIndex) {
        for(let i = this._edges.iterator(); i.hasNext();){
            const e = i.next();
            const eLoc = e.getLabel().getLocation(argIndex);
            for(let eiIt = e.eiList.iterator(); eiIt.hasNext();){
                const ei = eiIt.next();
                this.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
            }
        }
    }
    add() {
        if (arguments.length === 1 && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const g = arguments[0];
            if (g.isEmpty()) return null;
            if (g instanceof (0, _multiPolygonJsDefault.default)) this._useBoundaryDeterminationRule = false;
            if (g instanceof (0, _polygonJsDefault.default)) this.addPolygon(g);
            else if (g instanceof (0, _lineStringJsDefault.default)) this.addLineString(g);
            else if (g instanceof (0, _pointJsDefault.default)) this.addPoint(g);
            else if (g instanceof (0, _multiPointJsDefault.default)) this.addCollection(g);
            else if (g instanceof (0, _multiLineStringJsDefault.default)) this.addCollection(g);
            else if (g instanceof (0, _multiPolygonJsDefault.default)) this.addCollection(g);
            else if (g instanceof (0, _geometryCollectionJsDefault.default)) this.addCollection(g);
            else throw new (0, _unsupportedOperationExceptionJsDefault.default)(g.getGeometryType());
        } else return super.add.apply(this, arguments);
    }
    addCollection(gc) {
        for(let i = 0; i < gc.getNumGeometries(); i++){
            const g = gc.getGeometryN(i);
            this.add(g);
        }
    }
    locate(pt) {
        if ((0, _hasInterfaceJsDefault.default)(this._parentGeom, (0, _polygonalJsDefault.default)) && this._parentGeom.getNumGeometries() > 50) {
            if (this._areaPtLocator === null) this._areaPtLocator = new (0, _indexedPointInAreaLocatorJsDefault.default)(this._parentGeom);
            return this._areaPtLocator.locate(pt);
        }
        return this._ptLocator.locate(pt, this._parentGeom);
    }
    findEdge() {
        if (arguments.length === 1 && arguments[0] instanceof (0, _lineStringJsDefault.default)) {
            const line = arguments[0];
            return this._lineEdgeMap.get(line);
        } else return super.findEdge.apply(this, arguments);
    }
    computeSplitEdges(edgelist) {
        for(let i = this._edges.iterator(); i.hasNext();){
            const e = i.next();
            e.eiList.addSplitEdges(edgelist);
        }
    }
    computeEdgeIntersections(g, li, includeProper) {
        const si = new (0, _segmentIntersectorJsDefault.default)(li, includeProper, true);
        si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
        const esi = this.createEdgeSetIntersector();
        esi.computeIntersections(this._edges, g._edges, si);
        return si;
    }
    getGeometry() {
        return this._parentGeom;
    }
    getBoundaryNodeRule() {
        return this._boundaryNodeRule;
    }
    hasTooFewPoints() {
        return this._hasTooFewPoints;
    }
    addPoint() {
        if (arguments[0] instanceof (0, _pointJsDefault.default)) {
            const p = arguments[0];
            const coord = p.getCoordinate();
            this.insertPoint(this._argIndex, coord, (0, _locationJsDefault.default).INTERIOR);
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const pt = arguments[0];
            this.insertPoint(this._argIndex, pt, (0, _locationJsDefault.default).INTERIOR);
        }
    }
    getBoundaryNodes() {
        if (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);
        return this._boundaryNodes;
    }
    addSelfIntersectionNode(argIndex, coord, loc) {
        if (this.isBoundaryNode(argIndex, coord)) return null;
        if (loc === (0, _locationJsDefault.default).BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord);
        else this.insertPoint(argIndex, coord, loc);
    }
    addPolygonRing(lr, cwLeft, cwRight) {
        if (lr.isEmpty()) return null;
        const coord = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(lr.getCoordinates());
        if (coord.length < 4) {
            this._hasTooFewPoints = true;
            this._invalidPoint = coord[0];
            return null;
        }
        let left = cwLeft;
        let right = cwRight;
        if ((0, _orientationJsDefault.default).isCCW(coord)) {
            left = cwRight;
            right = cwLeft;
        }
        const e = new (0, _edgeJsDefault.default)(coord, new (0, _labelJsDefault.default)(this._argIndex, (0, _locationJsDefault.default).BOUNDARY, left, right));
        this._lineEdgeMap.put(lr, e);
        this.insertEdge(e);
        this.insertPoint(this._argIndex, coord[0], (0, _locationJsDefault.default).BOUNDARY);
    }
    insertPoint(argIndex, coord, onLocation) {
        const n = this._nodes.addNode(coord);
        const lbl = n.getLabel();
        if (lbl === null) n._label = new (0, _labelJsDefault.default)(argIndex, onLocation);
        else lbl.setLocation(argIndex, onLocation);
    }
    createEdgeSetIntersector() {
        return new (0, _simpleMCSweepLineIntersectorJsDefault.default)();
    }
}
exports.default = GeometryGraph;

},{"../geom/LineString.js":"4eIEg","../../../../java/util/HashMap.js":"40yYo","../geom/Geometry.js":"9DSzO","../../../../hasInterface.js":"5bpze","./Position.js":"13raO","./index/SimpleMCSweepLineIntersector.js":"kM3ci","../algorithm/Orientation.js":"avl08","./Label.js":"dJJOo","../geom/CoordinateArrays.js":"lncg4","../geom/Polygonal.js":"jIBid","../geom/MultiLineString.js":"5UyOx","./PlanarGraph.js":"etG4v","../algorithm/PointLocator.js":"lFmUP","../geom/Location.js":"9aPCX","../geom/Coordinate.js":"ii2fh","../geom/Point.js":"lwZpO","../geom/Polygon.js":"kpOA5","../geom/MultiPoint.js":"5w2To","../geom/LinearRing.js":"2x4Ym","../algorithm/BoundaryNodeRule.js":"bcj6y","./index/SegmentIntersector.js":"8euX4","../geom/MultiPolygon.js":"6Hrab","../geom/GeometryCollection.js":"6RJQO","../../../../java/lang/UnsupportedOperationException.js":"dV3kx","../algorithm/locate/IndexedPointInAreaLocator.js":"1MFtW","../util/Assert.js":"1vSRy","./Edge.js":"gQhhu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kM3ci":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _edgeSetIntersectorJs = require("./EdgeSetIntersector.js");
var _edgeSetIntersectorJsDefault = parcelHelpers.interopDefault(_edgeSetIntersectorJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
var _segmentIntersectorJs = require("./SegmentIntersector.js");
var _segmentIntersectorJsDefault = parcelHelpers.interopDefault(_segmentIntersectorJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _listJs = require("../../../../../java/util/List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
var _monotoneChainJs = require("./MonotoneChain.js");
var _monotoneChainJsDefault = parcelHelpers.interopDefault(_monotoneChainJs);
var _sweepLineEventJs = require("./SweepLineEvent.js");
var _sweepLineEventJsDefault = parcelHelpers.interopDefault(_sweepLineEventJs);
class SimpleMCSweepLineIntersector extends (0, _edgeSetIntersectorJsDefault.default) {
    constructor(){
        super();
        SimpleMCSweepLineIntersector.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.events = new (0, _arrayListJsDefault.default)();
        this.nOverlaps = null;
    }
    prepareEvents() {
        (0, _collectionsJsDefault.default).sort(this.events);
        for(let i = 0; i < this.events.size(); i++){
            const ev = this.events.get(i);
            if (ev.isDelete()) ev.getInsertEvent().setDeleteEventIndex(i);
        }
    }
    computeIntersections() {
        if (arguments.length === 1) {
            const si = arguments[0];
            this.nOverlaps = 0;
            this.prepareEvents();
            for(let i = 0; i < this.events.size(); i++){
                const ev = this.events.get(i);
                if (ev.isInsert()) this.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
                if (si.isDone()) break;
            }
        } else if (arguments.length === 3) {
            if (arguments[2] instanceof (0, _segmentIntersectorJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[0], (0, _listJsDefault.default)) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _listJsDefault.default))) {
                const edges0 = arguments[0], edges1 = arguments[1], si = arguments[2];
                this.addEdges(edges0, edges0);
                this.addEdges(edges1, edges1);
                this.computeIntersections(si);
            } else if (typeof arguments[2] === 'boolean' && (0, _hasInterfaceJsDefault.default)(arguments[0], (0, _listJsDefault.default)) && arguments[1] instanceof (0, _segmentIntersectorJsDefault.default)) {
                const edges = arguments[0], si = arguments[1], testAllSegments = arguments[2];
                if (testAllSegments) this.addEdges(edges, null);
                else this.addEdges(edges);
                this.computeIntersections(si);
            }
        }
    }
    addEdge(edge, edgeSet) {
        const mce = edge.getMonotoneChainEdge();
        const startIndex = mce.getStartIndexes();
        for(let i = 0; i < startIndex.length - 1; i++){
            const mc = new (0, _monotoneChainJsDefault.default)(mce, i);
            const insertEvent = new (0, _sweepLineEventJsDefault.default)(edgeSet, mce.getMinX(i), mc);
            this.events.add(insertEvent);
            this.events.add(new (0, _sweepLineEventJsDefault.default)(mce.getMaxX(i), insertEvent));
        }
    }
    processOverlaps(start, end, ev0, si) {
        const mc0 = ev0.getObject();
        for(let i = start; i < end; i++){
            const ev1 = this.events.get(i);
            if (ev1.isInsert()) {
                const mc1 = ev1.getObject();
                if (!ev0.isSameLabel(ev1)) {
                    mc0.computeIntersections(mc1, si);
                    this.nOverlaps++;
                }
            }
        }
    }
    addEdges() {
        if (arguments.length === 1) {
            const edges = arguments[0];
            for(let i = edges.iterator(); i.hasNext();){
                const edge = i.next();
                this.addEdge(edge, edge);
            }
        } else if (arguments.length === 2) {
            const edges = arguments[0], edgeSet = arguments[1];
            for(let i = edges.iterator(); i.hasNext();){
                const edge = i.next();
                this.addEdge(edge, edgeSet);
            }
        }
    }
}
exports.default = SimpleMCSweepLineIntersector;

},{"../../../../../hasInterface.js":"5bpze","./EdgeSetIntersector.js":"co6Fg","../../../../../java/util/Collections.js":"c5dcW","./SegmentIntersector.js":"8euX4","../../../../../java/util/ArrayList.js":"gGAQZ","../../../../../java/util/List.js":"7jAhK","./MonotoneChain.js":"80YB0","./SweepLineEvent.js":"vslxl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"co6Fg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class EdgeSetIntersector {
}
exports.default = EdgeSetIntersector;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c5dcW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arraysJs = require("./Arrays.js");
var _arraysJsDefault = parcelHelpers.interopDefault(_arraysJs);
var _arrayListJs = require("./ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
const Collections = {
    reverseOrder: function() {
        return {
            compare (a, b) {
                return b.compareTo(a);
            }
        };
    },
    min: function(l) {
        Collections.sort(l);
        return l.get(0);
    },
    sort: function(l, c) {
        const a = l.toArray();
        if (c) (0, _arraysJsDefault.default).sort(a, c);
        else (0, _arraysJsDefault.default).sort(a);
        const i = l.iterator();
        for(let pos = 0, alen = a.length; pos < alen; pos++){
            i.next();
            i.set(a[pos]);
        }
    },
    singletonList: function(o) {
        const arrayList = new (0, _arrayListJsDefault.default)();
        arrayList.add(o);
        return arrayList;
    }
};
exports.default = Collections;

},{"./Arrays.js":"a6V8H","./ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8euX4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class SegmentIntersector {
    constructor(){
        SegmentIntersector.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._hasIntersection = false;
        this._hasProper = false;
        this._hasProperInterior = false;
        this._properIntersectionPoint = null;
        this._li = null;
        this._includeProper = null;
        this._recordIsolated = null;
        this._isSelfIntersection = null;
        this._numIntersections = 0;
        this.numTests = 0;
        this._bdyNodes = null;
        this._isDone = false;
        this._isDoneWhenProperInt = false;
        const li = arguments[0], includeProper = arguments[1], recordIsolated = arguments[2];
        this._li = li;
        this._includeProper = includeProper;
        this._recordIsolated = recordIsolated;
    }
    static isAdjacentSegments(i1, i2) {
        return Math.abs(i1 - i2) === 1;
    }
    isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
        if (e0 === e1) {
            if (this._li.getIntersectionNum() === 1) {
                if (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;
                if (e0.isClosed()) {
                    const maxSegIndex = e0.getNumPoints() - 1;
                    if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) return true;
                }
            }
        }
        return false;
    }
    hasProperInteriorIntersection() {
        return this._hasProperInterior;
    }
    isBoundaryPointInternal(li, bdyNodes) {
        for(let i = bdyNodes.iterator(); i.hasNext();){
            const node = i.next();
            const pt = node.getCoordinate();
            if (li.isIntersection(pt)) return true;
        }
        return false;
    }
    hasProperIntersection() {
        return this._hasProper;
    }
    hasIntersection() {
        return this._hasIntersection;
    }
    isDone() {
        return this._isDone;
    }
    isBoundaryPoint(li, bdyNodes) {
        if (bdyNodes === null) return false;
        if (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;
        if (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;
        return false;
    }
    setBoundaryNodes(bdyNodes0, bdyNodes1) {
        this._bdyNodes = new Array(2).fill(null);
        this._bdyNodes[0] = bdyNodes0;
        this._bdyNodes[1] = bdyNodes1;
    }
    addIntersections(e0, segIndex0, e1, segIndex1) {
        if (e0 === e1 && segIndex0 === segIndex1) return null;
        this.numTests++;
        const p00 = e0.getCoordinates()[segIndex0];
        const p01 = e0.getCoordinates()[segIndex0 + 1];
        const p10 = e1.getCoordinates()[segIndex1];
        const p11 = e1.getCoordinates()[segIndex1 + 1];
        this._li.computeIntersection(p00, p01, p10, p11);
        if (this._li.hasIntersection()) {
            if (this._recordIsolated) {
                e0.setIsolated(false);
                e1.setIsolated(false);
            }
            this._numIntersections++;
            if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
                this._hasIntersection = true;
                if (this._includeProper || !this._li.isProper()) {
                    e0.addIntersections(this._li, segIndex0, 0);
                    e1.addIntersections(this._li, segIndex1, 1);
                }
                if (this._li.isProper()) {
                    this._properIntersectionPoint = this._li.getIntersection(0).copy();
                    this._hasProper = true;
                    if (this._isDoneWhenProperInt) this._isDone = true;
                    if (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;
                }
            }
        }
    }
    getProperIntersectionPoint() {
        return this._properIntersectionPoint;
    }
    setIsDoneIfProperInt(isDoneWhenProperInt) {
        this._isDoneWhenProperInt = isDoneWhenProperInt;
    }
}
exports.default = SegmentIntersector;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"80YB0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class MonotoneChain {
    constructor(){
        MonotoneChain.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.mce = null;
        this.chainIndex = null;
        const mce = arguments[0], chainIndex = arguments[1];
        this.mce = mce;
        this.chainIndex = chainIndex;
    }
    computeIntersections(mc, si) {
        this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
    }
}
exports.default = MonotoneChain;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"vslxl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparableJs = require("../../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
class SweepLineEvent {
    constructor(){
        SweepLineEvent.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._label = null;
        this._xValue = null;
        this._eventType = null;
        this._insertEvent = null;
        this._deleteEventIndex = null;
        this._obj = null;
        if (arguments.length === 2) {
            const x = arguments[0], insertEvent = arguments[1];
            this._eventType = SweepLineEvent.DELETE;
            this._xValue = x;
            this._insertEvent = insertEvent;
        } else if (arguments.length === 3) {
            const label = arguments[0], x = arguments[1], obj = arguments[2];
            this._eventType = SweepLineEvent.INSERT;
            this._label = label;
            this._xValue = x;
            this._obj = obj;
        }
    }
    getObject() {
        return this._obj;
    }
    getDeleteEventIndex() {
        return this._deleteEventIndex;
    }
    isDelete() {
        return this._eventType === SweepLineEvent.DELETE;
    }
    setDeleteEventIndex(deleteEventIndex) {
        this._deleteEventIndex = deleteEventIndex;
    }
    compareTo(o) {
        const pe = o;
        if (this._xValue < pe._xValue) return -1;
        if (this._xValue > pe._xValue) return 1;
        if (this._eventType < pe._eventType) return -1;
        if (this._eventType > pe._eventType) return 1;
        return 0;
    }
    getInsertEvent() {
        return this._insertEvent;
    }
    isInsert() {
        return this._eventType === SweepLineEvent.INSERT;
    }
    isSameLabel(ev) {
        if (this._label === null) return false;
        return this._label === ev._label;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = SweepLineEvent;
SweepLineEvent.INSERT = 1;
SweepLineEvent.DELETE = 2;

},{"../../../../../java/lang/Comparable.js":"WFeEu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"etG4v":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _nodeJs = require("./Node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
var _nodeMapJs = require("./NodeMap.js");
var _nodeMapJsDefault = parcelHelpers.interopDefault(_nodeMapJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _quadrantJs = require("./Quadrant.js");
var _quadrantJsDefault = parcelHelpers.interopDefault(_quadrantJs);
var _nodeFactoryJs = require("./NodeFactory.js");
var _nodeFactoryJsDefault = parcelHelpers.interopDefault(_nodeFactoryJs);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _directedEdgeJs = require("./DirectedEdge.js");
var _directedEdgeJsDefault = parcelHelpers.interopDefault(_directedEdgeJs);
class PlanarGraph {
    constructor(){
        PlanarGraph.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._edges = new (0, _arrayListJsDefault.default)();
        this._nodes = null;
        this._edgeEndList = new (0, _arrayListJsDefault.default)();
        if (arguments.length === 0) this._nodes = new (0, _nodeMapJsDefault.default)(new (0, _nodeFactoryJsDefault.default)());
        else if (arguments.length === 1) {
            const nodeFact = arguments[0];
            this._nodes = new (0, _nodeMapJsDefault.default)(nodeFact);
        }
    }
    static linkResultDirectedEdges(nodes) {
        for(let nodeit = nodes.iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().linkResultDirectedEdges();
        }
    }
    printEdges(out) {
        out.println('Edges:');
        for(let i = 0; i < this._edges.size(); i++){
            out.println('edge ' + i + ':');
            const e = this._edges.get(i);
            e.print(out);
            e.eiList.print(out);
        }
    }
    debugPrintln(o) {
        (0, _systemJsDefault.default).out.println(o);
    }
    isBoundaryNode(geomIndex, coord) {
        const node = this._nodes.find(coord);
        if (node === null) return false;
        const label = node.getLabel();
        if (label !== null && label.getLocation(geomIndex) === (0, _locationJsDefault.default).BOUNDARY) return true;
        return false;
    }
    linkAllDirectedEdges() {
        for(let nodeit = this._nodes.iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().linkAllDirectedEdges();
        }
    }
    debugPrint(o) {
        (0, _systemJsDefault.default).out.print(o);
    }
    findEdgeEnd(e) {
        for(let i = this.getEdgeEnds().iterator(); i.hasNext();){
            const ee = i.next();
            if (ee.getEdge() === e) return ee;
        }
        return null;
    }
    getNodes() {
        return this._nodes.values();
    }
    findEdge(p0, p1) {
        for(let i = 0; i < this._edges.size(); i++){
            const e = this._edges.get(i);
            const eCoord = e.getCoordinates();
            if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;
        }
        return null;
    }
    find(coord) {
        return this._nodes.find(coord);
    }
    addNode() {
        if (arguments[0] instanceof (0, _nodeJsDefault.default)) {
            const node = arguments[0];
            return this._nodes.addNode(node);
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const coord = arguments[0];
            return this._nodes.addNode(coord);
        }
    }
    getNodeIterator() {
        return this._nodes.iterator();
    }
    linkResultDirectedEdges() {
        for(let nodeit = this._nodes.iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().linkResultDirectedEdges();
        }
    }
    matchInSameDirection(p0, p1, ep0, ep1) {
        if (!p0.equals(ep0)) return false;
        if ((0, _orientationJsDefault.default).index(p0, p1, ep1) === (0, _orientationJsDefault.default).COLLINEAR && (0, _quadrantJsDefault.default).quadrant(p0, p1) === (0, _quadrantJsDefault.default).quadrant(ep0, ep1)) return true;
        return false;
    }
    getEdgeEnds() {
        return this._edgeEndList;
    }
    getEdgeIterator() {
        return this._edges.iterator();
    }
    findEdgeInSameDirection(p0, p1) {
        for(let i = 0; i < this._edges.size(); i++){
            const e = this._edges.get(i);
            const eCoord = e.getCoordinates();
            if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;
            if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;
        }
        return null;
    }
    insertEdge(e) {
        this._edges.add(e);
    }
    addEdges(edgesToAdd) {
        for(let it = edgesToAdd.iterator(); it.hasNext();){
            const e = it.next();
            this._edges.add(e);
            const de1 = new (0, _directedEdgeJsDefault.default)(e, true);
            const de2 = new (0, _directedEdgeJsDefault.default)(e, false);
            de1.setSym(de2);
            de2.setSym(de1);
            this.add(de1);
            this.add(de2);
        }
    }
    add(e) {
        this._nodes.add(e);
        this._edgeEndList.add(e);
    }
}
exports.default = PlanarGraph;

},{"../geom/Location.js":"9aPCX","../geom/Coordinate.js":"ii2fh","./Node.js":"azV0J","./NodeMap.js":"2ZFXA","../../../../java/lang/System.js":"dYmTx","../../../../java/util/ArrayList.js":"gGAQZ","./Quadrant.js":"86Qmh","./NodeFactory.js":"5wP5U","../algorithm/Orientation.js":"avl08","./DirectedEdge.js":"aFTwO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5wP5U":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nodeJs = require("./Node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
class NodeFactory {
    createNode(coord) {
        return new (0, _nodeJsDefault.default)(coord, null);
    }
}
exports.default = NodeFactory;

},{"./Node.js":"azV0J","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aFTwO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _edgeEndJs = require("./EdgeEnd.js");
var _edgeEndJsDefault = parcelHelpers.interopDefault(_edgeEndJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _topologyExceptionJs = require("../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
class DirectedEdge extends (0, _edgeEndJsDefault.default) {
    constructor(){
        super();
        DirectedEdge.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._isForward = null;
        this._isInResult = false;
        this._isVisited = false;
        this._sym = null;
        this._next = null;
        this._nextMin = null;
        this._edgeRing = null;
        this._minEdgeRing = null;
        this._depth = [
            0,
            -999,
            -999
        ];
        const edge = arguments[0], isForward = arguments[1];
        (0, _edgeEndJsDefault.default).constructor_.call(this, edge);
        this._isForward = isForward;
        if (isForward) this.init(edge.getCoordinate(0), edge.getCoordinate(1));
        else {
            const n = edge.getNumPoints() - 1;
            this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
        }
        this.computeDirectedLabel();
    }
    static depthFactor(currLocation, nextLocation) {
        if (currLocation === (0, _locationJsDefault.default).EXTERIOR && nextLocation === (0, _locationJsDefault.default).INTERIOR) return 1;
        else if (currLocation === (0, _locationJsDefault.default).INTERIOR && nextLocation === (0, _locationJsDefault.default).EXTERIOR) return -1;
        return 0;
    }
    setVisited(isVisited) {
        this._isVisited = isVisited;
    }
    setDepth(position, depthVal) {
        if (this._depth[position] !== -999) {
            if (this._depth[position] !== depthVal) throw new (0, _topologyExceptionJsDefault.default)('assigned depths do not match', this.getCoordinate());
        }
        this._depth[position] = depthVal;
    }
    isInteriorAreaEdge() {
        let isInteriorAreaEdge = true;
        for(let i = 0; i < 2; i++)if (!(this._label.isArea(i) && this._label.getLocation(i, (0, _positionJsDefault.default).LEFT) === (0, _locationJsDefault.default).INTERIOR && this._label.getLocation(i, (0, _positionJsDefault.default).RIGHT) === (0, _locationJsDefault.default).INTERIOR)) isInteriorAreaEdge = false;
        return isInteriorAreaEdge;
    }
    setNextMin(nextMin) {
        this._nextMin = nextMin;
    }
    print(out) {
        super.print.call(this, out);
        out.print(' ' + this._depth[(0, _positionJsDefault.default).LEFT] + '/' + this._depth[(0, _positionJsDefault.default).RIGHT]);
        out.print(' (' + this.getDepthDelta() + ')');
        if (this._isInResult) out.print(' inResult');
    }
    setMinEdgeRing(minEdgeRing) {
        this._minEdgeRing = minEdgeRing;
    }
    getSym() {
        return this._sym;
    }
    isForward() {
        return this._isForward;
    }
    setSym(de) {
        this._sym = de;
    }
    setVisitedEdge(isVisited) {
        this.setVisited(isVisited);
        this._sym.setVisited(isVisited);
    }
    getNextMin() {
        return this._nextMin;
    }
    getDepth(position) {
        return this._depth[position];
    }
    computeDirectedLabel() {
        this._label = new (0, _labelJsDefault.default)(this._edge.getLabel());
        if (!this._isForward) this._label.flip();
    }
    getNext() {
        return this._next;
    }
    isLineEdge() {
        const isLine = this._label.isLine(0) || this._label.isLine(1);
        const isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, (0, _locationJsDefault.default).EXTERIOR);
        const isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, (0, _locationJsDefault.default).EXTERIOR);
        return isLine && isExteriorIfArea0 && isExteriorIfArea1;
    }
    setEdgeRing(edgeRing) {
        this._edgeRing = edgeRing;
    }
    getMinEdgeRing() {
        return this._minEdgeRing;
    }
    getDepthDelta() {
        let depthDelta = this._edge.getDepthDelta();
        if (!this._isForward) depthDelta = -depthDelta;
        return depthDelta;
    }
    setInResult(isInResult) {
        this._isInResult = isInResult;
    }
    getEdge() {
        return this._edge;
    }
    printEdge(out) {
        this.print(out);
        out.print(' ');
        if (this._isForward) this._edge.print(out);
        else this._edge.printReverse(out);
    }
    setEdgeDepths(position, depth) {
        let depthDelta = this.getEdge().getDepthDelta();
        if (!this._isForward) depthDelta = -depthDelta;
        let directionFactor = 1;
        if (position === (0, _positionJsDefault.default).LEFT) directionFactor = -1;
        const oppositePos = (0, _positionJsDefault.default).opposite(position);
        const delta = depthDelta * directionFactor;
        const oppositeDepth = depth + delta;
        this.setDepth(position, depth);
        this.setDepth(oppositePos, oppositeDepth);
    }
    getEdgeRing() {
        return this._edgeRing;
    }
    isInResult() {
        return this._isInResult;
    }
    setNext(next) {
        this._next = next;
    }
    isVisited() {
        return this._isVisited;
    }
}
exports.default = DirectedEdge;

},{"../geom/Location.js":"9aPCX","./EdgeEnd.js":"5lYIw","./Position.js":"13raO","../geom/TopologyException.js":"bOVA5","./Label.js":"dJJOo","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lFmUP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _pointLocationJs = require("./PointLocation.js");
var _pointLocationJsDefault = parcelHelpers.interopDefault(_pointLocationJs);
var _boundaryNodeRuleJs = require("./BoundaryNodeRule.js");
var _boundaryNodeRuleJsDefault = parcelHelpers.interopDefault(_boundaryNodeRuleJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _geometryCollectionIteratorJs = require("../geom/GeometryCollectionIterator.js");
var _geometryCollectionIteratorJsDefault = parcelHelpers.interopDefault(_geometryCollectionIteratorJs);
var _geometryCollectionJs = require("../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
class PointLocator {
    constructor(){
        PointLocator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._boundaryRule = (0, _boundaryNodeRuleJsDefault.default).OGC_SFS_BOUNDARY_RULE;
        this._isIn = null;
        this._numBoundaries = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const boundaryRule = arguments[0];
            if (boundaryRule === null) throw new (0, _illegalArgumentExceptionJsDefault.default)('Rule must be non-null');
            this._boundaryRule = boundaryRule;
        }
    }
    locateInPolygonRing(p, ring) {
        if (!ring.getEnvelopeInternal().intersects(p)) return (0, _locationJsDefault.default).EXTERIOR;
        return (0, _pointLocationJsDefault.default).locateInRing(p, ring.getCoordinates());
    }
    intersects(p, geom) {
        return this.locate(p, geom) !== (0, _locationJsDefault.default).EXTERIOR;
    }
    updateLocationInfo(loc) {
        if (loc === (0, _locationJsDefault.default).INTERIOR) this._isIn = true;
        if (loc === (0, _locationJsDefault.default).BOUNDARY) this._numBoundaries++;
    }
    computeLocation(p, geom) {
        if (geom instanceof (0, _pointJsDefault.default)) this.updateLocationInfo(this.locateOnPoint(p, geom));
        if (geom instanceof (0, _lineStringJsDefault.default)) this.updateLocationInfo(this.locateOnLineString(p, geom));
        else if (geom instanceof (0, _polygonJsDefault.default)) this.updateLocationInfo(this.locateInPolygon(p, geom));
        else if (geom instanceof (0, _multiLineStringJsDefault.default)) {
            const ml = geom;
            for(let i = 0; i < ml.getNumGeometries(); i++){
                const l = ml.getGeometryN(i);
                this.updateLocationInfo(this.locateOnLineString(p, l));
            }
        } else if (geom instanceof (0, _multiPolygonJsDefault.default)) {
            const mpoly = geom;
            for(let i = 0; i < mpoly.getNumGeometries(); i++){
                const poly = mpoly.getGeometryN(i);
                this.updateLocationInfo(this.locateInPolygon(p, poly));
            }
        } else if (geom instanceof (0, _geometryCollectionJsDefault.default)) {
            const geomi = new (0, _geometryCollectionIteratorJsDefault.default)(geom);
            while(geomi.hasNext()){
                const g2 = geomi.next();
                if (g2 !== geom) this.computeLocation(p, g2);
            }
        }
    }
    locateOnPoint(p, pt) {
        const ptCoord = pt.getCoordinate();
        if (ptCoord.equals2D(p)) return (0, _locationJsDefault.default).INTERIOR;
        return (0, _locationJsDefault.default).EXTERIOR;
    }
    locateOnLineString(p, l) {
        if (!l.getEnvelopeInternal().intersects(p)) return (0, _locationJsDefault.default).EXTERIOR;
        const seq = l.getCoordinateSequence();
        if (!l.isClosed()) {
            if (p.equals(seq.getCoordinate(0)) || p.equals(seq.getCoordinate(seq.size() - 1))) return (0, _locationJsDefault.default).BOUNDARY;
        }
        if ((0, _pointLocationJsDefault.default).isOnLine(p, seq)) return (0, _locationJsDefault.default).INTERIOR;
        return (0, _locationJsDefault.default).EXTERIOR;
    }
    locateInPolygon(p, poly) {
        if (poly.isEmpty()) return (0, _locationJsDefault.default).EXTERIOR;
        const shell = poly.getExteriorRing();
        const shellLoc = this.locateInPolygonRing(p, shell);
        if (shellLoc === (0, _locationJsDefault.default).EXTERIOR) return (0, _locationJsDefault.default).EXTERIOR;
        if (shellLoc === (0, _locationJsDefault.default).BOUNDARY) return (0, _locationJsDefault.default).BOUNDARY;
        for(let i = 0; i < poly.getNumInteriorRing(); i++){
            const hole = poly.getInteriorRingN(i);
            const holeLoc = this.locateInPolygonRing(p, hole);
            if (holeLoc === (0, _locationJsDefault.default).INTERIOR) return (0, _locationJsDefault.default).EXTERIOR;
            if (holeLoc === (0, _locationJsDefault.default).BOUNDARY) return (0, _locationJsDefault.default).BOUNDARY;
        }
        return (0, _locationJsDefault.default).INTERIOR;
    }
    locate(p, geom) {
        if (geom.isEmpty()) return (0, _locationJsDefault.default).EXTERIOR;
        if (geom instanceof (0, _lineStringJsDefault.default)) return this.locateOnLineString(p, geom);
        else if (geom instanceof (0, _polygonJsDefault.default)) return this.locateInPolygon(p, geom);
        this._isIn = false;
        this._numBoundaries = 0;
        this.computeLocation(p, geom);
        if (this._boundaryRule.isInBoundary(this._numBoundaries)) return (0, _locationJsDefault.default).BOUNDARY;
        if (this._numBoundaries > 0 || this._isIn) return (0, _locationJsDefault.default).INTERIOR;
        return (0, _locationJsDefault.default).EXTERIOR;
    }
}
exports.default = PointLocator;

},{"../geom/Location.js":"9aPCX","../geom/LineString.js":"4eIEg","../geom/Polygon.js":"kpOA5","./PointLocation.js":"l7FlP","./BoundaryNodeRule.js":"bcj6y","../geom/MultiPolygon.js":"6Hrab","../geom/GeometryCollectionIterator.js":"8NoVw","../geom/GeometryCollection.js":"6RJQO","../geom/MultiLineString.js":"5UyOx","../../../../java/lang/IllegalArgumentException.js":"9ppVW","../geom/Point.js":"lwZpO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bcj6y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class BoundaryNodeRule {
    isInBoundary(boundaryCount) {}
}
exports.default = BoundaryNodeRule;
class Mod2BoundaryNodeRule {
    isInBoundary(boundaryCount) {
        return boundaryCount % 2 === 1;
    }
    get interfaces_() {
        return [
            BoundaryNodeRule
        ];
    }
}
class EndPointBoundaryNodeRule {
    isInBoundary(boundaryCount) {
        return boundaryCount > 0;
    }
    get interfaces_() {
        return [
            BoundaryNodeRule
        ];
    }
}
class MultiValentEndPointBoundaryNodeRule {
    isInBoundary(boundaryCount) {
        return boundaryCount > 1;
    }
    get interfaces_() {
        return [
            BoundaryNodeRule
        ];
    }
}
class MonoValentEndPointBoundaryNodeRule {
    isInBoundary(boundaryCount) {
        return boundaryCount === 1;
    }
    get interfaces_() {
        return [
            BoundaryNodeRule
        ];
    }
}
BoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;
BoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;
BoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;
BoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;
BoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();
BoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();
BoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();
BoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();
BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1MFtW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _illegalArgumentExceptionJs = require("../../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _itemVisitorJs = require("../../index/ItemVisitor.js");
var _itemVisitorJsDefault = parcelHelpers.interopDefault(_itemVisitorJs);
var _pointOnGeometryLocatorJs = require("./PointOnGeometryLocator.js");
var _pointOnGeometryLocatorJsDefault = parcelHelpers.interopDefault(_pointOnGeometryLocatorJs);
var _linearRingJs = require("../../geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _sortedPackedIntervalRTreeJs = require("../../index/intervalrtree/SortedPackedIntervalRTree.js");
var _sortedPackedIntervalRTreeJsDefault = parcelHelpers.interopDefault(_sortedPackedIntervalRTreeJs);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
var _linearComponentExtracterJs = require("../../geom/util/LinearComponentExtracter.js");
var _linearComponentExtracterJsDefault = parcelHelpers.interopDefault(_linearComponentExtracterJs);
var _arrayListVisitorJs = require("../../index/ArrayListVisitor.js");
var _arrayListVisitorJsDefault = parcelHelpers.interopDefault(_arrayListVisitorJs);
var _rayCrossingCounterJs = require("../RayCrossingCounter.js");
var _rayCrossingCounterJsDefault = parcelHelpers.interopDefault(_rayCrossingCounterJs);
var _polygonalJs = require("../../geom/Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class IndexedPointInAreaLocator {
    constructor(){
        IndexedPointInAreaLocator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geom = null;
        this._index = null;
        const g = arguments[0];
        if (!((0, _hasInterfaceJsDefault.default)(g, (0, _polygonalJsDefault.default)) || g instanceof (0, _linearRingJsDefault.default))) throw new (0, _illegalArgumentExceptionJsDefault.default)('Argument must be Polygonal or LinearRing');
        this._geom = g;
    }
    locate(p) {
        if (this._index === null) {
            this._index = new IntervalIndexedGeometry(this._geom);
            this._geom = null;
        }
        const rcc = new (0, _rayCrossingCounterJsDefault.default)(p);
        const visitor = new SegmentVisitor(rcc);
        this._index.query(p.y, p.y, visitor);
        return rcc.getLocation();
    }
    get interfaces_() {
        return [
            (0, _pointOnGeometryLocatorJsDefault.default)
        ];
    }
}
exports.default = IndexedPointInAreaLocator;
class SegmentVisitor {
    constructor(){
        SegmentVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._counter = null;
        const counter = arguments[0];
        this._counter = counter;
    }
    visitItem(item) {
        const seg = item;
        this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
    }
    get interfaces_() {
        return [
            (0, _itemVisitorJsDefault.default)
        ];
    }
}
class IntervalIndexedGeometry {
    constructor(){
        IntervalIndexedGeometry.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._isEmpty = false;
        this._index = new (0, _sortedPackedIntervalRTreeJsDefault.default)();
        const geom = arguments[0];
        if (geom.isEmpty()) this._isEmpty = true;
        else this.init(geom);
    }
    init(geom) {
        const lines = (0, _linearComponentExtracterJsDefault.default).getLines(geom);
        for(let i = lines.iterator(); i.hasNext();){
            const line = i.next();
            const pts = line.getCoordinates();
            this.addLine(pts);
        }
    }
    addLine(pts) {
        for(let i = 1; i < pts.length; i++){
            const seg = new (0, _lineSegmentJsDefault.default)(pts[i - 1], pts[i]);
            const min = Math.min(seg.p0.y, seg.p1.y);
            const max = Math.max(seg.p0.y, seg.p1.y);
            this._index.insert(min, max, seg);
        }
    }
    query() {
        if (arguments.length === 2) {
            const min = arguments[0], max = arguments[1];
            if (this._isEmpty) return new (0, _arrayListJsDefault.default)();
            const visitor = new (0, _arrayListVisitorJsDefault.default)();
            this._index.query(min, max, visitor);
            return visitor.getItems();
        } else if (arguments.length === 3) {
            const min = arguments[0], max = arguments[1], visitor = arguments[2];
            if (this._isEmpty) return null;
            this._index.query(min, max, visitor);
        }
    }
}
IndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;
IndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;

},{"../../../../../hasInterface.js":"5bpze","../../../../../java/lang/IllegalArgumentException.js":"9ppVW","../../index/ItemVisitor.js":"nuRea","./PointOnGeometryLocator.js":"aJaNX","../../geom/LinearRing.js":"2x4Ym","../../index/intervalrtree/SortedPackedIntervalRTree.js":"7OWXC","../../geom/LineSegment.js":"8Ncbv","../../geom/util/LinearComponentExtracter.js":"2LyeQ","../../index/ArrayListVisitor.js":"7KSI5","../RayCrossingCounter.js":"g16hB","../../geom/Polygonal.js":"jIBid","../../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"nuRea":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class ItemVisitor {
    visitItem(item) {}
}
exports.default = ItemVisitor;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7OWXC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktwriterJs = require("../../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _intervalRTreeLeafNodeJs = require("./IntervalRTreeLeafNode.js");
var _intervalRTreeLeafNodeJsDefault = parcelHelpers.interopDefault(_intervalRTreeLeafNodeJs);
var _intervalRTreeNodeJs = require("./IntervalRTreeNode.js");
var _intervalRTreeNodeJsDefault = parcelHelpers.interopDefault(_intervalRTreeNodeJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
var _systemJs = require("../../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _illegalStateExceptionJs = require("../../../../../java/lang/IllegalStateException.js");
var _illegalStateExceptionJsDefault = parcelHelpers.interopDefault(_illegalStateExceptionJs);
var _intervalRTreeBranchNodeJs = require("./IntervalRTreeBranchNode.js");
var _intervalRTreeBranchNodeJsDefault = parcelHelpers.interopDefault(_intervalRTreeBranchNodeJs);
class SortedPackedIntervalRTree {
    constructor(){
        SortedPackedIntervalRTree.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._leaves = new (0, _arrayListJsDefault.default)();
        this._root = null;
        this._level = 0;
    }
    buildTree() {
        (0, _collectionsJsDefault.default).sort(this._leaves, new (0, _intervalRTreeNodeJsDefault.default).NodeComparator());
        let src = this._leaves;
        let temp = null;
        let dest = new (0, _arrayListJsDefault.default)();
        while(true){
            this.buildLevel(src, dest);
            if (dest.size() === 1) return dest.get(0);
            temp = src;
            src = dest;
            dest = temp;
        }
    }
    insert(min, max, item) {
        if (this._root !== null) throw new (0, _illegalStateExceptionJsDefault.default)('Index cannot be added to once it has been queried');
        this._leaves.add(new (0, _intervalRTreeLeafNodeJsDefault.default)(min, max, item));
    }
    query(min, max, visitor) {
        this.init();
        if (this._root === null) return null;
        this._root.query(min, max, visitor);
    }
    buildRoot() {
        if (this._root !== null) return null;
        this._root = this.buildTree();
    }
    printNode(node) {
        (0, _systemJsDefault.default).out.println((0, _wktwriterJsDefault.default).toLineString(new (0, _coordinateJsDefault.default)(node._min, this._level), new (0, _coordinateJsDefault.default)(node._max, this._level)));
    }
    init() {
        if (this._root !== null) return null;
        if (this._leaves.size() === 0) return null;
        this.buildRoot();
    }
    buildLevel(src, dest) {
        this._level++;
        dest.clear();
        for(let i = 0; i < src.size(); i += 2){
            const n1 = src.get(i);
            const n2 = i + 1 < src.size() ? src.get(i) : null;
            if (n2 === null) dest.add(n1);
            else {
                const node = new (0, _intervalRTreeBranchNodeJsDefault.default)(src.get(i), src.get(i + 1));
                dest.add(node);
            }
        }
    }
}
exports.default = SortedPackedIntervalRTree;

},{"../../io/WKTWriter.js":"1WLaw","../../geom/Coordinate.js":"ii2fh","./IntervalRTreeLeafNode.js":"2Ku3u","./IntervalRTreeNode.js":"6tTkW","../../../../../java/util/Collections.js":"c5dcW","../../../../../java/lang/System.js":"dYmTx","../../../../../java/util/ArrayList.js":"gGAQZ","../../../../../java/lang/IllegalStateException.js":"efv6w","./IntervalRTreeBranchNode.js":"l3t0Q","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2Ku3u":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _intervalRTreeNodeJs = require("./IntervalRTreeNode.js");
var _intervalRTreeNodeJsDefault = parcelHelpers.interopDefault(_intervalRTreeNodeJs);
class IntervalRTreeLeafNode extends (0, _intervalRTreeNodeJsDefault.default) {
    constructor(){
        super();
        IntervalRTreeLeafNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._item = null;
        const min = arguments[0], max = arguments[1], item = arguments[2];
        this._min = min;
        this._max = max;
        this._item = item;
    }
    query(queryMin, queryMax, visitor) {
        if (!this.intersects(queryMin, queryMax)) return null;
        visitor.visitItem(this._item);
    }
}
exports.default = IntervalRTreeLeafNode;

},{"./IntervalRTreeNode.js":"6tTkW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6tTkW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktwriterJs = require("../../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _comparatorJs = require("../../../../../java/util/Comparator.js");
var _comparatorJsDefault = parcelHelpers.interopDefault(_comparatorJs);
class IntervalRTreeNode {
    constructor(){
        IntervalRTreeNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._min = (0, _doubleJsDefault.default).POSITIVE_INFINITY;
        this._max = (0, _doubleJsDefault.default).NEGATIVE_INFINITY;
    }
    getMin() {
        return this._min;
    }
    intersects(queryMin, queryMax) {
        if (this._min > queryMax || this._max < queryMin) return false;
        return true;
    }
    getMax() {
        return this._max;
    }
    toString() {
        return (0, _wktwriterJsDefault.default).toLineString(new (0, _coordinateJsDefault.default)(this._min, 0), new (0, _coordinateJsDefault.default)(this._max, 0));
    }
}
exports.default = IntervalRTreeNode;
class NodeComparator {
    compare(o1, o2) {
        const n1 = o1;
        const n2 = o2;
        const mid1 = (n1._min + n1._max) / 2;
        const mid2 = (n2._min + n2._max) / 2;
        if (mid1 < mid2) return -1;
        if (mid1 > mid2) return 1;
        return 0;
    }
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
}
IntervalRTreeNode.NodeComparator = NodeComparator;

},{"../../io/WKTWriter.js":"1WLaw","../../geom/Coordinate.js":"ii2fh","../../../../../java/lang/Double.js":"clUxd","../../../../../java/util/Comparator.js":"hcSJ3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l3t0Q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _intervalRTreeNodeJs = require("./IntervalRTreeNode.js");
var _intervalRTreeNodeJsDefault = parcelHelpers.interopDefault(_intervalRTreeNodeJs);
class IntervalRTreeBranchNode extends (0, _intervalRTreeNodeJsDefault.default) {
    constructor(){
        super();
        IntervalRTreeBranchNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._node1 = null;
        this._node2 = null;
        const n1 = arguments[0], n2 = arguments[1];
        this._node1 = n1;
        this._node2 = n2;
        this.buildExtent(this._node1, this._node2);
    }
    buildExtent(n1, n2) {
        this._min = Math.min(n1._min, n2._min);
        this._max = Math.max(n1._max, n2._max);
    }
    query(queryMin, queryMax, visitor) {
        if (!this.intersects(queryMin, queryMax)) return null;
        if (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);
        if (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);
    }
}
exports.default = IntervalRTreeBranchNode;

},{"./IntervalRTreeNode.js":"6tTkW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8Ncbv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _robustLineIntersectorJs = require("../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _illegalStateExceptionJs = require("../../../../java/lang/IllegalStateException.js");
var _illegalStateExceptionJsDefault = parcelHelpers.interopDefault(_illegalStateExceptionJs);
var _distanceJs = require("../algorithm/Distance.js");
var _distanceJsDefault = parcelHelpers.interopDefault(_distanceJs);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _intersectionJs = require("../algorithm/Intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
class LineSegment {
    constructor(){
        LineSegment.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.p0 = null;
        this.p1 = null;
        if (arguments.length === 0) LineSegment.constructor_.call(this, new (0, _coordinateJsDefault.default)(), new (0, _coordinateJsDefault.default)());
        else if (arguments.length === 1) {
            const ls = arguments[0];
            LineSegment.constructor_.call(this, ls.p0, ls.p1);
        } else if (arguments.length === 2) {
            const p0 = arguments[0], p1 = arguments[1];
            this.p0 = p0;
            this.p1 = p1;
        } else if (arguments.length === 4) {
            const x0 = arguments[0], y0 = arguments[1], x1 = arguments[2], y1 = arguments[3];
            LineSegment.constructor_.call(this, new (0, _coordinateJsDefault.default)(x0, y0), new (0, _coordinateJsDefault.default)(x1, y1));
        }
    }
    static midPoint(p0, p1) {
        return new (0, _coordinateJsDefault.default)((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
    }
    minX() {
        return Math.min(this.p0.x, this.p1.x);
    }
    orientationIndex() {
        if (arguments[0] instanceof LineSegment) {
            const seg = arguments[0];
            const orient0 = (0, _orientationJsDefault.default).index(this.p0, this.p1, seg.p0);
            const orient1 = (0, _orientationJsDefault.default).index(this.p0, this.p1, seg.p1);
            if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);
            if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);
            return 0;
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const p = arguments[0];
            return (0, _orientationJsDefault.default).index(this.p0, this.p1, p);
        }
    }
    toGeometry(geomFactory) {
        return geomFactory.createLineString([
            this.p0,
            this.p1
        ]);
    }
    isVertical() {
        return this.p0.x === this.p1.x;
    }
    minY() {
        return Math.min(this.p0.y, this.p1.y);
    }
    midPoint() {
        return LineSegment.midPoint(this.p0, this.p1);
    }
    maxY() {
        return Math.max(this.p0.y, this.p1.y);
    }
    pointAlongOffset(segmentLengthFraction, offsetDistance) {
        const segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
        const segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
        const dx = this.p1.x - this.p0.x;
        const dy = this.p1.y - this.p0.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        let ux = 0.0;
        let uy = 0.0;
        if (offsetDistance !== 0.0) {
            if (len <= 0.0) throw new (0, _illegalStateExceptionJsDefault.default)('Cannot compute offset from zero-length line segment');
            ux = offsetDistance * dx / len;
            uy = offsetDistance * dy / len;
        }
        const offsetx = segx - uy;
        const offsety = segy + ux;
        const coord = new (0, _coordinateJsDefault.default)(offsetx, offsety);
        return coord;
    }
    setCoordinates() {
        if (arguments.length === 1) {
            const ls = arguments[0];
            this.setCoordinates(ls.p0, ls.p1);
        } else if (arguments.length === 2) {
            const p0 = arguments[0], p1 = arguments[1];
            this.p0.x = p0.x;
            this.p0.y = p0.y;
            this.p1.x = p1.x;
            this.p1.y = p1.y;
        }
    }
    segmentFraction(inputPt) {
        let segFrac = this.projectionFactor(inputPt);
        if (segFrac < 0.0) segFrac = 0.0;
        else if (segFrac > 1.0 || (0, _doubleJsDefault.default).isNaN(segFrac)) segFrac = 1.0;
        return segFrac;
    }
    toString() {
        return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')';
    }
    distance() {
        if (arguments[0] instanceof LineSegment) {
            const ls = arguments[0];
            return (0, _distanceJsDefault.default).segmentToSegment(this.p0, this.p1, ls.p0, ls.p1);
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const p = arguments[0];
            return (0, _distanceJsDefault.default).pointToSegment(p, this.p0, this.p1);
        }
    }
    equals(o) {
        if (!(o instanceof LineSegment)) return false;
        const other = o;
        return this.p0.equals(other.p0) && this.p1.equals(other.p1);
    }
    intersection(line) {
        const li = new (0, _robustLineIntersectorJsDefault.default)();
        li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
        if (li.hasIntersection()) return li.getIntersection(0);
        return null;
    }
    project() {
        if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const p = arguments[0];
            if (p.equals(this.p0) || p.equals(this.p1)) return new (0, _coordinateJsDefault.default)(p);
            const r = this.projectionFactor(p);
            const coord = new (0, _coordinateJsDefault.default)();
            coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
            coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
            return coord;
        } else if (arguments[0] instanceof LineSegment) {
            const seg = arguments[0];
            const pf0 = this.projectionFactor(seg.p0);
            const pf1 = this.projectionFactor(seg.p1);
            if (pf0 >= 1.0 && pf1 >= 1.0) return null;
            if (pf0 <= 0.0 && pf1 <= 0.0) return null;
            let newp0 = this.project(seg.p0);
            if (pf0 < 0.0) newp0 = this.p0;
            if (pf0 > 1.0) newp0 = this.p1;
            let newp1 = this.project(seg.p1);
            if (pf1 < 0.0) newp1 = this.p0;
            if (pf1 > 1.0) newp1 = this.p1;
            return new LineSegment(newp0, newp1);
        }
    }
    normalize() {
        if (this.p1.compareTo(this.p0) < 0) this.reverse();
    }
    angle() {
        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
    }
    getCoordinate(i) {
        if (i === 0) return this.p0;
        return this.p1;
    }
    distancePerpendicular(p) {
        return (0, _distanceJsDefault.default).pointToLinePerpendicular(p, this.p0, this.p1);
    }
    closestPoint(p) {
        const factor = this.projectionFactor(p);
        if (factor > 0 && factor < 1) return this.project(p);
        const dist0 = this.p0.distance(p);
        const dist1 = this.p1.distance(p);
        if (dist0 < dist1) return this.p0;
        return this.p1;
    }
    projectionFactor(p) {
        if (p.equals(this.p0)) return 0.0;
        if (p.equals(this.p1)) return 1.0;
        const dx = this.p1.x - this.p0.x;
        const dy = this.p1.y - this.p0.y;
        const len = dx * dx + dy * dy;
        if (len <= 0.0) return (0, _doubleJsDefault.default).NaN;
        const r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
        return r;
    }
    closestPoints(line) {
        const intPt = this.intersection(line);
        if (intPt !== null) return [
            intPt,
            intPt
        ];
        const closestPt = new Array(2).fill(null);
        let minDistance = (0, _doubleJsDefault.default).MAX_VALUE;
        let dist = null;
        const close00 = this.closestPoint(line.p0);
        minDistance = close00.distance(line.p0);
        closestPt[0] = close00;
        closestPt[1] = line.p0;
        const close01 = this.closestPoint(line.p1);
        dist = close01.distance(line.p1);
        if (dist < minDistance) {
            minDistance = dist;
            closestPt[0] = close01;
            closestPt[1] = line.p1;
        }
        const close10 = line.closestPoint(this.p0);
        dist = close10.distance(this.p0);
        if (dist < minDistance) {
            minDistance = dist;
            closestPt[0] = this.p0;
            closestPt[1] = close10;
        }
        const close11 = line.closestPoint(this.p1);
        dist = close11.distance(this.p1);
        if (dist < minDistance) {
            minDistance = dist;
            closestPt[0] = this.p1;
            closestPt[1] = close11;
        }
        return closestPt;
    }
    maxX() {
        return Math.max(this.p0.x, this.p1.x);
    }
    getLength() {
        return this.p0.distance(this.p1);
    }
    compareTo(o) {
        const other = o;
        const comp0 = this.p0.compareTo(other.p0);
        if (comp0 !== 0) return comp0;
        return this.p1.compareTo(other.p1);
    }
    reverse() {
        const temp = this.p0;
        this.p0 = this.p1;
        this.p1 = temp;
    }
    equalsTopo(other) {
        return this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);
    }
    lineIntersection(line) {
        const intPt = (0, _intersectionJsDefault.default).intersection(this.p0, this.p1, line.p0, line.p1);
        return intPt;
    }
    isHorizontal() {
        return this.p0.y === this.p1.y;
    }
    reflect(p) {
        const A = this.p1.getY() - this.p0.getY();
        const B = this.p0.getX() - this.p1.getX();
        const C = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY());
        const A2plusB2 = A * A + B * B;
        const A2subB2 = A * A - B * B;
        const x = p.getX();
        const y = p.getY();
        const rx = (-A2subB2 * x - 2 * A * B * y - 2 * A * C) / A2plusB2;
        const ry = (A2subB2 * y - 2 * A * B * x - 2 * B * C) / A2plusB2;
        return new (0, _coordinateJsDefault.default)(rx, ry);
    }
    pointAlong(segmentLengthFraction) {
        const coord = new (0, _coordinateJsDefault.default)();
        coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
        coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
        return coord;
    }
    hashCode() {
        let bits0 = (0, _doubleJsDefault.default).doubleToLongBits(this.p0.x);
        bits0 ^= (0, _doubleJsDefault.default).doubleToLongBits(this.p0.y) * 31;
        const hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
        let bits1 = (0, _doubleJsDefault.default).doubleToLongBits(this.p1.x);
        bits1 ^= (0, _doubleJsDefault.default).doubleToLongBits(this.p1.y) * 31;
        const hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
        return hash0 ^ hash1;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = LineSegment;

},{"./Coordinate.js":"ii2fh","../../../../java/lang/Double.js":"clUxd","../../../../java/lang/Comparable.js":"WFeEu","../algorithm/RobustLineIntersector.js":"kLdG9","../../../../java/io/Serializable.js":"5sRbw","../../../../java/lang/IllegalStateException.js":"efv6w","../algorithm/Distance.js":"4ZaWr","../algorithm/Orientation.js":"avl08","../algorithm/Intersection.js":"bynFG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2LyeQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _geometryJs = require("../Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _collectionJs = require("../../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _linearRingJs = require("../LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _geometryComponentFilterJs = require("../GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class LinearComponentExtracter {
    constructor(){
        LinearComponentExtracter.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._lines = null;
        this._isForcedToLineString = false;
        if (arguments.length === 1) {
            const lines = arguments[0];
            this._lines = lines;
        } else if (arguments.length === 2) {
            const lines = arguments[0], isForcedToLineString = arguments[1];
            this._lines = lines;
            this._isForcedToLineString = isForcedToLineString;
        }
    }
    static getLines() {
        if (arguments.length === 1) {
            const geom = arguments[0];
            return LinearComponentExtracter.getLines(geom, false);
        } else if (arguments.length === 2) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default)) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _collectionJsDefault.default))) {
                const geoms = arguments[0], lines = arguments[1];
                for(let i = geoms.iterator(); i.hasNext();){
                    const g = i.next();
                    LinearComponentExtracter.getLines(g, lines);
                }
                return lines;
            } else if (arguments[0] instanceof (0, _geometryJsDefault.default) && typeof arguments[1] === 'boolean') {
                const geom = arguments[0], forceToLineString = arguments[1];
                const lines = new (0, _arrayListJsDefault.default)();
                geom.apply(new LinearComponentExtracter(lines, forceToLineString));
                return lines;
            } else if (arguments[0] instanceof (0, _geometryJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _collectionJsDefault.default))) {
                const geom = arguments[0], lines = arguments[1];
                if (geom instanceof (0, _lineStringJsDefault.default)) lines.add(geom);
                else geom.apply(new LinearComponentExtracter(lines));
                return lines;
            }
        } else if (arguments.length === 3) {
            if (typeof arguments[2] === 'boolean' && (0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default)) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _collectionJsDefault.default))) {
                const geoms = arguments[0], lines = arguments[1], forceToLineString = arguments[2];
                for(let i = geoms.iterator(); i.hasNext();){
                    const g = i.next();
                    LinearComponentExtracter.getLines(g, lines, forceToLineString);
                }
                return lines;
            } else if (typeof arguments[2] === 'boolean' && arguments[0] instanceof (0, _geometryJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _collectionJsDefault.default))) {
                const geom = arguments[0], lines = arguments[1], forceToLineString = arguments[2];
                geom.apply(new LinearComponentExtracter(lines, forceToLineString));
                return lines;
            }
        }
    }
    static getGeometry() {
        if (arguments.length === 1) {
            const geom = arguments[0];
            return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));
        } else if (arguments.length === 2) {
            const geom = arguments[0], forceToLineString = arguments[1];
            return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));
        }
    }
    filter(geom) {
        if (this._isForcedToLineString && geom instanceof (0, _linearRingJsDefault.default)) {
            const line = geom.getFactory().createLineString(geom.getCoordinateSequence());
            this._lines.add(line);
            return null;
        }
        if (geom instanceof (0, _lineStringJsDefault.default)) this._lines.add(geom);
    }
    setForceToLineString(isForcedToLineString) {
        this._isForcedToLineString = isForcedToLineString;
    }
    get interfaces_() {
        return [
            (0, _geometryComponentFilterJsDefault.default)
        ];
    }
}
exports.default = LinearComponentExtracter;

},{"../LineString.js":"4eIEg","../Geometry.js":"9DSzO","../../../../../hasInterface.js":"5bpze","../../../../../java/util/Collection.js":"cggki","../LinearRing.js":"2x4Ym","../GeometryComponentFilter.js":"lqE9C","../../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7KSI5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itemVisitorJs = require("./ItemVisitor.js");
var _itemVisitorJsDefault = parcelHelpers.interopDefault(_itemVisitorJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class ArrayListVisitor {
    constructor(){
        ArrayListVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._items = new (0, _arrayListJsDefault.default)();
    }
    getItems() {
        return this._items;
    }
    visitItem(item) {
        this._items.add(item);
    }
    get interfaces_() {
        return [
            (0, _itemVisitorJsDefault.default)
        ];
    }
}
exports.default = ArrayListVisitor;

},{"./ItemVisitor.js":"nuRea","../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gQhhu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeIntersectionListJs = require("./EdgeIntersectionList.js");
var _edgeIntersectionListJsDefault = parcelHelpers.interopDefault(_edgeIntersectionListJs);
var _intersectionMatrixJs = require("../geom/IntersectionMatrix.js");
var _intersectionMatrixJsDefault = parcelHelpers.interopDefault(_intersectionMatrixJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _envelopeJs = require("../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _stringBuilderJs = require("../../../../java/lang/StringBuilder.js");
var _stringBuilderJsDefault = parcelHelpers.interopDefault(_stringBuilderJs);
var _depthJs = require("./Depth.js");
var _depthJsDefault = parcelHelpers.interopDefault(_depthJs);
var _graphComponentJs = require("./GraphComponent.js");
var _graphComponentJsDefault = parcelHelpers.interopDefault(_graphComponentJs);
var _monotoneChainEdgeJs = require("./index/MonotoneChainEdge.js");
var _monotoneChainEdgeJsDefault = parcelHelpers.interopDefault(_monotoneChainEdgeJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
class Edge extends (0, _graphComponentJsDefault.default) {
    constructor(){
        super();
        Edge.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.pts = null;
        this._env = null;
        this.eiList = new (0, _edgeIntersectionListJsDefault.default)(this);
        this._name = null;
        this._mce = null;
        this._isIsolated = true;
        this._depth = new (0, _depthJsDefault.default)();
        this._depthDelta = 0;
        if (arguments.length === 1) {
            const pts = arguments[0];
            Edge.constructor_.call(this, pts, null);
        } else if (arguments.length === 2) {
            const pts = arguments[0], label = arguments[1];
            this.pts = pts;
            this._label = label;
        }
    }
    static updateIM() {
        if (arguments.length === 2 && arguments[1] instanceof (0, _intersectionMatrixJsDefault.default) && arguments[0] instanceof (0, _labelJsDefault.default)) {
            const label = arguments[0], im = arguments[1];
            im.setAtLeastIfValid(label.getLocation(0, (0, _positionJsDefault.default).ON), label.getLocation(1, (0, _positionJsDefault.default).ON), 1);
            if (label.isArea()) {
                im.setAtLeastIfValid(label.getLocation(0, (0, _positionJsDefault.default).LEFT), label.getLocation(1, (0, _positionJsDefault.default).LEFT), 2);
                im.setAtLeastIfValid(label.getLocation(0, (0, _positionJsDefault.default).RIGHT), label.getLocation(1, (0, _positionJsDefault.default).RIGHT), 2);
            }
        } else return super.updateIM.apply(this, arguments);
    }
    getDepth() {
        return this._depth;
    }
    getCollapsedEdge() {
        const newPts = new Array(2).fill(null);
        newPts[0] = this.pts[0];
        newPts[1] = this.pts[1];
        const newe = new Edge(newPts, (0, _labelJsDefault.default).toLineLabel(this._label));
        return newe;
    }
    setIsolated(isIsolated) {
        this._isIsolated = isIsolated;
    }
    setName(name) {
        this._name = name;
    }
    equals(o) {
        if (!(o instanceof Edge)) return false;
        const e = o;
        if (this.pts.length !== e.pts.length) return false;
        let isEqualForward = true;
        let isEqualReverse = true;
        let iRev = this.pts.length;
        for(let i = 0; i < this.pts.length; i++){
            if (!this.pts[i].equals2D(e.pts[i])) isEqualForward = false;
            if (!this.pts[i].equals2D(e.pts[--iRev])) isEqualReverse = false;
            if (!isEqualForward && !isEqualReverse) return false;
        }
        return true;
    }
    getCoordinate() {
        if (arguments.length === 0) {
            if (this.pts.length > 0) return this.pts[0];
            return null;
        } else if (arguments.length === 1) {
            const i = arguments[0];
            return this.pts[i];
        }
    }
    isClosed() {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
    }
    getMaximumSegmentIndex() {
        return this.pts.length - 1;
    }
    setDepthDelta(depthDelta) {
        this._depthDelta = depthDelta;
    }
    getEdgeIntersectionList() {
        return this.eiList;
    }
    addIntersections(li, segmentIndex, geomIndex) {
        for(let i = 0; i < li.getIntersectionNum(); i++)this.addIntersection(li, segmentIndex, geomIndex, i);
    }
    isIsolated() {
        return this._isIsolated;
    }
    getCoordinates() {
        return this.pts;
    }
    print(out) {
        out.print('edge ' + this._name + ': ');
        out.print('LINESTRING (');
        for(let i = 0; i < this.pts.length; i++){
            if (i > 0) out.print(',');
            out.print(this.pts[i].x + ' ' + this.pts[i].y);
        }
        out.print(')  ' + this._label + ' ' + this._depthDelta);
    }
    computeIM(im) {
        Edge.updateIM(this._label, im);
    }
    isCollapsed() {
        if (!this._label.isArea()) return false;
        if (this.pts.length !== 3) return false;
        if (this.pts[0].equals(this.pts[2])) return true;
        return false;
    }
    getDepthDelta() {
        return this._depthDelta;
    }
    getNumPoints() {
        return this.pts.length;
    }
    printReverse(out) {
        out.print('edge ' + this._name + ': ');
        for(let i = this.pts.length - 1; i >= 0; i--)out.print(this.pts[i] + ' ');
        out.println('');
    }
    getMonotoneChainEdge() {
        if (this._mce === null) this._mce = new (0, _monotoneChainEdgeJsDefault.default)(this);
        return this._mce;
    }
    getEnvelope() {
        if (this._env === null) {
            this._env = new (0, _envelopeJsDefault.default)();
            for(let i = 0; i < this.pts.length; i++)this._env.expandToInclude(this.pts[i]);
        }
        return this._env;
    }
    addIntersection(li, segmentIndex, geomIndex, intIndex) {
        const intPt = new (0, _coordinateJsDefault.default)(li.getIntersection(intIndex));
        let normalizedSegmentIndex = segmentIndex;
        let dist = li.getEdgeDistance(geomIndex, intIndex);
        const nextSegIndex = normalizedSegmentIndex + 1;
        if (nextSegIndex < this.pts.length) {
            const nextPt = this.pts[nextSegIndex];
            if (intPt.equals2D(nextPt)) {
                normalizedSegmentIndex = nextSegIndex;
                dist = 0.0;
            }
        }
        const ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);
    }
    toString() {
        const builder = new (0, _stringBuilderJsDefault.default)();
        builder.append('edge ' + this._name + ': ');
        builder.append('LINESTRING (');
        for(let i = 0; i < this.pts.length; i++){
            if (i > 0) builder.append(',');
            builder.append(this.pts[i].x + ' ' + this.pts[i].y);
        }
        builder.append(')  ' + this._label + ' ' + this._depthDelta);
        return builder.toString();
    }
    isPointwiseEqual(e) {
        if (this.pts.length !== e.pts.length) return false;
        for(let i = 0; i < this.pts.length; i++)if (!this.pts[i].equals2D(e.pts[i])) return false;
        return true;
    }
}
exports.default = Edge;

},{"./EdgeIntersectionList.js":"3nEDx","../geom/IntersectionMatrix.js":"7t1VF","../geom/Coordinate.js":"ii2fh","./Label.js":"dJJOo","../geom/Envelope.js":"h2zeM","../../../../java/lang/StringBuilder.js":"30Zhx","./Depth.js":"cVVmG","./GraphComponent.js":"1jRLn","./index/MonotoneChainEdge.js":"fsDd0","./Position.js":"13raO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3nEDx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeIntersectionJs = require("./EdgeIntersection.js");
var _edgeIntersectionJsDefault = parcelHelpers.interopDefault(_edgeIntersectionJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _edgeJs = require("./Edge.js");
var _edgeJsDefault = parcelHelpers.interopDefault(_edgeJs);
var _treeMapJs = require("../../../../java/util/TreeMap.js");
var _treeMapJsDefault = parcelHelpers.interopDefault(_treeMapJs);
class EdgeIntersectionList {
    constructor(){
        EdgeIntersectionList.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._nodeMap = new (0, _treeMapJsDefault.default)();
        this.edge = null;
        const edge = arguments[0];
        this.edge = edge;
    }
    print(out) {
        out.println('Intersections:');
        for(let it = this.iterator(); it.hasNext();){
            const ei = it.next();
            ei.print(out);
        }
    }
    addEndpoints() {
        const maxSegIndex = this.edge.pts.length - 1;
        this.add(this.edge.pts[0], 0, 0.0);
        this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);
    }
    createSplitEdge(ei0, ei1) {
        let npts = ei1.segmentIndex - ei0.segmentIndex + 2;
        const lastSegStartPt = this.edge.pts[ei1.segmentIndex];
        const useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);
        if (!useIntPt1) npts--;
        const pts = new Array(npts).fill(null);
        let ipt = 0;
        pts[ipt++] = new (0, _coordinateJsDefault.default)(ei0.coord);
        for(let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++)pts[ipt++] = this.edge.pts[i];
        if (useIntPt1) pts[ipt] = ei1.coord;
        return new (0, _edgeJsDefault.default)(pts, new (0, _labelJsDefault.default)(this.edge._label));
    }
    add(intPt, segmentIndex, dist) {
        const eiNew = new (0, _edgeIntersectionJsDefault.default)(intPt, segmentIndex, dist);
        const ei = this._nodeMap.get(eiNew);
        if (ei !== null) return ei;
        this._nodeMap.put(eiNew, eiNew);
        return eiNew;
    }
    isIntersection(pt) {
        for(let it = this.iterator(); it.hasNext();){
            const ei = it.next();
            if (ei.coord.equals(pt)) return true;
        }
        return false;
    }
    iterator() {
        return this._nodeMap.values().iterator();
    }
    addSplitEdges(edgeList) {
        this.addEndpoints();
        const it = this.iterator();
        let eiPrev = it.next();
        while(it.hasNext()){
            const ei = it.next();
            const newEdge = this.createSplitEdge(eiPrev, ei);
            edgeList.add(newEdge);
            eiPrev = ei;
        }
    }
}
exports.default = EdgeIntersectionList;

},{"./EdgeIntersection.js":"bqYLS","../geom/Coordinate.js":"ii2fh","./Label.js":"dJJOo","./Edge.js":"gQhhu","../../../../java/util/TreeMap.js":"dQNYS","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bqYLS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
class EdgeIntersection {
    constructor(){
        EdgeIntersection.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.coord = null;
        this.segmentIndex = null;
        this.dist = null;
        const coord = arguments[0], segmentIndex = arguments[1], dist = arguments[2];
        this.coord = new (0, _coordinateJsDefault.default)(coord);
        this.segmentIndex = segmentIndex;
        this.dist = dist;
    }
    getSegmentIndex() {
        return this.segmentIndex;
    }
    getCoordinate() {
        return this.coord;
    }
    print(out) {
        out.print(this.coord);
        out.print(' seg # = ' + this.segmentIndex);
        out.println(' dist = ' + this.dist);
    }
    compareTo(obj) {
        const other = obj;
        return this.compare(other.segmentIndex, other.dist);
    }
    isEndPoint(maxSegmentIndex) {
        if (this.segmentIndex === 0 && this.dist === 0.0) return true;
        if (this.segmentIndex === maxSegmentIndex) return true;
        return false;
    }
    toString() {
        return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist;
    }
    getDistance() {
        return this.dist;
    }
    compare(segmentIndex, dist) {
        if (this.segmentIndex < segmentIndex) return -1;
        if (this.segmentIndex > segmentIndex) return 1;
        if (this.dist < dist) return -1;
        if (this.dist > dist) return 1;
        return 0;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = EdgeIntersection;

},{"../geom/Coordinate.js":"ii2fh","../../../../java/lang/Comparable.js":"WFeEu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cVVmG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
class Depth {
    constructor(){
        Depth.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._depth = Array(2).fill().map(()=>Array(3));
        for(let i = 0; i < 2; i++)for(let j = 0; j < 3; j++)this._depth[i][j] = Depth.NULL_VALUE;
    }
    static depthAtLocation(location) {
        if (location === (0, _locationJsDefault.default).EXTERIOR) return 0;
        if (location === (0, _locationJsDefault.default).INTERIOR) return 1;
        return Depth.NULL_VALUE;
    }
    getDepth(geomIndex, posIndex) {
        return this._depth[geomIndex][posIndex];
    }
    setDepth(geomIndex, posIndex, depthValue) {
        this._depth[geomIndex][posIndex] = depthValue;
    }
    isNull() {
        if (arguments.length === 0) {
            for(let i = 0; i < 2; i++)for(let j = 0; j < 3; j++)if (this._depth[i][j] !== Depth.NULL_VALUE) return false;
            return true;
        } else if (arguments.length === 1) {
            const geomIndex = arguments[0];
            return this._depth[geomIndex][1] === Depth.NULL_VALUE;
        } else if (arguments.length === 2) {
            const geomIndex = arguments[0], posIndex = arguments[1];
            return this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;
        }
    }
    normalize() {
        for(let i = 0; i < 2; i++)if (!this.isNull(i)) {
            let minDepth = this._depth[i][1];
            if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];
            if (minDepth < 0) minDepth = 0;
            for(let j = 1; j < 3; j++){
                let newValue = 0;
                if (this._depth[i][j] > minDepth) newValue = 1;
                this._depth[i][j] = newValue;
            }
        }
    }
    getDelta(geomIndex) {
        return this._depth[geomIndex][(0, _positionJsDefault.default).RIGHT] - this._depth[geomIndex][(0, _positionJsDefault.default).LEFT];
    }
    getLocation(geomIndex, posIndex) {
        if (this._depth[geomIndex][posIndex] <= 0) return (0, _locationJsDefault.default).EXTERIOR;
        return (0, _locationJsDefault.default).INTERIOR;
    }
    toString() {
        return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2];
    }
    add() {
        if (arguments.length === 1) {
            const lbl = arguments[0];
            for(let i = 0; i < 2; i++)for(let j = 1; j < 3; j++){
                const loc = lbl.getLocation(i, j);
                if (loc === (0, _locationJsDefault.default).EXTERIOR || loc === (0, _locationJsDefault.default).INTERIOR) {
                    if (this.isNull(i, j)) this._depth[i][j] = Depth.depthAtLocation(loc);
                    else this._depth[i][j] += Depth.depthAtLocation(loc);
                }
            }
        } else if (arguments.length === 3) {
            const geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];
            if (location === (0, _locationJsDefault.default).INTERIOR) this._depth[geomIndex][posIndex]++;
        }
    }
}
exports.default = Depth;
Depth.NULL_VALUE = -1;

},{"../geom/Location.js":"9aPCX","./Position.js":"13raO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fsDd0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _monotoneChainIndexerJs = require("./MonotoneChainIndexer.js");
var _monotoneChainIndexerJsDefault = parcelHelpers.interopDefault(_monotoneChainIndexerJs);
var _envelopeJs = require("../../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class MonotoneChainEdge {
    constructor(){
        MonotoneChainEdge.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.e = null;
        this.pts = null;
        this.startIndex = null;
        const e = arguments[0];
        this.e = e;
        this.pts = e.getCoordinates();
        const mcb = new (0, _monotoneChainIndexerJsDefault.default)();
        this.startIndex = mcb.getChainStartIndices(this.pts);
    }
    getCoordinates() {
        return this.pts;
    }
    getMaxX(chainIndex) {
        const x1 = this.pts[this.startIndex[chainIndex]].x;
        const x2 = this.pts[this.startIndex[chainIndex + 1]].x;
        return x1 > x2 ? x1 : x2;
    }
    getMinX(chainIndex) {
        const x1 = this.pts[this.startIndex[chainIndex]].x;
        const x2 = this.pts[this.startIndex[chainIndex + 1]].x;
        return x1 < x2 ? x1 : x2;
    }
    computeIntersectsForChain() {
        if (arguments.length === 4) {
            const chainIndex0 = arguments[0], mce = arguments[1], chainIndex1 = arguments[2], si = arguments[3];
            this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
        } else if (arguments.length === 6) {
            const start0 = arguments[0], end0 = arguments[1], mce = arguments[2], start1 = arguments[3], end1 = arguments[4], ei = arguments[5];
            if (end0 - start0 === 1 && end1 - start1 === 1) {
                ei.addIntersections(this.e, start0, mce.e, start1);
                return null;
            }
            if (!this.overlaps(start0, end0, mce, start1, end1)) return null;
            const mid0 = Math.trunc((start0 + end0) / 2);
            const mid1 = Math.trunc((start1 + end1) / 2);
            if (start0 < mid0) {
                if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);
                if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);
            }
            if (mid0 < end0) {
                if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);
                if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);
            }
        }
    }
    overlaps(start0, end0, mce, start1, end1) {
        return (0, _envelopeJsDefault.default).intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1]);
    }
    getStartIndexes() {
        return this.startIndex;
    }
    computeIntersects(mce, si) {
        for(let i = 0; i < this.startIndex.length - 1; i++)for(let j = 0; j < mce.startIndex.length - 1; j++)this.computeIntersectsForChain(i, mce, j, si);
    }
}
exports.default = MonotoneChainEdge;

},{"./MonotoneChainIndexer.js":"6ncnc","../../geom/Envelope.js":"h2zeM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6ncnc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _intArrayListJs = require("../../util/IntArrayList.js");
var _intArrayListJsDefault = parcelHelpers.interopDefault(_intArrayListJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _quadrantJs = require("../Quadrant.js");
var _quadrantJsDefault = parcelHelpers.interopDefault(_quadrantJs);
class MonotoneChainIndexer {
    static toIntArray(list) {
        const array = new Array(list.size()).fill(null);
        for(let i = 0; i < array.length; i++)array[i] = list.get(i).intValue();
        return array;
    }
    findChainEnd(pts, start) {
        const chainQuad = (0, _quadrantJsDefault.default).quadrant(pts[start], pts[start + 1]);
        let last = start + 1;
        while(last < pts.length){
            const quad = (0, _quadrantJsDefault.default).quadrant(pts[last - 1], pts[last]);
            if (quad !== chainQuad) break;
            last++;
        }
        return last - 1;
    }
    OLDgetChainStartIndices(pts) {
        let start = 0;
        const startIndexList = new (0, _arrayListJsDefault.default)();
        startIndexList.add(start);
        do {
            const last = this.findChainEnd(pts, start);
            startIndexList.add(last);
            start = last;
        }while (start < pts.length - 1);
        const startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
        return startIndex;
    }
    getChainStartIndices(pts) {
        let start = 0;
        const startIndexList = new (0, _intArrayListJsDefault.default)(Math.trunc(pts.length / 2));
        startIndexList.add(start);
        do {
            const last = this.findChainEnd(pts, start);
            startIndexList.add(last);
            start = last;
        }while (start < pts.length - 1);
        return startIndexList.toArray();
    }
}
exports.default = MonotoneChainIndexer;

},{"../../util/IntArrayList.js":"gQnda","../../../../../java/util/ArrayList.js":"gGAQZ","../Quadrant.js":"86Qmh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gQnda":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arraysJs = require("../../../../java/util/Arrays.js");
var _arraysJsDefault = parcelHelpers.interopDefault(_arraysJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
class IntArrayList {
    constructor(){
        IntArrayList.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._data = null;
        this._size = 0;
        if (arguments.length === 0) IntArrayList.constructor_.call(this, 10);
        else if (arguments.length === 1) {
            const initialCapacity = arguments[0];
            this._data = new Array(initialCapacity).fill(null);
        }
    }
    size() {
        return this._size;
    }
    addAll(values) {
        if (values === null) return null;
        if (values.length === 0) return null;
        this.ensureCapacity(this._size + values.length);
        (0, _systemJsDefault.default).arraycopy(values, 0, this._data, this._size, values.length);
        this._size += values.length;
    }
    ensureCapacity(capacity) {
        if (capacity <= this._data.length) return null;
        const newLength = Math.max(capacity, this._data.length * 2);
        this._data = (0, _arraysJsDefault.default).copyOf(this._data, newLength);
    }
    toArray() {
        const array = new Array(this._size).fill(null);
        (0, _systemJsDefault.default).arraycopy(this._data, 0, array, 0, this._size);
        return array;
    }
    add(value) {
        this.ensureCapacity(this._size + 1);
        this._data[this._size] = value;
        ++this._size;
    }
}
exports.default = IntArrayList;

},{"../../../../java/util/Arrays.js":"a6V8H","../../../../java/lang/System.js":"dYmTx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a4b3P":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nodeJs = require("../../geomgraph/Node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
class RelateNode extends (0, _nodeJsDefault.default) {
    constructor(){
        super();
        RelateNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const coord = arguments[0], edges = arguments[1];
        (0, _nodeJsDefault.default).constructor_.call(this, coord, edges);
    }
    computeIM(im) {
        im.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);
    }
    updateIMFromEdges(im) {
        this._edges.updateIM(im);
    }
}
exports.default = RelateNode;

},{"../../geomgraph/Node.js":"azV0J","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3eQ0s":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _boundaryNodeRuleJs = require("../algorithm/BoundaryNodeRule.js");
var _boundaryNodeRuleJsDefault = parcelHelpers.interopDefault(_boundaryNodeRuleJs);
var _geometryGraphJs = require("../geomgraph/GeometryGraph.js");
var _geometryGraphJsDefault = parcelHelpers.interopDefault(_geometryGraphJs);
var _robustLineIntersectorJs = require("../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
class GeometryGraphOperation {
    constructor(){
        GeometryGraphOperation.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._resultPrecisionModel = null;
        this._arg = null;
        if (arguments.length === 1) {
            const g0 = arguments[0];
            this.setComputationPrecision(g0.getPrecisionModel());
            this._arg = new Array(1).fill(null);
            this._arg[0] = new (0, _geometryGraphJsDefault.default)(0, g0);
        } else if (arguments.length === 2) {
            const g0 = arguments[0], g1 = arguments[1];
            GeometryGraphOperation.constructor_.call(this, g0, g1, (0, _boundaryNodeRuleJsDefault.default).OGC_SFS_BOUNDARY_RULE);
        } else if (arguments.length === 3) {
            const g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];
            if (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel());
            else this.setComputationPrecision(g1.getPrecisionModel());
            this._arg = new Array(2).fill(null);
            this._arg[0] = new (0, _geometryGraphJsDefault.default)(0, g0, boundaryNodeRule);
            this._arg[1] = new (0, _geometryGraphJsDefault.default)(1, g1, boundaryNodeRule);
        }
    }
    setComputationPrecision(pm) {
        this._resultPrecisionModel = pm;
        this._li.setPrecisionModel(this._resultPrecisionModel);
    }
    getArgGeometry(i) {
        return this._arg[i].getGeometry();
    }
}
exports.default = GeometryGraphOperation;

},{"../algorithm/BoundaryNodeRule.js":"bcj6y","../geomgraph/GeometryGraph.js":"eMT6T","../algorithm/RobustLineIntersector.js":"kLdG9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"61hKF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _polygonJs = require("../../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _pointJs = require("../../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
class RectangleContains {
    constructor(){
        RectangleContains.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._rectEnv = null;
        const rectangle = arguments[0];
        this._rectEnv = rectangle.getEnvelopeInternal();
    }
    static contains(rectangle, b) {
        const rc = new RectangleContains(rectangle);
        return rc.contains(b);
    }
    isContainedInBoundary(geom) {
        if (geom instanceof (0, _polygonJsDefault.default)) return false;
        if (geom instanceof (0, _pointJsDefault.default)) return this.isPointContainedInBoundary(geom);
        if (geom instanceof (0, _lineStringJsDefault.default)) return this.isLineStringContainedInBoundary(geom);
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const comp = geom.getGeometryN(i);
            if (!this.isContainedInBoundary(comp)) return false;
        }
        return true;
    }
    isLineSegmentContainedInBoundary(p0, p1) {
        if (p0.equals(p1)) return this.isPointContainedInBoundary(p0);
        if (p0.x === p1.x) {
            if (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;
        } else if (p0.y === p1.y) {
            if (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;
        }
        return false;
    }
    isLineStringContainedInBoundary(line) {
        const seq = line.getCoordinateSequence();
        const p0 = new (0, _coordinateJsDefault.default)();
        const p1 = new (0, _coordinateJsDefault.default)();
        for(let i = 0; i < seq.size() - 1; i++){
            seq.getCoordinate(i, p0);
            seq.getCoordinate(i + 1, p1);
            if (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;
        }
        return true;
    }
    isPointContainedInBoundary() {
        if (arguments[0] instanceof (0, _pointJsDefault.default)) {
            const point = arguments[0];
            return this.isPointContainedInBoundary(point.getCoordinate());
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const pt = arguments[0];
            return pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();
        }
    }
    contains(geom) {
        if (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;
        if (this.isContainedInBoundary(geom)) return false;
        return true;
    }
}
exports.default = RectangleContains;

},{"../../geom/LineString.js":"4eIEg","../../geom/Polygon.js":"kpOA5","../../geom/Coordinate.js":"ii2fh","../../geom/Point.js":"lwZpO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eB5Iy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _polygonJs = require("../../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _rectangleLineIntersectorJs = require("../../algorithm/RectangleLineIntersector.js");
var _rectangleLineIntersectorJsDefault = parcelHelpers.interopDefault(_rectangleLineIntersectorJs);
var _shortCircuitedGeometryVisitorJs = require("../../geom/util/ShortCircuitedGeometryVisitor.js");
var _shortCircuitedGeometryVisitorJsDefault = parcelHelpers.interopDefault(_shortCircuitedGeometryVisitorJs);
var _simplePointInAreaLocatorJs = require("../../algorithm/locate/SimplePointInAreaLocator.js");
var _simplePointInAreaLocatorJsDefault = parcelHelpers.interopDefault(_simplePointInAreaLocatorJs);
var _linearComponentExtracterJs = require("../../geom/util/LinearComponentExtracter.js");
var _linearComponentExtracterJsDefault = parcelHelpers.interopDefault(_linearComponentExtracterJs);
class RectangleIntersects {
    constructor(){
        RectangleIntersects.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._rectangle = null;
        this._rectEnv = null;
        const rectangle = arguments[0];
        this._rectangle = rectangle;
        this._rectEnv = rectangle.getEnvelopeInternal();
    }
    static intersects(rectangle, b) {
        const rp = new RectangleIntersects(rectangle);
        return rp.intersects(b);
    }
    intersects(geom) {
        if (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;
        const visitor = new EnvelopeIntersectsVisitor(this._rectEnv);
        visitor.applyTo(geom);
        if (visitor.intersects()) return true;
        const ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);
        ecpVisitor.applyTo(geom);
        if (ecpVisitor.containsPoint()) return true;
        const riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);
        riVisitor.applyTo(geom);
        if (riVisitor.intersects()) return true;
        return false;
    }
}
exports.default = RectangleIntersects;
class EnvelopeIntersectsVisitor extends (0, _shortCircuitedGeometryVisitorJsDefault.default) {
    constructor(){
        super();
        EnvelopeIntersectsVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._rectEnv = null;
        this._intersects = false;
        const rectEnv = arguments[0];
        this._rectEnv = rectEnv;
    }
    intersects() {
        return this._intersects;
    }
    visit(element) {
        const elementEnv = element.getEnvelopeInternal();
        if (!this._rectEnv.intersects(elementEnv)) return null;
        if (this._rectEnv.contains(elementEnv)) {
            this._intersects = true;
            return null;
        }
        if (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {
            this._intersects = true;
            return null;
        }
        if (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {
            this._intersects = true;
            return null;
        }
    }
    isDone() {
        return this._intersects === true;
    }
}
class GeometryContainsPointVisitor extends (0, _shortCircuitedGeometryVisitorJsDefault.default) {
    constructor(){
        super();
        GeometryContainsPointVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._rectSeq = null;
        this._rectEnv = null;
        this._containsPoint = false;
        const rectangle = arguments[0];
        this._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();
        this._rectEnv = rectangle.getEnvelopeInternal();
    }
    visit(geom) {
        if (!(geom instanceof (0, _polygonJsDefault.default))) return null;
        const elementEnv = geom.getEnvelopeInternal();
        if (!this._rectEnv.intersects(elementEnv)) return null;
        const rectPt = new (0, _coordinateJsDefault.default)();
        for(let i = 0; i < 4; i++){
            this._rectSeq.getCoordinate(i, rectPt);
            if (!elementEnv.contains(rectPt)) continue;
            if ((0, _simplePointInAreaLocatorJsDefault.default).containsPointInPolygon(rectPt, geom)) {
                this._containsPoint = true;
                return null;
            }
        }
    }
    containsPoint() {
        return this._containsPoint;
    }
    isDone() {
        return this._containsPoint === true;
    }
}
class RectangleIntersectsSegmentVisitor extends (0, _shortCircuitedGeometryVisitorJsDefault.default) {
    constructor(){
        super();
        RectangleIntersectsSegmentVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._rectEnv = null;
        this._rectIntersector = null;
        this._hasIntersection = false;
        this._p0 = new (0, _coordinateJsDefault.default)();
        this._p1 = new (0, _coordinateJsDefault.default)();
        const rectangle = arguments[0];
        this._rectEnv = rectangle.getEnvelopeInternal();
        this._rectIntersector = new (0, _rectangleLineIntersectorJsDefault.default)(this._rectEnv);
    }
    intersects() {
        return this._hasIntersection;
    }
    isDone() {
        return this._hasIntersection === true;
    }
    visit(geom) {
        const elementEnv = geom.getEnvelopeInternal();
        if (!this._rectEnv.intersects(elementEnv)) return null;
        const lines = (0, _linearComponentExtracterJsDefault.default).getLines(geom);
        this.checkIntersectionWithLineStrings(lines);
    }
    checkIntersectionWithLineStrings(lines) {
        for(let i = lines.iterator(); i.hasNext();){
            const testLine = i.next();
            this.checkIntersectionWithSegments(testLine);
            if (this._hasIntersection) return null;
        }
    }
    checkIntersectionWithSegments(testLine) {
        const seq1 = testLine.getCoordinateSequence();
        for(let j = 1; j < seq1.size(); j++){
            seq1.getCoordinate(j - 1, this._p0);
            seq1.getCoordinate(j, this._p1);
            if (this._rectIntersector.intersects(this._p0, this._p1)) {
                this._hasIntersection = true;
                return null;
            }
        }
    }
}

},{"../../geom/Coordinate.js":"ii2fh","../../geom/Polygon.js":"kpOA5","../../algorithm/RectangleLineIntersector.js":"5lfSK","../../geom/util/ShortCircuitedGeometryVisitor.js":"9JKOr","../../algorithm/locate/SimplePointInAreaLocator.js":"agQck","../../geom/util/LinearComponentExtracter.js":"2LyeQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5lfSK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _robustLineIntersectorJs = require("./RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _envelopeJs = require("../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class RectangleLineIntersector {
    constructor(){
        RectangleLineIntersector.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._rectEnv = null;
        this._diagUp0 = null;
        this._diagUp1 = null;
        this._diagDown0 = null;
        this._diagDown1 = null;
        const rectEnv = arguments[0];
        this._rectEnv = rectEnv;
        this._diagUp0 = new (0, _coordinateJsDefault.default)(rectEnv.getMinX(), rectEnv.getMinY());
        this._diagUp1 = new (0, _coordinateJsDefault.default)(rectEnv.getMaxX(), rectEnv.getMaxY());
        this._diagDown0 = new (0, _coordinateJsDefault.default)(rectEnv.getMinX(), rectEnv.getMaxY());
        this._diagDown1 = new (0, _coordinateJsDefault.default)(rectEnv.getMaxX(), rectEnv.getMinY());
    }
    intersects(p0, p1) {
        const segEnv = new (0, _envelopeJsDefault.default)(p0, p1);
        if (!this._rectEnv.intersects(segEnv)) return false;
        if (this._rectEnv.intersects(p0)) return true;
        if (this._rectEnv.intersects(p1)) return true;
        if (p0.compareTo(p1) > 0) {
            const tmp = p0;
            p0 = p1;
            p1 = tmp;
        }
        let isSegUpwards = false;
        if (p1.y > p0.y) isSegUpwards = true;
        if (isSegUpwards) this._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);
        else this._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);
        if (this._li.hasIntersection()) return true;
        return false;
    }
}
exports.default = RectangleLineIntersector;

},{"../geom/Coordinate.js":"ii2fh","./RobustLineIntersector.js":"kLdG9","../geom/Envelope.js":"h2zeM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9JKOr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryCollectionJs = require("../GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
class ShortCircuitedGeometryVisitor {
    constructor(){
        ShortCircuitedGeometryVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._isDone = false;
    }
    applyTo(geom) {
        for(let i = 0; i < geom.getNumGeometries() && !this._isDone; i++){
            const element = geom.getGeometryN(i);
            if (!(element instanceof (0, _geometryCollectionJsDefault.default))) {
                this.visit(element);
                if (this.isDone()) {
                    this._isDone = true;
                    return null;
                }
            } else this.applyTo(element);
        }
    }
}
exports.default = ShortCircuitedGeometryVisitor;

},{"../GeometryCollection.js":"6RJQO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b4ekL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnaryUnionOp", ()=>(0, _unaryUnionOpJsDefault.default));
var _unaryUnionOpJs = require("./union/UnaryUnionOp.js");
var _unaryUnionOpJsDefault = parcelHelpers.interopDefault(_unaryUnionOpJs);

},{"./union/UnaryUnionOp.js":"b5s8c","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b5s8c":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _collectionJs = require("../../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _snapIfNeededOverlayOpJs = require("../overlay/snap/SnapIfNeededOverlayOp.js");
var _snapIfNeededOverlayOpJsDefault = parcelHelpers.interopDefault(_snapIfNeededOverlayOpJs);
var _inputExtracterJs = require("./InputExtracter.js");
var _inputExtracterJsDefault = parcelHelpers.interopDefault(_inputExtracterJs);
var _geometryJs = require("../../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _pointGeometryUnionJs = require("./PointGeometryUnion.js");
var _pointGeometryUnionJsDefault = parcelHelpers.interopDefault(_pointGeometryUnionJs);
var _overlayOpJs = require("../overlay/OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
var _cascadedPolygonUnionJs = require("./CascadedPolygonUnion.js");
var _cascadedPolygonUnionJsDefault = parcelHelpers.interopDefault(_cascadedPolygonUnionJs);
class UnaryUnionOp {
    constructor(){
        UnaryUnionOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geomFact = null;
        this._extracter = null;
        if (arguments.length === 1) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
                const geoms = arguments[0];
                this.extract(geoms);
            } else if (arguments[0] instanceof (0, _geometryJsDefault.default)) {
                const geom = arguments[0];
                this.extract(geom);
            }
        } else if (arguments.length === 2) {
            const geoms = arguments[0], geomFact = arguments[1];
            this._geomFact = geomFact;
            this.extract(geoms);
        }
    }
    static union() {
        if (arguments.length === 1) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
                const geoms = arguments[0];
                const op = new UnaryUnionOp(geoms);
                return op.union();
            } else if (arguments[0] instanceof (0, _geometryJsDefault.default)) {
                const geom = arguments[0];
                const op = new UnaryUnionOp(geom);
                return op.union();
            }
        } else if (arguments.length === 2) {
            const geoms = arguments[0], geomFact = arguments[1];
            const op = new UnaryUnionOp(geoms, geomFact);
            return op.union();
        }
    }
    extract() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const geoms = arguments[0];
            this._extracter = (0, _inputExtracterJsDefault.default).extract(geoms);
        } else if (arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const geom = arguments[0];
            this._extracter = (0, _inputExtracterJsDefault.default).extract(geom);
        }
    }
    unionWithNull(g0, g1) {
        if (g0 === null && g1 === null) return null;
        if (g1 === null) return g0;
        if (g0 === null) return g1;
        return (0, _overlayOpJsDefault.default).union(g0, g1);
    }
    unionNoOpt(g0) {
        const empty = this._geomFact.createPoint();
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(g0, empty, (0, _overlayOpJsDefault.default).UNION);
    }
    union() {
        if (this._geomFact === null) this._geomFact = this._extracter.getFactory();
        if (this._geomFact === null) return null;
        if (this._extracter.isEmpty()) return this._geomFact.createEmpty(this._extracter.getDimension());
        const points = this._extracter.getExtract(0);
        const lines = this._extracter.getExtract(1);
        const polygons = this._extracter.getExtract(2);
        let unionPoints = null;
        if (points.size() > 0) {
            const ptGeom = this._geomFact.buildGeometry(points);
            unionPoints = this.unionNoOpt(ptGeom);
        }
        let unionLines = null;
        if (lines.size() > 0) {
            const lineGeom = this._geomFact.buildGeometry(lines);
            unionLines = this.unionNoOpt(lineGeom);
        }
        let unionPolygons = null;
        if (polygons.size() > 0) unionPolygons = (0, _cascadedPolygonUnionJsDefault.default).union(polygons);
        const unionLA = this.unionWithNull(unionLines, unionPolygons);
        let union = null;
        if (unionPoints === null) union = unionLA;
        else if (unionLA === null) union = unionPoints;
        else union = (0, _pointGeometryUnionJsDefault.default).union(unionPoints, unionLA);
        if (union === null) return this._geomFact.createGeometryCollection();
        return union;
    }
}
exports.default = UnaryUnionOp;

},{"../../../../../hasInterface.js":"5bpze","../../../../../java/util/Collection.js":"cggki","../overlay/snap/SnapIfNeededOverlayOp.js":"gxP36","./InputExtracter.js":"fRnOp","../../geom/Geometry.js":"9DSzO","./PointGeometryUnion.js":"8dfi7","../overlay/OverlayOp.js":"9f5ft","./CascadedPolygonUnion.js":"63KSD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gxP36":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _snapOverlayOpJs = require("./SnapOverlayOp.js");
var _snapOverlayOpJsDefault = parcelHelpers.interopDefault(_snapOverlayOpJs);
var _runtimeExceptionJs = require("../../../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
var _overlayOpJs = require("../OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
class SnapIfNeededOverlayOp {
    constructor(){
        SnapIfNeededOverlayOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geom = new Array(2).fill(null);
        const g1 = arguments[0], g2 = arguments[1];
        this._geom[0] = g1;
        this._geom[1] = g2;
    }
    static overlayOp(g0, g1, opCode) {
        const op = new SnapIfNeededOverlayOp(g0, g1);
        return op.getResultGeometry(opCode);
    }
    static union(g0, g1) {
        return SnapIfNeededOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).UNION);
    }
    static intersection(g0, g1) {
        return SnapIfNeededOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).INTERSECTION);
    }
    static symDifference(g0, g1) {
        return SnapIfNeededOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).SYMDIFFERENCE);
    }
    static difference(g0, g1) {
        return SnapIfNeededOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).DIFFERENCE);
    }
    getResultGeometry(opCode) {
        let result = null;
        let isSuccess = false;
        let savedException = null;
        try {
            result = (0, _overlayOpJsDefault.default).overlayOp(this._geom[0], this._geom[1], opCode);
            const isValid = true;
            if (isValid) isSuccess = true;
        } catch (ex) {
            if (ex instanceof (0, _runtimeExceptionJsDefault.default)) savedException = ex;
            else throw ex;
        } finally{}
        if (!isSuccess) try {
            result = (0, _snapOverlayOpJsDefault.default).overlayOp(this._geom[0], this._geom[1], opCode);
        } catch (ex) {
            if (ex instanceof (0, _runtimeExceptionJsDefault.default)) throw savedException;
            else throw ex;
        } finally{}
        return result;
    }
}
exports.default = SnapIfNeededOverlayOp;

},{"./SnapOverlayOp.js":"gpgjQ","../../../../../../java/lang/RuntimeException.js":"3yvnL","../OverlayOp.js":"9f5ft","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gpgjQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometrySnapperJs = require("./GeometrySnapper.js");
var _geometrySnapperJsDefault = parcelHelpers.interopDefault(_geometrySnapperJs);
var _systemJs = require("../../../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _commonBitsRemoverJs = require("../../../precision/CommonBitsRemover.js");
var _commonBitsRemoverJsDefault = parcelHelpers.interopDefault(_commonBitsRemoverJs);
var _overlayOpJs = require("../OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
class SnapOverlayOp {
    constructor(){
        SnapOverlayOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geom = new Array(2).fill(null);
        this._snapTolerance = null;
        this._cbr = null;
        const g1 = arguments[0], g2 = arguments[1];
        this._geom[0] = g1;
        this._geom[1] = g2;
        this.computeSnapTolerance();
    }
    static overlayOp(g0, g1, opCode) {
        const op = new SnapOverlayOp(g0, g1);
        return op.getResultGeometry(opCode);
    }
    static union(g0, g1) {
        return SnapOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).UNION);
    }
    static intersection(g0, g1) {
        return SnapOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).INTERSECTION);
    }
    static symDifference(g0, g1) {
        return SnapOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).SYMDIFFERENCE);
    }
    static difference(g0, g1) {
        return SnapOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).DIFFERENCE);
    }
    selfSnap(geom) {
        const snapper0 = new (0, _geometrySnapperJsDefault.default)(geom);
        const snapGeom = snapper0.snapTo(geom, this._snapTolerance);
        return snapGeom;
    }
    removeCommonBits(geom) {
        this._cbr = new (0, _commonBitsRemoverJsDefault.default)();
        this._cbr.add(geom[0]);
        this._cbr.add(geom[1]);
        const remGeom = new Array(2).fill(null);
        remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
        remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
        return remGeom;
    }
    prepareResult(geom) {
        this._cbr.addCommonBits(geom);
        return geom;
    }
    getResultGeometry(opCode) {
        const prepGeom = this.snap(this._geom);
        const result = (0, _overlayOpJsDefault.default).overlayOp(prepGeom[0], prepGeom[1], opCode);
        return this.prepareResult(result);
    }
    checkValid(g) {
        if (!g.isValid()) (0, _systemJsDefault.default).out.println('Snapped geometry is invalid');
    }
    computeSnapTolerance() {
        this._snapTolerance = (0, _geometrySnapperJsDefault.default).computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
    }
    snap(geom) {
        const remGeom = this.removeCommonBits(geom);
        const snapGeom = (0, _geometrySnapperJsDefault.default).snap(remGeom[0], remGeom[1], this._snapTolerance);
        return snapGeom;
    }
}
exports.default = SnapOverlayOp;

},{"./GeometrySnapper.js":"30aKs","../../../../../../java/lang/System.js":"dYmTx","../../../precision/CommonBitsRemover.js":"7y7Cu","../OverlayOp.js":"9f5ft","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"30aKs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _treeSetJs = require("../../../../../../java/util/TreeSet.js");
var _treeSetJsDefault = parcelHelpers.interopDefault(_treeSetJs);
var _doubleJs = require("../../../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _bufferOpJs = require("../../buffer/BufferOp.js");
var _bufferOpJsDefault = parcelHelpers.interopDefault(_bufferOpJs);
var _lineStringSnapperJs = require("./LineStringSnapper.js");
var _lineStringSnapperJsDefault = parcelHelpers.interopDefault(_lineStringSnapperJs);
var _precisionModelJs = require("../../../geom/PrecisionModel.js");
var _precisionModelJsDefault = parcelHelpers.interopDefault(_precisionModelJs);
var _polygonalJs = require("../../../geom/Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _geometryTransformerJs = require("../../../geom/util/GeometryTransformer.js");
var _geometryTransformerJsDefault = parcelHelpers.interopDefault(_geometryTransformerJs);
var _hasInterfaceJs = require("../../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
class GeometrySnapper {
    constructor(){
        GeometrySnapper.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._srcGeom = null;
        const srcGeom = arguments[0];
        this._srcGeom = srcGeom;
    }
    static computeSizeBasedSnapTolerance(g) {
        const env = g.getEnvelopeInternal();
        const minDimension = Math.min(env.getHeight(), env.getWidth());
        const snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
        return snapTol;
    }
    static computeOverlaySnapTolerance() {
        if (arguments.length === 1) {
            const g = arguments[0];
            let snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
            const pm = g.getPrecisionModel();
            if (pm.getType() === (0, _precisionModelJsDefault.default).FIXED) {
                const fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
                if (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;
            }
            return snapTolerance;
        } else if (arguments.length === 2) {
            const g0 = arguments[0], g1 = arguments[1];
            return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));
        }
    }
    static snapToSelf(geom, snapTolerance, cleanResult) {
        const snapper0 = new GeometrySnapper(geom);
        return snapper0.snapToSelf(snapTolerance, cleanResult);
    }
    static snap(g0, g1, snapTolerance) {
        const snapGeom = new Array(2).fill(null);
        const snapper0 = new GeometrySnapper(g0);
        snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
        const snapper1 = new GeometrySnapper(g1);
        snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
        return snapGeom;
    }
    computeSnapTolerance(ringPts) {
        const minSegLen = this.computeMinimumSegmentLength(ringPts);
        const snapTol = minSegLen / 10;
        return snapTol;
    }
    snapTo(snapGeom, snapTolerance) {
        const snapPts = this.extractTargetCoordinates(snapGeom);
        const snapTrans = new SnapTransformer(snapTolerance, snapPts);
        return snapTrans.transform(this._srcGeom);
    }
    snapToSelf(snapTolerance, cleanResult) {
        const snapPts = this.extractTargetCoordinates(this._srcGeom);
        const snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
        const snappedGeom = snapTrans.transform(this._srcGeom);
        let result = snappedGeom;
        if (cleanResult && (0, _hasInterfaceJsDefault.default)(result, (0, _polygonalJsDefault.default))) result = (0, _bufferOpJsDefault.default).bufferOp(snappedGeom, 0);
        return result;
    }
    extractTargetCoordinates(g) {
        const ptSet = new (0, _treeSetJsDefault.default)();
        const pts = g.getCoordinates();
        for(let i = 0; i < pts.length; i++)ptSet.add(pts[i]);
        return ptSet.toArray(new Array(0).fill(null));
    }
    computeMinimumSegmentLength(pts) {
        let minSegLen = (0, _doubleJsDefault.default).MAX_VALUE;
        for(let i = 0; i < pts.length - 1; i++){
            const segLen = pts[i].distance(pts[i + 1]);
            if (segLen < minSegLen) minSegLen = segLen;
        }
        return minSegLen;
    }
}
exports.default = GeometrySnapper;
GeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;
class SnapTransformer extends (0, _geometryTransformerJsDefault.default) {
    constructor(){
        super();
        SnapTransformer.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._snapTolerance = null;
        this._snapPts = null;
        this._isSelfSnap = false;
        if (arguments.length === 2) {
            const snapTolerance = arguments[0], snapPts = arguments[1];
            this._snapTolerance = snapTolerance;
            this._snapPts = snapPts;
        } else if (arguments.length === 3) {
            const snapTolerance = arguments[0], snapPts = arguments[1], isSelfSnap = arguments[2];
            this._snapTolerance = snapTolerance;
            this._snapPts = snapPts;
            this._isSelfSnap = isSelfSnap;
        }
    }
    transformCoordinates(coords, parent) {
        const srcPts = coords.toCoordinateArray();
        const newPts = this.snapLine(srcPts, this._snapPts);
        return this._factory.getCoordinateSequenceFactory().create(newPts);
    }
    snapLine(srcPts, snapPts) {
        const snapper = new (0, _lineStringSnapperJsDefault.default)(srcPts, this._snapTolerance);
        snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
        return snapper.snapTo(snapPts);
    }
}

},{"../../../../../../java/util/TreeSet.js":"is5ah","../../../../../../java/lang/Double.js":"clUxd","../../buffer/BufferOp.js":"1i41m","./LineStringSnapper.js":"3M1zL","../../../geom/PrecisionModel.js":"9XxRL","../../../geom/Polygonal.js":"jIBid","../../../geom/util/GeometryTransformer.js":"d0nTa","../../../../../../hasInterface.js":"5bpze","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1i41m":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bufferParametersJs = require("./BufferParameters.js");
var _bufferParametersJsDefault = parcelHelpers.interopDefault(_bufferParametersJs);
var _scaledNoderJs = require("../../noding/ScaledNoder.js");
var _scaledNoderJsDefault = parcelHelpers.interopDefault(_scaledNoderJs);
var _topologyExceptionJs = require("../../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _mathUtilJs = require("../../math/MathUtil.js");
var _mathUtilJsDefault = parcelHelpers.interopDefault(_mathUtilJs);
var _precisionModelJs = require("../../geom/PrecisionModel.js");
var _precisionModelJsDefault = parcelHelpers.interopDefault(_precisionModelJs);
var _runtimeExceptionJs = require("../../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
var _mcindexSnapRounderJs = require("../../noding/snapround/MCIndexSnapRounder.js");
var _mcindexSnapRounderJsDefault = parcelHelpers.interopDefault(_mcindexSnapRounderJs);
var _geometryJs = require("../../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _bufferBuilderJs = require("./BufferBuilder.js");
var _bufferBuilderJsDefault = parcelHelpers.interopDefault(_bufferBuilderJs);
class BufferOp {
    constructor(){
        BufferOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._argGeom = null;
        this._distance = null;
        this._bufParams = new (0, _bufferParametersJsDefault.default)();
        this._resultGeometry = null;
        this._saveException = null;
        if (arguments.length === 1) {
            const g = arguments[0];
            this._argGeom = g;
        } else if (arguments.length === 2) {
            const g = arguments[0], bufParams = arguments[1];
            this._argGeom = g;
            this._bufParams = bufParams;
        }
    }
    static bufferOp() {
        if (arguments.length === 2) {
            const g = arguments[0], distance = arguments[1];
            const gBuf = new BufferOp(g);
            const geomBuf = gBuf.getResultGeometry(distance);
            return geomBuf;
        } else if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof (0, _geometryJsDefault.default) && typeof arguments[1] === 'number') {
                const g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2];
                const bufOp = new BufferOp(g);
                bufOp.setQuadrantSegments(quadrantSegments);
                const geomBuf = bufOp.getResultGeometry(distance);
                return geomBuf;
            } else if (arguments[2] instanceof (0, _bufferParametersJsDefault.default) && arguments[0] instanceof (0, _geometryJsDefault.default) && typeof arguments[1] === 'number') {
                const g = arguments[0], distance = arguments[1], params = arguments[2];
                const bufOp = new BufferOp(g, params);
                const geomBuf = bufOp.getResultGeometry(distance);
                return geomBuf;
            }
        } else if (arguments.length === 4) {
            const g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2], endCapStyle = arguments[3];
            const bufOp = new BufferOp(g);
            bufOp.setQuadrantSegments(quadrantSegments);
            bufOp.setEndCapStyle(endCapStyle);
            const geomBuf = bufOp.getResultGeometry(distance);
            return geomBuf;
        }
    }
    static precisionScaleFactor(g, distance, maxPrecisionDigits) {
        const env = g.getEnvelopeInternal();
        const envMax = (0, _mathUtilJsDefault.default).max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
        const expandByDistance = distance > 0.0 ? distance : 0.0;
        const bufEnvMax = envMax + 2 * expandByDistance;
        const bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);
        const minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
        const scaleFactor = Math.pow(10.0, minUnitLog10);
        return scaleFactor;
    }
    bufferFixedPrecision(fixedPM) {
        const noder = new (0, _scaledNoderJsDefault.default)(new (0, _mcindexSnapRounderJsDefault.default)(new (0, _precisionModelJsDefault.default)(1.0)), fixedPM.getScale());
        const bufBuilder = new (0, _bufferBuilderJsDefault.default)(this._bufParams);
        bufBuilder.setWorkingPrecisionModel(fixedPM);
        bufBuilder.setNoder(noder);
        this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
    }
    bufferReducedPrecision() {
        if (arguments.length === 0) {
            for(let precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--){
                try {
                    this.bufferReducedPrecision(precDigits);
                } catch (ex) {
                    if (ex instanceof (0, _topologyExceptionJsDefault.default)) this._saveException = ex;
                    else throw ex;
                } finally{}
                if (this._resultGeometry !== null) return null;
            }
            throw this._saveException;
        } else if (arguments.length === 1) {
            const precisionDigits = arguments[0];
            const sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
            const fixedPM = new (0, _precisionModelJsDefault.default)(sizeBasedScaleFactor);
            this.bufferFixedPrecision(fixedPM);
        }
    }
    bufferOriginalPrecision() {
        try {
            const bufBuilder = new (0, _bufferBuilderJsDefault.default)(this._bufParams);
            this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
        } catch (ex) {
            if (ex instanceof (0, _runtimeExceptionJsDefault.default)) this._saveException = ex;
            else throw ex;
        } finally{}
    }
    getResultGeometry(distance) {
        this._distance = distance;
        this.computeGeometry();
        return this._resultGeometry;
    }
    setEndCapStyle(endCapStyle) {
        this._bufParams.setEndCapStyle(endCapStyle);
    }
    computeGeometry() {
        this.bufferOriginalPrecision();
        if (this._resultGeometry !== null) return null;
        const argPM = this._argGeom.getFactory().getPrecisionModel();
        if (argPM.getType() === (0, _precisionModelJsDefault.default).FIXED) this.bufferFixedPrecision(argPM);
        else this.bufferReducedPrecision();
    }
    setQuadrantSegments(quadrantSegments) {
        this._bufParams.setQuadrantSegments(quadrantSegments);
    }
}
exports.default = BufferOp;
BufferOp.CAP_ROUND = (0, _bufferParametersJsDefault.default).CAP_ROUND;
BufferOp.CAP_BUTT = (0, _bufferParametersJsDefault.default).CAP_FLAT;
BufferOp.CAP_FLAT = (0, _bufferParametersJsDefault.default).CAP_FLAT;
BufferOp.CAP_SQUARE = (0, _bufferParametersJsDefault.default).CAP_SQUARE;
BufferOp.MAX_PRECISION_DIGITS = 12;

},{"./BufferParameters.js":"idesX","../../noding/ScaledNoder.js":"XDiPO","../../geom/TopologyException.js":"bOVA5","../../math/MathUtil.js":"432sT","../../geom/PrecisionModel.js":"9XxRL","../../../../../java/lang/RuntimeException.js":"3yvnL","../../noding/snapround/MCIndexSnapRounder.js":"hoOy8","../../geom/Geometry.js":"9DSzO","./BufferBuilder.js":"a6cSc","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"idesX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class BufferParameters {
    constructor(){
        BufferParameters.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
        this._endCapStyle = BufferParameters.CAP_ROUND;
        this._joinStyle = BufferParameters.JOIN_ROUND;
        this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;
        this._isSingleSided = false;
        this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const quadrantSegments = arguments[0];
            this.setQuadrantSegments(quadrantSegments);
        } else if (arguments.length === 2) {
            const quadrantSegments = arguments[0], endCapStyle = arguments[1];
            this.setQuadrantSegments(quadrantSegments);
            this.setEndCapStyle(endCapStyle);
        } else if (arguments.length === 4) {
            const quadrantSegments = arguments[0], endCapStyle = arguments[1], joinStyle = arguments[2], mitreLimit = arguments[3];
            this.setQuadrantSegments(quadrantSegments);
            this.setEndCapStyle(endCapStyle);
            this.setJoinStyle(joinStyle);
            this.setMitreLimit(mitreLimit);
        }
    }
    static bufferDistanceError(quadSegs) {
        const alpha = Math.PI / 2.0 / quadSegs;
        return 1 - Math.cos(alpha / 2.0);
    }
    getEndCapStyle() {
        return this._endCapStyle;
    }
    isSingleSided() {
        return this._isSingleSided;
    }
    setQuadrantSegments(quadSegs) {
        this._quadrantSegments = quadSegs;
        if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;
        if (this._quadrantSegments < 0) {
            this._joinStyle = BufferParameters.JOIN_MITRE;
            this._mitreLimit = Math.abs(this._quadrantSegments);
        }
        if (quadSegs <= 0) this._quadrantSegments = 1;
        if (this._joinStyle !== BufferParameters.JOIN_ROUND) this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
    }
    getJoinStyle() {
        return this._joinStyle;
    }
    setJoinStyle(joinStyle) {
        this._joinStyle = joinStyle;
    }
    setSimplifyFactor(simplifyFactor) {
        this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
    }
    getSimplifyFactor() {
        return this._simplifyFactor;
    }
    getQuadrantSegments() {
        return this._quadrantSegments;
    }
    setEndCapStyle(endCapStyle) {
        this._endCapStyle = endCapStyle;
    }
    getMitreLimit() {
        return this._mitreLimit;
    }
    setMitreLimit(mitreLimit) {
        this._mitreLimit = mitreLimit;
    }
    setSingleSided(isSingleSided) {
        this._isSingleSided = isSingleSided;
    }
}
exports.default = BufferParameters;
BufferParameters.CAP_ROUND = 1;
BufferParameters.CAP_FLAT = 2;
BufferParameters.CAP_SQUARE = 3;
BufferParameters.JOIN_ROUND = 1;
BufferParameters.JOIN_MITRE = 2;
BufferParameters.JOIN_BEVEL = 3;
BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;
BufferParameters.DEFAULT_MITRE_LIMIT = 5.0;
BufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"XDiPO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _nodedSegmentStringJs = require("./NodedSegmentString.js");
var _nodedSegmentStringJsDefault = parcelHelpers.interopDefault(_nodedSegmentStringJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _coordinateArraysJs = require("../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _collectionJs = require("../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _noderJs = require("./Noder.js");
var _noderJsDefault = parcelHelpers.interopDefault(_noderJs);
class ScaledNoder {
    constructor(){
        ScaledNoder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._noder = null;
        this._scaleFactor = null;
        this._offsetX = null;
        this._offsetY = null;
        this._isScaled = false;
        if (arguments.length === 2) {
            const noder = arguments[0], scaleFactor = arguments[1];
            ScaledNoder.constructor_.call(this, noder, scaleFactor, 0, 0);
        } else if (arguments.length === 4) {
            const noder = arguments[0], scaleFactor = arguments[1], offsetX = arguments[2], offsetY = arguments[3];
            this._noder = noder;
            this._scaleFactor = scaleFactor;
            this._isScaled = !this.isIntegerPrecision();
        }
    }
    rescale() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const segStrings = arguments[0];
            for(let i = segStrings.iterator(); i.hasNext();){
                const ss = i.next();
                this.rescale(ss.getCoordinates());
            }
        } else if (arguments[0] instanceof Array) {
            const pts = arguments[0];
            for(let i = 0; i < pts.length; i++){
                pts[i].x = pts[i].x / this._scaleFactor + this._offsetX;
                pts[i].y = pts[i].y / this._scaleFactor + this._offsetY;
            }
            if (pts.length === 2 && pts[0].equals2D(pts[1])) (0, _systemJsDefault.default).out.println(pts);
        }
    }
    scale() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const segStrings = arguments[0];
            const nodedSegmentStrings = new (0, _arrayListJsDefault.default)(segStrings.size());
            for(let i = segStrings.iterator(); i.hasNext();){
                const ss = i.next();
                nodedSegmentStrings.add(new (0, _nodedSegmentStringJsDefault.default)(this.scale(ss.getCoordinates()), ss.getData()));
            }
            return nodedSegmentStrings;
        } else if (arguments[0] instanceof Array) {
            const pts = arguments[0];
            const roundPts = new Array(pts.length).fill(null);
            for(let i = 0; i < pts.length; i++)roundPts[i] = new (0, _coordinateJsDefault.default)(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].getZ());
            const roundPtsNoDup = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(roundPts);
            return roundPtsNoDup;
        }
    }
    isIntegerPrecision() {
        return this._scaleFactor === 1.0;
    }
    getNodedSubstrings() {
        const splitSS = this._noder.getNodedSubstrings();
        if (this._isScaled) this.rescale(splitSS);
        return splitSS;
    }
    computeNodes(inputSegStrings) {
        let intSegStrings = inputSegStrings;
        if (this._isScaled) intSegStrings = this.scale(inputSegStrings);
        this._noder.computeNodes(intSegStrings);
    }
    get interfaces_() {
        return [
            (0, _noderJsDefault.default)
        ];
    }
}
exports.default = ScaledNoder;

},{"../../../../hasInterface.js":"5bpze","../geom/Coordinate.js":"ii2fh","./NodedSegmentString.js":"gBLDJ","../../../../java/lang/System.js":"dYmTx","../geom/CoordinateArrays.js":"lncg4","../../../../java/util/ArrayList.js":"gGAQZ","../../../../java/util/Collection.js":"cggki","./Noder.js":"jKC91","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gBLDJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _segmentNodeListJs = require("./SegmentNodeList.js");
var _segmentNodeListJsDefault = parcelHelpers.interopDefault(_segmentNodeListJs);
var _wktwriterJs = require("../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _coordinateArraySequenceJs = require("../geom/impl/CoordinateArraySequence.js");
var _coordinateArraySequenceJsDefault = parcelHelpers.interopDefault(_coordinateArraySequenceJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _octantJs = require("./Octant.js");
var _octantJsDefault = parcelHelpers.interopDefault(_octantJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _nodableSegmentStringJs = require("./NodableSegmentString.js");
var _nodableSegmentStringJsDefault = parcelHelpers.interopDefault(_nodableSegmentStringJs);
class NodedSegmentString {
    constructor(){
        NodedSegmentString.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._nodeList = new (0, _segmentNodeListJsDefault.default)(this);
        this._pts = null;
        this._data = null;
        const pts = arguments[0], data = arguments[1];
        this._pts = pts;
        this._data = data;
    }
    static getNodedSubstrings() {
        if (arguments.length === 1) {
            const segStrings = arguments[0];
            const resultEdgelist = new (0, _arrayListJsDefault.default)();
            NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
            return resultEdgelist;
        } else if (arguments.length === 2) {
            const segStrings = arguments[0], resultEdgelist = arguments[1];
            for(let i = segStrings.iterator(); i.hasNext();){
                const ss = i.next();
                ss.getNodeList().addSplitEdges(resultEdgelist);
            }
        }
    }
    getCoordinates() {
        return this._pts;
    }
    size() {
        return this._pts.length;
    }
    getCoordinate(i) {
        return this._pts[i];
    }
    isClosed() {
        return this._pts[0].equals(this._pts[this._pts.length - 1]);
    }
    getSegmentOctant(index) {
        if (index === this._pts.length - 1) return -1;
        return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));
    }
    toString() {
        return (0, _wktwriterJsDefault.default).toLineString(new (0, _coordinateArraySequenceJsDefault.default)(this._pts));
    }
    getNodeList() {
        return this._nodeList;
    }
    addIntersectionNode(intPt, segmentIndex) {
        let normalizedSegmentIndex = segmentIndex;
        const nextSegIndex = normalizedSegmentIndex + 1;
        if (nextSegIndex < this._pts.length) {
            const nextPt = this._pts[nextSegIndex];
            if (intPt.equals2D(nextPt)) normalizedSegmentIndex = nextSegIndex;
        }
        const ei = this._nodeList.add(intPt, normalizedSegmentIndex);
        return ei;
    }
    addIntersections(li, segmentIndex, geomIndex) {
        for(let i = 0; i < li.getIntersectionNum(); i++)this.addIntersection(li, segmentIndex, geomIndex, i);
    }
    setData(data) {
        this._data = data;
    }
    safeOctant(p0, p1) {
        if (p0.equals2D(p1)) return 0;
        return (0, _octantJsDefault.default).octant(p0, p1);
    }
    getData() {
        return this._data;
    }
    addIntersection() {
        if (arguments.length === 2) {
            const intPt = arguments[0], segmentIndex = arguments[1];
            this.addIntersectionNode(intPt, segmentIndex);
        } else if (arguments.length === 4) {
            const li = arguments[0], segmentIndex = arguments[1], geomIndex = arguments[2], intIndex = arguments[3];
            const intPt = new (0, _coordinateJsDefault.default)(li.getIntersection(intIndex));
            this.addIntersection(intPt, segmentIndex);
        }
    }
    get interfaces_() {
        return [
            (0, _nodableSegmentStringJsDefault.default)
        ];
    }
}
exports.default = NodedSegmentString;

},{"./SegmentNodeList.js":"fBtLO","../io/WKTWriter.js":"1WLaw","../geom/impl/CoordinateArraySequence.js":"grBJo","../geom/Coordinate.js":"ii2fh","./Octant.js":"5OU0v","../../../../java/util/ArrayList.js":"gGAQZ","./NodableSegmentString.js":"dNf4G","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fBtLO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateListJs = require("../geom/CoordinateList.js");
var _coordinateListJsDefault = parcelHelpers.interopDefault(_coordinateListJs);
var _segmentNodeJs = require("./SegmentNode.js");
var _segmentNodeJsDefault = parcelHelpers.interopDefault(_segmentNodeJs);
var _iteratorJs = require("../../../../java/util/Iterator.js");
var _iteratorJsDefault = parcelHelpers.interopDefault(_iteratorJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _nodedSegmentStringJs = require("./NodedSegmentString.js");
var _nodedSegmentStringJsDefault = parcelHelpers.interopDefault(_nodedSegmentStringJs);
var _integerJs = require("../../../../java/lang/Integer.js");
var _integerJsDefault = parcelHelpers.interopDefault(_integerJs);
var _unsupportedOperationExceptionJs = require("../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _treeMapJs = require("../../../../java/util/TreeMap.js");
var _treeMapJsDefault = parcelHelpers.interopDefault(_treeMapJs);
var _runtimeExceptionJs = require("../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class SegmentNodeList {
    constructor(){
        SegmentNodeList.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._nodeMap = new (0, _treeMapJsDefault.default)();
        this._edge = null;
        const edge = arguments[0];
        this._edge = edge;
    }
    getSplitCoordinates() {
        const coordList = new (0, _coordinateListJsDefault.default)();
        this.addEndpoints();
        const it = this.iterator();
        let eiPrev = it.next();
        while(it.hasNext()){
            const ei = it.next();
            this.addEdgeCoordinates(eiPrev, ei, coordList);
            eiPrev = ei;
        }
        return coordList.toCoordinateArray();
    }
    print(out) {
        out.println('Intersections:');
        for(let it = this.iterator(); it.hasNext();){
            const ei = it.next();
            ei.print(out);
        }
    }
    findCollapsesFromExistingVertices(collapsedVertexIndexes) {
        for(let i = 0; i < this._edge.size() - 2; i++){
            const p0 = this._edge.getCoordinate(i);
            const p1 = this._edge.getCoordinate(i + 1);
            const p2 = this._edge.getCoordinate(i + 2);
            if (p0.equals2D(p2)) collapsedVertexIndexes.add((0, _integerJsDefault.default).valueOf(i + 1));
        }
    }
    addEdgeCoordinates(ei0, ei1, coordList) {
        const pts = this.createSplitEdgePts(ei0, ei1);
        coordList.add(pts, false);
    }
    findCollapseIndex(ei0, ei1, collapsedVertexIndex) {
        if (!ei0.coord.equals2D(ei1.coord)) return false;
        let numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
        if (!ei1.isInterior()) numVerticesBetween--;
        if (numVerticesBetween === 1) {
            collapsedVertexIndex[0] = ei0.segmentIndex + 1;
            return true;
        }
        return false;
    }
    findCollapsesFromInsertedNodes(collapsedVertexIndexes) {
        const collapsedVertexIndex = new Array(1).fill(null);
        const it = this.iterator();
        let eiPrev = it.next();
        while(it.hasNext()){
            const ei = it.next();
            const isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
            if (isCollapsed) collapsedVertexIndexes.add((0, _integerJsDefault.default).valueOf(collapsedVertexIndex[0]));
            eiPrev = ei;
        }
    }
    getEdge() {
        return this._edge;
    }
    addEndpoints() {
        const maxSegIndex = this._edge.size() - 1;
        this.add(this._edge.getCoordinate(0), 0);
        this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
    }
    createSplitEdge(ei0, ei1) {
        const pts = this.createSplitEdgePts(ei0, ei1);
        return new (0, _nodedSegmentStringJsDefault.default)(pts, this._edge.getData());
    }
    add(intPt, segmentIndex) {
        const eiNew = new (0, _segmentNodeJsDefault.default)(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
        const ei = this._nodeMap.get(eiNew);
        if (ei !== null) {
            (0, _assertJsDefault.default).isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');
            return ei;
        }
        this._nodeMap.put(eiNew, eiNew);
        return eiNew;
    }
    checkSplitEdgesCorrectness(splitEdges) {
        const edgePts = this._edge.getCoordinates();
        const split0 = splitEdges.get(0);
        const pt0 = split0.getCoordinate(0);
        if (!pt0.equals2D(edgePts[0])) throw new (0, _runtimeExceptionJsDefault.default)('bad split edge start point at ' + pt0);
        const splitn = splitEdges.get(splitEdges.size() - 1);
        const splitnPts = splitn.getCoordinates();
        const ptn = splitnPts[splitnPts.length - 1];
        if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new (0, _runtimeExceptionJsDefault.default)('bad split edge end point at ' + ptn);
    }
    addCollapsedNodes() {
        const collapsedVertexIndexes = new (0, _arrayListJsDefault.default)();
        this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
        this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
        for(let it = collapsedVertexIndexes.iterator(); it.hasNext();){
            const vertexIndex = it.next().intValue();
            this.add(this._edge.getCoordinate(vertexIndex), vertexIndex);
        }
    }
    createSplitEdgePts(ei0, ei1) {
        let npts = ei1.segmentIndex - ei0.segmentIndex + 2;
        if (npts === 2) return [
            new (0, _coordinateJsDefault.default)(ei0.coord),
            new (0, _coordinateJsDefault.default)(ei1.coord)
        ];
        const lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
        const useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
        if (!useIntPt1) npts--;
        const pts = new Array(npts).fill(null);
        let ipt = 0;
        pts[ipt++] = new (0, _coordinateJsDefault.default)(ei0.coord);
        for(let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++)pts[ipt++] = this._edge.getCoordinate(i);
        if (useIntPt1) pts[ipt] = new (0, _coordinateJsDefault.default)(ei1.coord);
        return pts;
    }
    iterator() {
        return this._nodeMap.values().iterator();
    }
    addSplitEdges(edgeList) {
        this.addEndpoints();
        this.addCollapsedNodes();
        const it = this.iterator();
        let eiPrev = it.next();
        while(it.hasNext()){
            const ei = it.next();
            const newEdge = this.createSplitEdge(eiPrev, ei);
            edgeList.add(newEdge);
            eiPrev = ei;
        }
    }
}
exports.default = SegmentNodeList;
class NodeVertexIterator {
    constructor(){
        NodeVertexIterator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._nodeList = null;
        this._edge = null;
        this._nodeIt = null;
        this._currNode = null;
        this._nextNode = null;
        this._currSegIndex = 0;
        const nodeList = arguments[0];
        this._nodeList = nodeList;
        this._edge = nodeList.getEdge();
        this._nodeIt = nodeList.iterator();
        this.readNextNode();
    }
    next() {
        if (this._currNode === null) {
            this._currNode = this._nextNode;
            this._currSegIndex = this._currNode.segmentIndex;
            this.readNextNode();
            return this._currNode;
        }
        if (this._nextNode === null) return null;
        if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {
            this._currNode = this._nextNode;
            this._currSegIndex = this._currNode.segmentIndex;
            this.readNextNode();
            return this._currNode;
        }
        this._nextNode.segmentIndex, this._currNode.segmentIndex;
        return null;
    }
    readNextNode() {
        if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next();
        else this._nextNode = null;
    }
    hasNext() {
        if (this._nextNode === null) return false;
        return true;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)(this.getClass().getName());
    }
    get interfaces_() {
        return [
            (0, _iteratorJsDefault.default)
        ];
    }
}

},{"../geom/CoordinateList.js":"ibs54","./SegmentNode.js":"i2Y5Z","../../../../java/util/Iterator.js":"zp5SP","../geom/Coordinate.js":"ii2fh","./NodedSegmentString.js":"gBLDJ","../../../../java/lang/Integer.js":"b3mDP","../../../../java/lang/UnsupportedOperationException.js":"dV3kx","../../../../java/util/ArrayList.js":"gGAQZ","../../../../java/util/TreeMap.js":"dQNYS","../../../../java/lang/RuntimeException.js":"3yvnL","../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i2Y5Z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _segmentPointComparatorJs = require("./SegmentPointComparator.js");
var _segmentPointComparatorJsDefault = parcelHelpers.interopDefault(_segmentPointComparatorJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
class SegmentNode {
    constructor(){
        SegmentNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._segString = null;
        this.coord = null;
        this.segmentIndex = null;
        this._segmentOctant = null;
        this._isInterior = null;
        const segString = arguments[0], coord = arguments[1], segmentIndex = arguments[2], segmentOctant = arguments[3];
        this._segString = segString;
        this.coord = new (0, _coordinateJsDefault.default)(coord);
        this.segmentIndex = segmentIndex;
        this._segmentOctant = segmentOctant;
        this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
    }
    getCoordinate() {
        return this.coord;
    }
    print(out) {
        out.print(this.coord);
        out.print(' seg # = ' + this.segmentIndex);
    }
    compareTo(obj) {
        const other = obj;
        if (this.segmentIndex < other.segmentIndex) return -1;
        if (this.segmentIndex > other.segmentIndex) return 1;
        if (this.coord.equals2D(other.coord)) return 0;
        if (!this._isInterior) return -1;
        if (!other._isInterior) return 1;
        return (0, _segmentPointComparatorJsDefault.default).compare(this._segmentOctant, this.coord, other.coord);
    }
    isEndPoint(maxSegmentIndex) {
        if (this.segmentIndex === 0 && !this._isInterior) return true;
        if (this.segmentIndex === maxSegmentIndex) return true;
        return false;
    }
    toString() {
        return this.segmentIndex + ':' + this.coord.toString();
    }
    isInterior() {
        return this._isInterior;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = SegmentNode;

},{"../geom/Coordinate.js":"ii2fh","./SegmentPointComparator.js":"1JLGC","../../../../java/lang/Comparable.js":"WFeEu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1JLGC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class SegmentPointComparator {
    static relativeSign(x0, x1) {
        if (x0 < x1) return -1;
        if (x0 > x1) return 1;
        return 0;
    }
    static compareValue(compareSign0, compareSign1) {
        if (compareSign0 < 0) return -1;
        if (compareSign0 > 0) return 1;
        if (compareSign1 < 0) return -1;
        if (compareSign1 > 0) return 1;
        return 0;
    }
    static compare(octant, p0, p1) {
        if (p0.equals2D(p1)) return 0;
        const xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
        const ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
        switch(octant){
            case 0:
                return SegmentPointComparator.compareValue(xSign, ySign);
            case 1:
                return SegmentPointComparator.compareValue(ySign, xSign);
            case 2:
                return SegmentPointComparator.compareValue(ySign, -xSign);
            case 3:
                return SegmentPointComparator.compareValue(-xSign, ySign);
            case 4:
                return SegmentPointComparator.compareValue(-xSign, -ySign);
            case 5:
                return SegmentPointComparator.compareValue(-ySign, -xSign);
            case 6:
                return SegmentPointComparator.compareValue(-ySign, xSign);
            case 7:
                return SegmentPointComparator.compareValue(xSign, -ySign);
        }
        (0, _assertJsDefault.default).shouldNeverReachHere('invalid octant value');
        return 0;
    }
}
exports.default = SegmentPointComparator;

},{"../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5OU0v":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class Octant {
    static octant() {
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            const dx = arguments[0], dy = arguments[1];
            if (dx === 0.0 && dy === 0.0) throw new (0, _illegalArgumentExceptionJsDefault.default)('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )');
            const adx = Math.abs(dx);
            const ady = Math.abs(dy);
            if (dx >= 0) {
                if (dy >= 0) {
                    if (adx >= ady) return 0;
                    else return 1;
                } else if (adx >= ady) return 7;
                else return 6;
            } else if (dy >= 0) {
                if (adx >= ady) return 3;
                else return 2;
            } else if (adx >= ady) return 4;
            else return 5;
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
            const p0 = arguments[0], p1 = arguments[1];
            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;
            if (dx === 0.0 && dy === 0.0) throw new (0, _illegalArgumentExceptionJsDefault.default)('Cannot compute the octant for two identical points ' + p0);
            return Octant.octant(dx, dy);
        }
    }
}
exports.default = Octant;

},{"../geom/Coordinate.js":"ii2fh","../../../../java/lang/IllegalArgumentException.js":"9ppVW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dNf4G":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _segmentStringJs = require("./SegmentString.js");
var _segmentStringJsDefault = parcelHelpers.interopDefault(_segmentStringJs);
class NodableSegmentString {
    addIntersection(intPt, segmentIndex) {}
    get interfaces_() {
        return [
            (0, _segmentStringJsDefault.default)
        ];
    }
}
exports.default = NodableSegmentString;

},{"./SegmentString.js":"isRVw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"isRVw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class SegmentString {
    getCoordinates() {}
    size() {}
    getCoordinate(i) {}
    isClosed() {}
    setData(data) {}
    getData() {}
}
exports.default = SegmentString;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jKC91":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Noder {
    getNodedSubstrings() {}
    computeNodes(segStrings) {}
}
exports.default = Noder;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hoOy8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nodingValidatorJs = require("../NodingValidator.js");
var _nodingValidatorJsDefault = parcelHelpers.interopDefault(_nodingValidatorJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _mcindexNoderJs = require("../MCIndexNoder.js");
var _mcindexNoderJsDefault = parcelHelpers.interopDefault(_mcindexNoderJs);
var _nodedSegmentStringJs = require("../NodedSegmentString.js");
var _nodedSegmentStringJsDefault = parcelHelpers.interopDefault(_nodedSegmentStringJs);
var _hotPixelJs = require("./HotPixel.js");
var _hotPixelJsDefault = parcelHelpers.interopDefault(_hotPixelJs);
var _exceptionJs = require("../../../../../java/lang/Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
var _mcindexPointSnapperJs = require("./MCIndexPointSnapper.js");
var _mcindexPointSnapperJsDefault = parcelHelpers.interopDefault(_mcindexPointSnapperJs);
var _robustLineIntersectorJs = require("../../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _interiorIntersectionFinderAdderJs = require("../InteriorIntersectionFinderAdder.js");
var _interiorIntersectionFinderAdderJsDefault = parcelHelpers.interopDefault(_interiorIntersectionFinderAdderJs);
var _collectionJs = require("../../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _noderJs = require("../Noder.js");
var _noderJsDefault = parcelHelpers.interopDefault(_noderJs);
class MCIndexSnapRounder {
    constructor(){
        MCIndexSnapRounder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._pm = null;
        this._li = null;
        this._scaleFactor = null;
        this._noder = null;
        this._pointSnapper = null;
        this._nodedSegStrings = null;
        const pm = arguments[0];
        this._pm = pm;
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._li.setPrecisionModel(pm);
        this._scaleFactor = pm.getScale();
    }
    checkCorrectness(inputSegmentStrings) {
        const resultSegStrings = (0, _nodedSegmentStringJsDefault.default).getNodedSubstrings(inputSegmentStrings);
        const nv = new (0, _nodingValidatorJsDefault.default)(resultSegStrings);
        try {
            nv.checkValid();
        } catch (ex) {
            if (ex instanceof (0, _exceptionJsDefault.default)) ex.printStackTrace();
            else throw ex;
        } finally{}
    }
    getNodedSubstrings() {
        return (0, _nodedSegmentStringJsDefault.default).getNodedSubstrings(this._nodedSegStrings);
    }
    snapRound(segStrings, li) {
        const intersections = this.findInteriorIntersections(segStrings, li);
        this.computeIntersectionSnaps(intersections);
        this.computeVertexSnaps(segStrings);
    }
    findInteriorIntersections(segStrings, li) {
        const intFinderAdder = new (0, _interiorIntersectionFinderAdderJsDefault.default)(li);
        this._noder.setSegmentIntersector(intFinderAdder);
        this._noder.computeNodes(segStrings);
        return intFinderAdder.getInteriorIntersections();
    }
    computeVertexSnaps() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const edges = arguments[0];
            for(let i0 = edges.iterator(); i0.hasNext();){
                const edge0 = i0.next();
                this.computeVertexSnaps(edge0);
            }
        } else if (arguments[0] instanceof (0, _nodedSegmentStringJsDefault.default)) {
            const e = arguments[0];
            const pts0 = e.getCoordinates();
            for(let i = 0; i < pts0.length; i++){
                const hotPixel = new (0, _hotPixelJsDefault.default)(pts0[i], this._scaleFactor, this._li);
                const isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);
                if (isNodeAdded) e.addIntersection(pts0[i], i);
            }
        }
    }
    computeNodes(inputSegmentStrings) {
        this._nodedSegStrings = inputSegmentStrings;
        this._noder = new (0, _mcindexNoderJsDefault.default)();
        this._pointSnapper = new (0, _mcindexPointSnapperJsDefault.default)(this._noder.getIndex());
        this.snapRound(inputSegmentStrings, this._li);
    }
    computeIntersectionSnaps(snapPts) {
        for(let it = snapPts.iterator(); it.hasNext();){
            const snapPt = it.next();
            const hotPixel = new (0, _hotPixelJsDefault.default)(snapPt, this._scaleFactor, this._li);
            this._pointSnapper.snap(hotPixel);
        }
    }
    get interfaces_() {
        return [
            (0, _noderJsDefault.default)
        ];
    }
}
exports.default = MCIndexSnapRounder;

},{"../NodingValidator.js":"cKZlA","../../../../../hasInterface.js":"5bpze","../MCIndexNoder.js":"1deq0","../NodedSegmentString.js":"gBLDJ","./HotPixel.js":"g53tv","../../../../../java/lang/Exception.js":"8tbsL","./MCIndexPointSnapper.js":"lR2tW","../../algorithm/RobustLineIntersector.js":"kLdG9","../InteriorIntersectionFinderAdder.js":"esmGM","../../../../../java/util/Collection.js":"cggki","../Noder.js":"jKC91","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cKZlA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryFactoryJs = require("../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _robustLineIntersectorJs = require("../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _runtimeExceptionJs = require("../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
class NodingValidator {
    constructor(){
        NodingValidator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._segStrings = null;
        const segStrings = arguments[0];
        this._segStrings = segStrings;
    }
    checkEndPtVertexIntersections() {
        if (arguments.length === 0) for(let i = this._segStrings.iterator(); i.hasNext();){
            const ss = i.next();
            const pts = ss.getCoordinates();
            this.checkEndPtVertexIntersections(pts[0], this._segStrings);
            this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);
        }
        else if (arguments.length === 2) {
            const testPt = arguments[0], segStrings = arguments[1];
            for(let i = segStrings.iterator(); i.hasNext();){
                const ss = i.next();
                const pts = ss.getCoordinates();
                for(let j = 1; j < pts.length - 1; j++)if (pts[j].equals(testPt)) throw new (0, _runtimeExceptionJsDefault.default)('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt);
            }
        }
    }
    checkInteriorIntersections() {
        if (arguments.length === 0) for(let i = this._segStrings.iterator(); i.hasNext();){
            const ss0 = i.next();
            for(let j = this._segStrings.iterator(); j.hasNext();){
                const ss1 = j.next();
                this.checkInteriorIntersections(ss0, ss1);
            }
        }
        else if (arguments.length === 2) {
            const ss0 = arguments[0], ss1 = arguments[1];
            const pts0 = ss0.getCoordinates();
            const pts1 = ss1.getCoordinates();
            for(let i0 = 0; i0 < pts0.length - 1; i0++)for(let i1 = 0; i1 < pts1.length - 1; i1++)this.checkInteriorIntersections(ss0, i0, ss1, i1);
        } else if (arguments.length === 4) {
            const e0 = arguments[0], segIndex0 = arguments[1], e1 = arguments[2], segIndex1 = arguments[3];
            if (e0 === e1 && segIndex0 === segIndex1) return null;
            const p00 = e0.getCoordinates()[segIndex0];
            const p01 = e0.getCoordinates()[segIndex0 + 1];
            const p10 = e1.getCoordinates()[segIndex1];
            const p11 = e1.getCoordinates()[segIndex1 + 1];
            this._li.computeIntersection(p00, p01, p10, p11);
            if (this._li.hasIntersection()) {
                if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) throw new (0, _runtimeExceptionJsDefault.default)('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11);
            }
        }
    }
    checkValid() {
        this.checkEndPtVertexIntersections();
        this.checkInteriorIntersections();
        this.checkCollapses();
    }
    checkCollapses() {
        if (arguments.length === 0) for(let i = this._segStrings.iterator(); i.hasNext();){
            const ss = i.next();
            this.checkCollapses(ss);
        }
        else if (arguments.length === 1) {
            const ss = arguments[0];
            const pts = ss.getCoordinates();
            for(let i = 0; i < pts.length - 2; i++)this.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);
        }
    }
    hasInteriorIntersection(li, p0, p1) {
        for(let i = 0; i < li.getIntersectionNum(); i++){
            const intPt = li.getIntersection(i);
            if (!(intPt.equals(p0) || intPt.equals(p1))) return true;
        }
        return false;
    }
    checkCollapse(p0, p1, p2) {
        if (p0.equals(p2)) throw new (0, _runtimeExceptionJsDefault.default)('found non-noded collapse at ' + NodingValidator.fact.createLineString([
            p0,
            p1,
            p2
        ]));
    }
}
exports.default = NodingValidator;
NodingValidator.fact = new (0, _geometryFactoryJsDefault.default)();

},{"../geom/GeometryFactory.js":"cGt0T","../algorithm/RobustLineIntersector.js":"kLdG9","../../../../java/lang/RuntimeException.js":"3yvnL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1deq0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _strtreeJs = require("../index/strtree/STRtree.js");
var _strtreeJsDefault = parcelHelpers.interopDefault(_strtreeJs);
var _nodedSegmentStringJs = require("./NodedSegmentString.js");
var _nodedSegmentStringJsDefault = parcelHelpers.interopDefault(_nodedSegmentStringJs);
var _monotoneChainOverlapActionJs = require("../index/chain/MonotoneChainOverlapAction.js");
var _monotoneChainOverlapActionJsDefault = parcelHelpers.interopDefault(_monotoneChainOverlapActionJs);
var _monotoneChainBuilderJs = require("../index/chain/MonotoneChainBuilder.js");
var _monotoneChainBuilderJsDefault = parcelHelpers.interopDefault(_monotoneChainBuilderJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _singlePassNoderJs = require("./SinglePassNoder.js");
var _singlePassNoderJsDefault = parcelHelpers.interopDefault(_singlePassNoderJs);
class MCIndexNoder extends (0, _singlePassNoderJsDefault.default) {
    constructor(){
        super();
        MCIndexNoder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._monoChains = new (0, _arrayListJsDefault.default)();
        this._index = new (0, _strtreeJsDefault.default)();
        this._idCounter = 0;
        this._nodedSegStrings = null;
        this._nOverlaps = 0;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const si = arguments[0];
            (0, _singlePassNoderJsDefault.default).constructor_.call(this, si);
        }
    }
    getMonotoneChains() {
        return this._monoChains;
    }
    getNodedSubstrings() {
        return (0, _nodedSegmentStringJsDefault.default).getNodedSubstrings(this._nodedSegStrings);
    }
    getIndex() {
        return this._index;
    }
    add(segStr) {
        const segChains = (0, _monotoneChainBuilderJsDefault.default).getChains(segStr.getCoordinates(), segStr);
        for(let i = segChains.iterator(); i.hasNext();){
            const mc = i.next();
            mc.setId(this._idCounter++);
            this._index.insert(mc.getEnvelope(), mc);
            this._monoChains.add(mc);
        }
    }
    computeNodes(inputSegStrings) {
        this._nodedSegStrings = inputSegStrings;
        for(let i = inputSegStrings.iterator(); i.hasNext();)this.add(i.next());
        this.intersectChains();
    }
    intersectChains() {
        const overlapAction = new SegmentOverlapAction(this._segInt);
        for(let i = this._monoChains.iterator(); i.hasNext();){
            const queryChain = i.next();
            const overlapChains = this._index.query(queryChain.getEnvelope());
            for(let j = overlapChains.iterator(); j.hasNext();){
                const testChain = j.next();
                if (testChain.getId() > queryChain.getId()) {
                    queryChain.computeOverlaps(testChain, overlapAction);
                    this._nOverlaps++;
                }
                if (this._segInt.isDone()) return null;
            }
        }
    }
}
exports.default = MCIndexNoder;
class SegmentOverlapAction extends (0, _monotoneChainOverlapActionJsDefault.default) {
    constructor(){
        super();
        SegmentOverlapAction.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._si = null;
        const si = arguments[0];
        this._si = si;
    }
    overlap() {
        if (arguments.length === 4) {
            const mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3];
            const ss1 = mc1.getContext();
            const ss2 = mc2.getContext();
            this._si.processIntersections(ss1, start1, ss2, start2);
        } else return super.overlap.apply(this, arguments);
    }
}
MCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;

},{"../index/strtree/STRtree.js":"2wZHu","./NodedSegmentString.js":"gBLDJ","../index/chain/MonotoneChainOverlapAction.js":"25ZO4","../index/chain/MonotoneChainBuilder.js":"doUZZ","../../../../java/util/ArrayList.js":"gGAQZ","./SinglePassNoder.js":"h7eIw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2wZHu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itemBoundableJs = require("./ItemBoundable.js");
var _itemBoundableJsDefault = parcelHelpers.interopDefault(_itemBoundableJs);
var _priorityQueueJs = require("../../../../../java/util/PriorityQueue.js");
var _priorityQueueJsDefault = parcelHelpers.interopDefault(_priorityQueueJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _doubleJs = require("../../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _spatialIndexJs = require("../SpatialIndex.js");
var _spatialIndexJsDefault = parcelHelpers.interopDefault(_spatialIndexJs);
var _abstractNodeJs = require("./AbstractNode.js");
var _abstractNodeJsDefault = parcelHelpers.interopDefault(_abstractNodeJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
var _boundablePairJs = require("./BoundablePair.js");
var _boundablePairJsDefault = parcelHelpers.interopDefault(_boundablePairJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _comparatorJs = require("../../../../../java/util/Comparator.js");
var _comparatorJsDefault = parcelHelpers.interopDefault(_comparatorJs);
var _envelopeJs = require("../../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _abstractSTRtreeJs = require("./AbstractSTRtree.js");
var _abstractSTRtreeJsDefault = parcelHelpers.interopDefault(_abstractSTRtreeJs);
var _itemDistanceJs = require("./ItemDistance.js");
var _itemDistanceJsDefault = parcelHelpers.interopDefault(_itemDistanceJs);
class STRtree extends (0, _abstractSTRtreeJsDefault.default) {
    constructor(){
        super();
        STRtree.constructor_.apply(this, arguments);
    }
    static constructor_() {
        if (arguments.length === 0) STRtree.constructor_.call(this, STRtree.DEFAULT_NODE_CAPACITY);
        else if (arguments.length === 1) {
            const nodeCapacity = arguments[0];
            (0, _abstractSTRtreeJsDefault.default).constructor_.call(this, nodeCapacity);
        }
    }
    static getItems(kNearestNeighbors) {
        const items = new Array(kNearestNeighbors.size()).fill(null);
        let count = 0;
        while(!kNearestNeighbors.isEmpty()){
            const bp = kNearestNeighbors.poll();
            items[count] = bp.getBoundable(0).getItem();
            count++;
        }
        return items;
    }
    static avg(a, b) {
        return (a + b) / 2;
    }
    static centreY(e) {
        return STRtree.avg(e.getMinY(), e.getMaxY());
    }
    static centreX(e) {
        return STRtree.avg(e.getMinX(), e.getMaxX());
    }
    size() {
        if (arguments.length === 0) return super.size.call(this);
        else return super.size.apply(this, arguments);
    }
    insert() {
        if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof (0, _envelopeJsDefault.default)) {
            const itemEnv = arguments[0], item = arguments[1];
            if (itemEnv.isNull()) return null;
            super.insert.call(this, itemEnv, item);
        } else return super.insert.apply(this, arguments);
    }
    getIntersectsOp() {
        return STRtree.intersectsOp;
    }
    verticalSlices(childBoundables, sliceCount) {
        const sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
        const slices = new Array(sliceCount).fill(null);
        const i = childBoundables.iterator();
        for(let j = 0; j < sliceCount; j++){
            slices[j] = new (0, _arrayListJsDefault.default)();
            let boundablesAddedToSlice = 0;
            while(i.hasNext() && boundablesAddedToSlice < sliceCapacity){
                const childBoundable = i.next();
                slices[j].add(childBoundable);
                boundablesAddedToSlice++;
            }
        }
        return slices;
    }
    query() {
        if (arguments.length === 1) {
            const searchEnv = arguments[0];
            return super.query.call(this, searchEnv);
        } else if (arguments.length === 2) {
            const searchEnv = arguments[0], visitor = arguments[1];
            super.query.call(this, searchEnv, visitor);
        }
    }
    getComparator() {
        return STRtree.yComparator;
    }
    createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {
        return super.createParentBoundables.call(this, childBoundables, newLevel);
    }
    remove() {
        if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof (0, _envelopeJsDefault.default)) {
            const itemEnv = arguments[0], item = arguments[1];
            return super.remove.call(this, itemEnv, item);
        } else return super.remove.apply(this, arguments);
    }
    depth() {
        if (arguments.length === 0) return super.depth.call(this);
        else return super.depth.apply(this, arguments);
    }
    createParentBoundables(childBoundables, newLevel) {
        (0, _assertJsDefault.default).isTrue(!childBoundables.isEmpty());
        const minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
        const sortedChildBoundables = new (0, _arrayListJsDefault.default)(childBoundables);
        (0, _collectionsJsDefault.default).sort(sortedChildBoundables, STRtree.xComparator);
        const verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
        return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);
    }
    nearestNeighbour() {
        if (arguments.length === 1) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _itemDistanceJsDefault.default))) {
                const itemDist = arguments[0];
                if (this.isEmpty()) return null;
                const bp = new (0, _boundablePairJsDefault.default)(this.getRoot(), this.getRoot(), itemDist);
                return this.nearestNeighbour(bp);
            } else if (arguments[0] instanceof (0, _boundablePairJsDefault.default)) {
                const initBndPair = arguments[0];
                let distanceLowerBound = (0, _doubleJsDefault.default).POSITIVE_INFINITY;
                let minPair = null;
                const priQ = new (0, _priorityQueueJsDefault.default)();
                priQ.add(initBndPair);
                while(!priQ.isEmpty() && distanceLowerBound > 0.0){
                    const bndPair = priQ.poll();
                    const pairDistance = bndPair.getDistance();
                    if (pairDistance >= distanceLowerBound) break;
                    if (bndPair.isLeaves()) {
                        distanceLowerBound = pairDistance;
                        minPair = bndPair;
                    } else bndPair.expandToQueue(priQ, distanceLowerBound);
                }
                if (minPair === null) return null;
                return [
                    minPair.getBoundable(0).getItem(),
                    minPair.getBoundable(1).getItem()
                ];
            }
        } else if (arguments.length === 2) {
            const tree = arguments[0], itemDist = arguments[1];
            if (this.isEmpty() || tree.isEmpty()) return null;
            const bp = new (0, _boundablePairJsDefault.default)(this.getRoot(), tree.getRoot(), itemDist);
            return this.nearestNeighbour(bp);
        } else if (arguments.length === 3) {
            const env = arguments[0], item = arguments[1], itemDist = arguments[2];
            const bnd = new (0, _itemBoundableJsDefault.default)(env, item);
            const bp = new (0, _boundablePairJsDefault.default)(this.getRoot(), bnd, itemDist);
            return this.nearestNeighbour(bp)[0];
        } else if (arguments.length === 4) {
            const env = arguments[0], item = arguments[1], itemDist = arguments[2], k = arguments[3];
            const bnd = new (0, _itemBoundableJsDefault.default)(env, item);
            const bp = new (0, _boundablePairJsDefault.default)(this.getRoot(), bnd, itemDist);
            return this.nearestNeighbourK(bp, k);
        }
    }
    isWithinDistance() {
        if (arguments.length === 2) {
            const initBndPair = arguments[0], maxDistance = arguments[1];
            let distanceUpperBound = (0, _doubleJsDefault.default).POSITIVE_INFINITY;
            const priQ = new (0, _priorityQueueJsDefault.default)();
            priQ.add(initBndPair);
            while(!priQ.isEmpty()){
                const bndPair = priQ.poll();
                const pairDistance = bndPair.getDistance();
                if (pairDistance > maxDistance) return false;
                if (bndPair.maximumDistance() <= maxDistance) return true;
                if (bndPair.isLeaves()) {
                    distanceUpperBound = pairDistance;
                    if (distanceUpperBound <= maxDistance) return true;
                } else bndPair.expandToQueue(priQ, distanceUpperBound);
            }
            return false;
        } else if (arguments.length === 3) {
            const tree = arguments[0], itemDist = arguments[1], maxDistance = arguments[2];
            const bp = new (0, _boundablePairJsDefault.default)(this.getRoot(), tree.getRoot(), itemDist);
            return this.isWithinDistance(bp, maxDistance);
        }
    }
    createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {
        (0, _assertJsDefault.default).isTrue(verticalSlices.length > 0);
        const parentBoundables = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < verticalSlices.length; i++)parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
        return parentBoundables;
    }
    nearestNeighbourK() {
        if (arguments.length === 2) {
            const initBndPair = arguments[0], k = arguments[1];
            return this.nearestNeighbourK(initBndPair, (0, _doubleJsDefault.default).POSITIVE_INFINITY, k);
        } else if (arguments.length === 3) {
            const initBndPair = arguments[0], maxDistance = arguments[1], k = arguments[2];
            let distanceLowerBound = maxDistance;
            const priQ = new (0, _priorityQueueJsDefault.default)();
            priQ.add(initBndPair);
            const kNearestNeighbors = new (0, _priorityQueueJsDefault.default)();
            while(!priQ.isEmpty() && distanceLowerBound >= 0.0){
                const bndPair = priQ.poll();
                const pairDistance = bndPair.getDistance();
                if (pairDistance >= distanceLowerBound) break;
                if (bndPair.isLeaves()) {
                    if (kNearestNeighbors.size() < k) kNearestNeighbors.add(bndPair);
                    else {
                        const bp1 = kNearestNeighbors.peek();
                        if (bp1.getDistance() > pairDistance) {
                            kNearestNeighbors.poll();
                            kNearestNeighbors.add(bndPair);
                        }
                        const bp2 = kNearestNeighbors.peek();
                        distanceLowerBound = bp2.getDistance();
                    }
                } else bndPair.expandToQueue(priQ, distanceLowerBound);
            }
            return STRtree.getItems(kNearestNeighbors);
        }
    }
    createNode(level) {
        return new STRtreeNode(level);
    }
    get interfaces_() {
        return [
            (0, _spatialIndexJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = STRtree;
class STRtreeNode extends (0, _abstractNodeJsDefault.default) {
    constructor(){
        super();
        STRtreeNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const level = arguments[0];
        (0, _abstractNodeJsDefault.default).constructor_.call(this, level);
    }
    computeBounds() {
        let bounds = null;
        for(let i = this.getChildBoundables().iterator(); i.hasNext();){
            const childBoundable = i.next();
            if (bounds === null) bounds = new (0, _envelopeJsDefault.default)(childBoundable.getBounds());
            else bounds.expandToInclude(childBoundable.getBounds());
        }
        return bounds;
    }
}
STRtree.STRtreeNode = STRtreeNode;
STRtree.xComparator = new class {
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
    compare(o1, o2) {
        return (0, _abstractSTRtreeJsDefault.default).compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));
    }
}();
STRtree.yComparator = new class {
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
    compare(o1, o2) {
        return (0, _abstractSTRtreeJsDefault.default).compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));
    }
}();
STRtree.intersectsOp = new class {
    get interfaces_() {
        return [
            IntersectsOp
        ];
    }
    intersects(aBounds, bBounds) {
        return aBounds.intersects(bBounds);
    }
}();
STRtree.DEFAULT_NODE_CAPACITY = 10;

},{"./ItemBoundable.js":"eO4jy","../../../../../java/util/PriorityQueue.js":"b2lva","../../../../../hasInterface.js":"5bpze","../../../../../java/lang/Double.js":"clUxd","../../../../../java/io/Serializable.js":"5sRbw","../SpatialIndex.js":"2N5f4","./AbstractNode.js":"1SBma","../../../../../java/util/Collections.js":"c5dcW","./BoundablePair.js":"bUhyu","../../../../../java/util/ArrayList.js":"gGAQZ","../../../../../java/util/Comparator.js":"hcSJ3","../../geom/Envelope.js":"h2zeM","../../util/Assert.js":"1vSRy","./AbstractSTRtree.js":"4MW3s","./ItemDistance.js":"d4XWg","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eO4jy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _boundableJs = require("./Boundable.js");
var _boundableJsDefault = parcelHelpers.interopDefault(_boundableJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
class ItemBoundable {
    constructor(){
        ItemBoundable.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._bounds = null;
        this._item = null;
        const bounds = arguments[0], item = arguments[1];
        this._bounds = bounds;
        this._item = item;
    }
    getItem() {
        return this._item;
    }
    getBounds() {
        return this._bounds;
    }
    get interfaces_() {
        return [
            (0, _boundableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = ItemBoundable;

},{"./Boundable.js":"78kNi","../../../../../java/io/Serializable.js":"5sRbw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"78kNi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Boundable {
    getBounds() {}
}
exports.default = Boundable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b2lva":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastpriorityqueue = require("fastpriorityqueue");
var _fastpriorityqueueDefault = parcelHelpers.interopDefault(_fastpriorityqueue);
class PriorityQueue {
    constructor(){
        this._fpQueue = new (0, _fastpriorityqueueDefault.default)((a, b)=>a.compareTo(b) < 0);
    }
    poll() {
        return this._fpQueue.poll();
    }
    size() {
        return this._fpQueue.size;
    }
    clear() {
        this._fpQueue = new (0, _fastpriorityqueueDefault.default)();
    }
    peek() {
        return this._fpQueue.peek();
    }
    remove() {
        return this._fpQueue.poll();
    }
    isEmpty() {
        return this._fpQueue.isEmpty();
    }
    add(x) {
        this._fpQueue.add(x);
    }
}
exports.default = PriorityQueue;

},{"fastpriorityqueue":"lU7Rc","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lU7Rc":[function(require,module,exports,__globalThis) {
/**
 * FastPriorityQueue.js : a fast heap-based priority queue  in JavaScript.
 * (c) the authors
 * Licensed under the Apache License, Version 2.0.
 *
 * Speed-optimized heap-based priority queue for modern browsers and JavaScript engines.
 *
 * Usage :
         Installation (in shell, if you use node):
         $ npm install fastpriorityqueue

         Running test program (in JavaScript):

         // var FastPriorityQueue = require("fastpriorityqueue");// in node
         var x = new FastPriorityQueue();
         x.add(1);
         x.add(0);
         x.add(5);
         x.add(4);
         x.add(3);
         x.peek(); // should return 0, leaves x unchanged
         x.size; // should return 5, leaves x unchanged
         while(!x.isEmpty()) {
           console.log(x.poll());
         } // will print 0 1 3 4 5
         x.trim(); // (optional) optimizes memory usage
 */ 'use strict';
var defaultcomparator = function(a, b) {
    return a < b;
};
// construct a new priority queue
// the provided comparator function should take a, b and return *true* when a < b
function FastPriorityQueue(comparator) {
    if (!(this instanceof FastPriorityQueue)) return new FastPriorityQueue(comparator);
    this.array = [];
    this.size = 0;
    this.compare = comparator || defaultcomparator;
}
// copy the priority queue into another, and return it. Queue items are shallow-copied.
// Runs in `O(n)` time.
FastPriorityQueue.prototype.clone = function() {
    var fpq = new FastPriorityQueue(this.compare);
    fpq.size = this.size;
    fpq.array = this.array.slice(0, this.size);
    return fpq;
};
// add an element into the queue
// runs in `O(log n)` time
FastPriorityQueue.prototype.add = function(myval) {
    var i = this.size;
    this.array[this.size] = myval;
    this.size += 1;
    var p;
    var ap;
    while(i > 0){
        p = i - 1 >> 1;
        ap = this.array[p];
        if (!this.compare(myval, ap)) break;
        this.array[i] = ap;
        i = p;
    }
    this.array[i] = myval;
};
// replace the content of the heap by provided array and "heapify it"
FastPriorityQueue.prototype.heapify = function(arr) {
    this.array = arr;
    this.size = arr.length;
    var i;
    for(i = this.size >> 1; i >= 0; i--)this._percolateDown(i);
};
// for internal use
FastPriorityQueue.prototype._percolateUp = function(i, force) {
    var myval = this.array[i];
    var p;
    var ap;
    while(i > 0){
        p = i - 1 >> 1;
        ap = this.array[p];
        // force will skip the compare
        if (!force && !this.compare(myval, ap)) break;
        this.array[i] = ap;
        i = p;
    }
    this.array[i] = myval;
};
// for internal use
FastPriorityQueue.prototype._percolateDown = function(i) {
    var size = this.size;
    var hsize = this.size >>> 1;
    var ai = this.array[i];
    var l;
    var r;
    var bestc;
    while(i < hsize){
        l = (i << 1) + 1;
        r = l + 1;
        bestc = this.array[l];
        if (r < size) {
            if (this.compare(this.array[r], bestc)) {
                l = r;
                bestc = this.array[r];
            }
        }
        if (!this.compare(bestc, ai)) break;
        this.array[i] = bestc;
        i = l;
    }
    this.array[i] = ai;
};
// internal
// _removeAt(index) will remove the item at the given index from the queue,
// retaining balance. returns the removed item, or undefined if nothing is removed.
FastPriorityQueue.prototype._removeAt = function(index) {
    if (index > this.size - 1 || index < 0) return undefined;
    // impl1:
    //this.array.splice(index, 1);
    //this.heapify(this.array);
    // impl2:
    this._percolateUp(index, true);
    return this.poll();
};
// remove(myval) will remove an item matching the provided value from the
// queue, checked for equality by using the queue's comparator.
// return true if removed, false otherwise.
FastPriorityQueue.prototype.remove = function(myval) {
    for(var i = 0; i < this.size; i++)if (!this.compare(this.array[i], myval) && !this.compare(myval, this.array[i])) {
        // items match, comparator returns false both ways, remove item
        this._removeAt(i);
        return true;
    }
    return false;
};
// removeOne(callback) will execute the callback function for each item of the queue
// and will remove the first item for which the callback will return true.
// return the removed item, or undefined if nothing is removed.
FastPriorityQueue.prototype.removeOne = function(callback) {
    if (typeof callback !== "function") return undefined;
    for(var i = 0; i < this.size; i++){
        if (callback(this.array[i])) return this._removeAt(i);
    }
};
// remove(callback[, limit]) will execute the callback function for each item of
// the queue and will remove each item for which the callback returns true, up to
// a max limit of removed items if specified or no limit if unspecified.
// return an array containing the removed items.
// The callback function should be a pure function.
FastPriorityQueue.prototype.removeMany = function(callback, limit) {
    // Skip unnecessary processing for edge cases
    if (typeof callback !== "function" || this.size < 1) return [];
    limit = limit ? Math.min(limit, this.size) : this.size;
    // Prepare the results container to hold up to the results limit
    var resultSize = 0;
    var result = new Array(limit);
    // Prepare a temporary array to hold items we'll traverse through and need to keep
    var tmpSize = 0;
    var tmp = new Array(this.size);
    while(resultSize < limit && !this.isEmpty()){
        // Dequeue items into either the results or our temporary array
        var item = this.poll();
        if (callback(item)) result[resultSize++] = item;
        else tmp[tmpSize++] = item;
    }
    // Update the result array with the exact number of results
    result.length = resultSize;
    // Re-add all the items we can keep
    var i = 0;
    while(i < tmpSize)this.add(tmp[i++]);
    return result;
};
// Look at the top of the queue (one of the smallest elements) without removing it
// executes in constant time
//
// Calling peek on an empty priority queue returns
// the "undefined" value.
// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined
//
FastPriorityQueue.prototype.peek = function() {
    if (this.size == 0) return undefined;
    return this.array[0];
};
// remove the element on top of the heap (one of the smallest elements)
// runs in logarithmic time
//
// If the priority queue is empty, the function returns the
// "undefined" value.
// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined
//
// For long-running and large priority queues, or priority queues
// storing large objects, you may  want to call the trim function
// at strategic times to recover allocated memory.
FastPriorityQueue.prototype.poll = function() {
    if (this.size == 0) return undefined;
    var ans = this.array[0];
    if (this.size > 1) {
        this.array[0] = this.array[--this.size];
        this._percolateDown(0);
    } else this.size -= 1;
    return ans;
};
// This function adds the provided value to the heap, while removing
// and returning one of the smallest elements (like poll). The size of the queue
// thus remains unchanged.
FastPriorityQueue.prototype.replaceTop = function(myval) {
    if (this.size == 0) return undefined;
    var ans = this.array[0];
    this.array[0] = myval;
    this._percolateDown(0);
    return ans;
};
// recover unused memory (for long-running priority queues)
FastPriorityQueue.prototype.trim = function() {
    this.array = this.array.slice(0, this.size);
};
// Check whether the heap is empty
FastPriorityQueue.prototype.isEmpty = function() {
    return this.size === 0;
};
// iterate over the items in order, pass a callback that receives (item, index) as args.
// TODO once we transpile, uncomment
// if (Symbol && Symbol.iterator) {
//   FastPriorityQueue.prototype[Symbol.iterator] = function*() {
//     if (this.isEmpty()) return;
//     var fpq = this.clone();
//     while (!fpq.isEmpty()) {
//       yield fpq.poll();
//     }
//   };
// }
FastPriorityQueue.prototype.forEach = function(callback) {
    if (this.isEmpty() || typeof callback != 'function') return;
    var i = 0;
    var fpq = this.clone();
    while(!fpq.isEmpty())callback(fpq.poll(), i++);
};
// return the k 'smallest' elements of the queue as an array,
// runs in O(k log k) time, the elements are not removed
// from the priority queue.
FastPriorityQueue.prototype.kSmallest = function(k) {
    if (this.size == 0 || k <= 0) return [];
    k = Math.min(this.size, k);
    const newSize = Math.min(this.size, 2 ** (k - 1) + 1);
    if (newSize < 2) return [
        this.peek()
    ];
    const fpq = new FastPriorityQueue(this.compare);
    fpq.size = newSize;
    fpq.array = this.array.slice(0, newSize);
    const smallest = new Array(k);
    for(let i = 0; i < k; i++)smallest[i] = fpq.poll();
    return smallest;
};
module.exports = FastPriorityQueue;

},{}],"2N5f4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class SpatialIndex {
    query() {
        if (arguments.length === 1) {
            const searchEnv = arguments[0];
        } else if (arguments.length === 2) {
            const searchEnv = arguments[0], visitor = arguments[1];
        }
    }
    insert(itemEnv, item) {}
    remove(itemEnv, item) {}
}
exports.default = SpatialIndex;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1SBma":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _boundableJs = require("./Boundable.js");
var _boundableJsDefault = parcelHelpers.interopDefault(_boundableJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class AbstractNode {
    constructor(){
        AbstractNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._childBoundables = new (0, _arrayListJsDefault.default)();
        this._bounds = null;
        this._level = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const level = arguments[0];
            this._level = level;
        }
    }
    getLevel() {
        return this._level;
    }
    addChildBoundable(childBoundable) {
        (0, _assertJsDefault.default).isTrue(this._bounds === null);
        this._childBoundables.add(childBoundable);
    }
    isEmpty() {
        return this._childBoundables.isEmpty();
    }
    getBounds() {
        if (this._bounds === null) this._bounds = this.computeBounds();
        return this._bounds;
    }
    size() {
        return this._childBoundables.size();
    }
    getChildBoundables() {
        return this._childBoundables;
    }
    get interfaces_() {
        return [
            (0, _boundableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = AbstractNode;

},{"./Boundable.js":"78kNi","../../../../../java/util/ArrayList.js":"gGAQZ","../../../../../java/io/Serializable.js":"5sRbw","../../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bUhyu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _illegalArgumentExceptionJs = require("../../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _abstractNodeJs = require("./AbstractNode.js");
var _abstractNodeJsDefault = parcelHelpers.interopDefault(_abstractNodeJs);
var _envelopeDistanceJs = require("./EnvelopeDistance.js");
var _envelopeDistanceJsDefault = parcelHelpers.interopDefault(_envelopeDistanceJs);
var _comparableJs = require("../../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
class BoundablePair {
    constructor(){
        BoundablePair.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._boundable1 = null;
        this._boundable2 = null;
        this._distance = null;
        this._itemDistance = null;
        const boundable1 = arguments[0], boundable2 = arguments[1], itemDistance = arguments[2];
        this._boundable1 = boundable1;
        this._boundable2 = boundable2;
        this._itemDistance = itemDistance;
        this._distance = this.distance();
    }
    static area(b) {
        return b.getBounds().getArea();
    }
    static isComposite(item) {
        return item instanceof (0, _abstractNodeJsDefault.default);
    }
    maximumDistance() {
        return (0, _envelopeDistanceJsDefault.default).maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
    }
    expandToQueue(priQ, minDistance) {
        const isComp1 = BoundablePair.isComposite(this._boundable1);
        const isComp2 = BoundablePair.isComposite(this._boundable2);
        if (isComp1 && isComp2) {
            if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
                this.expand(this._boundable1, this._boundable2, false, priQ, minDistance);
                return null;
            } else {
                this.expand(this._boundable2, this._boundable1, true, priQ, minDistance);
                return null;
            }
        } else if (isComp1) {
            this.expand(this._boundable1, this._boundable2, false, priQ, minDistance);
            return null;
        } else if (isComp2) {
            this.expand(this._boundable2, this._boundable1, true, priQ, minDistance);
            return null;
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('neither boundable is composite');
    }
    isLeaves() {
        return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));
    }
    getBoundable(i) {
        if (i === 0) return this._boundable1;
        return this._boundable2;
    }
    getDistance() {
        return this._distance;
    }
    distance() {
        if (this.isLeaves()) return this._itemDistance.distance(this._boundable1, this._boundable2);
        return this._boundable1.getBounds().distance(this._boundable2.getBounds());
    }
    compareTo(o) {
        const nd = o;
        if (this._distance < nd._distance) return -1;
        if (this._distance > nd._distance) return 1;
        return 0;
    }
    expand(bndComposite, bndOther, isFlipped, priQ, minDistance) {
        const children = bndComposite.getChildBoundables();
        for(let i = children.iterator(); i.hasNext();){
            const child = i.next();
            let bp = null;
            if (isFlipped) bp = new BoundablePair(bndOther, child, this._itemDistance);
            else bp = new BoundablePair(child, bndOther, this._itemDistance);
            if (bp.getDistance() < minDistance) priQ.add(bp);
        }
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = BoundablePair;

},{"../../../../../java/lang/IllegalArgumentException.js":"9ppVW","./AbstractNode.js":"1SBma","./EnvelopeDistance.js":"aOul4","../../../../../java/lang/Comparable.js":"WFeEu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aOul4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class EnvelopeDistance {
    static distance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }
    static maximumDistance(env1, env2) {
        const minx = Math.min(env1.getMinX(), env2.getMinX());
        const miny = Math.min(env1.getMinY(), env2.getMinY());
        const maxx = Math.max(env1.getMaxX(), env2.getMaxX());
        const maxy = Math.max(env1.getMaxY(), env2.getMaxY());
        return EnvelopeDistance.distance(minx, miny, maxx, maxy);
    }
    static minMaxDistance(a, b) {
        const aminx = a.getMinX();
        const aminy = a.getMinY();
        const amaxx = a.getMaxX();
        const amaxy = a.getMaxY();
        const bminx = b.getMinX();
        const bminy = b.getMinY();
        const bmaxx = b.getMaxX();
        const bmaxy = b.getMaxY();
        let dist = EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bminx, bminy, bminx, bmaxy);
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bminx, bminy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bmaxx, bmaxy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bmaxx, bmaxy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bminx, bminy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bminx, bminy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bmaxx, bmaxy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bmaxx, bmaxy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bminx, bminy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bminx, bminy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bmaxx, bmaxy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bmaxx, bmaxy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bminx, bminy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bminx, bminy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bmaxx, bmaxy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bmaxx, bmaxy, bmaxx, bminy));
        return dist;
    }
    static maxDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
        let dist = EnvelopeDistance.distance(ax1, ay1, bx1, by1);
        dist = Math.max(dist, EnvelopeDistance.distance(ax1, ay1, bx2, by2));
        dist = Math.max(dist, EnvelopeDistance.distance(ax2, ay2, bx1, by1));
        dist = Math.max(dist, EnvelopeDistance.distance(ax2, ay2, bx2, by2));
        return dist;
    }
}
exports.default = EnvelopeDistance;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4MW3s":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itemBoundableJs = require("./ItemBoundable.js");
var _itemBoundableJsDefault = parcelHelpers.interopDefault(_itemBoundableJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _itemVisitorJs = require("../ItemVisitor.js");
var _itemVisitorJsDefault = parcelHelpers.interopDefault(_itemVisitorJs);
var _abstractNodeJs = require("./AbstractNode.js");
var _abstractNodeJsDefault = parcelHelpers.interopDefault(_abstractNodeJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _listJs = require("../../../../../java/util/List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
class AbstractSTRtree {
    constructor(){
        AbstractSTRtree.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._root = null;
        this._built = false;
        this._itemBoundables = new (0, _arrayListJsDefault.default)();
        this._nodeCapacity = null;
        if (arguments.length === 0) AbstractSTRtree.constructor_.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);
        else if (arguments.length === 1) {
            const nodeCapacity = arguments[0];
            (0, _assertJsDefault.default).isTrue(nodeCapacity > 1, 'Node capacity must be greater than 1');
            this._nodeCapacity = nodeCapacity;
        }
    }
    static compareDoubles(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
    }
    queryInternal() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[2], (0, _itemVisitorJsDefault.default)) && arguments[0] instanceof Object && arguments[1] instanceof (0, _abstractNodeJsDefault.default)) {
            const searchBounds = arguments[0], node = arguments[1], visitor = arguments[2];
            const childBoundables = node.getChildBoundables();
            for(let i = 0; i < childBoundables.size(); i++){
                const childBoundable = childBoundables.get(i);
                if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) continue;
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) this.queryInternal(searchBounds, childBoundable, visitor);
                else if (childBoundable instanceof (0, _itemBoundableJsDefault.default)) visitor.visitItem(childBoundable.getItem());
                else (0, _assertJsDefault.default).shouldNeverReachHere();
            }
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[2], (0, _listJsDefault.default)) && arguments[0] instanceof Object && arguments[1] instanceof (0, _abstractNodeJsDefault.default)) {
            const searchBounds = arguments[0], node = arguments[1], matches = arguments[2];
            const childBoundables = node.getChildBoundables();
            for(let i = 0; i < childBoundables.size(); i++){
                const childBoundable = childBoundables.get(i);
                if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) continue;
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) this.queryInternal(searchBounds, childBoundable, matches);
                else if (childBoundable instanceof (0, _itemBoundableJsDefault.default)) matches.add(childBoundable.getItem());
                else (0, _assertJsDefault.default).shouldNeverReachHere();
            }
        }
    }
    insert(bounds, item) {
        (0, _assertJsDefault.default).isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');
        this._itemBoundables.add(new (0, _itemBoundableJsDefault.default)(bounds, item));
    }
    boundablesAtLevel() {
        if (arguments.length === 1) {
            const level = arguments[0];
            const boundables = new (0, _arrayListJsDefault.default)();
            this.boundablesAtLevel(level, this._root, boundables);
            return boundables;
        } else if (arguments.length === 3) {
            const level = arguments[0], top = arguments[1], boundables = arguments[2];
            (0, _assertJsDefault.default).isTrue(level > -2);
            if (top.getLevel() === level) {
                boundables.add(top);
                return null;
            }
            for(let i = top.getChildBoundables().iterator(); i.hasNext();){
                const boundable = i.next();
                if (boundable instanceof (0, _abstractNodeJsDefault.default)) this.boundablesAtLevel(level, boundable, boundables);
                else {
                    (0, _assertJsDefault.default).isTrue(boundable instanceof (0, _itemBoundableJsDefault.default));
                    if (level === -1) boundables.add(boundable);
                }
            }
            return null;
        }
    }
    getRoot() {
        this.build();
        return this._root;
    }
    remove() {
        if (arguments.length === 2) {
            const searchBounds = arguments[0], item = arguments[1];
            this.build();
            if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) return this.remove(searchBounds, this._root, item);
            return false;
        } else if (arguments.length === 3) {
            const searchBounds = arguments[0], node = arguments[1], item = arguments[2];
            let found = this.removeItem(node, item);
            if (found) return true;
            let childToPrune = null;
            for(let i = node.getChildBoundables().iterator(); i.hasNext();){
                const childBoundable = i.next();
                if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) continue;
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) {
                    found = this.remove(searchBounds, childBoundable, item);
                    if (found) {
                        childToPrune = childBoundable;
                        break;
                    }
                }
            }
            if (childToPrune !== null) {
                if (childToPrune.getChildBoundables().isEmpty()) node.getChildBoundables().remove(childToPrune);
            }
            return found;
        }
    }
    createHigherLevels(boundablesOfALevel, level) {
        (0, _assertJsDefault.default).isTrue(!boundablesOfALevel.isEmpty());
        const parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
        if (parentBoundables.size() === 1) return parentBoundables.get(0);
        return this.createHigherLevels(parentBoundables, level + 1);
    }
    depth() {
        if (arguments.length === 0) {
            if (this.isEmpty()) return 0;
            this.build();
            return this.depth(this._root);
        } else if (arguments.length === 1) {
            const node = arguments[0];
            let maxChildDepth = 0;
            for(let i = node.getChildBoundables().iterator(); i.hasNext();){
                const childBoundable = i.next();
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) {
                    const childDepth = this.depth(childBoundable);
                    if (childDepth > maxChildDepth) maxChildDepth = childDepth;
                }
            }
            return maxChildDepth + 1;
        }
    }
    createParentBoundables(childBoundables, newLevel) {
        (0, _assertJsDefault.default).isTrue(!childBoundables.isEmpty());
        const parentBoundables = new (0, _arrayListJsDefault.default)();
        parentBoundables.add(this.createNode(newLevel));
        const sortedChildBoundables = new (0, _arrayListJsDefault.default)(childBoundables);
        (0, _collectionsJsDefault.default).sort(sortedChildBoundables, this.getComparator());
        for(let i = sortedChildBoundables.iterator(); i.hasNext();){
            const childBoundable = i.next();
            if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) parentBoundables.add(this.createNode(newLevel));
            this.lastNode(parentBoundables).addChildBoundable(childBoundable);
        }
        return parentBoundables;
    }
    isEmpty() {
        if (!this._built) return this._itemBoundables.isEmpty();
        return this._root.isEmpty();
    }
    getNodeCapacity() {
        return this._nodeCapacity;
    }
    lastNode(nodes) {
        return nodes.get(nodes.size() - 1);
    }
    size() {
        if (arguments.length === 0) {
            if (this.isEmpty()) return 0;
            this.build();
            return this.size(this._root);
        } else if (arguments.length === 1) {
            const node = arguments[0];
            let size = 0;
            for(let i = node.getChildBoundables().iterator(); i.hasNext();){
                const childBoundable = i.next();
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) size += this.size(childBoundable);
                else if (childBoundable instanceof (0, _itemBoundableJsDefault.default)) size += 1;
            }
            return size;
        }
    }
    removeItem(node, item) {
        let childToRemove = null;
        for(let i = node.getChildBoundables().iterator(); i.hasNext();){
            const childBoundable = i.next();
            if (childBoundable instanceof (0, _itemBoundableJsDefault.default)) {
                if (childBoundable.getItem() === item) childToRemove = childBoundable;
            }
        }
        if (childToRemove !== null) {
            node.getChildBoundables().remove(childToRemove);
            return true;
        }
        return false;
    }
    itemsTree() {
        if (arguments.length === 0) {
            this.build();
            const valuesTree = this.itemsTree(this._root);
            if (valuesTree === null) return new (0, _arrayListJsDefault.default)();
            return valuesTree;
        } else if (arguments.length === 1) {
            const node = arguments[0];
            const valuesTreeForNode = new (0, _arrayListJsDefault.default)();
            for(let i = node.getChildBoundables().iterator(); i.hasNext();){
                const childBoundable = i.next();
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) {
                    const valuesTreeForChild = this.itemsTree(childBoundable);
                    if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);
                } else if (childBoundable instanceof (0, _itemBoundableJsDefault.default)) valuesTreeForNode.add(childBoundable.getItem());
                else (0, _assertJsDefault.default).shouldNeverReachHere();
            }
            if (valuesTreeForNode.size() <= 0) return null;
            return valuesTreeForNode;
        }
    }
    query() {
        if (arguments.length === 1) {
            const searchBounds = arguments[0];
            this.build();
            const matches = new (0, _arrayListJsDefault.default)();
            if (this.isEmpty()) return matches;
            if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) this.queryInternal(searchBounds, this._root, matches);
            return matches;
        } else if (arguments.length === 2) {
            const searchBounds = arguments[0], visitor = arguments[1];
            this.build();
            if (this.isEmpty()) return null;
            if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) this.queryInternal(searchBounds, this._root, visitor);
        }
    }
    build() {
        if (this._built) return null;
        this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
        this._itemBoundables = null;
        this._built = true;
    }
    get interfaces_() {
        return [
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = AbstractSTRtree;
function IntersectsOp() {}
AbstractSTRtree.IntersectsOp = IntersectsOp;
AbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;

},{"./ItemBoundable.js":"eO4jy","../../../../../hasInterface.js":"5bpze","../ItemVisitor.js":"nuRea","./AbstractNode.js":"1SBma","../../../../../java/util/Collections.js":"c5dcW","../../../../../java/util/ArrayList.js":"gGAQZ","../../../../../java/io/Serializable.js":"5sRbw","../../util/Assert.js":"1vSRy","../../../../../java/util/List.js":"7jAhK","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d4XWg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class ItemDistance {
    distance(item1, item2) {}
}
exports.default = ItemDistance;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"25ZO4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
class MonotoneChainOverlapAction {
    constructor(){
        MonotoneChainOverlapAction.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._overlapSeg1 = new (0, _lineSegmentJsDefault.default)();
        this._overlapSeg2 = new (0, _lineSegmentJsDefault.default)();
    }
    overlap() {
        if (arguments.length === 2) {
            const seg1 = arguments[0], seg2 = arguments[1];
        } else if (arguments.length === 4) {
            const mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3];
            mc1.getLineSegment(start1, this._overlapSeg1);
            mc2.getLineSegment(start2, this._overlapSeg2);
            this.overlap(this._overlapSeg1, this._overlapSeg2);
        }
    }
}
exports.default = MonotoneChainOverlapAction;

},{"../../geom/LineSegment.js":"8Ncbv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"doUZZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _monotoneChainJs = require("./MonotoneChain.js");
var _monotoneChainJsDefault = parcelHelpers.interopDefault(_monotoneChainJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _quadrantJs = require("../../geomgraph/Quadrant.js");
var _quadrantJsDefault = parcelHelpers.interopDefault(_quadrantJs);
class MonotoneChainBuilder {
    static findChainEnd(pts, start) {
        let safeStart = start;
        while(safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1]))safeStart++;
        if (safeStart >= pts.length - 1) return pts.length - 1;
        const chainQuad = (0, _quadrantJsDefault.default).quadrant(pts[safeStart], pts[safeStart + 1]);
        let last = start + 1;
        while(last < pts.length){
            if (!pts[last - 1].equals2D(pts[last])) {
                const quad = (0, _quadrantJsDefault.default).quadrant(pts[last - 1], pts[last]);
                if (quad !== chainQuad) break;
            }
            last++;
        }
        return last - 1;
    }
    static getChains() {
        if (arguments.length === 1) {
            const pts = arguments[0];
            return MonotoneChainBuilder.getChains(pts, null);
        } else if (arguments.length === 2) {
            const pts = arguments[0], context = arguments[1];
            const mcList = new (0, _arrayListJsDefault.default)();
            let chainStart = 0;
            do {
                const chainEnd = MonotoneChainBuilder.findChainEnd(pts, chainStart);
                const mc = new (0, _monotoneChainJsDefault.default)(pts, chainStart, chainEnd, context);
                mcList.add(mc);
                chainStart = chainEnd;
            }while (chainStart < pts.length - 1);
            return mcList;
        }
    }
}
exports.default = MonotoneChainBuilder;

},{"./MonotoneChain.js":"5SbYX","../../../../../java/util/ArrayList.js":"gGAQZ","../../geomgraph/Quadrant.js":"86Qmh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5SbYX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _envelopeJs = require("../../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class MonotoneChain {
    constructor(){
        MonotoneChain.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._pts = null;
        this._start = null;
        this._end = null;
        this._env = null;
        this._context = null;
        this._id = null;
        const pts = arguments[0], start = arguments[1], end = arguments[2], context = arguments[3];
        this._pts = pts;
        this._start = start;
        this._end = end;
        this._context = context;
    }
    computeOverlaps() {
        if (arguments.length === 2) {
            const mc = arguments[0], mco = arguments[1];
            this.computeOverlaps(this._start, this._end, mc, mc._start, mc._end, mco);
        } else if (arguments.length === 6) {
            const start0 = arguments[0], end0 = arguments[1], mc = arguments[2], start1 = arguments[3], end1 = arguments[4], mco = arguments[5];
            if (end0 - start0 === 1 && end1 - start1 === 1) {
                mco.overlap(this, start0, mc, start1);
                return null;
            }
            if (!this.overlaps(start0, end0, mc, start1, end1)) return null;
            const mid0 = Math.trunc((start0 + end0) / 2);
            const mid1 = Math.trunc((start1 + end1) / 2);
            if (start0 < mid0) {
                if (start1 < mid1) this.computeOverlaps(start0, mid0, mc, start1, mid1, mco);
                if (mid1 < end1) this.computeOverlaps(start0, mid0, mc, mid1, end1, mco);
            }
            if (mid0 < end0) {
                if (start1 < mid1) this.computeOverlaps(mid0, end0, mc, start1, mid1, mco);
                if (mid1 < end1) this.computeOverlaps(mid0, end0, mc, mid1, end1, mco);
            }
        }
    }
    setId(id) {
        this._id = id;
    }
    select(searchEnv, mcs) {
        this.computeSelect(searchEnv, this._start, this._end, mcs);
    }
    getEnvelope() {
        if (this._env === null) {
            const p0 = this._pts[this._start];
            const p1 = this._pts[this._end];
            this._env = new (0, _envelopeJsDefault.default)(p0, p1);
        }
        return this._env;
    }
    overlaps(start0, end0, mc, start1, end1) {
        return (0, _envelopeJsDefault.default).intersects(this._pts[start0], this._pts[end0], mc._pts[start1], mc._pts[end1]);
    }
    getEndIndex() {
        return this._end;
    }
    getStartIndex() {
        return this._start;
    }
    getContext() {
        return this._context;
    }
    getId() {
        return this._id;
    }
    getLineSegment(index, ls) {
        ls.p0 = this._pts[index];
        ls.p1 = this._pts[index + 1];
    }
    computeSelect(searchEnv, start0, end0, mcs) {
        const p0 = this._pts[start0];
        const p1 = this._pts[end0];
        if (end0 - start0 === 1) {
            mcs.select(this, start0);
            return null;
        }
        if (!searchEnv.intersects(p0, p1)) return null;
        const mid = Math.trunc((start0 + end0) / 2);
        if (start0 < mid) this.computeSelect(searchEnv, start0, mid, mcs);
        if (mid < end0) this.computeSelect(searchEnv, mid, end0, mcs);
    }
    getCoordinates() {
        const coord = new Array(this._end - this._start + 1).fill(null);
        let index = 0;
        for(let i = this._start; i <= this._end; i++)coord[index++] = this._pts[i];
        return coord;
    }
}
exports.default = MonotoneChain;

},{"../../geom/Envelope.js":"h2zeM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h7eIw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noderJs = require("./Noder.js");
var _noderJsDefault = parcelHelpers.interopDefault(_noderJs);
class SinglePassNoder {
    constructor(){
        SinglePassNoder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._segInt = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const segInt = arguments[0];
            this.setSegmentIntersector(segInt);
        }
    }
    setSegmentIntersector(segInt) {
        this._segInt = segInt;
    }
    get interfaces_() {
        return [
            (0, _noderJsDefault.default)
        ];
    }
}
exports.default = SinglePassNoder;

},{"./Noder.js":"jKC91","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g53tv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _envelopeJs = require("../../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class HotPixel {
    constructor(){
        HotPixel.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = null;
        this._pt = null;
        this._originalPt = null;
        this._ptScaled = null;
        this._p0Scaled = null;
        this._p1Scaled = null;
        this._scaleFactor = null;
        this._minx = null;
        this._maxx = null;
        this._miny = null;
        this._maxy = null;
        this._corner = new Array(4).fill(null);
        this._safeEnv = null;
        const pt = arguments[0], scaleFactor = arguments[1], li = arguments[2];
        this._originalPt = pt;
        this._pt = pt;
        this._scaleFactor = scaleFactor;
        this._li = li;
        if (scaleFactor <= 0) throw new (0, _illegalArgumentExceptionJsDefault.default)('Scale factor must be non-zero');
        if (scaleFactor !== 1.0) {
            this._pt = new (0, _coordinateJsDefault.default)(this.scale(pt.x), this.scale(pt.y));
            this._p0Scaled = new (0, _coordinateJsDefault.default)();
            this._p1Scaled = new (0, _coordinateJsDefault.default)();
        }
        this.initCorners(this._pt);
    }
    intersectsScaled(p0, p1) {
        const segMinx = Math.min(p0.x, p1.x);
        const segMaxx = Math.max(p0.x, p1.x);
        const segMiny = Math.min(p0.y, p1.y);
        const segMaxy = Math.max(p0.y, p1.y);
        const isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
        if (isOutsidePixelEnv) return false;
        const intersects = this.intersectsToleranceSquare(p0, p1);
        (0, _assertJsDefault.default).isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');
        return intersects;
    }
    copyScaled(p, pScaled) {
        pScaled.x = this.scale(p.x);
        pScaled.y = this.scale(p.y);
    }
    getSafeEnvelope() {
        if (this._safeEnv === null) {
            const safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new (0, _envelopeJsDefault.default)(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
        }
        return this._safeEnv;
    }
    intersectsPixelClosure(p0, p1) {
        this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
        if (this._li.hasIntersection()) return true;
        this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
        if (this._li.hasIntersection()) return true;
        this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
        if (this._li.hasIntersection()) return true;
        this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
        if (this._li.hasIntersection()) return true;
        return false;
    }
    intersectsToleranceSquare(p0, p1) {
        let intersectsLeft = false;
        let intersectsBottom = false;
        this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
        if (this._li.isProper()) return true;
        this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
        if (this._li.isProper()) return true;
        if (this._li.hasIntersection()) intersectsLeft = true;
        this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
        if (this._li.isProper()) return true;
        if (this._li.hasIntersection()) intersectsBottom = true;
        this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
        if (this._li.isProper()) return true;
        if (intersectsLeft && intersectsBottom) return true;
        if (p0.equals(this._pt)) return true;
        if (p1.equals(this._pt)) return true;
        return false;
    }
    addSnappedNode(segStr, segIndex) {
        const p0 = segStr.getCoordinate(segIndex);
        const p1 = segStr.getCoordinate(segIndex + 1);
        if (this.intersects(p0, p1)) {
            segStr.addIntersection(this.getCoordinate(), segIndex);
            return true;
        }
        return false;
    }
    initCorners(pt) {
        const tolerance = 0.5;
        this._minx = pt.x - tolerance;
        this._maxx = pt.x + tolerance;
        this._miny = pt.y - tolerance;
        this._maxy = pt.y + tolerance;
        this._corner[0] = new (0, _coordinateJsDefault.default)(this._maxx, this._maxy);
        this._corner[1] = new (0, _coordinateJsDefault.default)(this._minx, this._maxy);
        this._corner[2] = new (0, _coordinateJsDefault.default)(this._minx, this._miny);
        this._corner[3] = new (0, _coordinateJsDefault.default)(this._maxx, this._miny);
    }
    intersects(p0, p1) {
        if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);
        this.copyScaled(p0, this._p0Scaled);
        this.copyScaled(p1, this._p1Scaled);
        return this.intersectsScaled(this._p0Scaled, this._p1Scaled);
    }
    scale(val) {
        return Math.round(val * this._scaleFactor);
    }
    getCoordinate() {
        return this._originalPt;
    }
}
exports.default = HotPixel;
HotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;

},{"../../geom/Coordinate.js":"ii2fh","../../../../../java/lang/IllegalArgumentException.js":"9ppVW","../../geom/Envelope.js":"h2zeM","../../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lR2tW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _monotoneChainSelectActionJs = require("../../index/chain/MonotoneChainSelectAction.js");
var _monotoneChainSelectActionJsDefault = parcelHelpers.interopDefault(_monotoneChainSelectActionJs);
var _monotoneChainJs = require("../../index/chain/MonotoneChain.js");
var _monotoneChainJsDefault = parcelHelpers.interopDefault(_monotoneChainJs);
var _itemVisitorJs = require("../../index/ItemVisitor.js");
var _itemVisitorJsDefault = parcelHelpers.interopDefault(_itemVisitorJs);
class MCIndexPointSnapper {
    constructor(){
        MCIndexPointSnapper.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._index = null;
        const index = arguments[0];
        this._index = index;
    }
    snap() {
        if (arguments.length === 1) {
            const hotPixel = arguments[0];
            return this.snap(hotPixel, null, -1);
        } else if (arguments.length === 3) {
            const hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2];
            const pixelEnv = hotPixel.getSafeEnvelope();
            const hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);
            this._index.query(pixelEnv, new class {
                get interfaces_() {
                    return [
                        (0, _itemVisitorJsDefault.default)
                    ];
                }
                visitItem(item) {
                    const testChain = item;
                    testChain.select(pixelEnv, hotPixelSnapAction);
                }
            }());
            return hotPixelSnapAction.isNodeAdded();
        }
    }
}
exports.default = MCIndexPointSnapper;
class HotPixelSnapAction extends (0, _monotoneChainSelectActionJsDefault.default) {
    constructor(){
        super();
        HotPixelSnapAction.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._hotPixel = null;
        this._parentEdge = null;
        this._hotPixelVertexIndex = null;
        this._isNodeAdded = false;
        const hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2];
        this._hotPixel = hotPixel;
        this._parentEdge = parentEdge;
        this._hotPixelVertexIndex = hotPixelVertexIndex;
    }
    select() {
        if (arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof (0, _monotoneChainJsDefault.default)) {
            const mc = arguments[0], startIndex = arguments[1];
            const ss = mc.getContext();
            if (this._parentEdge === ss) {
                if (startIndex === this._hotPixelVertexIndex || startIndex + 1 === this._hotPixelVertexIndex) return null;
            }
            this._isNodeAdded |= this._hotPixel.addSnappedNode(ss, startIndex);
        } else return super.select.apply(this, arguments);
    }
    isNodeAdded() {
        return this._isNodeAdded;
    }
}
MCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;

},{"../../index/chain/MonotoneChainSelectAction.js":"il549","../../index/chain/MonotoneChain.js":"5SbYX","../../index/ItemVisitor.js":"nuRea","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"il549":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
class MonotoneChainSelectAction {
    constructor(){
        MonotoneChainSelectAction.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.selectedSegment = new (0, _lineSegmentJsDefault.default)();
    }
    select() {
        if (arguments.length === 1) {
            const seg = arguments[0];
        } else if (arguments.length === 2) {
            const mc = arguments[0], startIndex = arguments[1];
            mc.getLineSegment(startIndex, this.selectedSegment);
            this.select(this.selectedSegment);
        }
    }
}
exports.default = MonotoneChainSelectAction;

},{"../../geom/LineSegment.js":"8Ncbv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"esmGM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _segmentIntersectorJs = require("./SegmentIntersector.js");
var _segmentIntersectorJsDefault = parcelHelpers.interopDefault(_segmentIntersectorJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class InteriorIntersectionFinderAdder {
    constructor(){
        InteriorIntersectionFinderAdder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = null;
        this._interiorIntersections = null;
        const li = arguments[0];
        this._li = li;
        this._interiorIntersections = new (0, _arrayListJsDefault.default)();
    }
    isDone() {
        return false;
    }
    processIntersections(e0, segIndex0, e1, segIndex1) {
        if (e0 === e1 && segIndex0 === segIndex1) return null;
        const p00 = e0.getCoordinates()[segIndex0];
        const p01 = e0.getCoordinates()[segIndex0 + 1];
        const p10 = e1.getCoordinates()[segIndex1];
        const p11 = e1.getCoordinates()[segIndex1 + 1];
        this._li.computeIntersection(p00, p01, p10, p11);
        if (this._li.hasIntersection()) {
            if (this._li.isInteriorIntersection()) {
                for(let intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++)this._interiorIntersections.add(this._li.getIntersection(intIndex));
                e0.addIntersections(this._li, segIndex0, 0);
                e1.addIntersections(this._li, segIndex1, 1);
            }
        }
    }
    getInteriorIntersections() {
        return this._interiorIntersections;
    }
    get interfaces_() {
        return [
            (0, _segmentIntersectorJsDefault.default)
        ];
    }
}
exports.default = InteriorIntersectionFinderAdder;

},{"./SegmentIntersector.js":"jNast","../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jNast":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class SegmentIntersector {
    isDone() {}
    processIntersections(e0, segIndex0, e1, segIndex1) {}
}
exports.default = SegmentIntersector;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a6cSc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _bufferSubgraphJs = require("./BufferSubgraph.js");
var _bufferSubgraphJsDefault = parcelHelpers.interopDefault(_bufferSubgraphJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _mcindexNoderJs = require("../../noding/MCIndexNoder.js");
var _mcindexNoderJsDefault = parcelHelpers.interopDefault(_mcindexNoderJs);
var _offsetCurveBuilderJs = require("./OffsetCurveBuilder.js");
var _offsetCurveBuilderJsDefault = parcelHelpers.interopDefault(_offsetCurveBuilderJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
var _labelJs = require("../../geomgraph/Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _planarGraphJs = require("../../geomgraph/PlanarGraph.js");
var _planarGraphJsDefault = parcelHelpers.interopDefault(_planarGraphJs);
var _polygonBuilderJs = require("../overlay/PolygonBuilder.js");
var _polygonBuilderJsDefault = parcelHelpers.interopDefault(_polygonBuilderJs);
var _geometryFactoryJs = require("../../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _subgraphDepthLocaterJs = require("./SubgraphDepthLocater.js");
var _subgraphDepthLocaterJsDefault = parcelHelpers.interopDefault(_subgraphDepthLocaterJs);
var _offsetCurveSetBuilderJs = require("./OffsetCurveSetBuilder.js");
var _offsetCurveSetBuilderJsDefault = parcelHelpers.interopDefault(_offsetCurveSetBuilderJs);
var _overlayNodeFactoryJs = require("../overlay/OverlayNodeFactory.js");
var _overlayNodeFactoryJsDefault = parcelHelpers.interopDefault(_overlayNodeFactoryJs);
var _edgeListJs = require("../../geomgraph/EdgeList.js");
var _edgeListJsDefault = parcelHelpers.interopDefault(_edgeListJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _robustLineIntersectorJs = require("../../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _intersectionAdderJs = require("../../noding/IntersectionAdder.js");
var _intersectionAdderJsDefault = parcelHelpers.interopDefault(_intersectionAdderJs);
var _edgeJs = require("../../geomgraph/Edge.js");
var _edgeJsDefault = parcelHelpers.interopDefault(_edgeJs);
class BufferBuilder {
    constructor(){
        BufferBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._bufParams = null;
        this._workingPrecisionModel = null;
        this._workingNoder = null;
        this._geomFact = null;
        this._graph = null;
        this._edgeList = new (0, _edgeListJsDefault.default)();
        const bufParams = arguments[0];
        this._bufParams = bufParams;
    }
    static convertSegStrings(it) {
        const fact = new (0, _geometryFactoryJsDefault.default)();
        const lines = new (0, _arrayListJsDefault.default)();
        while(it.hasNext()){
            const ss = it.next();
            const line = fact.createLineString(ss.getCoordinates());
            lines.add(line);
        }
        return fact.buildGeometry(lines);
    }
    static depthDelta(label) {
        const lLoc = label.getLocation(0, (0, _positionJsDefault.default).LEFT);
        const rLoc = label.getLocation(0, (0, _positionJsDefault.default).RIGHT);
        if (lLoc === (0, _locationJsDefault.default).INTERIOR && rLoc === (0, _locationJsDefault.default).EXTERIOR) return 1;
        else if (lLoc === (0, _locationJsDefault.default).EXTERIOR && rLoc === (0, _locationJsDefault.default).INTERIOR) return -1;
        return 0;
    }
    createEmptyResultGeometry() {
        const emptyGeom = this._geomFact.createPolygon();
        return emptyGeom;
    }
    getNoder(precisionModel) {
        if (this._workingNoder !== null) return this._workingNoder;
        const noder = new (0, _mcindexNoderJsDefault.default)();
        const li = new (0, _robustLineIntersectorJsDefault.default)();
        li.setPrecisionModel(precisionModel);
        noder.setSegmentIntersector(new (0, _intersectionAdderJsDefault.default)(li));
        return noder;
    }
    buffer(g, distance) {
        let precisionModel = this._workingPrecisionModel;
        if (precisionModel === null) precisionModel = g.getPrecisionModel();
        this._geomFact = g.getFactory();
        const curveBuilder = new (0, _offsetCurveBuilderJsDefault.default)(precisionModel, this._bufParams);
        const curveSetBuilder = new (0, _offsetCurveSetBuilderJsDefault.default)(g, distance, curveBuilder);
        const bufferSegStrList = curveSetBuilder.getCurves();
        if (bufferSegStrList.size() <= 0) return this.createEmptyResultGeometry();
        this.computeNodedEdges(bufferSegStrList, precisionModel);
        this._graph = new (0, _planarGraphJsDefault.default)(new (0, _overlayNodeFactoryJsDefault.default)());
        this._graph.addEdges(this._edgeList.getEdges());
        const subgraphList = this.createSubgraphs(this._graph);
        const polyBuilder = new (0, _polygonBuilderJsDefault.default)(this._geomFact);
        this.buildSubgraphs(subgraphList, polyBuilder);
        const resultPolyList = polyBuilder.getPolygons();
        if (resultPolyList.size() <= 0) return this.createEmptyResultGeometry();
        const resultGeom = this._geomFact.buildGeometry(resultPolyList);
        return resultGeom;
    }
    computeNodedEdges(bufferSegStrList, precisionModel) {
        const noder = this.getNoder(precisionModel);
        noder.computeNodes(bufferSegStrList);
        const nodedSegStrings = noder.getNodedSubstrings();
        for(let i = nodedSegStrings.iterator(); i.hasNext();){
            const segStr = i.next();
            const pts = segStr.getCoordinates();
            if (pts.length === 2 && pts[0].equals2D(pts[1])) continue;
            const oldLabel = segStr.getData();
            const edge = new (0, _edgeJsDefault.default)(segStr.getCoordinates(), new (0, _labelJsDefault.default)(oldLabel));
            this.insertUniqueEdge(edge);
        }
    }
    setNoder(noder) {
        this._workingNoder = noder;
    }
    setWorkingPrecisionModel(pm) {
        this._workingPrecisionModel = pm;
    }
    insertUniqueEdge(e) {
        const existingEdge = this._edgeList.findEqualEdge(e);
        if (existingEdge !== null) {
            const existingLabel = existingEdge.getLabel();
            let labelToMerge = e.getLabel();
            if (!existingEdge.isPointwiseEqual(e)) {
                labelToMerge = new (0, _labelJsDefault.default)(e.getLabel());
                labelToMerge.flip();
            }
            existingLabel.merge(labelToMerge);
            const mergeDelta = BufferBuilder.depthDelta(labelToMerge);
            const existingDelta = existingEdge.getDepthDelta();
            const newDelta = existingDelta + mergeDelta;
            existingEdge.setDepthDelta(newDelta);
        } else {
            this._edgeList.add(e);
            e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
        }
    }
    buildSubgraphs(subgraphList, polyBuilder) {
        const processedGraphs = new (0, _arrayListJsDefault.default)();
        for(let i = subgraphList.iterator(); i.hasNext();){
            const subgraph = i.next();
            const p = subgraph.getRightmostCoordinate();
            const locater = new (0, _subgraphDepthLocaterJsDefault.default)(processedGraphs);
            const outsideDepth = locater.getDepth(p);
            subgraph.computeDepth(outsideDepth);
            subgraph.findResultEdges();
            processedGraphs.add(subgraph);
            polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
        }
    }
    createSubgraphs(graph) {
        const subgraphList = new (0, _arrayListJsDefault.default)();
        for(let i = graph.getNodes().iterator(); i.hasNext();){
            const node = i.next();
            if (!node.isVisited()) {
                const subgraph = new (0, _bufferSubgraphJsDefault.default)();
                subgraph.create(node);
                subgraphList.add(subgraph);
            }
        }
        (0, _collectionsJsDefault.default).sort(subgraphList, (0, _collectionsJsDefault.default).reverseOrder());
        return subgraphList;
    }
}
exports.default = BufferBuilder;

},{"../../geom/Location.js":"9aPCX","./BufferSubgraph.js":"8yllK","../../geomgraph/Position.js":"13raO","../../noding/MCIndexNoder.js":"1deq0","./OffsetCurveBuilder.js":"aBCRI","../../../../../java/util/Collections.js":"c5dcW","../../geomgraph/Label.js":"dJJOo","../../geomgraph/PlanarGraph.js":"etG4v","../overlay/PolygonBuilder.js":"crM1Q","../../geom/GeometryFactory.js":"cGt0T","./SubgraphDepthLocater.js":"9iVKl","./OffsetCurveSetBuilder.js":"elu3d","../overlay/OverlayNodeFactory.js":"2jxBb","../../geomgraph/EdgeList.js":"cqdlm","../../../../../java/util/ArrayList.js":"gGAQZ","../../algorithm/RobustLineIntersector.js":"kLdG9","../../noding/IntersectionAdder.js":"dL4Dk","../../geomgraph/Edge.js":"gQhhu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8yllK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashSetJs = require("../../../../../java/util/HashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _stackJs = require("../../../../../java/util/Stack.js");
var _stackJsDefault = parcelHelpers.interopDefault(_stackJs);
var _rightmostEdgeFinderJs = require("./RightmostEdgeFinder.js");
var _rightmostEdgeFinderJsDefault = parcelHelpers.interopDefault(_rightmostEdgeFinderJs);
var _topologyExceptionJs = require("../../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _linkedListJs = require("../../../../../java/util/LinkedList.js");
var _linkedListJsDefault = parcelHelpers.interopDefault(_linkedListJs);
var _comparableJs = require("../../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _envelopeJs = require("../../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class BufferSubgraph {
    constructor(){
        BufferSubgraph.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._finder = null;
        this._dirEdgeList = new (0, _arrayListJsDefault.default)();
        this._nodes = new (0, _arrayListJsDefault.default)();
        this._rightMostCoord = null;
        this._env = null;
        this._finder = new (0, _rightmostEdgeFinderJsDefault.default)();
    }
    clearVisitedEdges() {
        for(let it = this._dirEdgeList.iterator(); it.hasNext();){
            const de = it.next();
            de.setVisited(false);
        }
    }
    compareTo(o) {
        const graph = o;
        if (this._rightMostCoord.x < graph._rightMostCoord.x) return -1;
        if (this._rightMostCoord.x > graph._rightMostCoord.x) return 1;
        return 0;
    }
    getEnvelope() {
        if (this._env === null) {
            const edgeEnv = new (0, _envelopeJsDefault.default)();
            for(let it = this._dirEdgeList.iterator(); it.hasNext();){
                const dirEdge = it.next();
                const pts = dirEdge.getEdge().getCoordinates();
                for(let i = 0; i < pts.length - 1; i++)edgeEnv.expandToInclude(pts[i]);
            }
            this._env = edgeEnv;
        }
        return this._env;
    }
    addReachable(startNode) {
        const nodeStack = new (0, _stackJsDefault.default)();
        nodeStack.add(startNode);
        while(!nodeStack.empty()){
            const node = nodeStack.pop();
            this.add(node, nodeStack);
        }
    }
    copySymDepths(de) {
        const sym = de.getSym();
        sym.setDepth((0, _positionJsDefault.default).LEFT, de.getDepth((0, _positionJsDefault.default).RIGHT));
        sym.setDepth((0, _positionJsDefault.default).RIGHT, de.getDepth((0, _positionJsDefault.default).LEFT));
    }
    add(node, nodeStack) {
        node.setVisited(true);
        this._nodes.add(node);
        for(let i = node.getEdges().iterator(); i.hasNext();){
            const de = i.next();
            this._dirEdgeList.add(de);
            const sym = de.getSym();
            const symNode = sym.getNode();
            if (!symNode.isVisited()) nodeStack.push(symNode);
        }
    }
    getRightmostCoordinate() {
        return this._rightMostCoord;
    }
    computeNodeDepth(n) {
        let startEdge = null;
        for(let i = n.getEdges().iterator(); i.hasNext();){
            const de = i.next();
            if (de.isVisited() || de.getSym().isVisited()) {
                startEdge = de;
                break;
            }
        }
        if (startEdge === null) throw new (0, _topologyExceptionJsDefault.default)('unable to find edge to compute depths at ' + n.getCoordinate());
        n.getEdges().computeDepths(startEdge);
        for(let i = n.getEdges().iterator(); i.hasNext();){
            const de = i.next();
            de.setVisited(true);
            this.copySymDepths(de);
        }
    }
    computeDepth(outsideDepth) {
        this.clearVisitedEdges();
        const de = this._finder.getEdge();
        const n = de.getNode();
        const label = de.getLabel();
        de.setEdgeDepths((0, _positionJsDefault.default).RIGHT, outsideDepth);
        this.copySymDepths(de);
        this.computeDepths(de);
    }
    create(node) {
        this.addReachable(node);
        this._finder.findEdge(this._dirEdgeList);
        this._rightMostCoord = this._finder.getCoordinate();
    }
    findResultEdges() {
        for(let it = this._dirEdgeList.iterator(); it.hasNext();){
            const de = it.next();
            if (de.getDepth((0, _positionJsDefault.default).RIGHT) >= 1 && de.getDepth((0, _positionJsDefault.default).LEFT) <= 0 && !de.isInteriorAreaEdge()) de.setInResult(true);
        }
    }
    computeDepths(startEdge) {
        const nodesVisited = new (0, _hashSetJsDefault.default)();
        const nodeQueue = new (0, _linkedListJsDefault.default)();
        const startNode = startEdge.getNode();
        nodeQueue.addLast(startNode);
        nodesVisited.add(startNode);
        startEdge.setVisited(true);
        while(!nodeQueue.isEmpty()){
            const n = nodeQueue.removeFirst();
            nodesVisited.add(n);
            this.computeNodeDepth(n);
            for(let i = n.getEdges().iterator(); i.hasNext();){
                const de = i.next();
                const sym = de.getSym();
                if (sym.isVisited()) continue;
                const adjNode = sym.getNode();
                if (!nodesVisited.contains(adjNode)) {
                    nodeQueue.addLast(adjNode);
                    nodesVisited.add(adjNode);
                }
            }
        }
    }
    getNodes() {
        return this._nodes;
    }
    getDirectedEdges() {
        return this._dirEdgeList;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = BufferSubgraph;

},{"../../../../../java/util/HashSet.js":"a1U62","../../geomgraph/Position.js":"13raO","../../../../../java/util/Stack.js":"7AeBO","./RightmostEdgeFinder.js":"1uf1p","../../geom/TopologyException.js":"bOVA5","../../../../../java/util/LinkedList.js":"iokEz","../../../../../java/lang/Comparable.js":"WFeEu","../../../../../java/util/ArrayList.js":"gGAQZ","../../geom/Envelope.js":"h2zeM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7AeBO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _emptyStackExceptionJs = require("./EmptyStackException.js");
var _emptyStackExceptionJsDefault = parcelHelpers.interopDefault(_emptyStackExceptionJs);
var _indexOutOfBoundsExceptionJs = require("../lang/IndexOutOfBoundsException.js");
var _indexOutOfBoundsExceptionJsDefault = parcelHelpers.interopDefault(_indexOutOfBoundsExceptionJs);
var _listJs = require("./List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
class Stack extends (0, _listJsDefault.default) {
    constructor(){
        super();
        this.array = [];
    }
    add(e) {
        this.array.push(e);
        return true;
    }
    get(index) {
        if (index < 0 || index >= this.size()) throw new (0, _indexOutOfBoundsExceptionJsDefault.default)();
        return this.array[index];
    }
    /**
   * Pushes an item onto the top of this stack.
   * @param {Object} e
   * @return {Object}
   */ push(e) {
        this.array.push(e);
        return e;
    }
    /**
   * Removes the object at the top of this stack and returns that object as the value of this function.
   * @return {Object}
   */ pop() {
        if (this.array.length === 0) throw new (0, _emptyStackExceptionJsDefault.default)();
        return this.array.pop();
    }
    /**
   * Looks at the object at the top of this stack without removing it from the
   * stack.
   * @return {Object}
   */ peek() {
        if (this.array.length === 0) throw new (0, _emptyStackExceptionJsDefault.default)();
        return this.array[this.array.length - 1];
    }
    /**
   * Tests if this stack is empty.
   * @return {boolean} true if and only if this stack contains no items; false
   *         otherwise.
   */ empty() {
        return this.array.length === 0;
    }
    /**
   * @return {boolean}
   */ isEmpty() {
        return this.empty();
    }
    /**
   * Returns the 1-based position where an object is on this stack. If the object
   * o occurs as an item in this stack, this method returns the distance from the
   * top of the stack of the occurrence nearest the top of the stack; the topmost
   * item on the stack is considered to be at distance 1. The equals method is
   * used to compare o to the items in this stack.
   *
   * NOTE: does not currently actually use equals. (=== is used)
   *
   * @param {Object} o
   * @return {number} the 1-based position from the top of the stack where the
   *         object is located; the return value -1 indicates that the object is
   *         not on the stack.
   */ search(o) {
        return this.array.indexOf(o);
    }
    /**
   * @return {number}
   */ size() {
        return this.array.length;
    }
    /**
   * @return {Array}
   */ toArray() {
        return this.array.slice();
    }
}
exports.default = Stack;

},{"./EmptyStackException.js":"lzH4a","../lang/IndexOutOfBoundsException.js":"bQ4AR","./List.js":"7jAhK","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lzH4a":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("../lang/Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class EmptyStackException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            EmptyStackException
        })[0];
    }
}
exports.default = EmptyStackException;

},{"../lang/Exception.js":"8tbsL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1uf1p":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _orientationJs = require("../../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class RightmostEdgeFinder {
    constructor(){
        RightmostEdgeFinder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._minIndex = -1;
        this._minCoord = null;
        this._minDe = null;
        this._orientedDe = null;
    }
    getCoordinate() {
        return this._minCoord;
    }
    getRightmostSide(de, index) {
        let side = this.getRightmostSideOfSegment(de, index);
        if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);
        if (side < 0) {
            this._minCoord = null;
            this.checkForRightmostCoordinate(de);
        }
        return side;
    }
    findRightmostEdgeAtVertex() {
        const pts = this._minDe.getEdge().getCoordinates();
        (0, _assertJsDefault.default).isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');
        const pPrev = pts[this._minIndex - 1];
        const pNext = pts[this._minIndex + 1];
        const orientation = (0, _orientationJsDefault.default).index(this._minCoord, pNext, pPrev);
        let usePrev = false;
        if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === (0, _orientationJsDefault.default).COUNTERCLOCKWISE) usePrev = true;
        else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === (0, _orientationJsDefault.default).CLOCKWISE) usePrev = true;
        if (usePrev) this._minIndex = this._minIndex - 1;
    }
    getRightmostSideOfSegment(de, i) {
        const e = de.getEdge();
        const coord = e.getCoordinates();
        if (i < 0 || i + 1 >= coord.length) return -1;
        if (coord[i].y === coord[i + 1].y) return -1;
        let pos = (0, _positionJsDefault.default).LEFT;
        if (coord[i].y < coord[i + 1].y) pos = (0, _positionJsDefault.default).RIGHT;
        return pos;
    }
    getEdge() {
        return this._orientedDe;
    }
    checkForRightmostCoordinate(de) {
        const coord = de.getEdge().getCoordinates();
        for(let i = 0; i < coord.length - 1; i++)if (this._minCoord === null || coord[i].x > this._minCoord.x) {
            this._minDe = de;
            this._minIndex = i;
            this._minCoord = coord[i];
        }
    }
    findRightmostEdgeAtNode() {
        const node = this._minDe.getNode();
        const star = node.getEdges();
        this._minDe = star.getRightmostEdge();
        if (!this._minDe.isForward()) {
            this._minDe = this._minDe.getSym();
            this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
        }
    }
    findEdge(dirEdgeList) {
        for(let i = dirEdgeList.iterator(); i.hasNext();){
            const de = i.next();
            if (!de.isForward()) continue;
            this.checkForRightmostCoordinate(de);
        }
        (0, _assertJsDefault.default).isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');
        if (this._minIndex === 0) this.findRightmostEdgeAtNode();
        else this.findRightmostEdgeAtVertex();
        this._orientedDe = this._minDe;
        const rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
        if (rightmostSide === (0, _positionJsDefault.default).LEFT) this._orientedDe = this._minDe.getSym();
    }
}
exports.default = RightmostEdgeFinder;

},{"../../geomgraph/Position.js":"13raO","../../algorithm/Orientation.js":"avl08","../../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iokEz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class LinkedList {
    constructor(){
        this.array = [];
    }
    addLast(e) {
        this.array.push(e);
    }
    removeFirst() {
        return this.array.shift();
    }
    isEmpty() {
        return this.array.length === 0;
    }
}
exports.default = LinkedList;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aBCRI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bufferParametersJs = require("./BufferParameters.js");
var _bufferParametersJsDefault = parcelHelpers.interopDefault(_bufferParametersJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _bufferInputLineSimplifierJs = require("./BufferInputLineSimplifier.js");
var _bufferInputLineSimplifierJsDefault = parcelHelpers.interopDefault(_bufferInputLineSimplifierJs);
var _coordinateArraysJs = require("../../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _offsetSegmentGeneratorJs = require("./OffsetSegmentGenerator.js");
var _offsetSegmentGeneratorJsDefault = parcelHelpers.interopDefault(_offsetSegmentGeneratorJs);
class OffsetCurveBuilder {
    constructor(){
        OffsetCurveBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._distance = 0.0;
        this._precisionModel = null;
        this._bufParams = null;
        const precisionModel = arguments[0], bufParams = arguments[1];
        this._precisionModel = precisionModel;
        this._bufParams = bufParams;
    }
    static copyCoordinates(pts) {
        const copy = new Array(pts.length).fill(null);
        for(let i = 0; i < copy.length; i++)copy[i] = new (0, _coordinateJsDefault.default)(pts[i]);
        return copy;
    }
    getOffsetCurve(inputPts, distance) {
        this._distance = distance;
        if (distance === 0.0) return null;
        const isRightSide = distance < 0.0;
        const posDistance = Math.abs(distance);
        const segGen = this.getSegGen(posDistance);
        if (inputPts.length <= 1) this.computePointCurve(inputPts[0], segGen);
        else this.computeOffsetCurve(inputPts, isRightSide, segGen);
        const curvePts = segGen.getCoordinates();
        if (isRightSide) (0, _coordinateArraysJsDefault.default).reverse(curvePts);
        return curvePts;
    }
    computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {
        const distTol = this.simplifyTolerance(this._distance);
        if (isRightSide) {
            segGen.addSegments(inputPts, true);
            const simp2 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, -distTol);
            const n2 = simp2.length - 1;
            segGen.initSideSegments(simp2[n2], simp2[n2 - 1], (0, _positionJsDefault.default).LEFT);
            segGen.addFirstSegment();
            for(let i = n2 - 2; i >= 0; i--)segGen.addNextSegment(simp2[i], true);
        } else {
            segGen.addSegments(inputPts, false);
            const simp1 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, distTol);
            const n1 = simp1.length - 1;
            segGen.initSideSegments(simp1[0], simp1[1], (0, _positionJsDefault.default).LEFT);
            segGen.addFirstSegment();
            for(let i = 2; i <= n1; i++)segGen.addNextSegment(simp1[i], true);
        }
        segGen.addLastSegment();
        segGen.closeRing();
    }
    computeRingBufferCurve(inputPts, side, segGen) {
        let distTol = this.simplifyTolerance(this._distance);
        if (side === (0, _positionJsDefault.default).RIGHT) distTol = -distTol;
        const simp = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, distTol);
        const n = simp.length - 1;
        segGen.initSideSegments(simp[n - 1], simp[0], side);
        for(let i = 1; i <= n; i++){
            const addStartPoint = i !== 1;
            segGen.addNextSegment(simp[i], addStartPoint);
        }
        segGen.closeRing();
    }
    computeLineBufferCurve(inputPts, segGen) {
        const distTol = this.simplifyTolerance(this._distance);
        const simp1 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, distTol);
        const n1 = simp1.length - 1;
        segGen.initSideSegments(simp1[0], simp1[1], (0, _positionJsDefault.default).LEFT);
        for(let i = 2; i <= n1; i++)segGen.addNextSegment(simp1[i], true);
        segGen.addLastSegment();
        segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
        const simp2 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, -distTol);
        const n2 = simp2.length - 1;
        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], (0, _positionJsDefault.default).LEFT);
        for(let i = n2 - 2; i >= 0; i--)segGen.addNextSegment(simp2[i], true);
        segGen.addLastSegment();
        segGen.addLineEndCap(simp2[1], simp2[0]);
        segGen.closeRing();
    }
    computePointCurve(pt, segGen) {
        switch(this._bufParams.getEndCapStyle()){
            case (0, _bufferParametersJsDefault.default).CAP_ROUND:
                segGen.createCircle(pt);
                break;
            case (0, _bufferParametersJsDefault.default).CAP_SQUARE:
                segGen.createSquare(pt);
                break;
        }
    }
    getLineCurve(inputPts, distance) {
        this._distance = distance;
        if (this.isLineOffsetEmpty(distance)) return null;
        const posDistance = Math.abs(distance);
        const segGen = this.getSegGen(posDistance);
        if (inputPts.length <= 1) this.computePointCurve(inputPts[0], segGen);
        else if (this._bufParams.isSingleSided()) {
            const isRightSide = distance < 0.0;
            this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
        } else this.computeLineBufferCurve(inputPts, segGen);
        const lineCoord = segGen.getCoordinates();
        return lineCoord;
    }
    getBufferParameters() {
        return this._bufParams;
    }
    simplifyTolerance(bufDistance) {
        return bufDistance * this._bufParams.getSimplifyFactor();
    }
    getRingCurve(inputPts, side, distance) {
        this._distance = distance;
        if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);
        if (distance === 0.0) return OffsetCurveBuilder.copyCoordinates(inputPts);
        const segGen = this.getSegGen(distance);
        this.computeRingBufferCurve(inputPts, side, segGen);
        return segGen.getCoordinates();
    }
    computeOffsetCurve(inputPts, isRightSide, segGen) {
        const distTol = this.simplifyTolerance(this._distance);
        if (isRightSide) {
            const simp2 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, -distTol);
            const n2 = simp2.length - 1;
            segGen.initSideSegments(simp2[n2], simp2[n2 - 1], (0, _positionJsDefault.default).LEFT);
            segGen.addFirstSegment();
            for(let i = n2 - 2; i >= 0; i--)segGen.addNextSegment(simp2[i], true);
        } else {
            const simp1 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, distTol);
            const n1 = simp1.length - 1;
            segGen.initSideSegments(simp1[0], simp1[1], (0, _positionJsDefault.default).LEFT);
            segGen.addFirstSegment();
            for(let i = 2; i <= n1; i++)segGen.addNextSegment(simp1[i], true);
        }
        segGen.addLastSegment();
    }
    isLineOffsetEmpty(distance) {
        if (distance === 0.0) return true;
        if (distance < 0.0 && !this._bufParams.isSingleSided()) return true;
        return false;
    }
    getSegGen(distance) {
        return new (0, _offsetSegmentGeneratorJsDefault.default)(this._precisionModel, this._bufParams, distance);
    }
}
exports.default = OffsetCurveBuilder;

},{"./BufferParameters.js":"idesX","../../geomgraph/Position.js":"13raO","../../geom/Coordinate.js":"ii2fh","./BufferInputLineSimplifier.js":"3wzkz","../../geom/CoordinateArrays.js":"lncg4","./OffsetSegmentGenerator.js":"dVlaz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3wzkz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateListJs = require("../../geom/CoordinateList.js");
var _coordinateListJsDefault = parcelHelpers.interopDefault(_coordinateListJs);
var _orientationJs = require("../../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _distanceJs = require("../../algorithm/Distance.js");
var _distanceJsDefault = parcelHelpers.interopDefault(_distanceJs);
class BufferInputLineSimplifier {
    constructor(){
        BufferInputLineSimplifier.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._inputLine = null;
        this._distanceTol = null;
        this._isDeleted = null;
        this._angleOrientation = (0, _orientationJsDefault.default).COUNTERCLOCKWISE;
        const inputLine = arguments[0];
        this._inputLine = inputLine;
    }
    static simplify(inputLine, distanceTol) {
        const simp = new BufferInputLineSimplifier(inputLine);
        return simp.simplify(distanceTol);
    }
    isDeletable(i0, i1, i2, distanceTol) {
        const p0 = this._inputLine[i0];
        const p1 = this._inputLine[i1];
        const p2 = this._inputLine[i2];
        if (!this.isConcave(p0, p1, p2)) return false;
        if (!this.isShallow(p0, p1, p2, distanceTol)) return false;
        return this.isShallowSampled(p0, p1, i0, i2, distanceTol);
    }
    deleteShallowConcavities() {
        let index = 1;
        let midIndex = this.findNextNonDeletedIndex(index);
        let lastIndex = this.findNextNonDeletedIndex(midIndex);
        let isChanged = false;
        while(lastIndex < this._inputLine.length){
            let isMiddleVertexDeleted = false;
            if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {
                this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
                isMiddleVertexDeleted = true;
                isChanged = true;
            }
            if (isMiddleVertexDeleted) index = lastIndex;
            else index = midIndex;
            midIndex = this.findNextNonDeletedIndex(index);
            lastIndex = this.findNextNonDeletedIndex(midIndex);
        }
        return isChanged;
    }
    isShallowConcavity(p0, p1, p2, distanceTol) {
        const orientation = (0, _orientationJsDefault.default).index(p0, p1, p2);
        const isAngleToSimplify = orientation === this._angleOrientation;
        if (!isAngleToSimplify) return false;
        const dist = (0, _distanceJsDefault.default).pointToSegment(p1, p0, p2);
        return dist < distanceTol;
    }
    isShallowSampled(p0, p2, i0, i2, distanceTol) {
        let inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
        if (inc <= 0) inc = 1;
        for(let i = i0; i < i2; i += inc)if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;
        return true;
    }
    isConcave(p0, p1, p2) {
        const orientation = (0, _orientationJsDefault.default).index(p0, p1, p2);
        const isConcave = orientation === this._angleOrientation;
        return isConcave;
    }
    simplify(distanceTol) {
        this._distanceTol = Math.abs(distanceTol);
        if (distanceTol < 0) this._angleOrientation = (0, _orientationJsDefault.default).CLOCKWISE;
        this._isDeleted = new Array(this._inputLine.length).fill(null);
        let isChanged = false;
        do isChanged = this.deleteShallowConcavities();
        while (isChanged);
        return this.collapseLine();
    }
    findNextNonDeletedIndex(index) {
        let next = index + 1;
        while(next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE)next++;
        return next;
    }
    isShallow(p0, p1, p2, distanceTol) {
        const dist = (0, _distanceJsDefault.default).pointToSegment(p1, p0, p2);
        return dist < distanceTol;
    }
    collapseLine() {
        const coordList = new (0, _coordinateListJsDefault.default)();
        for(let i = 0; i < this._inputLine.length; i++)if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);
        return coordList.toCoordinateArray();
    }
}
exports.default = BufferInputLineSimplifier;
BufferInputLineSimplifier.INIT = 0;
BufferInputLineSimplifier.DELETE = 1;
BufferInputLineSimplifier.KEEP = 1;
BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;

},{"../../geom/CoordinateList.js":"ibs54","../../algorithm/Orientation.js":"avl08","../../algorithm/Distance.js":"4ZaWr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dVlaz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bufferParametersJs = require("./BufferParameters.js");
var _bufferParametersJsDefault = parcelHelpers.interopDefault(_bufferParametersJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
var _offsetSegmentStringJs = require("./OffsetSegmentString.js");
var _offsetSegmentStringJsDefault = parcelHelpers.interopDefault(_offsetSegmentStringJs);
var _orientationJs = require("../../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _intersectionJs = require("../../algorithm/Intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
var _angleJs = require("../../algorithm/Angle.js");
var _angleJsDefault = parcelHelpers.interopDefault(_angleJs);
var _robustLineIntersectorJs = require("../../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
class OffsetSegmentGenerator {
    constructor(){
        OffsetSegmentGenerator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._maxCurveSegmentError = 0.0;
        this._filletAngleQuantum = null;
        this._closingSegLengthFactor = 1;
        this._segList = null;
        this._distance = 0.0;
        this._precisionModel = null;
        this._bufParams = null;
        this._li = null;
        this._s0 = null;
        this._s1 = null;
        this._s2 = null;
        this._seg0 = new (0, _lineSegmentJsDefault.default)();
        this._seg1 = new (0, _lineSegmentJsDefault.default)();
        this._offset0 = new (0, _lineSegmentJsDefault.default)();
        this._offset1 = new (0, _lineSegmentJsDefault.default)();
        this._side = 0;
        this._hasNarrowConcaveAngle = false;
        const precisionModel = arguments[0], bufParams = arguments[1], distance = arguments[2];
        this._precisionModel = precisionModel;
        this._bufParams = bufParams;
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();
        if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === (0, _bufferParametersJsDefault.default).JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;
        this.init(distance);
    }
    getCoordinates() {
        const pts = this._segList.getCoordinates();
        return pts;
    }
    addMitreJoin(p, offset0, offset1, distance) {
        const intPt = (0, _intersectionJsDefault.default).intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
        if (intPt !== null) {
            const mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);
            if (mitreRatio <= this._bufParams.getMitreLimit()) {
                this._segList.addPt(intPt);
                return null;
            }
        }
        this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());
    }
    addLastSegment() {
        this._segList.addPt(this._offset1.p1);
    }
    initSideSegments(s1, s2, side) {
        this._s1 = s1;
        this._s2 = s2;
        this._side = side;
        this._seg1.setCoordinates(s1, s2);
        this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
    }
    addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {
        const basePt = this._seg0.p1;
        const ang0 = (0, _angleJsDefault.default).angle(basePt, this._seg0.p0);
        const angDiff = (0, _angleJsDefault.default).angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
        const angDiffHalf = angDiff / 2;
        const midAng = (0, _angleJsDefault.default).normalize(ang0 + angDiffHalf);
        const mitreMidAng = (0, _angleJsDefault.default).normalize(midAng + Math.PI);
        const mitreDist = mitreLimit * distance;
        const bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
        const bevelHalfLen = distance - bevelDelta;
        const bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
        const bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
        const bevelMidPt = new (0, _coordinateJsDefault.default)(bevelMidX, bevelMidY);
        const mitreMidLine = new (0, _lineSegmentJsDefault.default)(basePt, bevelMidPt);
        const bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);
        const bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);
        if (this._side === (0, _positionJsDefault.default).LEFT) {
            this._segList.addPt(bevelEndLeft);
            this._segList.addPt(bevelEndRight);
        } else {
            this._segList.addPt(bevelEndRight);
            this._segList.addPt(bevelEndLeft);
        }
    }
    addDirectedFillet(p, startAngle, endAngle, direction, radius) {
        const directionFactor = direction === (0, _orientationJsDefault.default).CLOCKWISE ? -1 : 1;
        const totalAngle = Math.abs(startAngle - endAngle);
        const nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
        if (nSegs < 1) return null;
        const angleInc = totalAngle / nSegs;
        const pt = new (0, _coordinateJsDefault.default)();
        for(let i = 0; i < nSegs; i++){
            const angle = startAngle + directionFactor * i * angleInc;
            pt.x = p.x + radius * Math.cos(angle);
            pt.y = p.y + radius * Math.sin(angle);
            this._segList.addPt(pt);
        }
    }
    computeOffsetSegment(seg, side, distance, offset) {
        const sideSign = side === (0, _positionJsDefault.default).LEFT ? 1 : -1;
        const dx = seg.p1.x - seg.p0.x;
        const dy = seg.p1.y - seg.p0.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        const ux = sideSign * distance * dx / len;
        const uy = sideSign * distance * dy / len;
        offset.p0.x = seg.p0.x - uy;
        offset.p0.y = seg.p0.y + ux;
        offset.p1.x = seg.p1.x - uy;
        offset.p1.y = seg.p1.y + ux;
    }
    addInsideTurn(orientation, addStartPoint) {
        this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
        if (this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
        else {
            this._hasNarrowConcaveAngle = true;
            if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
            else {
                this._segList.addPt(this._offset0.p1);
                if (this._closingSegLengthFactor > 0) {
                    const mid0 = new (0, _coordinateJsDefault.default)((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                    this._segList.addPt(mid0);
                    const mid1 = new (0, _coordinateJsDefault.default)((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                    this._segList.addPt(mid1);
                } else this._segList.addPt(this._s1);
                this._segList.addPt(this._offset1.p0);
            }
        }
    }
    createCircle(p) {
        const pt = new (0, _coordinateJsDefault.default)(p.x + this._distance, p.y);
        this._segList.addPt(pt);
        this.addDirectedFillet(p, 0.0, 2.0 * Math.PI, -1, this._distance);
        this._segList.closeRing();
    }
    addBevelJoin(offset0, offset1) {
        this._segList.addPt(offset0.p1);
        this._segList.addPt(offset1.p0);
    }
    init(distance) {
        this._distance = distance;
        this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));
        this._segList = new (0, _offsetSegmentStringJsDefault.default)();
        this._segList.setPrecisionModel(this._precisionModel);
        this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
    }
    addCollinear(addStartPoint) {
        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
        const numInt = this._li.getIntersectionNum();
        if (numInt >= 2) {
            if (this._bufParams.getJoinStyle() === (0, _bufferParametersJsDefault.default).JOIN_BEVEL || this._bufParams.getJoinStyle() === (0, _bufferParametersJsDefault.default).JOIN_MITRE) {
                if (addStartPoint) this._segList.addPt(this._offset0.p1);
                this._segList.addPt(this._offset1.p0);
            } else this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, (0, _orientationJsDefault.default).CLOCKWISE, this._distance);
        }
    }
    addNextSegment(p, addStartPoint) {
        this._s0 = this._s1;
        this._s1 = this._s2;
        this._s2 = p;
        this._seg0.setCoordinates(this._s0, this._s1);
        this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
        this._seg1.setCoordinates(this._s1, this._s2);
        this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
        if (this._s1.equals(this._s2)) return null;
        const orientation = (0, _orientationJsDefault.default).index(this._s0, this._s1, this._s2);
        const outsideTurn = orientation === (0, _orientationJsDefault.default).CLOCKWISE && this._side === (0, _positionJsDefault.default).LEFT || orientation === (0, _orientationJsDefault.default).COUNTERCLOCKWISE && this._side === (0, _positionJsDefault.default).RIGHT;
        if (orientation === 0) this.addCollinear(addStartPoint);
        else if (outsideTurn) this.addOutsideTurn(orientation, addStartPoint);
        else this.addInsideTurn(orientation, addStartPoint);
    }
    addLineEndCap(p0, p1) {
        const seg = new (0, _lineSegmentJsDefault.default)(p0, p1);
        const offsetL = new (0, _lineSegmentJsDefault.default)();
        this.computeOffsetSegment(seg, (0, _positionJsDefault.default).LEFT, this._distance, offsetL);
        const offsetR = new (0, _lineSegmentJsDefault.default)();
        this.computeOffsetSegment(seg, (0, _positionJsDefault.default).RIGHT, this._distance, offsetR);
        const dx = p1.x - p0.x;
        const dy = p1.y - p0.y;
        const angle = Math.atan2(dy, dx);
        switch(this._bufParams.getEndCapStyle()){
            case (0, _bufferParametersJsDefault.default).CAP_ROUND:
                this._segList.addPt(offsetL.p1);
                this.addDirectedFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2, (0, _orientationJsDefault.default).CLOCKWISE, this._distance);
                this._segList.addPt(offsetR.p1);
                break;
            case (0, _bufferParametersJsDefault.default).CAP_FLAT:
                this._segList.addPt(offsetL.p1);
                this._segList.addPt(offsetR.p1);
                break;
            case (0, _bufferParametersJsDefault.default).CAP_SQUARE:
                const squareCapSideOffset = new (0, _coordinateJsDefault.default)();
                squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);
                squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);
                const squareCapLOffset = new (0, _coordinateJsDefault.default)(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
                const squareCapROffset = new (0, _coordinateJsDefault.default)(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
                this._segList.addPt(squareCapLOffset);
                this._segList.addPt(squareCapROffset);
                break;
        }
    }
    addOutsideTurn(orientation, addStartPoint) {
        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
            this._segList.addPt(this._offset0.p1);
            return null;
        }
        if (this._bufParams.getJoinStyle() === (0, _bufferParametersJsDefault.default).JOIN_MITRE) this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
        else if (this._bufParams.getJoinStyle() === (0, _bufferParametersJsDefault.default).JOIN_BEVEL) this.addBevelJoin(this._offset0, this._offset1);
        else {
            if (addStartPoint) this._segList.addPt(this._offset0.p1);
            this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);
            this._segList.addPt(this._offset1.p0);
        }
    }
    createSquare(p) {
        this._segList.addPt(new (0, _coordinateJsDefault.default)(p.x + this._distance, p.y + this._distance));
        this._segList.addPt(new (0, _coordinateJsDefault.default)(p.x + this._distance, p.y - this._distance));
        this._segList.addPt(new (0, _coordinateJsDefault.default)(p.x - this._distance, p.y - this._distance));
        this._segList.addPt(new (0, _coordinateJsDefault.default)(p.x - this._distance, p.y + this._distance));
        this._segList.closeRing();
    }
    addSegments(pt, isForward) {
        this._segList.addPts(pt, isForward);
    }
    addFirstSegment() {
        this._segList.addPt(this._offset1.p0);
    }
    addCornerFillet(p, p0, p1, direction, radius) {
        const dx0 = p0.x - p.x;
        const dy0 = p0.y - p.y;
        let startAngle = Math.atan2(dy0, dx0);
        const dx1 = p1.x - p.x;
        const dy1 = p1.y - p.y;
        const endAngle = Math.atan2(dy1, dx1);
        if (direction === (0, _orientationJsDefault.default).CLOCKWISE) {
            if (startAngle <= endAngle) startAngle += 2.0 * Math.PI;
        } else if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;
        this._segList.addPt(p0);
        this.addDirectedFillet(p, startAngle, endAngle, direction, radius);
        this._segList.addPt(p1);
    }
    closeRing() {
        this._segList.closeRing();
    }
    hasNarrowConcaveAngle() {
        return this._hasNarrowConcaveAngle;
    }
}
exports.default = OffsetSegmentGenerator;
OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;
OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;
OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;
OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;

},{"./BufferParameters.js":"idesX","../../geomgraph/Position.js":"13raO","../../geom/Coordinate.js":"ii2fh","../../geom/LineSegment.js":"8Ncbv","./OffsetSegmentString.js":"dQ6jS","../../algorithm/Orientation.js":"avl08","../../algorithm/Intersection.js":"bynFG","../../algorithm/Angle.js":"61NBK","../../algorithm/RobustLineIntersector.js":"kLdG9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dQ6jS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryFactoryJs = require("../../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class OffsetSegmentString {
    constructor(){
        OffsetSegmentString.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._ptList = null;
        this._precisionModel = null;
        this._minimimVertexDistance = 0.0;
        this._ptList = new (0, _arrayListJsDefault.default)();
    }
    getCoordinates() {
        const coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
        return coord;
    }
    setPrecisionModel(precisionModel) {
        this._precisionModel = precisionModel;
    }
    addPt(pt) {
        const bufPt = new (0, _coordinateJsDefault.default)(pt);
        this._precisionModel.makePrecise(bufPt);
        if (this.isRedundant(bufPt)) return null;
        this._ptList.add(bufPt);
    }
    reverse() {}
    addPts(pt, isForward) {
        if (isForward) for(let i = 0; i < pt.length; i++)this.addPt(pt[i]);
        else for(let i = pt.length - 1; i >= 0; i--)this.addPt(pt[i]);
    }
    isRedundant(pt) {
        if (this._ptList.size() < 1) return false;
        const lastPt = this._ptList.get(this._ptList.size() - 1);
        const ptDist = pt.distance(lastPt);
        if (ptDist < this._minimimVertexDistance) return true;
        return false;
    }
    toString() {
        const fact = new (0, _geometryFactoryJsDefault.default)();
        const line = fact.createLineString(this.getCoordinates());
        return line.toString();
    }
    closeRing() {
        if (this._ptList.size() < 1) return null;
        const startPt = new (0, _coordinateJsDefault.default)(this._ptList.get(0));
        const lastPt = this._ptList.get(this._ptList.size() - 1);
        if (startPt.equals(lastPt)) return null;
        this._ptList.add(startPt);
    }
    setMinimumVertexDistance(minimimVertexDistance) {
        this._minimimVertexDistance = minimimVertexDistance;
    }
}
exports.default = OffsetSegmentString;
OffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);

},{"../../geom/GeometryFactory.js":"cGt0T","../../geom/Coordinate.js":"ii2fh","../../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"61NBK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _orientationJs = require("./Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
class Angle {
    static toDegrees(radians) {
        return radians * 180 / Math.PI;
    }
    static isAcute(p0, p1, p2) {
        const dx0 = p0.x - p1.x;
        const dy0 = p0.y - p1.y;
        const dx1 = p2.x - p1.x;
        const dy1 = p2.y - p1.y;
        const dotprod = dx0 * dx1 + dy0 * dy1;
        return dotprod > 0;
    }
    static isObtuse(p0, p1, p2) {
        const dx0 = p0.x - p1.x;
        const dy0 = p0.y - p1.y;
        const dx1 = p2.x - p1.x;
        const dy1 = p2.y - p1.y;
        const dotprod = dx0 * dx1 + dy0 * dy1;
        return dotprod < 0;
    }
    static interiorAngle(p0, p1, p2) {
        const anglePrev = Angle.angle(p1, p0);
        const angleNext = Angle.angle(p1, p2);
        return Math.abs(angleNext - anglePrev);
    }
    static normalizePositive(angle) {
        if (angle < 0.0) {
            while(angle < 0.0)angle += Angle.PI_TIMES_2;
            if (angle >= Angle.PI_TIMES_2) angle = 0.0;
        } else {
            while(angle >= Angle.PI_TIMES_2)angle -= Angle.PI_TIMES_2;
            if (angle < 0.0) angle = 0.0;
        }
        return angle;
    }
    static angleBetween(tip1, tail, tip2) {
        const a1 = Angle.angle(tail, tip1);
        const a2 = Angle.angle(tail, tip2);
        return Angle.diff(a1, a2);
    }
    static diff(ang1, ang2) {
        let delAngle = null;
        if (ang1 < ang2) delAngle = ang2 - ang1;
        else delAngle = ang1 - ang2;
        if (delAngle > Math.PI) delAngle = 2 * Math.PI - delAngle;
        return delAngle;
    }
    static toRadians(angleDegrees) {
        return angleDegrees * Math.PI / 180.0;
    }
    static normalize(angle) {
        while(angle > Math.PI)angle -= Angle.PI_TIMES_2;
        while(angle <= -Math.PI)angle += Angle.PI_TIMES_2;
        return angle;
    }
    static angle() {
        if (arguments.length === 1) {
            const p = arguments[0];
            return Math.atan2(p.y, p.x);
        } else if (arguments.length === 2) {
            const p0 = arguments[0], p1 = arguments[1];
            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;
            return Math.atan2(dy, dx);
        }
    }
    static getTurn(ang1, ang2) {
        const crossproduct = Math.sin(ang2 - ang1);
        if (crossproduct > 0) return Angle.COUNTERCLOCKWISE;
        if (crossproduct < 0) return Angle.CLOCKWISE;
        return Angle.NONE;
    }
    static angleBetweenOriented(tip1, tail, tip2) {
        const a1 = Angle.angle(tail, tip1);
        const a2 = Angle.angle(tail, tip2);
        const angDel = a2 - a1;
        if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;
        if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;
        return angDel;
    }
}
exports.default = Angle;
Angle.PI_TIMES_2 = 2.0 * Math.PI;
Angle.PI_OVER_2 = Math.PI / 2.0;
Angle.PI_OVER_4 = Math.PI / 4.0;
Angle.COUNTERCLOCKWISE = (0, _orientationJsDefault.default).COUNTERCLOCKWISE;
Angle.CLOCKWISE = (0, _orientationJsDefault.default).CLOCKWISE;
Angle.NONE = (0, _orientationJsDefault.default).COLLINEAR;

},{"./Orientation.js":"avl08","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"crM1Q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointLocationJs = require("../../algorithm/PointLocation.js");
var _pointLocationJsDefault = parcelHelpers.interopDefault(_pointLocationJs);
var _topologyExceptionJs = require("../../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _maximalEdgeRingJs = require("./MaximalEdgeRing.js");
var _maximalEdgeRingJsDefault = parcelHelpers.interopDefault(_maximalEdgeRingJs);
var _coordinateArraysJs = require("../../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _planarGraphJs = require("../../geomgraph/PlanarGraph.js");
var _planarGraphJsDefault = parcelHelpers.interopDefault(_planarGraphJs);
class PolygonBuilder {
    constructor(){
        PolygonBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geometryFactory = null;
        this._shellList = new (0, _arrayListJsDefault.default)();
        const geometryFactory = arguments[0];
        this._geometryFactory = geometryFactory;
    }
    static findEdgeRingContaining(testEr, shellList) {
        const testRing = testEr.getLinearRing();
        const testEnv = testRing.getEnvelopeInternal();
        let testPt = testRing.getCoordinateN(0);
        let minShell = null;
        let minShellEnv = null;
        for(let it = shellList.iterator(); it.hasNext();){
            const tryShell = it.next();
            const tryShellRing = tryShell.getLinearRing();
            const tryShellEnv = tryShellRing.getEnvelopeInternal();
            if (tryShellEnv.equals(testEnv)) continue;
            if (!tryShellEnv.contains(testEnv)) continue;
            testPt = (0, _coordinateArraysJsDefault.default).ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates());
            let isContained = false;
            if ((0, _pointLocationJsDefault.default).isInRing(testPt, tryShellRing.getCoordinates())) isContained = true;
            if (isContained) {
                if (minShell === null || minShellEnv.contains(tryShellEnv)) {
                    minShell = tryShell;
                    minShellEnv = minShell.getLinearRing().getEnvelopeInternal();
                }
            }
        }
        return minShell;
    }
    sortShellsAndHoles(edgeRings, shellList, freeHoleList) {
        for(let it = edgeRings.iterator(); it.hasNext();){
            const er = it.next();
            if (er.isHole()) freeHoleList.add(er);
            else shellList.add(er);
        }
    }
    computePolygons(shellList) {
        const resultPolyList = new (0, _arrayListJsDefault.default)();
        for(let it = shellList.iterator(); it.hasNext();){
            const er = it.next();
            const poly = er.toPolygon(this._geometryFactory);
            resultPolyList.add(poly);
        }
        return resultPolyList;
    }
    placeFreeHoles(shellList, freeHoleList) {
        for(let it = freeHoleList.iterator(); it.hasNext();){
            const hole = it.next();
            if (hole.getShell() === null) {
                const shell = PolygonBuilder.findEdgeRingContaining(hole, shellList);
                if (shell === null) throw new (0, _topologyExceptionJsDefault.default)('unable to assign hole to a shell', hole.getCoordinate(0));
                hole.setShell(shell);
            }
        }
    }
    buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {
        const edgeRings = new (0, _arrayListJsDefault.default)();
        for(let it = maxEdgeRings.iterator(); it.hasNext();){
            const er = it.next();
            if (er.getMaxNodeDegree() > 2) {
                er.linkDirectedEdgesForMinimalEdgeRings();
                const minEdgeRings = er.buildMinimalRings();
                const shell = this.findShell(minEdgeRings);
                if (shell !== null) {
                    this.placePolygonHoles(shell, minEdgeRings);
                    shellList.add(shell);
                } else freeHoleList.addAll(minEdgeRings);
            } else edgeRings.add(er);
        }
        return edgeRings;
    }
    buildMaximalEdgeRings(dirEdges) {
        const maxEdgeRings = new (0, _arrayListJsDefault.default)();
        for(let it = dirEdges.iterator(); it.hasNext();){
            const de = it.next();
            if (de.isInResult() && de.getLabel().isArea()) {
                if (de.getEdgeRing() === null) {
                    const er = new (0, _maximalEdgeRingJsDefault.default)(de, this._geometryFactory);
                    maxEdgeRings.add(er);
                    er.setInResult();
                }
            }
        }
        return maxEdgeRings;
    }
    placePolygonHoles(shell, minEdgeRings) {
        for(let it = minEdgeRings.iterator(); it.hasNext();){
            const er = it.next();
            if (er.isHole()) er.setShell(shell);
        }
    }
    getPolygons() {
        const resultPolyList = this.computePolygons(this._shellList);
        return resultPolyList;
    }
    findShell(minEdgeRings) {
        let shellCount = 0;
        let shell = null;
        for(let it = minEdgeRings.iterator(); it.hasNext();){
            const er = it.next();
            if (!er.isHole()) {
                shell = er;
                shellCount++;
            }
        }
        (0, _assertJsDefault.default).isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');
        return shell;
    }
    add() {
        if (arguments.length === 1) {
            const graph = arguments[0];
            this.add(graph.getEdgeEnds(), graph.getNodes());
        } else if (arguments.length === 2) {
            const dirEdges = arguments[0], nodes = arguments[1];
            (0, _planarGraphJsDefault.default).linkResultDirectedEdges(nodes);
            const maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
            const freeHoleList = new (0, _arrayListJsDefault.default)();
            const edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
            this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
            this.placeFreeHoles(this._shellList, freeHoleList);
        }
    }
}
exports.default = PolygonBuilder;

},{"../../algorithm/PointLocation.js":"l7FlP","../../geom/TopologyException.js":"bOVA5","./MaximalEdgeRing.js":"4ayjA","../../geom/CoordinateArrays.js":"lncg4","../../../../../java/util/ArrayList.js":"gGAQZ","../../util/Assert.js":"1vSRy","../../geomgraph/PlanarGraph.js":"etG4v","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4ayjA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _minimalEdgeRingJs = require("./MinimalEdgeRing.js");
var _minimalEdgeRingJsDefault = parcelHelpers.interopDefault(_minimalEdgeRingJs);
var _edgeRingJs = require("../../geomgraph/EdgeRing.js");
var _edgeRingJsDefault = parcelHelpers.interopDefault(_edgeRingJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class MaximalEdgeRing extends (0, _edgeRingJsDefault.default) {
    constructor(){
        super();
        MaximalEdgeRing.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const start = arguments[0], geometryFactory = arguments[1];
        (0, _edgeRingJsDefault.default).constructor_.call(this, start, geometryFactory);
    }
    linkDirectedEdgesForMinimalEdgeRings() {
        let de = this._startDe;
        do {
            const node = de.getNode();
            node.getEdges().linkMinimalDirectedEdges(this);
            de = de.getNext();
        }while (de !== this._startDe);
    }
    buildMinimalRings() {
        const minEdgeRings = new (0, _arrayListJsDefault.default)();
        let de = this._startDe;
        do {
            if (de.getMinEdgeRing() === null) {
                const minEr = new (0, _minimalEdgeRingJsDefault.default)(de, this._geometryFactory);
                minEdgeRings.add(minEr);
            }
            de = de.getNext();
        }while (de !== this._startDe);
        return minEdgeRings;
    }
    getNext(de) {
        return de.getNext();
    }
    setEdgeRing(de, er) {
        de.setEdgeRing(er);
    }
}
exports.default = MaximalEdgeRing;

},{"./MinimalEdgeRing.js":"jJ8Uz","../../geomgraph/EdgeRing.js":"bsyLp","../../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jJ8Uz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeRingJs = require("../../geomgraph/EdgeRing.js");
var _edgeRingJsDefault = parcelHelpers.interopDefault(_edgeRingJs);
class MinimalEdgeRing extends (0, _edgeRingJsDefault.default) {
    constructor(){
        super();
        MinimalEdgeRing.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const start = arguments[0], geometryFactory = arguments[1];
        (0, _edgeRingJsDefault.default).constructor_.call(this, start, geometryFactory);
    }
    getNext(de) {
        return de.getNextMin();
    }
    setEdgeRing(de, er) {
        de.setMinEdgeRing(er);
    }
}
exports.default = MinimalEdgeRing;

},{"../../geomgraph/EdgeRing.js":"bsyLp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bsyLp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _pointLocationJs = require("../algorithm/PointLocation.js");
var _pointLocationJsDefault = parcelHelpers.interopDefault(_pointLocationJs);
var _topologyExceptionJs = require("../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class EdgeRing {
    constructor(){
        EdgeRing.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._startDe = null;
        this._maxNodeDegree = -1;
        this._edges = new (0, _arrayListJsDefault.default)();
        this._pts = new (0, _arrayListJsDefault.default)();
        this._label = new (0, _labelJsDefault.default)((0, _locationJsDefault.default).NONE);
        this._ring = null;
        this._isHole = null;
        this._shell = null;
        this._holes = new (0, _arrayListJsDefault.default)();
        this._geometryFactory = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 2) {
            const start = arguments[0], geometryFactory = arguments[1];
            this._geometryFactory = geometryFactory;
            this.computePoints(start);
            this.computeRing();
        }
    }
    computeRing() {
        if (this._ring !== null) return null;
        const coord = new Array(this._pts.size()).fill(null);
        for(let i = 0; i < this._pts.size(); i++)coord[i] = this._pts.get(i);
        this._ring = this._geometryFactory.createLinearRing(coord);
        this._isHole = (0, _orientationJsDefault.default).isCCW(this._ring.getCoordinates());
    }
    isIsolated() {
        return this._label.getGeometryCount() === 1;
    }
    computePoints(start) {
        this._startDe = start;
        let de = start;
        let isFirstEdge = true;
        do {
            if (de === null) throw new (0, _topologyExceptionJsDefault.default)('Found null DirectedEdge');
            if (de.getEdgeRing() === this) throw new (0, _topologyExceptionJsDefault.default)('Directed Edge visited twice during ring-building at ' + de.getCoordinate());
            this._edges.add(de);
            const label = de.getLabel();
            (0, _assertJsDefault.default).isTrue(label.isArea());
            this.mergeLabel(label);
            this.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
            isFirstEdge = false;
            this.setEdgeRing(de, this);
            de = this.getNext(de);
        }while (de !== this._startDe);
    }
    getLinearRing() {
        return this._ring;
    }
    getCoordinate(i) {
        return this._pts.get(i);
    }
    computeMaxNodeDegree() {
        this._maxNodeDegree = 0;
        let de = this._startDe;
        do {
            const node = de.getNode();
            const degree = node.getEdges().getOutgoingDegree(this);
            if (degree > this._maxNodeDegree) this._maxNodeDegree = degree;
            de = this.getNext(de);
        }while (de !== this._startDe);
        this._maxNodeDegree *= 2;
    }
    addPoints(edge, isForward, isFirstEdge) {
        const edgePts = edge.getCoordinates();
        if (isForward) {
            let startIndex = 1;
            if (isFirstEdge) startIndex = 0;
            for(let i = startIndex; i < edgePts.length; i++)this._pts.add(edgePts[i]);
        } else {
            let startIndex = edgePts.length - 2;
            if (isFirstEdge) startIndex = edgePts.length - 1;
            for(let i = startIndex; i >= 0; i--)this._pts.add(edgePts[i]);
        }
    }
    containsPoint(p) {
        const shell = this.getLinearRing();
        const env = shell.getEnvelopeInternal();
        if (!env.contains(p)) return false;
        if (!(0, _pointLocationJsDefault.default).isInRing(p, shell.getCoordinates())) return false;
        for(let i = this._holes.iterator(); i.hasNext();){
            const hole = i.next();
            if (hole.containsPoint(p)) return false;
        }
        return true;
    }
    getMaxNodeDegree() {
        if (this._maxNodeDegree < 0) this.computeMaxNodeDegree();
        return this._maxNodeDegree;
    }
    setShell(shell) {
        this._shell = shell;
        if (shell !== null) shell.addHole(this);
    }
    toPolygon(geometryFactory) {
        const holeLR = new Array(this._holes.size()).fill(null);
        for(let i = 0; i < this._holes.size(); i++)holeLR[i] = this._holes.get(i).getLinearRing();
        const poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
        return poly;
    }
    isHole() {
        return this._isHole;
    }
    setInResult() {
        let de = this._startDe;
        do {
            de.getEdge().setInResult(true);
            de = de.getNext();
        }while (de !== this._startDe);
    }
    addHole(ring) {
        this._holes.add(ring);
    }
    isShell() {
        return this._shell === null;
    }
    getLabel() {
        return this._label;
    }
    getEdges() {
        return this._edges;
    }
    getShell() {
        return this._shell;
    }
    mergeLabel() {
        if (arguments.length === 1) {
            const deLabel = arguments[0];
            this.mergeLabel(deLabel, 0);
            this.mergeLabel(deLabel, 1);
        } else if (arguments.length === 2) {
            const deLabel = arguments[0], geomIndex = arguments[1];
            const loc = deLabel.getLocation(geomIndex, (0, _positionJsDefault.default).RIGHT);
            if (loc === (0, _locationJsDefault.default).NONE) return null;
            if (this._label.getLocation(geomIndex) === (0, _locationJsDefault.default).NONE) {
                this._label.setLocation(geomIndex, loc);
                return null;
            }
        }
    }
}
exports.default = EdgeRing;

},{"../geom/Location.js":"9aPCX","./Position.js":"13raO","../algorithm/PointLocation.js":"l7FlP","../geom/TopologyException.js":"bOVA5","../algorithm/Orientation.js":"avl08","./Label.js":"dJJOo","../../../../java/util/ArrayList.js":"gGAQZ","../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9iVKl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
var _comparableJs = require("../../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _listJs = require("../../../../../java/util/List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
var _directedEdgeJs = require("../../geomgraph/DirectedEdge.js");
var _directedEdgeJsDefault = parcelHelpers.interopDefault(_directedEdgeJs);
var _orientationJs = require("../../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
class SubgraphDepthLocater {
    constructor(){
        SubgraphDepthLocater.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._subgraphs = null;
        this._seg = new (0, _lineSegmentJsDefault.default)();
        const subgraphs = arguments[0];
        this._subgraphs = subgraphs;
    }
    findStabbedSegments() {
        if (arguments.length === 1) {
            const stabbingRayLeftPt = arguments[0];
            const stabbedSegments = new (0, _arrayListJsDefault.default)();
            for(let i = this._subgraphs.iterator(); i.hasNext();){
                const bsg = i.next();
                const env = bsg.getEnvelope();
                if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;
                this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
            }
            return stabbedSegments;
        } else if (arguments.length === 3) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[2], (0, _listJsDefault.default)) && arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof (0, _directedEdgeJsDefault.default)) {
                const stabbingRayLeftPt = arguments[0], dirEdge = arguments[1], stabbedSegments = arguments[2];
                const pts = dirEdge.getEdge().getCoordinates();
                for(let i = 0; i < pts.length - 1; i++){
                    this._seg.p0 = pts[i];
                    this._seg.p1 = pts[i + 1];
                    if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();
                    const maxx = Math.max(this._seg.p0.x, this._seg.p1.x);
                    if (maxx < stabbingRayLeftPt.x) continue;
                    if (this._seg.isHorizontal()) continue;
                    if (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue;
                    if ((0, _orientationJsDefault.default).index(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === (0, _orientationJsDefault.default).RIGHT) continue;
                    let depth = dirEdge.getDepth((0, _positionJsDefault.default).LEFT);
                    if (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth((0, _positionJsDefault.default).RIGHT);
                    const ds = new DepthSegment(this._seg, depth);
                    stabbedSegments.add(ds);
                }
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[2], (0, _listJsDefault.default)) && arguments[0] instanceof (0, _coordinateJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _listJsDefault.default))) {
                const stabbingRayLeftPt = arguments[0], dirEdges = arguments[1], stabbedSegments = arguments[2];
                for(let i = dirEdges.iterator(); i.hasNext();){
                    const de = i.next();
                    if (!de.isForward()) continue;
                    this.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);
                }
            }
        }
    }
    getDepth(p) {
        const stabbedSegments = this.findStabbedSegments(p);
        if (stabbedSegments.size() === 0) return 0;
        const ds = (0, _collectionsJsDefault.default).min(stabbedSegments);
        return ds._leftDepth;
    }
}
exports.default = SubgraphDepthLocater;
class DepthSegment {
    constructor(){
        DepthSegment.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._upwardSeg = null;
        this._leftDepth = null;
        const seg = arguments[0], depth = arguments[1];
        this._upwardSeg = new (0, _lineSegmentJsDefault.default)(seg);
        this._leftDepth = depth;
    }
    compareX(seg0, seg1) {
        const compare0 = seg0.p0.compareTo(seg1.p0);
        if (compare0 !== 0) return compare0;
        return seg0.p1.compareTo(seg1.p1);
    }
    toString() {
        return this._upwardSeg.toString();
    }
    compareTo(obj) {
        const other = obj;
        if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;
        if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;
        let orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
        if (orientIndex !== 0) return orientIndex;
        orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
        if (orientIndex !== 0) return orientIndex;
        return this._upwardSeg.compareTo(other._upwardSeg);
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
SubgraphDepthLocater.DepthSegment = DepthSegment;

},{"../../../../../hasInterface.js":"5bpze","../../geomgraph/Position.js":"13raO","../../geom/Coordinate.js":"ii2fh","../../geom/LineSegment.js":"8Ncbv","../../../../../java/lang/Comparable.js":"WFeEu","../../../../../java/util/ArrayList.js":"gGAQZ","../../../../../java/util/List.js":"7jAhK","../../geomgraph/DirectedEdge.js":"aFTwO","../../algorithm/Orientation.js":"avl08","../../../../../java/util/Collections.js":"c5dcW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"elu3d":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _lineStringJs = require("../../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _pointJs = require("../../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _linearRingJs = require("../../geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _orientationJs = require("../../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _multiPolygonJs = require("../../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _labelJs = require("../../geomgraph/Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _coordinateArraysJs = require("../../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _distanceJs = require("../../algorithm/Distance.js");
var _distanceJsDefault = parcelHelpers.interopDefault(_distanceJs);
var _multiLineStringJs = require("../../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _triangleJs = require("../../geom/Triangle.js");
var _triangleJsDefault = parcelHelpers.interopDefault(_triangleJs);
var _nodedSegmentStringJs = require("../../noding/NodedSegmentString.js");
var _nodedSegmentStringJsDefault = parcelHelpers.interopDefault(_nodedSegmentStringJs);
var _polygonJs = require("../../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _multiPointJs = require("../../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _geometryCollectionJs = require("../../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _unsupportedOperationExceptionJs = require("../../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
class OffsetCurveSetBuilder {
    constructor(){
        OffsetCurveSetBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._inputGeom = null;
        this._distance = null;
        this._curveBuilder = null;
        this._curveList = new (0, _arrayListJsDefault.default)();
        const inputGeom = arguments[0], distance = arguments[1], curveBuilder = arguments[2];
        this._inputGeom = inputGeom;
        this._distance = distance;
        this._curveBuilder = curveBuilder;
    }
    addRingSide(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
        if (offsetDistance === 0.0 && coord.length < (0, _linearRingJsDefault.default).MINIMUM_VALID_SIZE) return null;
        let leftLoc = cwLeftLoc;
        let rightLoc = cwRightLoc;
        if (coord.length >= (0, _linearRingJsDefault.default).MINIMUM_VALID_SIZE && (0, _orientationJsDefault.default).isCCW(coord)) {
            leftLoc = cwRightLoc;
            rightLoc = cwLeftLoc;
            side = (0, _positionJsDefault.default).opposite(side);
        }
        const curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
        this.addCurve(curve, leftLoc, rightLoc);
    }
    addRingBothSides(coord, distance) {
        this.addRingSide(coord, distance, (0, _positionJsDefault.default).LEFT, (0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR);
        this.addRingSide(coord, distance, (0, _positionJsDefault.default).RIGHT, (0, _locationJsDefault.default).INTERIOR, (0, _locationJsDefault.default).EXTERIOR);
    }
    addPoint(p) {
        if (this._distance <= 0.0) return null;
        const coord = p.getCoordinates();
        const curve = this._curveBuilder.getLineCurve(coord, this._distance);
        this.addCurve(curve, (0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR);
    }
    addPolygon(p) {
        let offsetDistance = this._distance;
        let offsetSide = (0, _positionJsDefault.default).LEFT;
        if (this._distance < 0.0) {
            offsetDistance = -this._distance;
            offsetSide = (0, _positionJsDefault.default).RIGHT;
        }
        const shell = p.getExteriorRing();
        const shellCoord = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(shell.getCoordinates());
        if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;
        if (this._distance <= 0.0 && shellCoord.length < 3) return null;
        this.addRingSide(shellCoord, offsetDistance, offsetSide, (0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR);
        for(let i = 0; i < p.getNumInteriorRing(); i++){
            const hole = p.getInteriorRingN(i);
            const holeCoord = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(hole.getCoordinates());
            if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;
            this.addRingSide(holeCoord, offsetDistance, (0, _positionJsDefault.default).opposite(offsetSide), (0, _locationJsDefault.default).INTERIOR, (0, _locationJsDefault.default).EXTERIOR);
        }
    }
    isTriangleErodedCompletely(triangleCoord, bufferDistance) {
        const tri = new (0, _triangleJsDefault.default)(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
        const inCentre = tri.inCentre();
        const distToCentre = (0, _distanceJsDefault.default).pointToSegment(inCentre, tri.p0, tri.p1);
        return distToCentre < Math.abs(bufferDistance);
    }
    addLineString(line) {
        if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
        const coord = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(line.getCoordinates());
        if ((0, _coordinateArraysJsDefault.default).isRing(coord) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(coord, this._distance);
        else {
            const curve = this._curveBuilder.getLineCurve(coord, this._distance);
            this.addCurve(curve, (0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR);
        }
    }
    add(g) {
        if (g.isEmpty()) return null;
        if (g instanceof (0, _polygonJsDefault.default)) this.addPolygon(g);
        else if (g instanceof (0, _lineStringJsDefault.default)) this.addLineString(g);
        else if (g instanceof (0, _pointJsDefault.default)) this.addPoint(g);
        else if (g instanceof (0, _multiPointJsDefault.default)) this.addCollection(g);
        else if (g instanceof (0, _multiLineStringJsDefault.default)) this.addCollection(g);
        else if (g instanceof (0, _multiPolygonJsDefault.default)) this.addCollection(g);
        else if (g instanceof (0, _geometryCollectionJsDefault.default)) this.addCollection(g);
        else throw new (0, _unsupportedOperationExceptionJsDefault.default)(g.getGeometryType());
    }
    addCurve(coord, leftLoc, rightLoc) {
        if (coord === null || coord.length < 2) return null;
        const e = new (0, _nodedSegmentStringJsDefault.default)(coord, new (0, _labelJsDefault.default)(0, (0, _locationJsDefault.default).BOUNDARY, leftLoc, rightLoc));
        this._curveList.add(e);
    }
    getCurves() {
        this.add(this._inputGeom);
        return this._curveList;
    }
    isErodedCompletely(ring, bufferDistance) {
        const ringCoord = ring.getCoordinates();
        if (ringCoord.length < 4) return bufferDistance < 0;
        if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);
        const env = ring.getEnvelopeInternal();
        const envMinDimension = Math.min(env.getHeight(), env.getWidth());
        if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;
        return false;
    }
    addCollection(gc) {
        for(let i = 0; i < gc.getNumGeometries(); i++){
            const g = gc.getGeometryN(i);
            this.add(g);
        }
    }
}
exports.default = OffsetCurveSetBuilder;

},{"../../geom/Location.js":"9aPCX","../../geom/LineString.js":"4eIEg","../../geomgraph/Position.js":"13raO","../../geom/Point.js":"lwZpO","../../geom/LinearRing.js":"2x4Ym","../../algorithm/Orientation.js":"avl08","../../geom/MultiPolygon.js":"6Hrab","../../geomgraph/Label.js":"dJJOo","../../geom/CoordinateArrays.js":"lncg4","../../../../../java/util/ArrayList.js":"gGAQZ","../../algorithm/Distance.js":"4ZaWr","../../geom/MultiLineString.js":"5UyOx","../../geom/Triangle.js":"3tGRP","../../noding/NodedSegmentString.js":"gBLDJ","../../geom/Polygon.js":"kpOA5","../../geom/MultiPoint.js":"5w2To","../../geom/GeometryCollection.js":"6RJQO","../../../../../java/lang/UnsupportedOperationException.js":"dV3kx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3tGRP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _ddJs = require("../math/DD.js");
var _ddJsDefault = parcelHelpers.interopDefault(_ddJs);
var _angleJs = require("../algorithm/Angle.js");
var _angleJsDefault = parcelHelpers.interopDefault(_angleJs);
var _hcoordinateJs = require("../algorithm/HCoordinate.js");
var _hcoordinateJsDefault = parcelHelpers.interopDefault(_hcoordinateJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class Triangle {
    constructor(){
        Triangle.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.p0 = null;
        this.p1 = null;
        this.p2 = null;
        const p0 = arguments[0], p1 = arguments[1], p2 = arguments[2];
        this.p0 = p0;
        this.p1 = p1;
        this.p2 = p2;
    }
    static isAcute(a, b, c) {
        if (!(0, _angleJsDefault.default).isAcute(a, b, c)) return false;
        if (!(0, _angleJsDefault.default).isAcute(b, c, a)) return false;
        if (!(0, _angleJsDefault.default).isAcute(c, a, b)) return false;
        return true;
    }
    static circumcentre(a, b, c) {
        const cx = c.x;
        const cy = c.y;
        const ax = a.x - cx;
        const ay = a.y - cy;
        const bx = b.x - cx;
        const by = b.y - cy;
        const denom = 2 * Triangle.det(ax, ay, bx, by);
        const numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
        const numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
        const ccx = cx - numx / denom;
        const ccy = cy + numy / denom;
        return new (0, _coordinateJsDefault.default)(ccx, ccy);
    }
    static perpendicularBisector(a, b) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const l1 = new (0, _hcoordinateJsDefault.default)(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);
        const l2 = new (0, _hcoordinateJsDefault.default)(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);
        return new (0, _hcoordinateJsDefault.default)(l1, l2);
    }
    static angleBisector(a, b, c) {
        const len0 = b.distance(a);
        const len2 = b.distance(c);
        const frac = len0 / (len0 + len2);
        const dx = c.x - a.x;
        const dy = c.y - a.y;
        const splitPt = new (0, _coordinateJsDefault.default)(a.x + frac * dx, a.y + frac * dy);
        return splitPt;
    }
    static inCentre(a, b, c) {
        const len0 = b.distance(c);
        const len1 = a.distance(c);
        const len2 = a.distance(b);
        const circum = len0 + len1 + len2;
        const inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
        const inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
        return new (0, _coordinateJsDefault.default)(inCentreX, inCentreY);
    }
    static area(a, b, c) {
        return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);
    }
    static signedArea(a, b, c) {
        return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;
    }
    static det(m00, m01, m10, m11) {
        return m00 * m11 - m01 * m10;
    }
    static interpolateZ(p, v0, v1, v2) {
        const x0 = v0.x;
        const y0 = v0.y;
        const a = v1.x - x0;
        const b = v2.x - x0;
        const c = v1.y - y0;
        const d = v2.y - y0;
        const det = a * d - b * c;
        const dx = p.x - x0;
        const dy = p.y - y0;
        const t = (d * dx - b * dy) / det;
        const u = (-c * dx + a * dy) / det;
        const z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());
        return z;
    }
    static longestSideLength(a, b, c) {
        const lenAB = a.distance(b);
        const lenBC = b.distance(c);
        const lenCA = c.distance(a);
        let maxLen = lenAB;
        if (lenBC > maxLen) maxLen = lenBC;
        if (lenCA > maxLen) maxLen = lenCA;
        return maxLen;
    }
    static circumcentreDD(a, b, c) {
        const ax = (0, _ddJsDefault.default).valueOf(a.x).subtract(c.x);
        const ay = (0, _ddJsDefault.default).valueOf(a.y).subtract(c.y);
        const bx = (0, _ddJsDefault.default).valueOf(b.x).subtract(c.x);
        const by = (0, _ddJsDefault.default).valueOf(b.y).subtract(c.y);
        const denom = (0, _ddJsDefault.default).determinant(ax, ay, bx, by).multiply(2);
        const asqr = ax.sqr().add(ay.sqr());
        const bsqr = bx.sqr().add(by.sqr());
        const numx = (0, _ddJsDefault.default).determinant(ay, asqr, by, bsqr);
        const numy = (0, _ddJsDefault.default).determinant(ax, asqr, bx, bsqr);
        const ccx = (0, _ddJsDefault.default).valueOf(c.x).subtract(numx.divide(denom)).doubleValue();
        const ccy = (0, _ddJsDefault.default).valueOf(c.y).add(numy.divide(denom)).doubleValue();
        return new (0, _coordinateJsDefault.default)(ccx, ccy);
    }
    static area3D(a, b, c) {
        const ux = b.x - a.x;
        const uy = b.y - a.y;
        const uz = b.getZ() - a.getZ();
        const vx = c.x - a.x;
        const vy = c.y - a.y;
        const vz = c.getZ() - a.getZ();
        const crossx = uy * vz - uz * vy;
        const crossy = uz * vx - ux * vz;
        const crossz = ux * vy - uy * vx;
        const absSq = crossx * crossx + crossy * crossy + crossz * crossz;
        const area3D = Math.sqrt(absSq) / 2;
        return area3D;
    }
    static centroid(a, b, c) {
        const x = (a.x + b.x + c.x) / 3;
        const y = (a.y + b.y + c.y) / 3;
        return new (0, _coordinateJsDefault.default)(x, y);
    }
    interpolateZ(p) {
        if (p === null) throw new (0, _illegalArgumentExceptionJsDefault.default)('Supplied point is null.');
        return Triangle.interpolateZ(p, this.p0, this.p1, this.p2);
    }
    longestSideLength() {
        return Triangle.longestSideLength(this.p0, this.p1, this.p2);
    }
    isAcute() {
        return Triangle.isAcute(this.p0, this.p1, this.p2);
    }
    circumcentre() {
        return Triangle.circumcentre(this.p0, this.p1, this.p2);
    }
    inCentre() {
        return Triangle.inCentre(this.p0, this.p1, this.p2);
    }
    area() {
        return Triangle.area(this.p0, this.p1, this.p2);
    }
    signedArea() {
        return Triangle.signedArea(this.p0, this.p1, this.p2);
    }
    area3D() {
        return Triangle.area3D(this.p0, this.p1, this.p2);
    }
    centroid() {
        return Triangle.centroid(this.p0, this.p1, this.p2);
    }
}
exports.default = Triangle;

},{"../math/DD.js":"12omc","../algorithm/Angle.js":"61NBK","../algorithm/HCoordinate.js":"1Fobc","./Coordinate.js":"ii2fh","../../../../java/lang/IllegalArgumentException.js":"9ppVW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1Fobc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _notRepresentableExceptionJs = require("./NotRepresentableException.js");
var _notRepresentableExceptionJsDefault = parcelHelpers.interopDefault(_notRepresentableExceptionJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
class HCoordinate {
    constructor(){
        HCoordinate.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.x = null;
        this.y = null;
        this.w = null;
        if (arguments.length === 0) {
            this.x = 0.0;
            this.y = 0.0;
            this.w = 1.0;
        } else if (arguments.length === 1) {
            const p = arguments[0];
            this.x = p.x;
            this.y = p.y;
            this.w = 1.0;
        } else if (arguments.length === 2) {
            if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
                const _x = arguments[0], _y = arguments[1];
                this.x = _x;
                this.y = _y;
                this.w = 1.0;
            } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {
                const p1 = arguments[0], p2 = arguments[1];
                this.x = p1.y * p2.w - p2.y * p1.w;
                this.y = p2.x * p1.w - p1.x * p2.w;
                this.w = p1.x * p2.y - p2.x * p1.y;
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
                const p1 = arguments[0], p2 = arguments[1];
                this.x = p1.y - p2.y;
                this.y = p2.x - p1.x;
                this.w = p1.x * p2.y - p2.x * p1.y;
            }
        } else if (arguments.length === 3) {
            const _x = arguments[0], _y = arguments[1], _w = arguments[2];
            this.x = _x;
            this.y = _y;
            this.w = _w;
        } else if (arguments.length === 4) {
            const p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];
            const px = p1.y - p2.y;
            const py = p2.x - p1.x;
            const pw = p1.x * p2.y - p2.x * p1.y;
            const qx = q1.y - q2.y;
            const qy = q2.x - q1.x;
            const qw = q1.x * q2.y - q2.x * q1.y;
            this.x = py * qw - qy * pw;
            this.y = qx * pw - px * qw;
            this.w = px * qy - qx * py;
        }
    }
    getCoordinate() {
        const p = new (0, _coordinateJsDefault.default)();
        p.x = this.getX();
        p.y = this.getY();
        return p;
    }
    getX() {
        const a = this.x / this.w;
        if ((0, _doubleJsDefault.default).isNaN(a) || (0, _doubleJsDefault.default).isInfinite(a)) throw new (0, _notRepresentableExceptionJsDefault.default)();
        return a;
    }
    getY() {
        const a = this.y / this.w;
        if ((0, _doubleJsDefault.default).isNaN(a) || (0, _doubleJsDefault.default).isInfinite(a)) throw new (0, _notRepresentableExceptionJsDefault.default)();
        return a;
    }
}
exports.default = HCoordinate;

},{"./NotRepresentableException.js":"2MRq4","../geom/Coordinate.js":"ii2fh","../../../../java/lang/Double.js":"clUxd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2MRq4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("../../../../java/lang/Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class NotRepresentableException extends (0, _exceptionJsDefault.default) {
    constructor(){
        super();
        NotRepresentableException.constructor_.apply(this, arguments);
    }
    static constructor_() {
        (0, _exceptionJsDefault.default).constructor_.call(this, 'Projective point not representable on the Cartesian plane.');
    }
}
exports.default = NotRepresentableException;

},{"../../../../java/lang/Exception.js":"8tbsL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2jxBb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _directedEdgeStarJs = require("../../geomgraph/DirectedEdgeStar.js");
var _directedEdgeStarJsDefault = parcelHelpers.interopDefault(_directedEdgeStarJs);
var _nodeJs = require("../../geomgraph/Node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
var _nodeFactoryJs = require("../../geomgraph/NodeFactory.js");
var _nodeFactoryJsDefault = parcelHelpers.interopDefault(_nodeFactoryJs);
class OverlayNodeFactory extends (0, _nodeFactoryJsDefault.default) {
    constructor(){
        super();
    }
    createNode(coord) {
        return new (0, _nodeJsDefault.default)(coord, new (0, _directedEdgeStarJsDefault.default)());
    }
}
exports.default = OverlayNodeFactory;

},{"../../geomgraph/DirectedEdgeStar.js":"1iJ32","../../geomgraph/Node.js":"azV0J","../../geomgraph/NodeFactory.js":"5wP5U","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1iJ32":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _topologyExceptionJs = require("../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _edgeEndStarJs = require("./EdgeEndStar.js");
var _edgeEndStarJsDefault = parcelHelpers.interopDefault(_edgeEndStarJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _quadrantJs = require("./Quadrant.js");
var _quadrantJsDefault = parcelHelpers.interopDefault(_quadrantJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class DirectedEdgeStar extends (0, _edgeEndStarJsDefault.default) {
    constructor(){
        super();
        DirectedEdgeStar.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._resultAreaEdgeList = null;
        this._label = null;
        this._SCANNING_FOR_INCOMING = 1;
        this._LINKING_TO_OUTGOING = 2;
    }
    linkResultDirectedEdges() {
        this.getResultAreaEdges();
        let firstOut = null;
        let incoming = null;
        let state = this._SCANNING_FOR_INCOMING;
        for(let i = 0; i < this._resultAreaEdgeList.size(); i++){
            const nextOut = this._resultAreaEdgeList.get(i);
            const nextIn = nextOut.getSym();
            if (!nextOut.getLabel().isArea()) continue;
            if (firstOut === null && nextOut.isInResult()) firstOut = nextOut;
            switch(state){
                case this._SCANNING_FOR_INCOMING:
                    if (!nextIn.isInResult()) continue;
                    incoming = nextIn;
                    state = this._LINKING_TO_OUTGOING;
                    break;
                case this._LINKING_TO_OUTGOING:
                    if (!nextOut.isInResult()) continue;
                    incoming.setNext(nextOut);
                    state = this._SCANNING_FOR_INCOMING;
                    break;
            }
        }
        if (state === this._LINKING_TO_OUTGOING) {
            if (firstOut === null) throw new (0, _topologyExceptionJsDefault.default)('no outgoing dirEdge found', this.getCoordinate());
            (0, _assertJsDefault.default).isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');
            incoming.setNext(firstOut);
        }
    }
    insert(ee) {
        const de = ee;
        this.insertEdgeEnd(de, de);
    }
    getRightmostEdge() {
        const edges = this.getEdges();
        const size = edges.size();
        if (size < 1) return null;
        const de0 = edges.get(0);
        if (size === 1) return de0;
        const deLast = edges.get(size - 1);
        const quad0 = de0.getQuadrant();
        const quad1 = deLast.getQuadrant();
        if ((0, _quadrantJsDefault.default).isNorthern(quad0) && (0, _quadrantJsDefault.default).isNorthern(quad1)) return de0;
        else if (!(0, _quadrantJsDefault.default).isNorthern(quad0) && !(0, _quadrantJsDefault.default).isNorthern(quad1)) return deLast;
        else {
            const nonHorizontalEdge = null;
            if (de0.getDy() !== 0) return de0;
            else if (deLast.getDy() !== 0) return deLast;
        }
        (0, _assertJsDefault.default).shouldNeverReachHere('found two horizontal edges incident on node');
        return null;
    }
    updateLabelling(nodeLabel) {
        for(let it = this.iterator(); it.hasNext();){
            const de = it.next();
            const label = de.getLabel();
            label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
            label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
        }
    }
    linkAllDirectedEdges() {
        this.getEdges();
        let prevOut = null;
        let firstIn = null;
        for(let i = this._edgeList.size() - 1; i >= 0; i--){
            const nextOut = this._edgeList.get(i);
            const nextIn = nextOut.getSym();
            if (firstIn === null) firstIn = nextIn;
            if (prevOut !== null) nextIn.setNext(prevOut);
            prevOut = nextOut;
        }
        firstIn.setNext(prevOut);
    }
    computeDepths() {
        if (arguments.length === 1) {
            const de = arguments[0];
            const edgeIndex = this.findIndex(de);
            const startDepth = de.getDepth((0, _positionJsDefault.default).LEFT);
            const targetLastDepth = de.getDepth((0, _positionJsDefault.default).RIGHT);
            const nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
            const lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
            if (lastDepth !== targetLastDepth) throw new (0, _topologyExceptionJsDefault.default)('depth mismatch at ' + de.getCoordinate());
        } else if (arguments.length === 3) {
            const startIndex = arguments[0], endIndex = arguments[1], startDepth = arguments[2];
            let currDepth = startDepth;
            for(let i = startIndex; i < endIndex; i++){
                const nextDe = this._edgeList.get(i);
                nextDe.setEdgeDepths((0, _positionJsDefault.default).RIGHT, currDepth);
                currDepth = nextDe.getDepth((0, _positionJsDefault.default).LEFT);
            }
            return currDepth;
        }
    }
    mergeSymLabels() {
        for(let it = this.iterator(); it.hasNext();){
            const de = it.next();
            const label = de.getLabel();
            label.merge(de.getSym().getLabel());
        }
    }
    linkMinimalDirectedEdges(er) {
        let firstOut = null;
        let incoming = null;
        let state = this._SCANNING_FOR_INCOMING;
        for(let i = this._resultAreaEdgeList.size() - 1; i >= 0; i--){
            const nextOut = this._resultAreaEdgeList.get(i);
            const nextIn = nextOut.getSym();
            if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;
            switch(state){
                case this._SCANNING_FOR_INCOMING:
                    if (nextIn.getEdgeRing() !== er) continue;
                    incoming = nextIn;
                    state = this._LINKING_TO_OUTGOING;
                    break;
                case this._LINKING_TO_OUTGOING:
                    if (nextOut.getEdgeRing() !== er) continue;
                    incoming.setNextMin(nextOut);
                    state = this._SCANNING_FOR_INCOMING;
                    break;
            }
        }
        if (state === this._LINKING_TO_OUTGOING) {
            (0, _assertJsDefault.default).isTrue(firstOut !== null, 'found null for first outgoing dirEdge');
            (0, _assertJsDefault.default).isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');
            incoming.setNextMin(firstOut);
        }
    }
    getOutgoingDegree() {
        if (arguments.length === 0) {
            let degree = 0;
            for(let it = this.iterator(); it.hasNext();){
                const de = it.next();
                if (de.isInResult()) degree++;
            }
            return degree;
        } else if (arguments.length === 1) {
            const er = arguments[0];
            let degree = 0;
            for(let it = this.iterator(); it.hasNext();){
                const de = it.next();
                if (de.getEdgeRing() === er) degree++;
            }
            return degree;
        }
    }
    getLabel() {
        return this._label;
    }
    findCoveredLineEdges() {
        let startLoc = (0, _locationJsDefault.default).NONE;
        for(let it = this.iterator(); it.hasNext();){
            const nextOut = it.next();
            const nextIn = nextOut.getSym();
            if (!nextOut.isLineEdge()) {
                if (nextOut.isInResult()) {
                    startLoc = (0, _locationJsDefault.default).INTERIOR;
                    break;
                }
                if (nextIn.isInResult()) {
                    startLoc = (0, _locationJsDefault.default).EXTERIOR;
                    break;
                }
            }
        }
        if (startLoc === (0, _locationJsDefault.default).NONE) return null;
        let currLoc = startLoc;
        for(let it = this.iterator(); it.hasNext();){
            const nextOut = it.next();
            const nextIn = nextOut.getSym();
            if (nextOut.isLineEdge()) nextOut.getEdge().setCovered(currLoc === (0, _locationJsDefault.default).INTERIOR);
            else {
                if (nextOut.isInResult()) currLoc = (0, _locationJsDefault.default).EXTERIOR;
                if (nextIn.isInResult()) currLoc = (0, _locationJsDefault.default).INTERIOR;
            }
        }
    }
    computeLabelling(geom) {
        super.computeLabelling.call(this, geom);
        this._label = new (0, _labelJsDefault.default)((0, _locationJsDefault.default).NONE);
        for(let it = this.iterator(); it.hasNext();){
            const ee = it.next();
            const e = ee.getEdge();
            const eLabel = e.getLabel();
            for(let i = 0; i < 2; i++){
                const eLoc = eLabel.getLocation(i);
                if (eLoc === (0, _locationJsDefault.default).INTERIOR || eLoc === (0, _locationJsDefault.default).BOUNDARY) this._label.setLocation(i, (0, _locationJsDefault.default).INTERIOR);
            }
        }
    }
    print(out) {
        (0, _systemJsDefault.default).out.println('DirectedEdgeStar: ' + this.getCoordinate());
        for(let it = this.iterator(); it.hasNext();){
            const de = it.next();
            out.print('out ');
            de.print(out);
            out.println();
            out.print('in ');
            de.getSym().print(out);
            out.println();
        }
    }
    getResultAreaEdges() {
        if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
        this._resultAreaEdgeList = new (0, _arrayListJsDefault.default)();
        for(let it = this.iterator(); it.hasNext();){
            const de = it.next();
            if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);
        }
        return this._resultAreaEdgeList;
    }
}
exports.default = DirectedEdgeStar;

},{"../geom/Location.js":"9aPCX","./Position.js":"13raO","../geom/TopologyException.js":"bOVA5","./Label.js":"dJJOo","../../../../java/util/ArrayList.js":"gGAQZ","./EdgeEndStar.js":"lc382","../../../../java/lang/System.js":"dYmTx","./Quadrant.js":"86Qmh","../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cqdlm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _orientedCoordinateArrayJs = require("../noding/OrientedCoordinateArray.js");
var _orientedCoordinateArrayJsDefault = parcelHelpers.interopDefault(_orientedCoordinateArrayJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _treeMapJs = require("../../../../java/util/TreeMap.js");
var _treeMapJsDefault = parcelHelpers.interopDefault(_treeMapJs);
class EdgeList {
    constructor(){
        EdgeList.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._edges = new (0, _arrayListJsDefault.default)();
        this._ocaMap = new (0, _treeMapJsDefault.default)();
    }
    print(out) {
        out.print('MULTILINESTRING ( ');
        for(let j = 0; j < this._edges.size(); j++){
            const e = this._edges.get(j);
            if (j > 0) out.print(',');
            out.print('(');
            const pts = e.getCoordinates();
            for(let i = 0; i < pts.length; i++){
                if (i > 0) out.print(',');
                out.print(pts[i].x + ' ' + pts[i].y);
            }
            out.println(')');
        }
        out.print(')  ');
    }
    addAll(edgeColl) {
        for(let i = edgeColl.iterator(); i.hasNext();)this.add(i.next());
    }
    findEdgeIndex(e) {
        for(let i = 0; i < this._edges.size(); i++)if (this._edges.get(i).equals(e)) return i;
        return -1;
    }
    iterator() {
        return this._edges.iterator();
    }
    getEdges() {
        return this._edges;
    }
    get(i) {
        return this._edges.get(i);
    }
    findEqualEdge(e) {
        const oca = new (0, _orientedCoordinateArrayJsDefault.default)(e.getCoordinates());
        const matchEdge = this._ocaMap.get(oca);
        return matchEdge;
    }
    add(e) {
        this._edges.add(e);
        const oca = new (0, _orientedCoordinateArrayJsDefault.default)(e.getCoordinates());
        this._ocaMap.put(oca, e);
    }
}
exports.default = EdgeList;

},{"../noding/OrientedCoordinateArray.js":"6WFuf","../../../../java/util/ArrayList.js":"gGAQZ","../../../../java/util/TreeMap.js":"dQNYS","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6WFuf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _coordinateArraysJs = require("../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
class OrientedCoordinateArray {
    constructor(){
        OrientedCoordinateArray.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._pts = null;
        this._orientation = null;
        const pts = arguments[0];
        this._pts = pts;
        this._orientation = OrientedCoordinateArray.orientation(pts);
    }
    static orientation(pts) {
        return (0, _coordinateArraysJsDefault.default).increasingDirection(pts) === 1;
    }
    static compareOriented(pts1, orientation1, pts2, orientation2) {
        const dir1 = orientation1 ? 1 : -1;
        const dir2 = orientation2 ? 1 : -1;
        const limit1 = orientation1 ? pts1.length : -1;
        const limit2 = orientation2 ? pts2.length : -1;
        let i1 = orientation1 ? 0 : pts1.length - 1;
        let i2 = orientation2 ? 0 : pts2.length - 1;
        while(true){
            const compPt = pts1[i1].compareTo(pts2[i2]);
            if (compPt !== 0) return compPt;
            i1 += dir1;
            i2 += dir2;
            const done1 = i1 === limit1;
            const done2 = i2 === limit2;
            if (done1 && !done2) return -1;
            if (!done1 && done2) return 1;
            if (done1 && done2) return 0;
        }
    }
    compareTo(o1) {
        const oca = o1;
        const comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
        return comp;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = OrientedCoordinateArray;

},{"../../../../java/lang/Comparable.js":"WFeEu","../geom/CoordinateArrays.js":"lncg4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dL4Dk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _segmentIntersectorJs = require("./SegmentIntersector.js");
var _segmentIntersectorJsDefault = parcelHelpers.interopDefault(_segmentIntersectorJs);
class IntersectionAdder {
    constructor(){
        IntersectionAdder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._hasIntersection = false;
        this._hasProper = false;
        this._hasProperInterior = false;
        this._hasInterior = false;
        this._properIntersectionPoint = null;
        this._li = null;
        this._isSelfIntersection = null;
        this.numIntersections = 0;
        this.numInteriorIntersections = 0;
        this.numProperIntersections = 0;
        this.numTests = 0;
        const li = arguments[0];
        this._li = li;
    }
    static isAdjacentSegments(i1, i2) {
        return Math.abs(i1 - i2) === 1;
    }
    isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
        if (e0 === e1) {
            if (this._li.getIntersectionNum() === 1) {
                if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;
                if (e0.isClosed()) {
                    const maxSegIndex = e0.size() - 1;
                    if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) return true;
                }
            }
        }
        return false;
    }
    getProperIntersectionPoint() {
        return this._properIntersectionPoint;
    }
    hasProperInteriorIntersection() {
        return this._hasProperInterior;
    }
    getLineIntersector() {
        return this._li;
    }
    hasProperIntersection() {
        return this._hasProper;
    }
    processIntersections(e0, segIndex0, e1, segIndex1) {
        if (e0 === e1 && segIndex0 === segIndex1) return null;
        this.numTests++;
        const p00 = e0.getCoordinates()[segIndex0];
        const p01 = e0.getCoordinates()[segIndex0 + 1];
        const p10 = e1.getCoordinates()[segIndex1];
        const p11 = e1.getCoordinates()[segIndex1 + 1];
        this._li.computeIntersection(p00, p01, p10, p11);
        if (this._li.hasIntersection()) {
            this.numIntersections++;
            if (this._li.isInteriorIntersection()) {
                this.numInteriorIntersections++;
                this._hasInterior = true;
            }
            if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
                this._hasIntersection = true;
                e0.addIntersections(this._li, segIndex0, 0);
                e1.addIntersections(this._li, segIndex1, 1);
                if (this._li.isProper()) {
                    this.numProperIntersections++;
                    this._hasProper = true;
                    this._hasProperInterior = true;
                }
            }
        }
    }
    hasIntersection() {
        return this._hasIntersection;
    }
    isDone() {
        return false;
    }
    hasInteriorIntersection() {
        return this._hasInterior;
    }
    get interfaces_() {
        return [
            (0, _segmentIntersectorJsDefault.default)
        ];
    }
}
exports.default = IntersectionAdder;

},{"./SegmentIntersector.js":"jNast","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3M1zL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../../../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _coordinateListJs = require("../../../geom/CoordinateList.js");
var _coordinateListJsDefault = parcelHelpers.interopDefault(_coordinateListJs);
var _coordinateJs = require("../../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _lineSegmentJs = require("../../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
class LineStringSnapper {
    constructor(){
        LineStringSnapper.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._snapTolerance = 0.0;
        this._srcPts = null;
        this._seg = new (0, _lineSegmentJsDefault.default)();
        this._allowSnappingToSourceVertices = false;
        this._isClosed = false;
        if (arguments[0] instanceof (0, _lineStringJsDefault.default) && typeof arguments[1] === 'number') {
            const srcLine = arguments[0], snapTolerance = arguments[1];
            LineStringSnapper.constructor_.call(this, srcLine.getCoordinates(), snapTolerance);
        } else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') {
            const srcPts = arguments[0], snapTolerance = arguments[1];
            this._srcPts = srcPts;
            this._isClosed = LineStringSnapper.isClosed(srcPts);
            this._snapTolerance = snapTolerance;
        }
    }
    static isClosed(pts) {
        if (pts.length <= 1) return false;
        return pts[0].equals2D(pts[pts.length - 1]);
    }
    snapVertices(srcCoords, snapPts) {
        const end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
        for(let i = 0; i < end; i++){
            const srcPt = srcCoords.get(i);
            const snapVert = this.findSnapForVertex(srcPt, snapPts);
            if (snapVert !== null) {
                srcCoords.set(i, new (0, _coordinateJsDefault.default)(snapVert));
                if (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new (0, _coordinateJsDefault.default)(snapVert));
            }
        }
    }
    findSnapForVertex(pt, snapPts) {
        for(let i = 0; i < snapPts.length; i++){
            if (pt.equals2D(snapPts[i])) return null;
            if (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];
        }
        return null;
    }
    snapTo(snapPts) {
        const coordList = new (0, _coordinateListJsDefault.default)(this._srcPts);
        this.snapVertices(coordList, snapPts);
        this.snapSegments(coordList, snapPts);
        const newPts = coordList.toCoordinateArray();
        return newPts;
    }
    snapSegments(srcCoords, snapPts) {
        if (snapPts.length === 0) return null;
        let distinctPtCount = snapPts.length;
        if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;
        for(let i = 0; i < distinctPtCount; i++){
            const snapPt = snapPts[i];
            const index = this.findSegmentIndexToSnap(snapPt, srcCoords);
            if (index >= 0) srcCoords.add(index + 1, new (0, _coordinateJsDefault.default)(snapPt), false);
        }
    }
    findSegmentIndexToSnap(snapPt, srcCoords) {
        let minDist = (0, _doubleJsDefault.default).MAX_VALUE;
        let snapIndex = -1;
        for(let i = 0; i < srcCoords.size() - 1; i++){
            this._seg.p0 = srcCoords.get(i);
            this._seg.p1 = srcCoords.get(i + 1);
            if (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {
                if (this._allowSnappingToSourceVertices) continue;
                else return -1;
            }
            const dist = this._seg.distance(snapPt);
            if (dist < this._snapTolerance && dist < minDist) {
                minDist = dist;
                snapIndex = i;
            }
        }
        return snapIndex;
    }
    setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {
        this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
    }
}
exports.default = LineStringSnapper;

},{"../../../geom/LineString.js":"4eIEg","../../../geom/CoordinateList.js":"ibs54","../../../geom/Coordinate.js":"ii2fh","../../../../../../java/lang/Double.js":"clUxd","../../../geom/LineSegment.js":"8Ncbv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d0nTa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _geometryFactoryJs = require("../GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _linearRingJs = require("../LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _multiPolygonJs = require("../MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _geometryCollectionJs = require("../GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _multiLineStringJs = require("../MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _illegalArgumentExceptionJs = require("../../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _pointJs = require("../Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("../Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _multiPointJs = require("../MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
class GeometryTransformer {
    constructor(){
        GeometryTransformer.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._inputGeom = null;
        this._factory = null;
        this._pruneEmptyGeometry = true;
        this._preserveGeometryCollectionType = true;
        this._preserveCollections = false;
        this._preserveType = false;
    }
    transformPoint(geom, parent) {
        return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));
    }
    transformPolygon(geom, parent) {
        let isAllValidLinearRings = true;
        const shell = this.transformLinearRing(geom.getExteriorRing(), geom);
        if (shell === null || !(shell instanceof (0, _linearRingJsDefault.default)) || shell.isEmpty()) isAllValidLinearRings = false;
        const holes = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumInteriorRing(); i++){
            const hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);
            if (hole === null || hole.isEmpty()) continue;
            if (!(hole instanceof (0, _linearRingJsDefault.default))) isAllValidLinearRings = false;
            holes.add(hole);
        }
        if (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([]));
        else {
            const components = new (0, _arrayListJsDefault.default)();
            if (shell !== null) components.add(shell);
            components.addAll(holes);
            return this._factory.buildGeometry(components);
        }
    }
    createCoordinateSequence(coords) {
        return this._factory.getCoordinateSequenceFactory().create(coords);
    }
    getInputGeometry() {
        return this._inputGeom;
    }
    transformMultiLineString(geom, parent) {
        const transGeomList = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const transformGeom = this.transformLineString(geom.getGeometryN(i), geom);
            if (transformGeom === null) continue;
            if (transformGeom.isEmpty()) continue;
            transGeomList.add(transformGeom);
        }
        return this._factory.buildGeometry(transGeomList);
    }
    transformCoordinates(coords, parent) {
        return this.copy(coords);
    }
    transformLineString(geom, parent) {
        return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));
    }
    transformMultiPoint(geom, parent) {
        const transGeomList = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const transformGeom = this.transformPoint(geom.getGeometryN(i), geom);
            if (transformGeom === null) continue;
            if (transformGeom.isEmpty()) continue;
            transGeomList.add(transformGeom);
        }
        return this._factory.buildGeometry(transGeomList);
    }
    transformMultiPolygon(geom, parent) {
        const transGeomList = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);
            if (transformGeom === null) continue;
            if (transformGeom.isEmpty()) continue;
            transGeomList.add(transformGeom);
        }
        return this._factory.buildGeometry(transGeomList);
    }
    copy(seq) {
        return seq.copy();
    }
    transformLinearRing(geom, parent) {
        const seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
        if (seq === null) return this._factory.createLinearRing(null);
        const seqSize = seq.size();
        if (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);
        return this._factory.createLinearRing(seq);
    }
    transformGeometryCollection(geom, parent) {
        const transGeomList = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const transformGeom = this.transform(geom.getGeometryN(i));
            if (transformGeom === null) continue;
            if (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;
            transGeomList.add(transformGeom);
        }
        if (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection((0, _geometryFactoryJsDefault.default).toGeometryArray(transGeomList));
        return this._factory.buildGeometry(transGeomList);
    }
    transform(inputGeom) {
        this._inputGeom = inputGeom;
        this._factory = inputGeom.getFactory();
        if (inputGeom instanceof (0, _pointJsDefault.default)) return this.transformPoint(inputGeom, null);
        if (inputGeom instanceof (0, _multiPointJsDefault.default)) return this.transformMultiPoint(inputGeom, null);
        if (inputGeom instanceof (0, _linearRingJsDefault.default)) return this.transformLinearRing(inputGeom, null);
        if (inputGeom instanceof (0, _lineStringJsDefault.default)) return this.transformLineString(inputGeom, null);
        if (inputGeom instanceof (0, _multiLineStringJsDefault.default)) return this.transformMultiLineString(inputGeom, null);
        if (inputGeom instanceof (0, _polygonJsDefault.default)) return this.transformPolygon(inputGeom, null);
        if (inputGeom instanceof (0, _multiPolygonJsDefault.default)) return this.transformMultiPolygon(inputGeom, null);
        if (inputGeom instanceof (0, _geometryCollectionJsDefault.default)) return this.transformGeometryCollection(inputGeom, null);
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Unknown Geometry subtype: ' + inputGeom.getGeometryType());
    }
}
exports.default = GeometryTransformer;

},{"../LineString.js":"4eIEg","../GeometryFactory.js":"cGt0T","../LinearRing.js":"2x4Ym","../MultiPolygon.js":"6Hrab","../GeometryCollection.js":"6RJQO","../../../../../java/util/ArrayList.js":"gGAQZ","../MultiLineString.js":"5UyOx","../../../../../java/lang/IllegalArgumentException.js":"9ppVW","../Point.js":"lwZpO","../Polygon.js":"kpOA5","../MultiPoint.js":"5w2To","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7y7Cu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _coordinateSequenceFilterJs = require("../geom/CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
var _commonBitsJs = require("./CommonBits.js");
var _commonBitsJsDefault = parcelHelpers.interopDefault(_commonBitsJs);
var _coordinateFilterJs = require("../geom/CoordinateFilter.js");
var _coordinateFilterJsDefault = parcelHelpers.interopDefault(_coordinateFilterJs);
class CommonBitsRemover {
    constructor(){
        CommonBitsRemover.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._commonCoord = null;
        this._ccFilter = new CommonCoordinateFilter();
    }
    add(geom) {
        geom.apply(this._ccFilter);
        this._commonCoord = this._ccFilter.getCommonCoordinate();
    }
    removeCommonBits(geom) {
        if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;
        const invCoord = new (0, _coordinateJsDefault.default)(this._commonCoord);
        invCoord.x = -invCoord.x;
        invCoord.y = -invCoord.y;
        const trans = new Translater(invCoord);
        geom.apply(trans);
        geom.geometryChanged();
        return geom;
    }
    addCommonBits(geom) {
        const trans = new Translater(this._commonCoord);
        geom.apply(trans);
        geom.geometryChanged();
    }
    getCommonCoordinate() {
        return this._commonCoord;
    }
}
exports.default = CommonBitsRemover;
class CommonCoordinateFilter {
    constructor(){
        CommonCoordinateFilter.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._commonBitsX = new (0, _commonBitsJsDefault.default)();
        this._commonBitsY = new (0, _commonBitsJsDefault.default)();
    }
    filter(coord) {
        this._commonBitsX.add(coord.x);
        this._commonBitsY.add(coord.y);
    }
    getCommonCoordinate() {
        return new (0, _coordinateJsDefault.default)(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
    }
    get interfaces_() {
        return [
            (0, _coordinateFilterJsDefault.default)
        ];
    }
}
class Translater {
    constructor(){
        Translater.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.trans = null;
        const trans = arguments[0];
        this.trans = trans;
    }
    filter(seq, i) {
        const xp = seq.getOrdinate(i, 0) + this.trans.x;
        const yp = seq.getOrdinate(i, 1) + this.trans.y;
        seq.setOrdinate(i, 0, xp);
        seq.setOrdinate(i, 1, yp);
    }
    isGeometryChanged() {
        return true;
    }
    isDone() {
        return false;
    }
    get interfaces_() {
        return [
            (0, _coordinateSequenceFilterJsDefault.default)
        ];
    }
}
CommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;
CommonBitsRemover.Translater = Translater;

},{"../geom/Coordinate.js":"ii2fh","../geom/CoordinateSequenceFilter.js":"8MSah","./CommonBits.js":"6B21P","../geom/CoordinateFilter.js":"cr8Rt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6B21P":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _longJs = require("../../../../java/lang/Long.js");
var _longJsDefault = parcelHelpers.interopDefault(_longJs);
class CommonBits {
    constructor(){
        this._isFirst = true;
        this._commonMantissaBitsCount = 53;
        this._commonBits = new (0, _longJsDefault.default)();
        this._commonSignExp = null;
    }
    getCommon() {
        return (0, _doubleJsDefault.default).longBitsToDouble(this._commonBits);
    }
    add(num) {
        const numBits = (0, _doubleJsDefault.default).doubleToLongBits(num);
        if (this._isFirst) {
            this._commonBits = numBits;
            this._commonSignExp = CommonBits.signExpBits(this._commonBits);
            this._isFirst = false;
            return null;
        }
        const numSignExp = CommonBits.signExpBits(numBits);
        if (numSignExp !== this._commonSignExp) {
            this._commonBits.high = 0;
            this._commonBits.low = 0;
            return null;
        }
        this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
        this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
    }
    toString() {
        if (arguments.length === 1) {
            const bits = arguments[0];
            const x = (0, _doubleJsDefault.default).longBitsToDouble(bits);
            const numStr = (0, _longJsDefault.default).toBinaryString(bits);
            const padStr = '0000000000000000000000000000000000000000000000000000000000000000' + numStr;
            const bitStr = padStr.substring(padStr.length - 64);
            const str = bitStr.substring(0, 1) + '  ' + bitStr.substring(1, 12) + '(exp) ' + bitStr.substring(12) + ' [ ' + x + ' ]';
            return str;
        }
    }
    getClass() {
        return CommonBits;
    }
    get interfaces_() {
        return [];
    }
    static getBit(bits, i) {
        const mask = 1 << i % 32;
        if (i < 32) return (bits.low & mask) !== 0 ? 1 : 0;
        return (bits.high & mask) !== 0 ? 1 : 0;
    }
    static signExpBits(num) {
        return num.high >>> 20;
    }
    static zeroLowerBits(bits, nBits) {
        let prop = 'low';
        if (nBits > 32) {
            bits.low = 0;
            nBits %= 32;
            prop = 'high';
        }
        if (nBits > 0) {
            const mask = nBits < 32 ? ~((1 << nBits) - 1) : 0;
            bits[prop] &= mask;
        }
        return bits;
    }
    static numCommonMostSigMantissaBits(num1, num2) {
        let count = 0;
        for(let i = 52; i >= 0; i--){
            if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;
            count++;
        }
        return 52;
    }
}
exports.default = CommonBits;

},{"../../../../java/lang/Double.js":"clUxd","../../../../java/lang/Long.js":"9ArwZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9f5ft":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _polygonBuilderJs = require("./PolygonBuilder.js");
var _polygonBuilderJsDefault = parcelHelpers.interopDefault(_polygonBuilderJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _illegalArgumentExceptionJs = require("../../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _lineBuilderJs = require("./LineBuilder.js");
var _lineBuilderJsDefault = parcelHelpers.interopDefault(_lineBuilderJs);
var _pointBuilderJs = require("./PointBuilder.js");
var _pointBuilderJsDefault = parcelHelpers.interopDefault(_pointBuilderJs);
var _snapIfNeededOverlayOpJs = require("./snap/SnapIfNeededOverlayOp.js");
var _snapIfNeededOverlayOpJsDefault = parcelHelpers.interopDefault(_snapIfNeededOverlayOpJs);
var _labelJs = require("../../geomgraph/Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _planarGraphJs = require("../../geomgraph/PlanarGraph.js");
var _planarGraphJsDefault = parcelHelpers.interopDefault(_planarGraphJs);
var _pointLocatorJs = require("../../algorithm/PointLocator.js");
var _pointLocatorJsDefault = parcelHelpers.interopDefault(_pointLocatorJs);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _edgeNodingValidatorJs = require("../../geomgraph/EdgeNodingValidator.js");
var _edgeNodingValidatorJsDefault = parcelHelpers.interopDefault(_edgeNodingValidatorJs);
var _geometryCollectionMapperJs = require("../../geom/util/GeometryCollectionMapper.js");
var _geometryCollectionMapperJsDefault = parcelHelpers.interopDefault(_geometryCollectionMapperJs);
var _overlayNodeFactoryJs = require("./OverlayNodeFactory.js");
var _overlayNodeFactoryJsDefault = parcelHelpers.interopDefault(_overlayNodeFactoryJs);
var _geometryGraphOperationJs = require("../GeometryGraphOperation.js");
var _geometryGraphOperationJsDefault = parcelHelpers.interopDefault(_geometryGraphOperationJs);
var _edgeListJs = require("../../geomgraph/EdgeList.js");
var _edgeListJsDefault = parcelHelpers.interopDefault(_edgeListJs);
class OverlayOp extends (0, _geometryGraphOperationJsDefault.default) {
    constructor(){
        super();
        OverlayOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._ptLocator = new (0, _pointLocatorJsDefault.default)();
        this._geomFact = null;
        this._resultGeom = null;
        this._graph = null;
        this._edgeList = new (0, _edgeListJsDefault.default)();
        this._resultPolyList = new (0, _arrayListJsDefault.default)();
        this._resultLineList = new (0, _arrayListJsDefault.default)();
        this._resultPointList = new (0, _arrayListJsDefault.default)();
        const g0 = arguments[0], g1 = arguments[1];
        (0, _geometryGraphOperationJsDefault.default).constructor_.call(this, g0, g1);
        this._graph = new (0, _planarGraphJsDefault.default)(new (0, _overlayNodeFactoryJsDefault.default)());
        this._geomFact = g0.getFactory();
    }
    static overlayOp(geom0, geom1, opCode) {
        const gov = new OverlayOp(geom0, geom1);
        const geomOv = gov.getResultGeometry(opCode);
        return geomOv;
    }
    static union(geom, other) {
        if (geom.isEmpty() || other.isEmpty()) {
            if (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, geom, other, geom.getFactory());
            if (geom.isEmpty()) return other.copy();
            if (other.isEmpty()) return geom.copy();
        }
        if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new (0, _illegalArgumentExceptionJsDefault.default)('This method does not support GeometryCollection arguments');
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(geom, other, OverlayOp.UNION);
    }
    static intersection(geom, other) {
        if (geom.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, geom, other, geom.getFactory());
        if (geom.isGeometryCollection()) {
            const g2 = other;
            return (0, _geometryCollectionMapperJsDefault.default).map(geom, new class {
                get interfaces_() {
                    return [
                        MapOp
                    ];
                }
                map(g) {
                    return OverlayOp.intersection(g, g2);
                }
            }());
        }
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(geom, other, OverlayOp.INTERSECTION);
    }
    static symDifference(geom, other) {
        if (geom.isEmpty() || other.isEmpty()) {
            if (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, geom, other, geom.getFactory());
            if (geom.isEmpty()) return other.copy();
            if (other.isEmpty()) return geom.copy();
        }
        if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new (0, _illegalArgumentExceptionJsDefault.default)('This method does not support GeometryCollection arguments');
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(geom, other, OverlayOp.SYMDIFFERENCE);
    }
    static resultDimension(opCode, g0, g1) {
        const dim0 = g0.getDimension();
        const dim1 = g1.getDimension();
        let resultDimension = -1;
        switch(opCode){
            case OverlayOp.INTERSECTION:
                resultDimension = Math.min(dim0, dim1);
                break;
            case OverlayOp.UNION:
                resultDimension = Math.max(dim0, dim1);
                break;
            case OverlayOp.DIFFERENCE:
                resultDimension = dim0;
                break;
            case OverlayOp.SYMDIFFERENCE:
                resultDimension = Math.max(dim0, dim1);
                break;
        }
        return resultDimension;
    }
    static createEmptyResult(overlayOpCode, a, b, geomFact) {
        let result = null;
        const resultDim = OverlayOp.resultDimension(overlayOpCode, a, b);
        return result = geomFact.createEmpty(resultDim);
    }
    static difference(geom, other) {
        if (geom.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, geom, other, geom.getFactory());
        if (other.isEmpty()) return geom.copy();
        if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new (0, _illegalArgumentExceptionJsDefault.default)('This method does not support GeometryCollection arguments');
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(geom, other, OverlayOp.DIFFERENCE);
    }
    static isResultOfOp() {
        if (arguments.length === 2) {
            const label = arguments[0], opCode = arguments[1];
            const loc0 = label.getLocation(0);
            const loc1 = label.getLocation(1);
            return OverlayOp.isResultOfOp(loc0, loc1, opCode);
        } else if (arguments.length === 3) {
            let loc0 = arguments[0], loc1 = arguments[1], overlayOpCode = arguments[2];
            if (loc0 === (0, _locationJsDefault.default).BOUNDARY) loc0 = (0, _locationJsDefault.default).INTERIOR;
            if (loc1 === (0, _locationJsDefault.default).BOUNDARY) loc1 = (0, _locationJsDefault.default).INTERIOR;
            switch(overlayOpCode){
                case OverlayOp.INTERSECTION:
                    return loc0 === (0, _locationJsDefault.default).INTERIOR && loc1 === (0, _locationJsDefault.default).INTERIOR;
                case OverlayOp.UNION:
                    return loc0 === (0, _locationJsDefault.default).INTERIOR || loc1 === (0, _locationJsDefault.default).INTERIOR;
                case OverlayOp.DIFFERENCE:
                    return loc0 === (0, _locationJsDefault.default).INTERIOR && loc1 !== (0, _locationJsDefault.default).INTERIOR;
                case OverlayOp.SYMDIFFERENCE:
                    return loc0 === (0, _locationJsDefault.default).INTERIOR && loc1 !== (0, _locationJsDefault.default).INTERIOR || loc0 !== (0, _locationJsDefault.default).INTERIOR && loc1 === (0, _locationJsDefault.default).INTERIOR;
            }
            return false;
        }
    }
    insertUniqueEdge(e) {
        const existingEdge = this._edgeList.findEqualEdge(e);
        if (existingEdge !== null) {
            const existingLabel = existingEdge.getLabel();
            let labelToMerge = e.getLabel();
            if (!existingEdge.isPointwiseEqual(e)) {
                labelToMerge = new (0, _labelJsDefault.default)(e.getLabel());
                labelToMerge.flip();
            }
            const depth = existingEdge.getDepth();
            if (depth.isNull()) depth.add(existingLabel);
            depth.add(labelToMerge);
            existingLabel.merge(labelToMerge);
        } else this._edgeList.add(e);
    }
    getGraph() {
        return this._graph;
    }
    cancelDuplicateResultEdges() {
        for(let it = this._graph.getEdgeEnds().iterator(); it.hasNext();){
            const de = it.next();
            const sym = de.getSym();
            if (de.isInResult() && sym.isInResult()) {
                de.setInResult(false);
                sym.setInResult(false);
            }
        }
    }
    mergeSymLabels() {
        for(let nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().mergeSymLabels();
        }
    }
    computeOverlay(opCode) {
        this.copyPoints(0);
        this.copyPoints(1);
        this._arg[0].computeSelfNodes(this._li, false);
        this._arg[1].computeSelfNodes(this._li, false);
        this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
        const baseSplitEdges = new (0, _arrayListJsDefault.default)();
        this._arg[0].computeSplitEdges(baseSplitEdges);
        this._arg[1].computeSplitEdges(baseSplitEdges);
        const splitEdges = baseSplitEdges;
        this.insertUniqueEdges(baseSplitEdges);
        this.computeLabelsFromDepths();
        this.replaceCollapsedEdges();
        (0, _edgeNodingValidatorJsDefault.default).checkValid(this._edgeList.getEdges());
        this._graph.addEdges(this._edgeList.getEdges());
        this.computeLabelling();
        this.labelIncompleteNodes();
        this.findResultAreaEdges(opCode);
        this.cancelDuplicateResultEdges();
        const polyBuilder = new (0, _polygonBuilderJsDefault.default)(this._geomFact);
        polyBuilder.add(this._graph);
        this._resultPolyList = polyBuilder.getPolygons();
        const lineBuilder = new (0, _lineBuilderJsDefault.default)(this, this._geomFact, this._ptLocator);
        this._resultLineList = lineBuilder.build(opCode);
        const pointBuilder = new (0, _pointBuilderJsDefault.default)(this, this._geomFact, this._ptLocator);
        this._resultPointList = pointBuilder.build(opCode);
        this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
    }
    findResultAreaEdges(opCode) {
        for(let it = this._graph.getEdgeEnds().iterator(); it.hasNext();){
            const de = it.next();
            const label = de.getLabel();
            if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, (0, _positionJsDefault.default).RIGHT), label.getLocation(1, (0, _positionJsDefault.default).RIGHT), opCode)) de.setInResult(true);
        }
    }
    computeLabelsFromDepths() {
        for(let it = this._edgeList.iterator(); it.hasNext();){
            const e = it.next();
            const lbl = e.getLabel();
            const depth = e.getDepth();
            if (!depth.isNull()) {
                depth.normalize();
                for(let i = 0; i < 2; i++)if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {
                    if (depth.getDelta(i) === 0) lbl.toLine(i);
                    else {
                        (0, _assertJsDefault.default).isTrue(!depth.isNull(i, (0, _positionJsDefault.default).LEFT), 'depth of LEFT side has not been initialized');
                        lbl.setLocation(i, (0, _positionJsDefault.default).LEFT, depth.getLocation(i, (0, _positionJsDefault.default).LEFT));
                        (0, _assertJsDefault.default).isTrue(!depth.isNull(i, (0, _positionJsDefault.default).RIGHT), 'depth of RIGHT side has not been initialized');
                        lbl.setLocation(i, (0, _positionJsDefault.default).RIGHT, depth.getLocation(i, (0, _positionJsDefault.default).RIGHT));
                    }
                }
            }
        }
    }
    isCoveredByA(coord) {
        if (this.isCovered(coord, this._resultPolyList)) return true;
        return false;
    }
    isCoveredByLA(coord) {
        if (this.isCovered(coord, this._resultLineList)) return true;
        if (this.isCovered(coord, this._resultPolyList)) return true;
        return false;
    }
    computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {
        const geomList = new (0, _arrayListJsDefault.default)();
        geomList.addAll(resultPointList);
        geomList.addAll(resultLineList);
        geomList.addAll(resultPolyList);
        if (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);
        return this._geomFact.buildGeometry(geomList);
    }
    isCovered(coord, geomList) {
        for(let it = geomList.iterator(); it.hasNext();){
            const geom = it.next();
            const loc = this._ptLocator.locate(coord, geom);
            if (loc !== (0, _locationJsDefault.default).EXTERIOR) return true;
        }
        return false;
    }
    replaceCollapsedEdges() {
        const newEdges = new (0, _arrayListJsDefault.default)();
        for(let it = this._edgeList.iterator(); it.hasNext();){
            const e = it.next();
            if (e.isCollapsed()) {
                it.remove();
                newEdges.add(e.getCollapsedEdge());
            }
        }
        this._edgeList.addAll(newEdges);
    }
    updateNodeLabelling() {
        for(let nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            const lbl = node.getEdges().getLabel();
            node.getLabel().merge(lbl);
        }
    }
    getResultGeometry(overlayOpCode) {
        this.computeOverlay(overlayOpCode);
        return this._resultGeom;
    }
    insertUniqueEdges(edges) {
        for(let i = edges.iterator(); i.hasNext();){
            const e = i.next();
            this.insertUniqueEdge(e);
        }
    }
    labelIncompleteNode(n, targetIndex) {
        const loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
        n.getLabel().setLocation(targetIndex, loc);
    }
    copyPoints(argIndex) {
        for(let i = this._arg[argIndex].getNodeIterator(); i.hasNext();){
            const graphNode = i.next();
            const newNode = this._graph.addNode(graphNode.getCoordinate());
            newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
        }
    }
    computeLabelling() {
        for(let nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().computeLabelling(this._arg);
        }
        this.mergeSymLabels();
        this.updateNodeLabelling();
    }
    labelIncompleteNodes() {
        for(let ni = this._graph.getNodes().iterator(); ni.hasNext();){
            const n = ni.next();
            const label = n.getLabel();
            if (n.isIsolated()) {
                if (label.isNull(0)) this.labelIncompleteNode(n, 0);
                else this.labelIncompleteNode(n, 1);
            }
            n.getEdges().updateLabelling(label);
        }
    }
}
exports.default = OverlayOp;
OverlayOp.INTERSECTION = 1;
OverlayOp.UNION = 2;
OverlayOp.DIFFERENCE = 3;
OverlayOp.SYMDIFFERENCE = 4;

},{"./PolygonBuilder.js":"crM1Q","../../geomgraph/Position.js":"13raO","../../../../../java/lang/IllegalArgumentException.js":"9ppVW","./LineBuilder.js":"2O8Aa","./PointBuilder.js":"cvTMk","./snap/SnapIfNeededOverlayOp.js":"gxP36","../../geomgraph/Label.js":"dJJOo","../../../../../java/util/ArrayList.js":"gGAQZ","../../util/Assert.js":"1vSRy","../../geomgraph/PlanarGraph.js":"etG4v","../../algorithm/PointLocator.js":"lFmUP","../../geom/Location.js":"9aPCX","../../geomgraph/EdgeNodingValidator.js":"aLQ5t","../../geom/util/GeometryCollectionMapper.js":"kOSsM","./OverlayNodeFactory.js":"2jxBb","../GeometryGraphOperation.js":"3eQ0s","../../geomgraph/EdgeList.js":"cqdlm","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2O8Aa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _overlayOpJs = require("./OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
class LineBuilder {
    constructor(){
        LineBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._op = null;
        this._geometryFactory = null;
        this._ptLocator = null;
        this._lineEdgesList = new (0, _arrayListJsDefault.default)();
        this._resultLineList = new (0, _arrayListJsDefault.default)();
        const op = arguments[0], geometryFactory = arguments[1], ptLocator = arguments[2];
        this._op = op;
        this._geometryFactory = geometryFactory;
        this._ptLocator = ptLocator;
    }
    collectLines(opCode) {
        for(let it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();){
            const de = it.next();
            this.collectLineEdge(de, opCode, this._lineEdgesList);
            this.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);
        }
    }
    labelIsolatedLine(e, targetIndex) {
        const loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));
        e.getLabel().setLocation(targetIndex, loc);
    }
    build(opCode) {
        this.findCoveredLineEdges();
        this.collectLines(opCode);
        this.buildLines(opCode);
        return this._resultLineList;
    }
    collectLineEdge(de, opCode, edges) {
        const label = de.getLabel();
        const e = de.getEdge();
        if (de.isLineEdge()) {
            if (!de.isVisited() && (0, _overlayOpJsDefault.default).isResultOfOp(label, opCode) && !e.isCovered()) {
                edges.add(e);
                de.setVisitedEdge(true);
            }
        }
    }
    findCoveredLineEdges() {
        for(let nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().findCoveredLineEdges();
        }
        for(let it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();){
            const de = it.next();
            const e = de.getEdge();
            if (de.isLineEdge() && !e.isCoveredSet()) {
                const isCovered = this._op.isCoveredByA(de.getCoordinate());
                e.setCovered(isCovered);
            }
        }
    }
    labelIsolatedLines(edgesList) {
        for(let it = edgesList.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            if (e.isIsolated()) {
                if (label.isNull(0)) this.labelIsolatedLine(e, 0);
                else this.labelIsolatedLine(e, 1);
            }
        }
    }
    buildLines(opCode) {
        for(let it = this._lineEdgesList.iterator(); it.hasNext();){
            const e = it.next();
            const line = this._geometryFactory.createLineString(e.getCoordinates());
            this._resultLineList.add(line);
            e.setInResult(true);
        }
    }
    collectBoundaryTouchEdge(de, opCode, edges) {
        const label = de.getLabel();
        if (de.isLineEdge()) return null;
        if (de.isVisited()) return null;
        if (de.isInteriorAreaEdge()) return null;
        if (de.getEdge().isInResult()) return null;
        (0, _assertJsDefault.default).isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
        if ((0, _overlayOpJsDefault.default).isResultOfOp(label, opCode) && opCode === (0, _overlayOpJsDefault.default).INTERSECTION) {
            edges.add(de.getEdge());
            de.setVisitedEdge(true);
        }
    }
}
exports.default = LineBuilder;

},{"../../../../../java/util/ArrayList.js":"gGAQZ","../../util/Assert.js":"1vSRy","./OverlayOp.js":"9f5ft","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cvTMk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _overlayOpJs = require("./OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
class PointBuilder {
    constructor(){
        PointBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._op = null;
        this._geometryFactory = null;
        this._resultPointList = new (0, _arrayListJsDefault.default)();
        const op = arguments[0], geometryFactory = arguments[1], ptLocator = arguments[2];
        this._op = op;
        this._geometryFactory = geometryFactory;
    }
    build(opCode) {
        this.extractNonCoveredResultNodes(opCode);
        return this._resultPointList;
    }
    extractNonCoveredResultNodes(opCode) {
        for(let nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();){
            const n = nodeit.next();
            if (n.isInResult()) continue;
            if (n.isIncidentEdgeInResult()) continue;
            if (n.getEdges().getDegree() === 0 || opCode === (0, _overlayOpJsDefault.default).INTERSECTION) {
                const label = n.getLabel();
                if ((0, _overlayOpJsDefault.default).isResultOfOp(label, opCode)) this.filterCoveredNodeToPoint(n);
            }
        }
    }
    filterCoveredNodeToPoint(n) {
        const coord = n.getCoordinate();
        if (!this._op.isCoveredByLA(coord)) {
            const pt = this._geometryFactory.createPoint(coord);
            this._resultPointList.add(pt);
        }
    }
}
exports.default = PointBuilder;

},{"../../../../../java/util/ArrayList.js":"gGAQZ","./OverlayOp.js":"9f5ft","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aLQ5t":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _basicSegmentStringJs = require("../noding/BasicSegmentString.js");
var _basicSegmentStringJsDefault = parcelHelpers.interopDefault(_basicSegmentStringJs);
var _fastNodingValidatorJs = require("../noding/FastNodingValidator.js");
var _fastNodingValidatorJsDefault = parcelHelpers.interopDefault(_fastNodingValidatorJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class EdgeNodingValidator {
    constructor(){
        EdgeNodingValidator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._nv = null;
        const edges = arguments[0];
        this._nv = new (0, _fastNodingValidatorJsDefault.default)(EdgeNodingValidator.toSegmentStrings(edges));
    }
    static toSegmentStrings(edges) {
        const segStrings = new (0, _arrayListJsDefault.default)();
        for(let i = edges.iterator(); i.hasNext();){
            const e = i.next();
            segStrings.add(new (0, _basicSegmentStringJsDefault.default)(e.getCoordinates(), e));
        }
        return segStrings;
    }
    static checkValid(edges) {
        const validator = new EdgeNodingValidator(edges);
        validator.checkValid();
    }
    checkValid() {
        this._nv.checkValid();
    }
}
exports.default = EdgeNodingValidator;

},{"../noding/BasicSegmentString.js":"fENuM","../noding/FastNodingValidator.js":"1FZBO","../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fENuM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktwriterJs = require("../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _coordinateArraySequenceJs = require("../geom/impl/CoordinateArraySequence.js");
var _coordinateArraySequenceJsDefault = parcelHelpers.interopDefault(_coordinateArraySequenceJs);
var _octantJs = require("./Octant.js");
var _octantJsDefault = parcelHelpers.interopDefault(_octantJs);
var _segmentStringJs = require("./SegmentString.js");
var _segmentStringJsDefault = parcelHelpers.interopDefault(_segmentStringJs);
class BasicSegmentString {
    constructor(){
        BasicSegmentString.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._pts = null;
        this._data = null;
        const pts = arguments[0], data = arguments[1];
        this._pts = pts;
        this._data = data;
    }
    getCoordinates() {
        return this._pts;
    }
    size() {
        return this._pts.length;
    }
    getCoordinate(i) {
        return this._pts[i];
    }
    isClosed() {
        return this._pts[0].equals(this._pts[this._pts.length - 1]);
    }
    getSegmentOctant(index) {
        if (index === this._pts.length - 1) return -1;
        return (0, _octantJsDefault.default).octant(this.getCoordinate(index), this.getCoordinate(index + 1));
    }
    setData(data) {
        this._data = data;
    }
    getData() {
        return this._data;
    }
    toString() {
        return (0, _wktwriterJsDefault.default).toLineString(new (0, _coordinateArraySequenceJsDefault.default)(this._pts));
    }
    get interfaces_() {
        return [
            (0, _segmentStringJsDefault.default)
        ];
    }
}
exports.default = BasicSegmentString;

},{"../io/WKTWriter.js":"1WLaw","../geom/impl/CoordinateArraySequence.js":"grBJo","./Octant.js":"5OU0v","./SegmentString.js":"isRVw","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1FZBO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktwriterJs = require("../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _mcindexNoderJs = require("./MCIndexNoder.js");
var _mcindexNoderJsDefault = parcelHelpers.interopDefault(_mcindexNoderJs);
var _topologyExceptionJs = require("../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _robustLineIntersectorJs = require("../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _nodingIntersectionFinderJs = require("./NodingIntersectionFinder.js");
var _nodingIntersectionFinderJsDefault = parcelHelpers.interopDefault(_nodingIntersectionFinderJs);
class FastNodingValidator {
    constructor(){
        FastNodingValidator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._segStrings = null;
        this._findAllIntersections = false;
        this._segInt = null;
        this._isValid = true;
        const segStrings = arguments[0];
        this._segStrings = segStrings;
    }
    static computeIntersections(segStrings) {
        const nv = new FastNodingValidator(segStrings);
        nv.setFindAllIntersections(true);
        nv.isValid();
        return nv.getIntersections();
    }
    isValid() {
        this.execute();
        return this._isValid;
    }
    setFindAllIntersections(findAllIntersections) {
        this._findAllIntersections = findAllIntersections;
    }
    checkInteriorIntersections() {
        this._isValid = true;
        this._segInt = new (0, _nodingIntersectionFinderJsDefault.default)(this._li);
        this._segInt.setFindAllIntersections(this._findAllIntersections);
        const noder = new (0, _mcindexNoderJsDefault.default)();
        noder.setSegmentIntersector(this._segInt);
        noder.computeNodes(this._segStrings);
        if (this._segInt.hasIntersection()) {
            this._isValid = false;
            return null;
        }
    }
    checkValid() {
        this.execute();
        if (!this._isValid) throw new (0, _topologyExceptionJsDefault.default)(this.getErrorMessage(), this._segInt.getIntersection());
    }
    getErrorMessage() {
        if (this._isValid) return 'no intersections found';
        const intSegs = this._segInt.getIntersectionSegments();
        return 'found non-noded intersection between ' + (0, _wktwriterJsDefault.default).toLineString(intSegs[0], intSegs[1]) + ' and ' + (0, _wktwriterJsDefault.default).toLineString(intSegs[2], intSegs[3]);
    }
    execute() {
        if (this._segInt !== null) return null;
        this.checkInteriorIntersections();
    }
    getIntersections() {
        return this._segInt.getIntersections();
    }
}
exports.default = FastNodingValidator;

},{"../io/WKTWriter.js":"1WLaw","./MCIndexNoder.js":"1deq0","../geom/TopologyException.js":"bOVA5","../algorithm/RobustLineIntersector.js":"kLdG9","./NodingIntersectionFinder.js":"iSydr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iSydr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _segmentIntersectorJs = require("./SegmentIntersector.js");
var _segmentIntersectorJsDefault = parcelHelpers.interopDefault(_segmentIntersectorJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class NodingIntersectionFinder {
    constructor(){
        NodingIntersectionFinder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._findAllIntersections = false;
        this._isCheckEndSegmentsOnly = false;
        this._keepIntersections = true;
        this._isInteriorIntersectionsOnly = false;
        this._li = null;
        this._interiorIntersection = null;
        this._intSegments = null;
        this._intersections = new (0, _arrayListJsDefault.default)();
        this._intersectionCount = 0;
        const li = arguments[0];
        this._li = li;
        this._interiorIntersection = null;
    }
    static createAllIntersectionsFinder(li) {
        const finder = new NodingIntersectionFinder(li);
        finder.setFindAllIntersections(true);
        return finder;
    }
    static isInteriorVertexIntersection() {
        if (arguments.length === 4) {
            const p0 = arguments[0], p1 = arguments[1], isEnd0 = arguments[2], isEnd1 = arguments[3];
            if (isEnd0 && isEnd1) return false;
            if (p0.equals2D(p1)) return true;
            return false;
        } else if (arguments.length === 8) {
            const p00 = arguments[0], p01 = arguments[1], p10 = arguments[2], p11 = arguments[3], isEnd00 = arguments[4], isEnd01 = arguments[5], isEnd10 = arguments[6], isEnd11 = arguments[7];
            if (NodingIntersectionFinder.isInteriorVertexIntersection(p00, p10, isEnd00, isEnd10)) return true;
            if (NodingIntersectionFinder.isInteriorVertexIntersection(p00, p11, isEnd00, isEnd11)) return true;
            if (NodingIntersectionFinder.isInteriorVertexIntersection(p01, p10, isEnd01, isEnd10)) return true;
            if (NodingIntersectionFinder.isInteriorVertexIntersection(p01, p11, isEnd01, isEnd11)) return true;
            return false;
        }
    }
    static createInteriorIntersectionCounter(li) {
        const finder = new NodingIntersectionFinder(li);
        finder.setInteriorIntersectionsOnly(true);
        finder.setFindAllIntersections(true);
        finder.setKeepIntersections(false);
        return finder;
    }
    static createIntersectionCounter(li) {
        const finder = new NodingIntersectionFinder(li);
        finder.setFindAllIntersections(true);
        finder.setKeepIntersections(false);
        return finder;
    }
    static isEndSegment(segStr, index) {
        if (index === 0) return true;
        if (index >= segStr.size() - 2) return true;
        return false;
    }
    static createAnyIntersectionFinder(li) {
        return new NodingIntersectionFinder(li);
    }
    static createInteriorIntersectionsFinder(li) {
        const finder = new NodingIntersectionFinder(li);
        finder.setFindAllIntersections(true);
        finder.setInteriorIntersectionsOnly(true);
        return finder;
    }
    count() {
        return this._intersectionCount;
    }
    getIntersections() {
        return this._intersections;
    }
    setFindAllIntersections(findAllIntersections) {
        this._findAllIntersections = findAllIntersections;
    }
    setKeepIntersections(keepIntersections) {
        this._keepIntersections = keepIntersections;
    }
    getIntersection() {
        return this._interiorIntersection;
    }
    processIntersections(e0, segIndex0, e1, segIndex1) {
        if (!this._findAllIntersections && this.hasIntersection()) return null;
        const isSameSegString = e0 === e1;
        const isSameSegment = isSameSegString && segIndex0 === segIndex1;
        if (isSameSegment) return null;
        if (this._isCheckEndSegmentsOnly) {
            const isEndSegPresent = NodingIntersectionFinder.isEndSegment(e0, segIndex0) || NodingIntersectionFinder.isEndSegment(e1, segIndex1);
            if (!isEndSegPresent) return null;
        }
        const p00 = e0.getCoordinate(segIndex0);
        const p01 = e0.getCoordinate(segIndex0 + 1);
        const p10 = e1.getCoordinate(segIndex1);
        const p11 = e1.getCoordinate(segIndex1 + 1);
        const isEnd00 = segIndex0 === 0;
        const isEnd01 = segIndex0 + 2 === e0.size();
        const isEnd10 = segIndex1 === 0;
        const isEnd11 = segIndex1 + 2 === e1.size();
        this._li.computeIntersection(p00, p01, p10, p11);
        const isInteriorInt = this._li.hasIntersection() && this._li.isInteriorIntersection();
        let isInteriorVertexInt = false;
        if (!this._isInteriorIntersectionsOnly) {
            const isAdjacentSegment = isSameSegString && Math.abs(segIndex1 - segIndex0) <= 1;
            isInteriorVertexInt = !isAdjacentSegment && NodingIntersectionFinder.isInteriorVertexIntersection(p00, p01, p10, p11, isEnd00, isEnd01, isEnd10, isEnd11);
        }
        if (isInteriorInt || isInteriorVertexInt) {
            this._intSegments = new Array(4).fill(null);
            this._intSegments[0] = p00;
            this._intSegments[1] = p01;
            this._intSegments[2] = p10;
            this._intSegments[3] = p11;
            this._interiorIntersection = this._li.getIntersection(0);
            if (this._keepIntersections) this._intersections.add(this._interiorIntersection);
            this._intersectionCount++;
        }
    }
    hasIntersection() {
        return this._interiorIntersection !== null;
    }
    isDone() {
        if (this._findAllIntersections) return false;
        return this._interiorIntersection !== null;
    }
    setInteriorIntersectionsOnly(isInteriorIntersectionsOnly) {
        this._isInteriorIntersectionsOnly = isInteriorIntersectionsOnly;
    }
    setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {
        this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
    }
    getIntersectionSegments() {
        return this._intSegments;
    }
    get interfaces_() {
        return [
            (0, _segmentIntersectorJsDefault.default)
        ];
    }
}
exports.default = NodingIntersectionFinder;

},{"./SegmentIntersector.js":"jNast","../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kOSsM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryFactoryJs = require("../GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class GeometryCollectionMapper {
    constructor(){
        GeometryCollectionMapper.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._mapOp = null;
        const mapOp = arguments[0];
        this._mapOp = mapOp;
    }
    static map(gc, op) {
        const mapper = new GeometryCollectionMapper(op);
        return mapper.map(gc);
    }
    map(gc) {
        const mapped = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < gc.getNumGeometries(); i++){
            const g = this._mapOp.map(gc.getGeometryN(i));
            if (!g.isEmpty()) mapped.add(g);
        }
        return gc.getFactory().createGeometryCollection((0, _geometryFactoryJsDefault.default).toGeometryArray(mapped));
    }
}
exports.default = GeometryCollectionMapper;

},{"../GeometryFactory.js":"cGt0T","../../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fRnOp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _geometryJs = require("../../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _collectionJs = require("../../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _pointJs = require("../../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("../../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _geometryCollectionJs = require("../../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _dimensionJs = require("../../geom/Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _geometryFilterJs = require("../../geom/GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class InputExtracter {
    constructor(){
        InputExtracter.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geomFactory = null;
        this._polygons = new (0, _arrayListJsDefault.default)();
        this._lines = new (0, _arrayListJsDefault.default)();
        this._points = new (0, _arrayListJsDefault.default)();
        this._dimension = (0, _dimensionJsDefault.default).FALSE;
    }
    static extract() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const geoms = arguments[0];
            const extracter = new InputExtracter();
            extracter.add(geoms);
            return extracter;
        } else if (arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const geom = arguments[0];
            const extracter = new InputExtracter();
            extracter.add(geom);
            return extracter;
        }
    }
    getFactory() {
        return this._geomFactory;
    }
    filter(geom) {
        this.recordDimension(geom.getDimension());
        if (geom instanceof (0, _geometryCollectionJsDefault.default)) return null;
        if (geom.isEmpty()) return null;
        if (geom instanceof (0, _polygonJsDefault.default)) {
            this._polygons.add(geom);
            return null;
        } else if (geom instanceof (0, _lineStringJsDefault.default)) {
            this._lines.add(geom);
            return null;
        } else if (geom instanceof (0, _pointJsDefault.default)) {
            this._points.add(geom);
            return null;
        }
        (0, _assertJsDefault.default).shouldNeverReachHere('Unhandled geometry type: ' + geom.getGeometryType());
    }
    getExtract(dim) {
        switch(dim){
            case 0:
                return this._points;
            case 1:
                return this._lines;
            case 2:
                return this._polygons;
        }
        (0, _assertJsDefault.default).shouldNeverReachHere('Invalid dimension: ' + dim);
        return null;
    }
    recordDimension(dim) {
        if (dim > this._dimension) this._dimension = dim;
    }
    getDimension() {
        return this._dimension;
    }
    isEmpty() {
        return this._polygons.isEmpty() && this._lines.isEmpty() && this._points.isEmpty();
    }
    add() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const geoms = arguments[0];
            for (const geom of geoms)this.add(geom);
        } else if (arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const geom = arguments[0];
            if (this._geomFactory === null) this._geomFactory = geom.getFactory();
            geom.apply(this);
        }
    }
    get interfaces_() {
        return [
            (0, _geometryFilterJsDefault.default)
        ];
    }
}
exports.default = InputExtracter;

},{"../../geom/LineString.js":"4eIEg","../../geom/Geometry.js":"9DSzO","../../../../../hasInterface.js":"5bpze","../../../../../java/util/Collection.js":"cggki","../../geom/Point.js":"lwZpO","../../geom/Polygon.js":"kpOA5","../../geom/GeometryCollection.js":"6RJQO","../../geom/Dimension.js":"kWqD0","../../../../../java/util/ArrayList.js":"gGAQZ","../../geom/GeometryFilter.js":"fZPJo","../../util/Assert.js":"1vSRy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8dfi7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _treeSetJs = require("../../../../../java/util/TreeSet.js");
var _treeSetJsDefault = parcelHelpers.interopDefault(_treeSetJs);
var _geometryCombinerJs = require("../../geom/util/GeometryCombiner.js");
var _geometryCombinerJsDefault = parcelHelpers.interopDefault(_geometryCombinerJs);
var _coordinateArraysJs = require("../../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _pointLocatorJs = require("../../algorithm/PointLocator.js");
var _pointLocatorJsDefault = parcelHelpers.interopDefault(_pointLocatorJs);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
class PointGeometryUnion {
    constructor(){
        PointGeometryUnion.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._pointGeom = null;
        this._otherGeom = null;
        this._geomFact = null;
        const pointGeom = arguments[0], otherGeom = arguments[1];
        this._pointGeom = pointGeom;
        this._otherGeom = otherGeom;
        this._geomFact = otherGeom.getFactory();
    }
    static union(pointGeom, otherGeom) {
        const unioner = new PointGeometryUnion(pointGeom, otherGeom);
        return unioner.union();
    }
    union() {
        const locater = new (0, _pointLocatorJsDefault.default)();
        const exteriorCoords = new (0, _treeSetJsDefault.default)();
        for(let i = 0; i < this._pointGeom.getNumGeometries(); i++){
            const point = this._pointGeom.getGeometryN(i);
            const coord = point.getCoordinate();
            const loc = locater.locate(coord, this._otherGeom);
            if (loc === (0, _locationJsDefault.default).EXTERIOR) exteriorCoords.add(coord);
        }
        if (exteriorCoords.size() === 0) return this._otherGeom;
        let ptComp = null;
        const coords = (0, _coordinateArraysJsDefault.default).toCoordinateArray(exteriorCoords);
        if (coords.length === 1) ptComp = this._geomFact.createPoint(coords[0]);
        else ptComp = this._geomFact.createMultiPointFromCoords(coords);
        return (0, _geometryCombinerJsDefault.default).combine(ptComp, this._otherGeom);
    }
}
exports.default = PointGeometryUnion;

},{"../../../../../java/util/TreeSet.js":"is5ah","../../geom/util/GeometryCombiner.js":"gAQ1x","../../geom/CoordinateArrays.js":"lncg4","../../algorithm/PointLocator.js":"lFmUP","../../geom/Location.js":"9aPCX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gAQ1x":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class GeometryCombiner {
    constructor(){
        GeometryCombiner.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geomFactory = null;
        this._skipEmpty = false;
        this._inputGeoms = null;
        const geoms = arguments[0];
        this._geomFactory = GeometryCombiner.extractFactory(geoms);
        this._inputGeoms = geoms;
    }
    static extractFactory(geoms) {
        if (geoms.isEmpty()) return null;
        return geoms.iterator().next().getFactory();
    }
    static createList() {
        if (arguments.length === 2) {
            const obj0 = arguments[0], obj1 = arguments[1];
            const list = new (0, _arrayListJsDefault.default)();
            list.add(obj0);
            list.add(obj1);
            return list;
        } else if (arguments.length === 3) {
            const obj0 = arguments[0], obj1 = arguments[1], obj2 = arguments[2];
            const list = new (0, _arrayListJsDefault.default)();
            list.add(obj0);
            list.add(obj1);
            list.add(obj2);
            return list;
        }
    }
    static combine() {
        if (arguments.length === 1) {
            const geoms = arguments[0];
            const combiner = new GeometryCombiner(geoms);
            return combiner.combine();
        } else if (arguments.length === 2) {
            const g0 = arguments[0], g1 = arguments[1];
            const combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));
            return combiner.combine();
        } else if (arguments.length === 3) {
            const g0 = arguments[0], g1 = arguments[1], g2 = arguments[2];
            const combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1, g2));
            return combiner.combine();
        }
    }
    extractElements(geom, elems) {
        if (geom === null) return null;
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const elemGeom = geom.getGeometryN(i);
            if (this._skipEmpty && elemGeom.isEmpty()) continue;
            elems.add(elemGeom);
        }
    }
    combine() {
        const elems = new (0, _arrayListJsDefault.default)();
        for(let i = this._inputGeoms.iterator(); i.hasNext();){
            const g = i.next();
            this.extractElements(g, elems);
        }
        if (elems.size() === 0) {
            if (this._geomFactory !== null) return this._geomFactory.createGeometryCollection();
            return null;
        }
        return this._geomFactory.buildGeometry(elems);
    }
}
exports.default = GeometryCombiner;

},{"../../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"63KSD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _polygonExtracterJs = require("../../geom/util/PolygonExtracter.js");
var _polygonExtracterJsDefault = parcelHelpers.interopDefault(_polygonExtracterJs);
var _overlapUnionJs = require("./OverlapUnion.js");
var _overlapUnionJsDefault = parcelHelpers.interopDefault(_overlapUnionJs);
var _strtreeJs = require("../../index/strtree/STRtree.js");
var _strtreeJsDefault = parcelHelpers.interopDefault(_strtreeJs);
var _geometryJs = require("../../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _listJs = require("../../../../../java/util/List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
var _illegalStateExceptionJs = require("../../../../../java/lang/IllegalStateException.js");
var _illegalStateExceptionJsDefault = parcelHelpers.interopDefault(_illegalStateExceptionJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _geometryFactoryJs = require("../../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _polygonalJs = require("../../geom/Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class CascadedPolygonUnion {
    constructor(){
        CascadedPolygonUnion.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._inputPolys = null;
        this._geomFactory = null;
        const polys = arguments[0];
        this._inputPolys = polys;
        if (this._inputPolys === null) this._inputPolys = new (0, _arrayListJsDefault.default)();
    }
    static getGeometry(list, index) {
        if (index >= list.size()) return null;
        return list.get(index);
    }
    static union(polys) {
        const op = new CascadedPolygonUnion(polys);
        return op.union();
    }
    static restrictToPolygons(g) {
        if ((0, _hasInterfaceJsDefault.default)(g, (0, _polygonalJsDefault.default))) return g;
        const polygons = (0, _polygonExtracterJsDefault.default).getPolygons(g);
        if (polygons.size() === 1) return polygons.get(0);
        return g.getFactory().createMultiPolygon((0, _geometryFactoryJsDefault.default).toPolygonArray(polygons));
    }
    reduceToGeometries(geomTree) {
        const geoms = new (0, _arrayListJsDefault.default)();
        for(let i = geomTree.iterator(); i.hasNext();){
            const o = i.next();
            let geom = null;
            if ((0, _hasInterfaceJsDefault.default)(o, (0, _listJsDefault.default))) geom = this.unionTree(o);
            else if (o instanceof (0, _geometryJsDefault.default)) geom = o;
            geoms.add(geom);
        }
        return geoms;
    }
    union() {
        if (this._inputPolys === null) throw new (0, _illegalStateExceptionJsDefault.default)('union() method cannot be called twice');
        if (this._inputPolys.isEmpty()) return null;
        this._geomFactory = this._inputPolys.iterator().next().getFactory();
        const index = new (0, _strtreeJsDefault.default)(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);
        for(let i = this._inputPolys.iterator(); i.hasNext();){
            const item = i.next();
            index.insert(item.getEnvelopeInternal(), item);
        }
        this._inputPolys = null;
        const itemTree = index.itemsTree();
        const unionAll = this.unionTree(itemTree);
        return unionAll;
    }
    binaryUnion() {
        if (arguments.length === 1) {
            const geoms = arguments[0];
            return this.binaryUnion(geoms, 0, geoms.size());
        } else if (arguments.length === 3) {
            const geoms = arguments[0], start = arguments[1], end = arguments[2];
            if (end - start <= 1) {
                const g0 = CascadedPolygonUnion.getGeometry(geoms, start);
                return this.unionSafe(g0, null);
            } else if (end - start === 2) return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms, start), CascadedPolygonUnion.getGeometry(geoms, start + 1));
            else {
                const mid = Math.trunc((end + start) / 2);
                const g0 = this.binaryUnion(geoms, start, mid);
                const g1 = this.binaryUnion(geoms, mid, end);
                return this.unionSafe(g0, g1);
            }
        }
    }
    unionSafe(g0, g1) {
        if (g0 === null && g1 === null) return null;
        if (g0 === null) return g1.copy();
        if (g1 === null) return g0.copy();
        return this.unionActual(g0, g1);
    }
    unionActual(g0, g1) {
        const union = (0, _overlapUnionJsDefault.default).union(g0, g1);
        return CascadedPolygonUnion.restrictToPolygons(union);
    }
    unionTree(geomTree) {
        const geoms = this.reduceToGeometries(geomTree);
        const union = this.binaryUnion(geoms);
        return union;
    }
}
exports.default = CascadedPolygonUnion;
CascadedPolygonUnion.STRTREE_NODE_CAPACITY = 4;

},{"../../geom/util/PolygonExtracter.js":"5SZnk","./OverlapUnion.js":"eiSu5","../../index/strtree/STRtree.js":"2wZHu","../../geom/Geometry.js":"9DSzO","../../../../../java/util/List.js":"7jAhK","../../../../../java/lang/IllegalStateException.js":"efv6w","../../../../../hasInterface.js":"5bpze","../../geom/GeometryFactory.js":"cGt0T","../../geom/Polygonal.js":"jIBid","../../../../../java/util/ArrayList.js":"gGAQZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5SZnk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _polygonJs = require("../Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _geometryCollectionJs = require("../GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _geometryFilterJs = require("../GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
class PolygonExtracter {
    constructor(){
        PolygonExtracter.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._comps = null;
        const comps = arguments[0];
        this._comps = comps;
    }
    static getPolygons() {
        if (arguments.length === 1) {
            const geom = arguments[0];
            return PolygonExtracter.getPolygons(geom, new (0, _arrayListJsDefault.default)());
        } else if (arguments.length === 2) {
            const geom = arguments[0], list = arguments[1];
            if (geom instanceof (0, _polygonJsDefault.default)) list.add(geom);
            else if (geom instanceof (0, _geometryCollectionJsDefault.default)) geom.apply(new PolygonExtracter(list));
            return list;
        }
    }
    filter(geom) {
        if (geom instanceof (0, _polygonJsDefault.default)) this._comps.add(geom);
    }
    get interfaces_() {
        return [
            (0, _geometryFilterJsDefault.default)
        ];
    }
}
exports.default = PolygonExtracter;

},{"../Polygon.js":"kpOA5","../GeometryCollection.js":"6RJQO","../../../../../java/util/ArrayList.js":"gGAQZ","../GeometryFilter.js":"fZPJo","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eiSu5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashSetJs = require("../../../../../java/util/HashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
var _unionOpJs = require("./UnionOp.js");
var _unionOpJsDefault = parcelHelpers.interopDefault(_unionOpJs);
var _topologyExceptionJs = require("../../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _coordinateSequenceFilterJs = require("../../geom/CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
var _bufferOpJs = require("../buffer/BufferOp.js");
var _bufferOpJsDefault = parcelHelpers.interopDefault(_bufferOpJs);
var _geometryCombinerJs = require("../../geom/util/GeometryCombiner.js");
var _geometryCombinerJsDefault = parcelHelpers.interopDefault(_geometryCombinerJs);
class OverlapUnion {
    constructor(){
        OverlapUnion.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geomFactory = null;
        this._g0 = null;
        this._g1 = null;
        this._isUnionSafe = null;
        const g0 = arguments[0], g1 = arguments[1];
        this._g0 = g0;
        this._g1 = g1;
        this._geomFactory = g0.getFactory();
    }
    static containsProperly() {
        if (arguments.length === 2) {
            const env = arguments[0], p = arguments[1];
            if (env.isNull()) return false;
            return p.getX() > env.getMinX() && p.getX() < env.getMaxX() && p.getY() > env.getMinY() && p.getY() < env.getMaxY();
        } else if (arguments.length === 3) {
            const env = arguments[0], p0 = arguments[1], p1 = arguments[2];
            return OverlapUnion.containsProperly(env, p0) && OverlapUnion.containsProperly(env, p1);
        }
    }
    static union(g0, g1) {
        const union = new OverlapUnion(g0, g1);
        return union.union();
    }
    static intersects(env, p0, p1) {
        return env.intersects(p0) || env.intersects(p1);
    }
    static overlapEnvelope(g0, g1) {
        const g0Env = g0.getEnvelopeInternal();
        const g1Env = g1.getEnvelopeInternal();
        const overlapEnv = g0Env.intersection(g1Env);
        return overlapEnv;
    }
    static extractBorderSegments(geom, env, segs) {
        geom.apply(new class {
            get interfaces_() {
                return [
                    (0, _coordinateSequenceFilterJsDefault.default)
                ];
            }
            filter(seq, i) {
                if (i <= 0) return null;
                const p0 = seq.getCoordinate(i - 1);
                const p1 = seq.getCoordinate(i);
                const isBorder = OverlapUnion.intersects(env, p0, p1) && !OverlapUnion.containsProperly(env, p0, p1);
                if (isBorder) {
                    const seg = new (0, _lineSegmentJsDefault.default)(p0, p1);
                    segs.add(seg);
                }
            }
            isDone() {
                return false;
            }
            isGeometryChanged() {
                return false;
            }
        }());
    }
    static unionBuffer(g0, g1) {
        const factory = g0.getFactory();
        const gColl = factory.createGeometryCollection([
            g0,
            g1
        ]);
        const union = (0, _bufferOpJsDefault.default).bufferOp(gColl, 0.0);
        return union;
    }
    isBorderSegmentsSame(result, env) {
        const segsBefore = this.extractBorderSegments(this._g0, this._g1, env);
        const segsAfter = new (0, _arrayListJsDefault.default)();
        OverlapUnion.extractBorderSegments(result, env, segsAfter);
        return this.isEqual(segsBefore, segsAfter);
    }
    union() {
        const overlapEnv = OverlapUnion.overlapEnvelope(this._g0, this._g1);
        if (overlapEnv.isNull()) {
            const g0Copy = this._g0.copy();
            const g1Copy = this._g1.copy();
            return (0, _geometryCombinerJsDefault.default).combine(g0Copy, g1Copy);
        }
        const disjointPolys = new (0, _arrayListJsDefault.default)();
        const g0Overlap = this.extractByEnvelope(overlapEnv, this._g0, disjointPolys);
        const g1Overlap = this.extractByEnvelope(overlapEnv, this._g1, disjointPolys);
        const unionGeom = this.unionFull(g0Overlap, g1Overlap);
        let result = null;
        this._isUnionSafe = this.isBorderSegmentsSame(unionGeom, overlapEnv);
        if (!this._isUnionSafe) result = this.unionFull(this._g0, this._g1);
        else result = this.combine(unionGeom, disjointPolys);
        return result;
    }
    extractBorderSegments(geom0, geom1, env) {
        const segs = new (0, _arrayListJsDefault.default)();
        OverlapUnion.extractBorderSegments(geom0, env, segs);
        if (geom1 !== null) OverlapUnion.extractBorderSegments(geom1, env, segs);
        return segs;
    }
    isUnionOptimized() {
        return this._isUnionSafe;
    }
    extractByEnvelope(env, geom, disjointGeoms) {
        const intersectingGeoms = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const elem = geom.getGeometryN(i);
            if (elem.getEnvelopeInternal().intersects(env)) intersectingGeoms.add(elem);
            else {
                const copy = elem.copy();
                disjointGeoms.add(copy);
            }
        }
        return this._geomFactory.buildGeometry(intersectingGeoms);
    }
    isEqual(segs0, segs1) {
        if (segs0.size() !== segs1.size()) return false;
        const segIndex = new (0, _hashSetJsDefault.default)(segs0);
        for (const seg of segs1)if (!segIndex.contains(seg)) return false;
        return true;
    }
    combine(unionGeom, disjointPolys) {
        if (disjointPolys.size() <= 0) return unionGeom;
        disjointPolys.add(unionGeom);
        const result = (0, _geometryCombinerJsDefault.default).combine(disjointPolys);
        return result;
    }
    unionFull(geom0, geom1) {
        try {
            return (0, _unionOpJsDefault.default).union(geom0, geom1);
        } catch (ex) {
            if (ex instanceof (0, _topologyExceptionJsDefault.default)) return OverlapUnion.unionBuffer(geom0, geom1);
            else throw ex;
        } finally{}
    }
}
exports.default = OverlapUnion;

},{"../../../../../java/util/HashSet.js":"a1U62","./UnionOp.js":"3YR2Y","../../geom/TopologyException.js":"bOVA5","../../geom/LineSegment.js":"8Ncbv","../../../../../java/util/ArrayList.js":"gGAQZ","../../geom/CoordinateSequenceFilter.js":"8MSah","../buffer/BufferOp.js":"1i41m","../../geom/util/GeometryCombiner.js":"gAQ1x","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3YR2Y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryJs = require("../../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _snapIfNeededOverlayOpJs = require("../overlay/snap/SnapIfNeededOverlayOp.js");
var _snapIfNeededOverlayOpJsDefault = parcelHelpers.interopDefault(_snapIfNeededOverlayOpJs);
var _overlayOpJs = require("../overlay/OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
class UnionOp {
    static union(g, other) {
        if (g.isEmpty() || other.isEmpty()) {
            if (g.isEmpty() && other.isEmpty()) return (0, _overlayOpJsDefault.default).createEmptyResult((0, _overlayOpJsDefault.default).UNION, g, other, g.getFactory());
            if (g.isEmpty()) return other.copy();
            if (other.isEmpty()) return g.copy();
        }
        (0, _geometryJsDefault.default).checkNotGeometryCollection(g);
        (0, _geometryJsDefault.default).checkNotGeometryCollection(other);
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(g, other, (0, _overlayOpJsDefault.default).UNION);
    }
}
exports.default = UnionOp;

},{"../../geom/Geometry.js":"9DSzO","../overlay/snap/SnapIfNeededOverlayOp.js":"gxP36","../overlay/OverlayOp.js":"9f5ft","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cLSxx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getNewWMTSSource", ()=>getNewWMTSSource);
parcelHelpers.export(exports, "createWMTSLayer", ()=>createWMTSLayer);
var _wmtscapabilities = require("ol/format/WMTSCapabilities");
var _wmtscapabilitiesDefault = parcelHelpers.interopDefault(_wmtscapabilities);
var _wmts = require("ol/source/WMTS");
var _wmtsDefault = parcelHelpers.interopDefault(_wmts);
var _webGLTileJs = require("ol/layer/WebGLTile.js");
var _webGLTileJsDefault = parcelHelpers.interopDefault(_webGLTileJs);
function getNewWMTSSource(geoserverURL, remoteLayer, localLayer) {
    const url = geoserverURL + '/gwc/service/wmts?REQUEST=GetCapabilities&SERVICE=WMTS';
    var parser = new (0, _wmtscapabilitiesDefault.default)();
    let options;
    fetch(url, {
        crossOrigin: 'anonymous',
        mode: 'cors'
    }).then(function(response) {
        if (response.ok) return response.text();
        else throw new Error("Network response was not ok!");
    }).then(function(text) {
        const result = parser.read(text);
        if (remoteLayer == 'ne:thromdeBoundary') {
            const layerOptions = result.Contents.Layer.find((layer)=>layer.Identifier === remoteLayer);
            if (layerOptions) options = (0, _wmts.optionsFromCapabilities)(result, {
                layer: remoteLayer,
                matrixSet: layerOptions.TileMatrixSetLink[1].TileMatrixSet,
                crossOrigin: 'anonymous',
                mode: 'cors'
            });
        }
        if (options) localLayer.setSource(new (0, _wmtsDefault.default)(options));
    });
}
function createWMTSLayer(geoserverURL, workspace, layer_name, extent) {
    const wmtsLayer = new (0, _webGLTileJsDefault.default)({
        extent: extent,
        title: "wmts-layer"
    });
    const layer = `${workspace}:${layer_name}`;
    const wmtsSource = getNewWMTSSource(geoserverURL, layer, wmtsLayer);
    return wmtsLayer;
}

},{"ol/format/WMTSCapabilities":"6ivHC","ol/source/WMTS":"gTdCA","ol/layer/WebGLTile.js":"hZssC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6ivHC":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/WMTSCapabilities
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _owsJs = require("./OWS.js");
var _owsJsDefault = parcelHelpers.interopDefault(_owsJs);
var _xmlJs = require("./XML.js");
var _xmlJsDefault = parcelHelpers.interopDefault(_xmlJs);
var _extentJs = require("../extent.js");
var _xmlJs1 = require("../xml.js");
var _xsdJs = require("./xsd.js");
var _xlinkJs = require("./xlink.js");
/**
 * @const
 * @type {Array<null|string>}
 */ const NAMESPACE_URIS = [
    null,
    'http://www.opengis.net/wmts/1.0'
];
/**
 * @const
 * @type {Array<null|string>}
 */ const OWS_NAMESPACE_URIS = [
    null,
    'http://www.opengis.net/ows/1.1'
];
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Contents': (0, _xmlJs1.makeObjectPropertySetter)(readContents)
});
/**
 * @classdesc
 * Format for reading WMTS capabilities data.
 *
 * @api
 */ class WMTSCapabilities extends (0, _xmlJsDefault.default) {
    constructor(){
        super();
        /**
     * @type {OWS}
     * @private
     */ this.owsParser_ = new (0, _owsJsDefault.default)();
    }
    /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   */ readFromNode(node) {
        let version = node.getAttribute('version');
        if (version) version = version.trim();
        let WMTSCapabilityObject = this.owsParser_.readFromNode(node);
        if (!WMTSCapabilityObject) return null;
        WMTSCapabilityObject['version'] = version;
        WMTSCapabilityObject = (0, _xmlJs1.pushParseAndPop)(WMTSCapabilityObject, PARSERS, node, []);
        return WMTSCapabilityObject ? WMTSCapabilityObject : null;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const CONTENTS_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Layer': (0, _xmlJs1.makeObjectPropertyPusher)(readLayer),
    'TileMatrixSet': (0, _xmlJs1.makeObjectPropertyPusher)(readTileMatrixSet)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const LAYER_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Style': (0, _xmlJs1.makeObjectPropertyPusher)(readStyle),
    'Format': (0, _xmlJs1.makeObjectPropertyPusher)((0, _xsdJs.readString)),
    'TileMatrixSetLink': (0, _xmlJs1.makeObjectPropertyPusher)(readTileMatrixSetLink),
    'Dimension': (0, _xmlJs1.makeObjectPropertyPusher)(readDimensions),
    'ResourceURL': (0, _xmlJs1.makeObjectPropertyPusher)(readResourceUrl)
}, (0, _xmlJs1.makeStructureNS)(OWS_NAMESPACE_URIS, {
    'Title': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'Abstract': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'WGS84BoundingBox': (0, _xmlJs1.makeObjectPropertySetter)(readBoundingBox),
    'Identifier': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString))
}));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const STYLE_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'LegendURL': (0, _xmlJs1.makeObjectPropertyPusher)(readLegendUrl)
}, (0, _xmlJs1.makeStructureNS)(OWS_NAMESPACE_URIS, {
    'Title': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'Identifier': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString))
}));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const TMS_LINKS_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'TileMatrixSet': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'TileMatrixSetLimits': (0, _xmlJs1.makeObjectPropertySetter)(readTileMatrixLimitsList)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const TMS_LIMITS_LIST_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'TileMatrixLimits': (0, _xmlJs1.makeArrayPusher)(readTileMatrixLimits)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const TMS_LIMITS_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'TileMatrix': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'MinTileRow': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
    'MaxTileRow': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
    'MinTileCol': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
    'MaxTileCol': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger))
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const DIMENSION_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Default': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'Value': (0, _xmlJs1.makeObjectPropertyPusher)((0, _xsdJs.readString))
}, (0, _xmlJs1.makeStructureNS)(OWS_NAMESPACE_URIS, {
    'Identifier': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString))
}));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const WGS84_BBOX_READERS = (0, _xmlJs1.makeStructureNS)(OWS_NAMESPACE_URIS, {
    'LowerCorner': (0, _xmlJs1.makeArrayPusher)(readCoordinates),
    'UpperCorner': (0, _xmlJs1.makeArrayPusher)(readCoordinates)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const TMS_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'WellKnownScaleSet': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'TileMatrix': (0, _xmlJs1.makeObjectPropertyPusher)(readTileMatrix)
}, (0, _xmlJs1.makeStructureNS)(OWS_NAMESPACE_URIS, {
    'SupportedCRS': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'Identifier': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'BoundingBox': (0, _xmlJs1.makeObjectPropertySetter)(readBoundingBox)
}));
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const TM_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'TopLeftCorner': (0, _xmlJs1.makeObjectPropertySetter)(readCoordinates),
    'ScaleDenominator': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readDecimal)),
    'TileWidth': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
    'TileHeight': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
    'MatrixWidth': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
    'MatrixHeight': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger))
}, (0, _xmlJs1.makeStructureNS)(OWS_NAMESPACE_URIS, {
    'Identifier': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString))
}));
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Attribution object.
 */ function readContents(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, CONTENTS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Layers object.
 */ function readLayer(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, LAYER_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Tile Matrix Set object.
 */ function readTileMatrixSet(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, TMS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Style object.
 */ function readStyle(node, objectStack) {
    const style = (0, _xmlJs1.pushParseAndPop)({}, STYLE_PARSERS, node, objectStack);
    if (!style) return undefined;
    const isDefault = node.getAttribute('isDefault') === 'true';
    style['isDefault'] = isDefault;
    return style;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Tile Matrix Set Link object.
 */ function readTileMatrixSetLink(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, TMS_LINKS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Dimension object.
 */ function readDimensions(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, DIMENSION_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Resource URL object.
 */ function readResourceUrl(node, objectStack) {
    const format = node.getAttribute('format');
    const template = node.getAttribute('template');
    const resourceType = node.getAttribute('resourceType');
    const resource = {};
    if (format) resource['format'] = format;
    if (template) resource['template'] = template;
    if (resourceType) resource['resourceType'] = resourceType;
    return resource;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} BBox object.
 */ function readBoundingBox(node, objectStack) {
    const coordinates = (0, _xmlJs1.pushParseAndPop)([], WGS84_BBOX_READERS, node, objectStack);
    if (coordinates.length != 2) return undefined;
    return (0, _extentJs.boundingExtent)(coordinates);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Legend object.
 */ function readLegendUrl(node, objectStack) {
    const legend = {};
    legend['format'] = node.getAttribute('format');
    legend['href'] = (0, _xlinkJs.readHref)(node);
    return legend;
}
/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Coordinates object.
 */ function readCoordinates(node, objectStack) {
    const coordinates = (0, _xsdJs.readString)(node).split(/\s+/);
    if (!coordinates || coordinates.length != 2) return undefined;
    const x = +coordinates[0];
    const y = +coordinates[1];
    if (isNaN(x) || isNaN(y)) return undefined;
    return [
        x,
        y
    ];
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} TileMatrix object.
 */ function readTileMatrix(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, TM_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} TileMatrixSetLimits Object.
 */ function readTileMatrixLimitsList(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)([], TMS_LIMITS_LIST_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} TileMatrixLimits Array.
 */ function readTileMatrixLimits(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, TMS_LIMITS_PARSERS, node, objectStack);
}
exports.default = WMTSCapabilities;

},{"./OWS.js":"fqtHT","./XML.js":"iv7tp","../extent.js":"bGUel","../xml.js":"4rPIo","./xsd.js":"cKLNr","./xlink.js":"jIKjY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fqtHT":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/OWS
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _xmlJs = require("./XML.js");
var _xmlJsDefault = parcelHelpers.interopDefault(_xmlJs);
var _xmlJs1 = require("../xml.js");
var _xlinkJs = require("./xlink.js");
var _xsdJs = require("./xsd.js");
/**
 * @const
 * @type {Array<null|string>}
 */ const NAMESPACE_URIS = [
    null,
    'http://www.opengis.net/ows/1.1'
];
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'ServiceIdentification': (0, _xmlJs1.makeObjectPropertySetter)(readServiceIdentification),
    'ServiceProvider': (0, _xmlJs1.makeObjectPropertySetter)(readServiceProvider),
    'OperationsMetadata': (0, _xmlJs1.makeObjectPropertySetter)(readOperationsMetadata)
});
class OWS extends (0, _xmlJsDefault.default) {
    constructor(){
        super();
    }
    /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   */ readFromNode(node) {
        const owsObject = (0, _xmlJs1.pushParseAndPop)({}, PARSERS, node, []);
        return owsObject ? owsObject : null;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const ADDRESS_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'DeliveryPoint': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'City': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'AdministrativeArea': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'PostalCode': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'Country': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'ElectronicMailAddress': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString))
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const ALLOWED_VALUES_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Value': (0, _xmlJs1.makeObjectPropertyPusher)(readValue)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const CONSTRAINT_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'AllowedValues': (0, _xmlJs1.makeObjectPropertySetter)(readAllowedValues)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const CONTACT_INFO_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Phone': (0, _xmlJs1.makeObjectPropertySetter)(readPhone),
    'Address': (0, _xmlJs1.makeObjectPropertySetter)(readAddress)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const DCP_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'HTTP': (0, _xmlJs1.makeObjectPropertySetter)(readHttp)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const HTTP_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Get': (0, _xmlJs1.makeObjectPropertyPusher)(readGet),
    'Post': undefined
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const OPERATION_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'DCP': (0, _xmlJs1.makeObjectPropertySetter)(readDcp)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const OPERATIONS_METADATA_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Operation': readOperation
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const PHONE_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Voice': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'Facsimile': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString))
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const REQUEST_METHOD_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Constraint': (0, _xmlJs1.makeObjectPropertyPusher)(readConstraint)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const SERVICE_CONTACT_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'IndividualName': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'PositionName': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'ContactInfo': (0, _xmlJs1.makeObjectPropertySetter)(readContactInfo)
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const SERVICE_IDENTIFICATION_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'Abstract': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'AccessConstraints': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'Fees': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'Title': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'ServiceTypeVersion': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'ServiceType': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString))
});
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ // @ts-ignore
const SERVICE_PROVIDER_PARSERS = (0, _xmlJs1.makeStructureNS)(NAMESPACE_URIS, {
    'ProviderName': (0, _xmlJs1.makeObjectPropertySetter)((0, _xsdJs.readString)),
    'ProviderSite': (0, _xmlJs1.makeObjectPropertySetter)((0, _xlinkJs.readHref)),
    'ServiceContact': (0, _xmlJs1.makeObjectPropertySetter)(readServiceContact)
});
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The address.
 */ function readAddress(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, ADDRESS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The values.
 */ function readAllowedValues(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, ALLOWED_VALUES_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The constraint.
 */ function readConstraint(node, objectStack) {
    const name = node.getAttribute('name');
    if (!name) return undefined;
    return (0, _xmlJs1.pushParseAndPop)({
        'name': name
    }, CONSTRAINT_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The contact info.
 */ function readContactInfo(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, CONTACT_INFO_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The DCP.
 */ function readDcp(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, DCP_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The GET object.
 */ function readGet(node, objectStack) {
    const href = (0, _xlinkJs.readHref)(node);
    if (!href) return undefined;
    return (0, _xmlJs1.pushParseAndPop)({
        'href': href
    }, REQUEST_METHOD_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The HTTP object.
 */ function readHttp(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, HTTP_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The operation.
 */ function readOperation(node, objectStack) {
    const name = node.getAttribute('name');
    const value = (0, _xmlJs1.pushParseAndPop)({}, OPERATION_PARSERS, node, objectStack);
    if (!value) return undefined;
    const object = /** @type {Object} */ objectStack[objectStack.length - 1];
    object[name] = value;
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The operations metadata.
 */ function readOperationsMetadata(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, OPERATIONS_METADATA_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The phone.
 */ function readPhone(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, PHONE_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The service identification.
 */ function readServiceIdentification(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The service contact.
 */ function readServiceContact(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, SERVICE_CONTACT_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} The service provider.
 */ function readServiceProvider(node, objectStack) {
    return (0, _xmlJs1.pushParseAndPop)({}, SERVICE_PROVIDER_PARSERS, node, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {string|undefined} The value.
 */ function readValue(node, objectStack) {
    return (0, _xsdJs.readString)(node);
}
exports.default = OWS;

},{"./XML.js":"iv7tp","../xml.js":"4rPIo","./xlink.js":"jIKjY","./xsd.js":"cKLNr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iv7tp":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/XML
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilJs = require("../util.js");
var _xmlJs = require("../xml.js");
/**
 * @classdesc
 * Generic format for reading non-feature XML data
 *
 * @abstract
 */ class XML {
    /**
   * Read the source document.
   *
   * @param {Document|Element|string} source The XML source.
   * @return {Object|null} An object representing the source.
   * @api
   */ read(source) {
        if (!source) return null;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readFromDocument(doc);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readFromDocument(/** @type {Document} */ source);
        return this.readFromNode(/** @type {Element} */ source);
    }
    /**
   * @param {Document} doc Document.
   * @return {Object|null} Object
   */ readFromDocument(doc) {
        for(let n = doc.firstChild; n; n = n.nextSibling){
            if (n.nodeType == Node.ELEMENT_NODE) return this.readFromNode(/** @type {Element} */ n);
        }
        return null;
    }
    /**
   * @abstract
   * @param {Element} node Node.
   * @return {Object|null} Object
   */ readFromNode(node) {
        (0, _utilJs.abstract)();
    }
}
exports.default = XML;

},{"../util.js":"l1iPW","../xml.js":"4rPIo","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jIKjY":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/xlink
 */ /**
 * @const
 * @type {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Element} node Node.
 * @return {string|null} href.
 */ parcelHelpers.export(exports, "readHref", ()=>readHref);
const NAMESPACE_URI = 'http://www.w3.org/1999/xlink';
function readHref(node) {
    return node.getAttributeNS(NAMESPACE_URI, 'href');
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gTdCA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/WMTS
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Generate source options from a capabilities object.
 * @param {Object} wmtsCap An object representing the capabilities document.
 * @param {!Object} config Configuration properties for the layer.  Defaults for
 *                  the layer will apply if not provided.
 *
 * Required config properties:
 *  - layer - {string} The layer identifier.
 *
 * Optional config properties:
 *  - matrixSet - {string} The matrix set identifier, required if there is
 *       more than one matrix set in the layer capabilities.
 *  - projection - {string} The desired CRS when no matrixSet is specified.
 *       eg: "EPSG:3857". If the desired projection is not available,
 *       an error is thrown.
 *  - requestEncoding - {string} url encoding format for the layer. Default is
 *       the first tile url format found in the GetCapabilities response.
 *  - style - {string} The name of the style
 *  - format - {string} Image format for the layer. Default is the first
 *       format returned in the GetCapabilities response.
 *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.
 * @return {Options|null} WMTS source options object or `null` if the layer was not found.
 * @api
 */ parcelHelpers.export(exports, "optionsFromCapabilities", ()=>optionsFromCapabilities);
var _tileImageJs = require("./TileImage.js");
var _tileImageJsDefault = parcelHelpers.interopDefault(_tileImageJs);
var _uriJs = require("../uri.js");
var _extentJs = require("../extent.js");
var _wmtsJs = require("../tilegrid/WMTS.js");
var _tileurlfunctionJs = require("../tileurlfunction.js");
var _projJs = require("../proj.js");
/**
 * Request encoding. One of 'KVP', 'REST'.
 * @typedef {'KVP' | 'REST'} RequestEncoding
 */ /**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
 * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
 * @property {import("../tilegrid/WMTS.js").default} tileGrid Tile grid.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {RequestEncoding} [requestEncoding='KVP'] Request encoding.
 * @property {string} layer Layer name as advertised in the WMTS capabilities.
 * @property {string} style Style name as advertised in the WMTS capabilities.
 * @property {typeof import("../ImageTile.js").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.
 * @property {string} [version='1.0.0'] WMTS version.
 * @property {string} matrixSet Matrix set.
 * @property {!Object} [dimensions] Additional "dimensions" for tile requests.
 * This is an object with properties named like the advertised WMTS dimensions.
 * @property {string} [url]  A URL for the service.
 * For the RESTful request encoding, this is a URL
 * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,
 * for example `subdomain{a-f}.domain.com`, may be used instead of defining
 * each one separately in the `urls` option.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {Array<string>} [urls] An array of URLs.
 * Requests will be distributed among the URLs in this array.
 * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
 * Choose whether to use tiles with a higher or lower zoom level when between integer
 * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
 */ /**
 * @classdesc
 * Layer source for tile data from WMTS servers.
 * @api
 */ class WMTS extends (0, _tileImageJsDefault.default) {
    /**
   * @param {Options} options WMTS options.
   */ constructor(options){
        // TODO: add support for TileMatrixLimits
        const requestEncoding = options.requestEncoding !== undefined ? options.requestEncoding : 'KVP';
        // FIXME: should we create a default tileGrid?
        // we could issue a getCapabilities xhr to retrieve missing configuration
        const tileGrid = options.tileGrid;
        let urls = options.urls;
        if (urls === undefined && options.url !== undefined) urls = (0, _tileurlfunctionJs.expandUrl)(options.url);
        super({
            attributions: options.attributions,
            attributionsCollapsible: options.attributionsCollapsible,
            cacheSize: options.cacheSize,
            crossOrigin: options.crossOrigin,
            interpolate: options.interpolate,
            projection: options.projection,
            reprojectionErrorThreshold: options.reprojectionErrorThreshold,
            tileClass: options.tileClass,
            tileGrid: tileGrid,
            tileLoadFunction: options.tileLoadFunction,
            tilePixelRatio: options.tilePixelRatio,
            urls: urls,
            wrapX: options.wrapX !== undefined ? options.wrapX : false,
            transition: options.transition,
            zDirection: options.zDirection
        });
        /**
     * @private
     * @type {string}
     */ this.version_ = options.version !== undefined ? options.version : '1.0.0';
        /**
     * @private
     * @type {string}
     */ this.format_ = options.format !== undefined ? options.format : 'image/jpeg';
        /**
     * @private
     * @type {!Object}
     */ this.dimensions_ = options.dimensions !== undefined ? options.dimensions : {};
        /**
     * @private
     * @type {string}
     */ this.layer_ = options.layer;
        /**
     * @private
     * @type {string}
     */ this.matrixSet_ = options.matrixSet;
        /**
     * @private
     * @type {string}
     */ this.style_ = options.style;
        // FIXME: should we guess this requestEncoding from options.url(s)
        //        structure? that would mean KVP only if a template is not provided.
        /**
     * @private
     * @type {RequestEncoding}
     */ this.requestEncoding_ = requestEncoding;
        this.setKey(this.getKeyForDimensions_());
        if (urls && urls.length > 0) this.tileUrlFunction = (0, _tileurlfunctionJs.createFromTileUrlFunctions)(urls.map(this.createFromWMTSTemplate.bind(this)));
    }
    /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   */ setUrls(urls) {
        this.urls = urls;
        const key = urls.join('\n');
        this.setTileUrlFunction((0, _tileurlfunctionJs.createFromTileUrlFunctions)(urls.map(this.createFromWMTSTemplate.bind(this))), key);
    }
    /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */ getDimensions() {
        return this.dimensions_;
    }
    /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */ getFormat() {
        return this.format_;
    }
    /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */ getLayer() {
        return this.layer_;
    }
    /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */ getMatrixSet() {
        return this.matrixSet_;
    }
    /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {RequestEncoding} Request encoding.
   * @api
   */ getRequestEncoding() {
        return this.requestEncoding_;
    }
    /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */ getStyle() {
        return this.style_;
    }
    /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */ getVersion() {
        return this.version_;
    }
    /**
   * @private
   * @return {string} The key for the current dimensions.
   */ getKeyForDimensions_() {
        const res = this.urls ? this.urls.slice(0) : [];
        for(const key in this.dimensions_)res.push(key + '-' + this.dimensions_[key]);
        return res.join('/');
    }
    /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */ updateDimensions(dimensions) {
        Object.assign(this.dimensions_, dimensions);
        this.setKey(this.getKeyForDimensions_());
    }
    /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */ createFromWMTSTemplate(template) {
        const requestEncoding = this.requestEncoding_;
        // context property names are lower case to allow for a case insensitive
        // replacement as some services use different naming conventions
        const context = {
            'layer': this.layer_,
            'style': this.style_,
            'tilematrixset': this.matrixSet_
        };
        if (requestEncoding == 'KVP') Object.assign(context, {
            'Service': 'WMTS',
            'Request': 'GetTile',
            'Version': this.version_,
            'Format': this.format_
        });
        // TODO: we may want to create our own appendParams function so that params
        // order conforms to wmts spec guidance, and so that we can avoid to escape
        // special template params
        template = requestEncoding == 'KVP' ? (0, _uriJs.appendParams)(template, context) : template.replace(/\{(\w+?)\}/g, function(m, p) {
            return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
        });
        const tileGrid = /** @type {import("../tilegrid/WMTS.js").default} */ this.tileGrid;
        const dimensions = this.dimensions_;
        return(/**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */ function(tileCoord, pixelRatio, projection) {
            if (!tileCoord) return undefined;
            const localContext = {
                'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),
                'TileCol': tileCoord[1],
                'TileRow': tileCoord[2]
            };
            Object.assign(localContext, dimensions);
            let url = template;
            if (requestEncoding == 'KVP') url = (0, _uriJs.appendParams)(url, localContext);
            else url = url.replace(/\{(\w+?)\}/g, function(m, p) {
                return localContext[p];
            });
            return url;
        });
    }
}
exports.default = WMTS;
function optionsFromCapabilities(wmtsCap, config) {
    const layers = wmtsCap['Contents']['Layer'];
    const l = layers.find(function(elt) {
        return elt['Identifier'] == config['layer'];
    });
    if (!l) return null;
    const tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];
    let idx;
    if (l['TileMatrixSetLink'].length > 1) {
        if ('projection' in config) idx = l['TileMatrixSetLink'].findIndex(function(elt) {
            const tileMatrixSet = tileMatrixSets.find(function(el) {
                return el['Identifier'] == elt['TileMatrixSet'];
            });
            const supportedCRS = tileMatrixSet['SupportedCRS'];
            const proj1 = (0, _projJs.get)(supportedCRS);
            const proj2 = (0, _projJs.get)(config['projection']);
            if (proj1 && proj2) return (0, _projJs.equivalent)(proj1, proj2);
            return supportedCRS == config['projection'];
        });
        else idx = l['TileMatrixSetLink'].findIndex(function(elt) {
            return elt['TileMatrixSet'] == config['matrixSet'];
        });
    } else idx = 0;
    if (idx < 0) idx = 0;
    const matrixSet = /** @type {string} */ l['TileMatrixSetLink'][idx]['TileMatrixSet'];
    const matrixLimits = /** @type {Array<Object>} */ l['TileMatrixSetLink'][idx]['TileMatrixSetLimits'];
    let format = /** @type {string} */ l['Format'][0];
    if ('format' in config) format = config['format'];
    idx = l['Style'].findIndex(function(elt) {
        if ('style' in config) return elt['Title'] == config['style'];
        return elt['isDefault'];
    });
    if (idx < 0) idx = 0;
    const style = /** @type {string} */ l['Style'][idx]['Identifier'];
    const dimensions = {};
    if ('Dimension' in l) l['Dimension'].forEach(function(elt, index, array) {
        const key = elt['Identifier'];
        let value = elt['Default'];
        if (value === undefined) value = elt['Value'][0];
        dimensions[key] = value;
    });
    const matrixSets = wmtsCap['Contents']['TileMatrixSet'];
    const matrixSetObj = matrixSets.find(function(elt) {
        return elt['Identifier'] == matrixSet;
    });
    let projection;
    const code = matrixSetObj['SupportedCRS'];
    if (code) projection = (0, _projJs.get)(code);
    if ('projection' in config) {
        const projConfig = (0, _projJs.get)(config['projection']);
        if (projConfig) {
            if (!projection || (0, _projJs.equivalent)(projConfig, projection)) projection = projConfig;
        }
    }
    let wrapX = false;
    const switchXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
    let matrix = matrixSetObj.TileMatrix[0];
    // create default matrixLimit
    let selectedMatrixLimit = {
        MinTileCol: 0,
        MinTileRow: 0,
        // subtract one to end up at tile top left
        MaxTileCol: matrix.MatrixWidth - 1,
        MaxTileRow: matrix.MatrixHeight - 1
    };
    //in case of matrix limits, use matrix limits to calculate extent
    if (matrixLimits) {
        selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];
        const m = matrixSetObj.TileMatrix.find((tileMatrixValue)=>tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix || matrixSetObj.Identifier + ':' + tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix);
        if (m) matrix = m;
    }
    const resolution = matrix.ScaleDenominator * 0.00028 / projection.getMetersPerUnit(); // WMTS 1.0.0: standardized rendering pixel size
    const origin = switchXY ? [
        matrix.TopLeftCorner[1],
        matrix.TopLeftCorner[0]
    ] : matrix.TopLeftCorner;
    const tileSpanX = matrix.TileWidth * resolution;
    const tileSpanY = matrix.TileHeight * resolution;
    let matrixSetExtent = matrixSetObj['BoundingBox'];
    if (matrixSetExtent && switchXY) matrixSetExtent = [
        matrixSetExtent[1],
        matrixSetExtent[0],
        matrixSetExtent[3],
        matrixSetExtent[2]
    ];
    let extent = [
        origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol,
        // add one to get proper bottom/right coordinate
        origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow),
        origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol),
        origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow
    ];
    if (matrixSetExtent !== undefined && !(0, _extentJs.containsExtent)(matrixSetExtent, extent)) {
        const wgs84BoundingBox = l['WGS84BoundingBox'];
        const wgs84ProjectionExtent = (0, _projJs.get)('EPSG:4326').getExtent();
        extent = matrixSetExtent;
        if (wgs84BoundingBox) wrapX = wgs84BoundingBox[0] === wgs84ProjectionExtent[0] && wgs84BoundingBox[2] === wgs84ProjectionExtent[2];
        else {
            const wgs84MatrixSetExtent = (0, _projJs.transformExtent)(matrixSetExtent, matrixSetObj['SupportedCRS'], 'EPSG:4326');
            // Ignore slight deviation from the correct x limits
            wrapX = wgs84MatrixSetExtent[0] - 1e-10 <= wgs84ProjectionExtent[0] && wgs84MatrixSetExtent[2] + 1e-10 >= wgs84ProjectionExtent[2];
        }
    }
    const tileGrid = (0, _wmtsJs.createFromCapabilitiesMatrixSet)(matrixSetObj, extent, matrixLimits);
    /** @type {!Array<string>} */ const urls = [];
    let requestEncoding = config['requestEncoding'];
    requestEncoding = requestEncoding !== undefined ? requestEncoding : '';
    if ('OperationsMetadata' in wmtsCap && 'GetTile' in wmtsCap['OperationsMetadata']) {
        const gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];
        for(let i = 0, ii = gets.length; i < ii; ++i){
            if (gets[i]['Constraint']) {
                const constraint = gets[i]['Constraint'].find(function(element) {
                    return element['name'] == 'GetEncoding';
                });
                const encodings = constraint['AllowedValues']['Value'];
                if (requestEncoding === '') // requestEncoding not provided, use the first encoding from the list
                requestEncoding = encodings[0];
                if (requestEncoding === 'KVP') {
                    if (encodings.includes('KVP')) urls.push(/** @type {string} */ gets[i]['href']);
                } else break;
            } else if (gets[i]['href']) {
                requestEncoding = 'KVP';
                urls.push(/** @type {string} */ gets[i]['href']);
            }
        }
    }
    if (urls.length === 0) {
        requestEncoding = 'REST';
        l['ResourceURL'].forEach(function(element) {
            if (element['resourceType'] === 'tile') {
                format = element['format'];
                urls.push(/** @type {string} */ element['template']);
            }
        });
    }
    return {
        urls: urls,
        layer: config['layer'],
        matrixSet: matrixSet,
        format: format,
        projection: projection,
        requestEncoding: requestEncoding,
        tileGrid: tileGrid,
        style: style,
        dimensions: dimensions,
        wrapX: wrapX,
        crossOrigin: config['crossOrigin']
    };
}

},{"./TileImage.js":"kLfUI","../uri.js":"fEC4D","../extent.js":"bGUel","../tilegrid/WMTS.js":"cas0X","../tileurlfunction.js":"7hwWE","../proj.js":"8OK47","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hZssC":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/WebGLTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseTileJs = require("./BaseTile.js");
var _baseTileJsDefault = parcelHelpers.interopDefault(_baseTileJs);
var _propertyJs = require("../layer/Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _tileLayerJs = require("../renderer/webgl/TileLayer.js");
var _tileLayerJsDefault = parcelHelpers.interopDefault(_tileLayerJs);
var _expressionJs = require("../expr/expression.js");
var _gpuJs = require("../expr/gpu.js");
var _styleparserJs = require("../webgl/styleparser.js");
/**
 * @typedef {import("../source/DataTile.js").default|import("../source/TileImage.js").default} SourceType
 */ /**
 * @typedef {Object} Style
 * Translates tile data to rendered pixels.
 *
 * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These
 * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`
 * {@link import("../expr/expression.js").ExpressionValue expressions}, using the `['var', 'varName']` operator.
 * To update style variables, use the {@link import("./WebGLTile.js").default#updateStyleVariables} method.
 * @property {import("../expr/expression.js").ExpressionValue} [color] An expression applied to color values.
 * @property {import("../expr/expression.js").ExpressionValue} [brightness=0] Value used to decrease or increase
 * the layer brightness.  Values range from -1 to 1.
 * @property {import("../expr/expression.js").ExpressionValue} [contrast=0] Value used to decrease or increase
 * the layer contrast.  Values range from -1 to 1.
 * @property {import("../expr/expression.js").ExpressionValue} [exposure=0] Value used to decrease or increase
 * the layer exposure.  Values range from -1 to 1.
 * @property {import("../expr/expression.js").ExpressionValue} [saturation=0] Value used to decrease or increase
 * the layer saturation.  Values range from -1 to 1.
 * @property {import("../expr/expression.js").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.
 * Values range from 0 to infinity.
 */ /**
 * @typedef {Object} Options
 * @property {Style} [style] Style to apply to the layer.
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {SourceType} [source] Source for this layer.
 * @property {Array<SourceType>|function(import("../extent.js").Extent, number):Array<SourceType>} [sources] Array
 * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that
 * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See
 * {@link module:ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a
 * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map~Map#addLayer}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render
 * two zoom levels worth of tiles.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @typedef {Object} ParsedStyle
 * @property {string} vertexShader The vertex shader.
 * @property {string} fragmentShader The fragment shader.
 * @property {Object<string,import("../webgl/Helper.js").UniformValue>} uniforms Uniform definitions.
 * @property {Array<import("../webgl/PaletteTexture.js").default>} paletteTextures Palette textures.
 */ /**
 * @param {Style} style The layer style.
 * @param {number} [bandCount] The number of bands.
 * @return {ParsedStyle} Shaders and uniforms generated from the style.
 */ function parseStyle(style, bandCount) {
    const vertexShader = `
    attribute vec2 ${(0, _tileLayerJs.Attributes).TEXTURE_COORD};
    uniform mat4 ${(0, _tileLayerJs.Uniforms).TILE_TRANSFORM};
    uniform float ${(0, _tileLayerJs.Uniforms).TEXTURE_PIXEL_WIDTH};
    uniform float ${(0, _tileLayerJs.Uniforms).TEXTURE_PIXEL_HEIGHT};
    uniform float ${(0, _tileLayerJs.Uniforms).TEXTURE_RESOLUTION};
    uniform float ${(0, _tileLayerJs.Uniforms).TEXTURE_ORIGIN_X};
    uniform float ${(0, _tileLayerJs.Uniforms).TEXTURE_ORIGIN_Y};
    uniform float ${(0, _tileLayerJs.Uniforms).DEPTH};

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;

    void main() {
      v_textureCoord = ${(0, _tileLayerJs.Attributes).TEXTURE_COORD};
      v_mapCoord = vec2(
        ${(0, _tileLayerJs.Uniforms).TEXTURE_ORIGIN_X} + ${(0, _tileLayerJs.Uniforms).TEXTURE_RESOLUTION} * ${(0, _tileLayerJs.Uniforms).TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],
        ${(0, _tileLayerJs.Uniforms).TEXTURE_ORIGIN_Y} - ${(0, _tileLayerJs.Uniforms).TEXTURE_RESOLUTION} * ${(0, _tileLayerJs.Uniforms).TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]
      );
      gl_Position = ${(0, _tileLayerJs.Uniforms).TILE_TRANSFORM} * vec4(${(0, _tileLayerJs.Attributes).TEXTURE_COORD}, ${(0, _tileLayerJs.Uniforms).DEPTH}, 1.0);
    }
  `;
    /**
   * @type {import("../expr/gpu.js").CompilationContext}
   */ const context = {
        ...(0, _gpuJs.newCompilationContext)(),
        inFragmentShader: true,
        bandCount: bandCount,
        style: style
    };
    const pipeline = [];
    if (style.color !== undefined) {
        const color = (0, _styleparserJs.expressionToGlsl)(context, style.color, (0, _expressionJs.ColorType));
        pipeline.push(`color = ${color};`);
    }
    if (style.contrast !== undefined) {
        const contrast = (0, _styleparserJs.expressionToGlsl)(context, style.contrast, (0, _expressionJs.NumberType));
        pipeline.push(`color.rgb = clamp((${contrast} + 1.0) * color.rgb - (${contrast} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
    }
    if (style.exposure !== undefined) {
        const exposure = (0, _styleparserJs.expressionToGlsl)(context, style.exposure, (0, _expressionJs.NumberType));
        pipeline.push(`color.rgb = clamp((${exposure} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
    }
    if (style.saturation !== undefined) {
        const saturation = (0, _styleparserJs.expressionToGlsl)(context, style.saturation, (0, _expressionJs.NumberType));
        pipeline.push(`
      float saturation = ${saturation} + 1.0;
      float sr = (1.0 - saturation) * 0.2126;
      float sg = (1.0 - saturation) * 0.7152;
      float sb = (1.0 - saturation) * 0.0722;
      mat3 saturationMatrix = mat3(
        sr + saturation, sr, sr,
        sg, sg + saturation, sg,
        sb, sb, sb + saturation
      );
      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
    `);
    }
    if (style.gamma !== undefined) {
        const gamma = (0, _styleparserJs.expressionToGlsl)(context, style.gamma, (0, _expressionJs.NumberType));
        pipeline.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${gamma}));`);
    }
    if (style.brightness !== undefined) {
        const brightness = (0, _styleparserJs.expressionToGlsl)(context, style.brightness, (0, _expressionJs.NumberType));
        pipeline.push(`color.rgb = clamp(color.rgb + ${brightness}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`);
    }
    /** @type {Object<string,import("../webgl/Helper").UniformValue>} */ const uniforms = {};
    const numVariables = Object.keys(context.variables).length;
    if (numVariables > 1 && !style.variables) throw new Error(`Missing variables in style (expected ${context.variables})`);
    for(let i = 0; i < numVariables; ++i){
        const variable = context.variables[Object.keys(context.variables)[i]];
        if (!(variable.name in style.variables)) throw new Error(`Missing '${variable.name}' in style variables`);
        const uniformName = (0, _gpuJs.uniformNameForVariable)(variable.name);
        uniforms[uniformName] = function() {
            let value = style.variables[variable.name];
            if (typeof value === 'string') value = (0, _gpuJs.getStringNumberEquivalent)(value);
            return value !== undefined ? value : -9999999; // to avoid matching with the first string literal
        };
    }
    const uniformDeclarations = Object.keys(uniforms).map(function(name) {
        return `uniform float ${name};`;
    });
    const textureCount = Math.ceil(bandCount / 4);
    uniformDeclarations.push(`uniform sampler2D ${(0, _tileLayerJs.Uniforms).TILE_TEXTURE_ARRAY}[${textureCount}];`);
    if (context.paletteTextures) uniformDeclarations.push(`uniform sampler2D ${(0, _gpuJs.PALETTE_TEXTURE_ARRAY)}[${context.paletteTextures.length}];`);
    const functionDefintions = Object.keys(context.functions).map(function(name) {
        return context.functions[name];
    });
    const fragmentShader = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;
    uniform vec4 ${(0, _tileLayerJs.Uniforms).RENDER_EXTENT};
    uniform float ${(0, _tileLayerJs.Uniforms).TRANSITION_ALPHA};
    uniform float ${(0, _tileLayerJs.Uniforms).TEXTURE_PIXEL_WIDTH};
    uniform float ${(0, _tileLayerJs.Uniforms).TEXTURE_PIXEL_HEIGHT};
    uniform float ${(0, _tileLayerJs.Uniforms).RESOLUTION};
    uniform float ${(0, _tileLayerJs.Uniforms).ZOOM};

    ${uniformDeclarations.join('\n')}

    ${functionDefintions.join('\n')}

    void main() {
      if (
        v_mapCoord[0] < ${(0, _tileLayerJs.Uniforms).RENDER_EXTENT}[0] ||
        v_mapCoord[1] < ${(0, _tileLayerJs.Uniforms).RENDER_EXTENT}[1] ||
        v_mapCoord[0] > ${(0, _tileLayerJs.Uniforms).RENDER_EXTENT}[2] ||
        v_mapCoord[1] > ${(0, _tileLayerJs.Uniforms).RENDER_EXTENT}[3]
      ) {
        discard;
      }

      vec4 color = texture2D(${(0, _tileLayerJs.Uniforms).TILE_TEXTURE_ARRAY}[0],  v_textureCoord);

      ${pipeline.join('\n')}

      gl_FragColor = color;
      gl_FragColor.rgb *= gl_FragColor.a;
      gl_FragColor *= ${(0, _tileLayerJs.Uniforms).TRANSITION_ALPHA};
    }`;
    return {
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        uniforms: uniforms,
        paletteTextures: context.paletteTextures
    };
}
/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>
 * @fires import("../render/Event.js").RenderEvent
 * @api
 */ class WebGLTileLayer extends (0, _baseTileJsDefault.default) {
    /**
   * @param {Options} options Tile layer options.
   */ constructor(options){
        options = options ? Object.assign({}, options) : {};
        const style = options.style || {};
        delete options.style;
        const cacheSize = options.cacheSize;
        delete options.cacheSize;
        super(options);
        /**
     * @type {Array<SourceType>|function(import("../extent.js").Extent, number):Array<SourceType>}
     * @private
     */ this.sources_ = options.sources;
        /**
     * @type {SourceType|null}
     * @private
     */ this.renderedSource_ = null;
        /**
     * @type {number}
     * @private
     */ this.renderedResolution_ = NaN;
        /**
     * @type {Style}
     * @private
     */ this.style_ = style;
        /**
     * @type {number}
     * @private
     */ this.cacheSize_ = cacheSize;
        /**
     * @type {Object<string, (string|number)>}
     * @private
     */ this.styleVariables_ = this.style_.variables || {};
        this.addChangeListener((0, _propertyJsDefault.default).SOURCE, this.handleSourceUpdate_);
    }
    /**
   * Gets the sources for this layer, for a given extent and resolution.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<SourceType>} Sources.
   */ getSources(extent, resolution) {
        const source = this.getSource();
        return this.sources_ ? typeof this.sources_ === 'function' ? this.sources_(extent, resolution) : this.sources_ : source ? [
            source
        ] : [];
    }
    /**
   * @return {SourceType} The source being rendered.
   */ getRenderSource() {
        return this.renderedSource_ || this.getSource();
    }
    /**
   * @return {import("../source/Source.js").State} Source state.
   */ getSourceState() {
        const source = this.getRenderSource();
        return source ? source.getState() : 'undefined';
    }
    /**
   * @private
   */ handleSourceUpdate_() {
        if (this.hasRenderer()) this.getRenderer().clearCache();
        if (this.getSource()) this.setStyle(this.style_);
    }
    /**
   * @private
   * @return {number} The number of source bands.
   */ getSourceBandCount_() {
        const max = Number.MAX_SAFE_INTEGER;
        const sources = this.getSources([
            -max,
            -max,
            max,
            max
        ], max);
        return sources && sources.length && 'bandCount' in sources[0] ? sources[0].bandCount : 4;
    }
    createRenderer() {
        const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
        return new (0, _tileLayerJsDefault.default)(this, {
            vertexShader: parsedStyle.vertexShader,
            fragmentShader: parsedStyle.fragmentShader,
            uniforms: parsedStyle.uniforms,
            cacheSize: this.cacheSize_,
            paletteTextures: parsedStyle.paletteTextures
        });
    }
    /**
   * @param {import("../Map").FrameState} frameState Frame state.
   * @param {Array<SourceType>} sources Sources.
   * @return {HTMLElement} Canvas.
   */ renderSources(frameState, sources) {
        const layerRenderer = this.getRenderer();
        let canvas;
        for(let i = 0, ii = sources.length; i < ii; ++i){
            this.renderedSource_ = sources[i];
            if (layerRenderer.prepareFrame(frameState)) canvas = layerRenderer.renderFrame(frameState);
        }
        return canvas;
    }
    /**
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */ render(frameState, target) {
        this.rendered = true;
        const viewState = frameState.viewState;
        const sources = this.getSources(frameState.extent, viewState.resolution);
        let ready = true;
        for(let i = 0, ii = sources.length; i < ii; ++i){
            const source = sources[i];
            const sourceState = source.getState();
            if (sourceState == 'loading') {
                const onChange = ()=>{
                    if (source.getState() == 'ready') {
                        source.removeEventListener('change', onChange);
                        this.changed();
                    }
                };
                source.addEventListener('change', onChange);
            }
            ready = ready && sourceState == 'ready';
        }
        const canvas = this.renderSources(frameState, sources);
        if (this.getRenderer().renderComplete && ready) {
            // Fully rendered, done.
            this.renderedResolution_ = viewState.resolution;
            return canvas;
        }
        // Render sources from previously fully rendered frames
        if (this.renderedResolution_ > 0.5 * viewState.resolution) {
            const altSources = this.getSources(frameState.extent, this.renderedResolution_).filter((source)=>!sources.includes(source));
            if (altSources.length > 0) return this.renderSources(frameState, altSources);
        }
        return canvas;
    }
    /**
   * Update the layer style.  The `updateStyleVariables` function is a more efficient
   * way to update layer rendering.  In cases where the whole style needs to be updated,
   * this method may be called instead.  Note that calling this method will also replace
   * any previously set variables, so the new style also needs to include new variables,
   * if needed.
   * @param {Style} style The new style.
   */ setStyle(style) {
        this.styleVariables_ = style.variables || {};
        this.style_ = style;
        const parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
        const renderer = this.getRenderer();
        renderer.reset({
            vertexShader: parsedStyle.vertexShader,
            fragmentShader: parsedStyle.fragmentShader,
            uniforms: parsedStyle.uniforms,
            paletteTextures: parsedStyle.paletteTextures
        });
        this.changed();
    }
    /**
   * Update any variables used by the layer style and trigger a re-render.
   * @param {Object<string, number>} variables Variables to update.
   * @api
   */ updateStyleVariables(variables) {
        Object.assign(this.styleVariables_, variables);
        this.changed();
    }
}
/**
 * Clean up underlying WebGL resources.
 * @function
 * @api
 */ WebGLTileLayer.prototype.dispose;
exports.default = WebGLTileLayer;

},{"./BaseTile.js":"7ay52","../layer/Property.js":"50gL3","../renderer/webgl/TileLayer.js":"5DBmj","../expr/expression.js":"8u0Bf","../expr/gpu.js":"7Mz5N","../webgl/styleparser.js":"irFsa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5DBmj":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/webgl/TileLayer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Uniforms", ()=>Uniforms);
parcelHelpers.export(exports, "Attributes", ()=>Attributes);
var _dataTileJs = require("../../reproj/DataTile.js");
var _dataTileJsDefault = parcelHelpers.interopDefault(_dataTileJs);
var _tileJs = require("../../reproj/Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("../../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _tileTextureJs = require("../../webgl/TileTexture.js");
var _tileTextureJsDefault = parcelHelpers.interopDefault(_tileTextureJs);
var _bufferJs = require("../../webgl/Buffer.js");
var _bufferJsDefault = parcelHelpers.interopDefault(_bufferJs);
var _tileLayerBaseJs = require("./TileLayerBase.js");
var _tileLayerBaseJsDefault = parcelHelpers.interopDefault(_tileLayerBaseJs);
var _helperJs = require("../../webgl/Helper.js");
var _webglJs = require("../../webgl.js");
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _projJs = require("../../proj.js");
var _mat4Js = require("../../vec/mat4.js");
var _sizeJs = require("../../size.js");
const Uniforms = {
    ...(0, _tileLayerBaseJs.Uniforms),
    TILE_TEXTURE_ARRAY: 'u_tileTextures',
    TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',
    TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',
    TEXTURE_RESOLUTION: 'u_textureResolution',
    TEXTURE_ORIGIN_X: 'u_textureOriginX',
    TEXTURE_ORIGIN_Y: 'u_textureOriginY'
};
const Attributes = {
    TEXTURE_COORD: 'a_textureCoord'
};
/**
 * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
 */ const attributeDescriptions = [
    {
        name: Attributes.TEXTURE_COORD,
        size: 2,
        type: (0, _helperJs.AttributeType).FLOAT
    }
];
/**
 * @typedef {Object} Options
 * @property {string} vertexShader Vertex shader source.
 * @property {string} fragmentShader Fragment shader source.
 * @property {Object<string, import("../../webgl/Helper").UniformValue>} [uniforms] Additional uniforms
 * made available to shaders.
 * @property {Array<import("../../webgl/PaletteTexture.js").default>} [paletteTextures] Palette textures.
 * @property {number} [cacheSize=512] The texture cache size.
 */ /**
 * @typedef {import("../../layer/WebGLTile.js").default} LayerType
 */ /**
 * @typedef {import("../../webgl/TileTexture.js").TileType} TileTextureType
 */ /**
 * @typedef {import("../../webgl/TileTexture.js").default} TileTextureRepresentation
 */ /**
 * @classdesc
 * WebGL renderer for tile layers.
 * @extends {WebGLBaseTileLayerRenderer<LayerType, TileTextureType, TileTextureRepresentation>}
 * @api
 */ class WebGLTileLayerRenderer extends (0, _tileLayerBaseJsDefault.default) {
    /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} options Options.
   */ constructor(tileLayer, options){
        super(tileLayer, options);
        /**
     * @type {WebGLProgram}
     * @private
     */ this.program_;
        /**
     * @private
     */ this.vertexShader_ = options.vertexShader;
        /**
     * @private
     */ this.fragmentShader_ = options.fragmentShader;
        /**
     * Tiles are rendered as a quad with the following structure:
     *
     *  [P3]---------[P2]
     *   |`           |
     *   |  `     B   |
     *   |    `       |
     *   |      `     |
     *   |   A    `   |
     *   |          ` |
     *  [P0]---------[P1]
     *
     * Triangle A: P0, P1, P3
     * Triangle B: P1, P2, P3
     *
     * @private
     */ this.indices_ = new (0, _bufferJsDefault.default)((0, _webglJs.ELEMENT_ARRAY_BUFFER), (0, _webglJs.STATIC_DRAW));
        this.indices_.fromArray([
            0,
            1,
            3,
            1,
            2,
            3
        ]);
        /**
     * @type {Array<import("../../webgl/PaletteTexture.js").default>}
     * @private
     */ this.paletteTextures_ = options.paletteTextures || [];
    }
    /**
   * @param {Options} options Options.
   */ reset(options) {
        super.reset(options);
        this.vertexShader_ = options.vertexShader;
        this.fragmentShader_ = options.fragmentShader;
        this.paletteTextures_ = options.paletteTextures || [];
        if (this.helper) this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
    }
    afterHelperCreated() {
        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
        this.helper.flushBufferData(this.indices_);
    }
    createTileRepresentation(options) {
        return new (0, _tileTextureJsDefault.default)(options);
    }
    beforeTilesRender(frameState, tilesWithAlpha) {
        super.beforeTilesRender(frameState, tilesWithAlpha);
        this.helper.useProgram(this.program_, frameState);
    }
    renderTile(tileTexture, tileTransform, frameState, renderExtent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha) {
        const gl = this.helper.getGL();
        this.helper.bindBuffer(tileTexture.coords);
        this.helper.bindBuffer(this.indices_);
        this.helper.enableAttributes(attributeDescriptions);
        let textureSlot = 0;
        while(textureSlot < tileTexture.textures.length){
            const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;
            this.helper.bindTexture(tileTexture.textures[textureSlot], textureSlot, uniformName);
            ++textureSlot;
        }
        for(let paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex){
            const paletteTexture = this.paletteTextures_[paletteIndex];
            const texture = paletteTexture.getTexture(gl);
            this.helper.bindTexture(texture, textureSlot, paletteTexture.name);
            ++textureSlot;
        }
        const viewState = frameState.viewState;
        const tileWidthWithGutter = tileSize[0] + 2 * gutter;
        const tileHeightWithGutter = tileSize[1] + 2 * gutter;
        const tile = tileTexture.tile;
        const tileCoord = tile.tileCoord;
        const tileCenterI = tileCoord[1];
        const tileCenterJ = tileCoord[2];
        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, (0, _mat4Js.fromTransform)(this.tempMat4, tileTransform));
        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);
        this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);
        let gutterExtent = renderExtent;
        if (gutter > 0) {
            gutterExtent = tileExtent;
            (0, _extentJs.getIntersection)(gutterExtent, renderExtent, gutterExtent);
        }
        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);
        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);
        this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileWidthWithGutter);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileHeightWithGutter);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution - gutter * tileResolution);
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution + gutter * tileResolution);
        this.helper.drawElements(0, this.indices_.getSize());
    }
    /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.
   */ getData(pixel) {
        const gl = this.helper.getGL();
        if (!gl) return null;
        const frameState = this.frameState;
        if (!frameState) return null;
        const layer = this.getLayer();
        const coordinate = (0, _transformJs.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
        const viewState = frameState.viewState;
        const layerExtent = layer.getExtent();
        if (layerExtent) {
            if (!(0, _extentJs.containsCoordinate)((0, _projJs.fromUserExtent)(layerExtent, viewState.projection), coordinate)) return null;
        }
        // determine last source suitable for rendering at coordinate
        const sources = layer.getSources((0, _extentJs.boundingExtent)([
            coordinate
        ]), viewState.resolution);
        let i, source, tileGrid;
        for(i = sources.length - 1; i >= 0; --i){
            source = sources[i];
            if (source.getState() === 'ready') {
                tileGrid = source.getTileGridForProjection(viewState.projection);
                if (source.getWrapX()) break;
                const gridExtent = tileGrid.getExtent();
                if (!gridExtent || (0, _extentJs.containsCoordinate)(gridExtent, coordinate)) break;
            }
        }
        if (i < 0) return null;
        const tileTextureCache = this.tileRepresentationCache;
        for(let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z){
            const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
            const cacheKey = (0, _tileLayerBaseJs.getCacheKey)(source, tileCoord);
            if (!tileTextureCache.containsKey(cacheKey)) continue;
            const tileTexture = tileTextureCache.get(cacheKey);
            const tile = tileTexture.tile;
            if ((tile instanceof (0, _tileJsDefault.default) || tile instanceof (0, _dataTileJsDefault.default)) && tile.getState() === (0, _tileStateJsDefault.default).EMPTY) return null;
            if (!tileTexture.loaded) continue;
            const tileOrigin = tileGrid.getOrigin(z);
            const tileSize = (0, _sizeJs.toSize)(tileGrid.getTileSize(z));
            const tileResolution = tileGrid.getResolution(z);
            const col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];
            const row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];
            return tileTexture.getPixelData(col, row);
        }
        return null;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        const helper = this.helper;
        if (helper) {
            const gl = helper.getGL();
            gl.deleteProgram(this.program_);
            delete this.program_;
            helper.deleteBuffer(this.indices_);
        }
        super.disposeInternal();
        delete this.indices_;
    }
}
exports.default = WebGLTileLayerRenderer;

},{"../../reproj/DataTile.js":"hOKCN","../../reproj/Tile.js":"dqATW","../../TileState.js":"2J5J5","../../webgl/TileTexture.js":"4tLAt","../../webgl/Buffer.js":"esyMP","./TileLayerBase.js":"9A0lW","../../webgl/Helper.js":"38rQm","../../webgl.js":"auzQ5","../../transform.js":"9LrRk","../../extent.js":"bGUel","../../proj.js":"8OK47","../../vec/mat4.js":"EdMck","../../size.js":"fXEON","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hOKCN":[function(require,module,exports,__globalThis) {
/**
 * @module ol/reproj/DataTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _commonJs = require("./common.js");
var _dataTileJs = require("../DataTile.js");
var _dataTileJsDefault = parcelHelpers.interopDefault(_dataTileJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _triangulationJs = require("./Triangulation.js");
var _triangulationJsDefault = parcelHelpers.interopDefault(_triangulationJs);
var _reprojJs = require("../reproj.js");
var _mathJs = require("../math.js");
var _domJs = require("../dom.js");
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
/**
 * @typedef {function(number, number, number, number) : import("../DataTile.js").default} TileGetter
 */ /**
 * @typedef {Object} Options
 * @property {import("../proj/Projection.js").default} sourceProj Source projection.
 * @property {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
 * @property {import("../proj/Projection.js").default} targetProj Target projection.
 * @property {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
 * @property {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
 * @property {import("../tilecoord.js").TileCoord} [wrappedTileCoord] Coordinate of the tile wrapped in X.
 * @property {number} pixelRatio Pixel ratio.
 * @property {number} gutter Gutter of the source tiles.
 * @property {TileGetter} getTileFunction Function returning source tiles (z, x, y, pixelRatio).
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @property {number} [errorThreshold] Acceptable reprojection error (in px).
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 */ /**
 * @classdesc
 * Class encapsulating single reprojected data tile.
 * See {@link module:ol/source/DataTile~DataTileSource}.
 *
 */ class ReprojDataTile extends (0, _dataTileJsDefault.default) {
    /**
   * @param {Options} options Tile options.
   */ constructor(options){
        super({
            tileCoord: options.tileCoord,
            loader: ()=>Promise.resolve(new Uint8Array(4)),
            interpolate: options.interpolate,
            transition: options.transition
        });
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = options.pixelRatio;
        /**
     * @private
     * @type {number}
     */ this.gutter_ = options.gutter;
        /**
     * @type {import("../DataTile.js").Data}
     * @private
     */ this.reprojData_ = null;
        /**
     * @type {Error}
     * @private
     */ this.reprojError_ = null;
        /**
     * @type {import('../size.js').Size}
     * @private
     */ this.reprojSize_ = undefined;
        /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */ this.sourceTileGrid_ = options.sourceTileGrid;
        /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */ this.targetTileGrid_ = options.targetTileGrid;
        /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */ this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;
        /**
     * @private
     * @type {!Array<DataTile>}
     */ this.sourceTiles_ = [];
        /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */ this.sourcesListenerKeys_ = null;
        /**
     * @private
     * @type {number}
     */ this.sourceZ_ = 0;
        const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
        const maxTargetExtent = this.targetTileGrid_.getExtent();
        let maxSourceExtent = this.sourceTileGrid_.getExtent();
        const limitedTargetExtent = maxTargetExtent ? (0, _extentJs.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;
        if ((0, _extentJs.getArea)(limitedTargetExtent) === 0) {
            // Tile is completely outside range -> EMPTY
            // TODO: is it actually correct that the source even creates the tile ?
            this.state = (0, _tileStateJsDefault.default).EMPTY;
            return;
        }
        const sourceProj = options.sourceProj;
        const sourceProjExtent = sourceProj.getExtent();
        if (sourceProjExtent) {
            if (!maxSourceExtent) maxSourceExtent = sourceProjExtent;
            else maxSourceExtent = (0, _extentJs.getIntersection)(maxSourceExtent, sourceProjExtent);
        }
        const targetResolution = this.targetTileGrid_.getResolution(this.wrappedTileCoord_[0]);
        const targetProj = options.targetProj;
        const sourceResolution = (0, _reprojJs.calculateSourceExtentResolution)(sourceProj, targetProj, limitedTargetExtent, targetResolution);
        if (!isFinite(sourceResolution) || sourceResolution <= 0) {
            // invalid sourceResolution -> EMPTY
            // probably edges of the projections when no extent is defined
            this.state = (0, _tileStateJsDefault.default).EMPTY;
            return;
        }
        const errorThresholdInPixels = options.errorThreshold !== undefined ? options.errorThreshold : (0, _commonJs.ERROR_THRESHOLD);
        /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */ this.triangulation_ = new (0, _triangulationJsDefault.default)(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
        if (this.triangulation_.getTriangles().length === 0) {
            // no valid triangles -> EMPTY
            this.state = (0, _tileStateJsDefault.default).EMPTY;
            return;
        }
        this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);
        let sourceExtent = this.triangulation_.calculateSourceExtent();
        if (maxSourceExtent) {
            if (sourceProj.canWrapX()) {
                sourceExtent[1] = (0, _mathJs.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
                sourceExtent[3] = (0, _mathJs.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
            } else sourceExtent = (0, _extentJs.getIntersection)(sourceExtent, maxSourceExtent);
        }
        if (!(0, _extentJs.getArea)(sourceExtent)) this.state = (0, _tileStateJsDefault.default).EMPTY;
        else {
            const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);
            const getTile = options.getTileFunction;
            for(let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++)for(let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++){
                const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);
                if (tile) this.sourceTiles_.push(tile);
            }
            if (this.sourceTiles_.length === 0) this.state = (0, _tileStateJsDefault.default).EMPTY;
        }
    }
    /**
   * Get the tile size.
   * @return {import('../size.js').Size} Tile size.
   */ getSize() {
        return this.reprojSize_;
    }
    /**
   * Get the data for the tile.
   * @return {import("../DataTile.js").Data} Tile data.
   */ getData() {
        return this.reprojData_;
    }
    /**
   * Get any loading error.
   * @return {Error} Loading error.
   */ getError() {
        return this.reprojError_;
    }
    /**
   * @private
   */ reproject_() {
        const dataSources = [];
        this.sourceTiles_.forEach((tile)=>{
            if (!tile || tile.getState() !== (0, _tileStateJsDefault.default).LOADED) return;
            const size = tile.getSize();
            const gutter = this.gutter_;
            /**
       * @type {import("../DataTile.js").ArrayLike}
       */ let tileData;
            const arrayData = (0, _dataTileJs.asArrayLike)(tile.getData());
            if (arrayData) tileData = arrayData;
            else tileData = (0, _dataTileJs.toArray)((0, _dataTileJs.asImageLike)(tile.getData()));
            const pixelSize = [
                size[0] + 2 * gutter,
                size[1] + 2 * gutter
            ];
            const isFloat = tileData instanceof Float32Array;
            const pixelCount = pixelSize[0] * pixelSize[1];
            const DataType = isFloat ? Float32Array : Uint8Array;
            const tileDataR = new DataType(tileData.buffer);
            const bytesPerElement = DataType.BYTES_PER_ELEMENT;
            const bytesPerPixel = bytesPerElement * tileDataR.length / pixelCount;
            const bytesPerRow = tileDataR.byteLength / pixelSize[1];
            const bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
            const packedLength = pixelCount * bandCount;
            let packedData = tileDataR;
            if (tileDataR.length !== packedLength) {
                packedData = new DataType(packedLength);
                let dataIndex = 0;
                let rowOffset = 0;
                const colCount = pixelSize[0] * bandCount;
                for(let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex){
                    for(let colIndex = 0; colIndex < colCount; ++colIndex)packedData[dataIndex++] = tileDataR[rowOffset + colIndex];
                    rowOffset += bytesPerRow / bytesPerElement;
                }
            }
            dataSources.push({
                extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
                data: new Uint8Array(packedData.buffer),
                dataType: DataType,
                bytesPerPixel: bytesPerPixel,
                pixelSize: pixelSize
            });
        });
        this.sourceTiles_.length = 0;
        if (dataSources.length === 0) this.state = (0, _tileStateJsDefault.default).ERROR;
        else {
            const z = this.wrappedTileCoord_[0];
            const size = this.targetTileGrid_.getTileSize(z);
            const targetWidth = typeof size === 'number' ? size : size[0];
            const targetHeight = typeof size === 'number' ? size : size[1];
            const targetResolution = this.targetTileGrid_.getResolution(z);
            const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
            const targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
            let dataR, dataU;
            const bytesPerPixel = dataSources[0].bytesPerPixel;
            const reprojs = Math.ceil(bytesPerPixel / 3);
            for(let reproj = reprojs - 1; reproj >= 0; --reproj){
                const sources = [];
                for(let i = 0, len = dataSources.length; i < len; ++i){
                    const dataSource = dataSources[i];
                    const buffer = dataSource.data;
                    const pixelSize = dataSource.pixelSize;
                    const width = pixelSize[0];
                    const height = pixelSize[1];
                    const context = (0, _domJs.createCanvasContext2D)(width, height, (0, _reprojJs.canvasPool));
                    const imageData = context.createImageData(width, height);
                    const data = imageData.data;
                    let offset = reproj * 3;
                    for(let j = 0, len = data.length; j < len; j += 4){
                        data[j] = buffer[offset];
                        data[j + 1] = buffer[offset + 1];
                        data[j + 2] = buffer[offset + 2];
                        data[j + 3] = 255;
                        offset += bytesPerPixel;
                    }
                    context.putImageData(imageData, 0, 0);
                    sources.push({
                        extent: dataSource.extent,
                        image: context.canvas
                    });
                }
                const canvas = (0, _reprojJs.render)(targetWidth, targetHeight, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, false, false);
                for(let i = 0, len = sources.length; i < len; ++i){
                    const canvas = sources[i].image;
                    const context = canvas.getContext('2d');
                    (0, _domJs.releaseCanvas)(context);
                    (0, _reprojJs.canvasPool).push(context.canvas);
                }
                const context = canvas.getContext('2d');
                const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                (0, _domJs.releaseCanvas)(context);
                (0, _reprojJs.canvasPool).push(canvas);
                if (!dataR) {
                    dataU = new Uint8Array(bytesPerPixel * imageData.width * imageData.height);
                    dataR = new dataSources[0].dataType(dataU.buffer);
                }
                const data = imageData.data;
                let offset = reproj * 3;
                for(let i = 0, len = data.length; i < len; i += 4){
                    if (data[i + 3] === 255) {
                        dataU[offset] = data[i];
                        dataU[offset + 1] = data[i + 1];
                        dataU[offset + 2] = data[i + 2];
                    } else {
                        dataU[offset] = 0;
                        dataU[offset + 1] = 0;
                        dataU[offset + 2] = 0;
                    }
                    offset += bytesPerPixel;
                }
            }
            this.reprojData_ = dataR;
            this.reprojSize_ = [
                Math.round(targetWidth * this.pixelRatio_),
                Math.round(targetHeight * this.pixelRatio_)
            ];
            this.state = (0, _tileStateJsDefault.default).LOADED;
        }
        this.changed();
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.state !== (0, _tileStateJsDefault.default).IDLE && this.state !== (0, _tileStateJsDefault.default).ERROR) return;
        this.state = (0, _tileStateJsDefault.default).LOADING;
        this.changed();
        let leftToLoad = 0;
        this.sourcesListenerKeys_ = [];
        this.sourceTiles_.forEach((tile)=>{
            const state = tile.getState();
            if (state !== (0, _tileStateJsDefault.default).IDLE && state !== (0, _tileStateJsDefault.default).LOADING) return;
            leftToLoad++;
            const sourceListenKey = (0, _eventsJs.listen)(tile, (0, _eventTypeJsDefault.default).CHANGE, function() {
                const state = tile.getState();
                if (state == (0, _tileStateJsDefault.default).LOADED || state == (0, _tileStateJsDefault.default).ERROR || state == (0, _tileStateJsDefault.default).EMPTY) {
                    (0, _eventsJs.unlistenByKey)(sourceListenKey);
                    leftToLoad--;
                    if (leftToLoad === 0) {
                        this.unlistenSources_();
                        this.reproject_();
                    }
                }
            }, this);
            this.sourcesListenerKeys_.push(sourceListenKey);
        });
        if (leftToLoad === 0) setTimeout(this.reproject_.bind(this), 0);
        else this.sourceTiles_.forEach(function(tile) {
            const state = tile.getState();
            if (state == (0, _tileStateJsDefault.default).IDLE) tile.load();
        });
    }
    /**
   * @private
   */ unlistenSources_() {
        this.sourcesListenerKeys_.forEach((0, _eventsJs.unlistenByKey));
        this.sourcesListenerKeys_ = null;
    }
}
exports.default = ReprojDataTile;

},{"./common.js":"aQ4PW","../DataTile.js":"9S3Xd","../events/EventType.js":"3uT2C","../TileState.js":"2J5J5","./Triangulation.js":"eWboV","../reproj.js":"i3wKe","../math.js":"d8zSj","../dom.js":"h98kD","../extent.js":"bGUel","../events.js":"lh4km","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9S3Xd":[function(require,module,exports,__globalThis) {
/**
 * @module ol/DataTile
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap} ImageLike
 */ /**
 * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} ArrayLike
 */ /**
 * Data that can be used with a DataTile.
 * @typedef {ArrayLike|ImageLike} Data
 */ /**
 * @param {Data} data Tile data.
 * @return {ImageLike|null} The image-like data.
 */ parcelHelpers.export(exports, "asImageLike", ()=>asImageLike);
/**
 * @param {Data} data Tile data.
 * @return {ArrayLike|null} The array-like data.
 */ parcelHelpers.export(exports, "asArrayLike", ()=>asArrayLike);
/**
 * @param {ImageLike} image The image.
 * @return {Uint8ClampedArray} The data.
 */ parcelHelpers.export(exports, "toArray", ()=>toArray);
var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _domJs = require("./dom.js");
function asImageLike(data) {
    return data instanceof Image || data instanceof HTMLCanvasElement || data instanceof HTMLVideoElement || data instanceof ImageBitmap ? data : null;
}
function asArrayLike(data) {
    return data instanceof Uint8Array || data instanceof Uint8ClampedArray || data instanceof Float32Array || data instanceof DataView ? data : null;
}
/**
 * @type {CanvasRenderingContext2D|null}
 */ let sharedContext = null;
function toArray(image) {
    if (!sharedContext) sharedContext = (0, _domJs.createCanvasContext2D)(image.width, image.height, undefined, {
        willReadFrequently: true
    });
    const canvas = sharedContext.canvas;
    const width = image.width;
    if (canvas.width !== width) canvas.width = width;
    const height = image.height;
    if (canvas.height !== height) canvas.height = height;
    sharedContext.clearRect(0, 0, width, height);
    sharedContext.drawImage(image, 0, 0);
    return sharedContext.getImageData(0, 0, width, height).data;
}
/**
 * @type {import('./size.js').Size}
 */ const defaultSize = [
    256,
    256
];
/**
 * @typedef {Object} Options
 * @property {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @property {function(): Promise<Data>} loader Data loader.  For loaders that generate images,
 * the promise should not resolve until the image is loaded.
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 * @property {import('./size.js').Size} [size=[256, 256]] Tile size.
 * @api
 */ class DataTile extends (0, _tileJsDefault.default) {
    /**
   * @param {Options} options Tile options.
   */ constructor(options){
        const state = (0, _tileStateJsDefault.default).IDLE;
        super(options.tileCoord, state, {
            transition: options.transition,
            interpolate: options.interpolate
        });
        /**
     * @type {function(): Promise<Data>}
     * @private
     */ this.loader_ = options.loader;
        /**
     * @type {Data}
     * @private
     */ this.data_ = null;
        /**
     * @type {Error}
     * @private
     */ this.error_ = null;
        /**
     * @type {import('./size.js').Size|null}
     * @private
     */ this.size_ = options.size || null;
    }
    /**
   * Get the tile size.
   * @return {import('./size.js').Size} Tile size.
   */ getSize() {
        if (this.size_) return this.size_;
        const imageData = asImageLike(this.data_);
        if (imageData) return [
            imageData.width,
            imageData.height
        ];
        return defaultSize;
    }
    /**
   * Get the data for the tile.
   * @return {Data} Tile data.
   * @api
   */ getData() {
        return this.data_;
    }
    /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @api
   */ getError() {
        return this.error_;
    }
    /**
   * Load not yet loaded URI.
   * @api
   */ load() {
        if (this.state !== (0, _tileStateJsDefault.default).IDLE && this.state !== (0, _tileStateJsDefault.default).ERROR) return;
        this.state = (0, _tileStateJsDefault.default).LOADING;
        this.changed();
        const self = this;
        this.loader_().then(function(data) {
            self.data_ = data;
            self.state = (0, _tileStateJsDefault.default).LOADED;
            self.changed();
        }).catch(function(error) {
            self.error_ = error;
            self.state = (0, _tileStateJsDefault.default).ERROR;
            self.changed();
        });
    }
}
exports.default = DataTile;

},{"./Tile.js":"eTFB8","./TileState.js":"2J5J5","./dom.js":"h98kD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4tLAt":[function(require,module,exports,__globalThis) {
/**
 * @module ol/webgl/TileTexture
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseTileRepresentationJs = require("./BaseTileRepresentation.js");
var _baseTileRepresentationJsDefault = parcelHelpers.interopDefault(_baseTileRepresentationJs);
var _dataTileJs = require("../DataTile.js");
var _dataTileJsDefault = parcelHelpers.interopDefault(_dataTileJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageTileJs = require("../ImageTile.js");
var _imageTileJsDefault = parcelHelpers.interopDefault(_imageTileJs);
var _tileJs = require("../reproj/Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _bufferJs = require("./Buffer.js");
var _bufferJsDefault = parcelHelpers.interopDefault(_bufferJs);
var _webglJs = require("../webgl.js");
var _domJs = require("../dom.js");
var _sizeJs = require("../size.js");
/**
 * @param {WebGLRenderingContext} gl The WebGL context.
 * @param {WebGLTexture} texture The texture.
 * @param {boolean} interpolate Interpolate when resampling.
 */ function bindAndConfigure(gl, texture, interpolate) {
    const resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);
}
/**
 * @param {WebGLRenderingContext} gl The WebGL context.
 * @param {WebGLTexture} texture The texture.
 * @param {import("../DataTile.js").ImageLike} image The image.
 * @param {boolean} interpolate Interpolate when resampling.
 */ function uploadImageTexture(gl, texture, image, interpolate) {
    bindAndConfigure(gl, texture, interpolate);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
}
/**
 * @param {import("./Helper.js").default} helper The WebGL helper.
 * @param {WebGLTexture} texture The texture.
 * @param {import("../DataTile.js").ArrayLike} data The pixel data.
 * @param {import("../size.js").Size} size The pixel size.
 * @param {number} bandCount The band count.
 * @param {boolean} interpolate Interpolate when resampling.
 */ function uploadDataTexture(helper, texture, data, size, bandCount, interpolate) {
    const gl = helper.getGL();
    let textureType;
    let canInterpolate;
    if (data instanceof Float32Array) {
        textureType = gl.FLOAT;
        helper.getExtension('OES_texture_float');
        const extension = helper.getExtension('OES_texture_float_linear');
        canInterpolate = extension !== null;
    } else {
        textureType = gl.UNSIGNED_BYTE;
        canInterpolate = true;
    }
    bindAndConfigure(gl, texture, interpolate && canInterpolate);
    const bytesPerRow = data.byteLength / size[1];
    let unpackAlignment = 1;
    if (bytesPerRow % 8 === 0) unpackAlignment = 8;
    else if (bytesPerRow % 4 === 0) unpackAlignment = 4;
    else if (bytesPerRow % 2 === 0) unpackAlignment = 2;
    let format;
    switch(bandCount){
        case 1:
            format = gl.LUMINANCE;
            break;
        case 2:
            format = gl.LUMINANCE_ALPHA;
            break;
        case 3:
            format = gl.RGB;
            break;
        case 4:
            format = gl.RGBA;
            break;
        default:
            throw new Error(`Unsupported number of bands: ${bandCount}`);
    }
    const oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, textureType, data);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);
}
/**
 * @type {CanvasRenderingContext2D}
 */ let pixelContext = null;
function createPixelContext() {
    pixelContext = (0, _domJs.createCanvasContext2D)(1, 1, undefined, {
        willReadFrequently: true
    });
}
/**
 * @typedef {import("../DataTile.js").default|ImageTile|ReprojTile} TileType
 */ /**
 * @extends {BaseTileRepresentation<TileType>}
 */ class TileTexture extends (0, _baseTileRepresentationJsDefault.default) {
    /**
   * @param {import("./BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options The tile texture options.
   */ constructor(options){
        super(options);
        /**
     * @type {Array<WebGLTexture>}
     */ this.textures = [];
        /**
     * @type {import("../size.js").Size}
     * @private
     */ this.renderSize_ = (0, _sizeJs.toSize)(options.grid.getTileSize(options.tile.tileCoord[0]));
        /**
     * @type {number}
     */ this.bandCount = NaN;
        const coords = new (0, _bufferJsDefault.default)((0, _webglJs.ARRAY_BUFFER), (0, _webglJs.STATIC_DRAW));
        coords.fromArray([
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0
        ]);
        this.helper_.flushBufferData(coords);
        /**
     * @type {WebGLArrayBuffer}
     */ this.coords = coords;
        this.setTile(options.tile);
    }
    uploadTile() {
        const helper = this.helper_;
        const gl = helper.getGL();
        const tile = this.tile;
        this.textures.length = 0;
        /**
     * @type {import("../DataTile.js").Data}
     */ let data;
        if (tile instanceof (0, _imageTileJsDefault.default) || tile instanceof (0, _tileJsDefault.default)) data = tile.getImage();
        else data = tile.getData();
        const image = (0, _dataTileJs.asImageLike)(data);
        if (image) {
            const texture = gl.createTexture();
            this.textures.push(texture);
            this.bandCount = 4;
            uploadImageTexture(gl, texture, image, tile.interpolate);
            this.setReady();
            return;
        }
        data = (0, _dataTileJs.asArrayLike)(data);
        const sourceTileSize = /** @type {DataTile} */ tile.getSize();
        const pixelSize = [
            sourceTileSize[0] + 2 * this.gutter_,
            sourceTileSize[1] + 2 * this.gutter_
        ];
        const isFloat = data instanceof Float32Array;
        const pixelCount = pixelSize[0] * pixelSize[1];
        const DataType = isFloat ? Float32Array : Uint8Array;
        const bytesPerElement = DataType.BYTES_PER_ELEMENT;
        const bytesPerRow = data.byteLength / pixelSize[1];
        this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
        const textureCount = Math.ceil(this.bandCount / 4);
        if (textureCount === 1) {
            const texture = gl.createTexture();
            this.textures.push(texture);
            uploadDataTexture(helper, texture, data, pixelSize, this.bandCount, tile.interpolate);
            this.setReady();
            return;
        }
        const textureDataArrays = new Array(textureCount);
        for(let textureIndex = 0; textureIndex < textureCount; ++textureIndex){
            const texture = gl.createTexture();
            this.textures.push(texture);
            const bandCount = textureIndex < textureCount - 1 ? 4 : (this.bandCount - 1) % 4 + 1;
            textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);
        }
        let dataIndex = 0;
        let rowOffset = 0;
        const colCount = pixelSize[0] * this.bandCount;
        for(let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex){
            for(let colIndex = 0; colIndex < colCount; ++colIndex){
                const dataValue = data[rowOffset + colIndex];
                const pixelIndex = Math.floor(dataIndex / this.bandCount);
                const bandIndex = colIndex % this.bandCount;
                const textureIndex = Math.floor(bandIndex / 4);
                const textureData = textureDataArrays[textureIndex];
                const bandCount = textureData.length / pixelCount;
                const textureBandIndex = bandIndex % 4;
                textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;
                ++dataIndex;
            }
            rowOffset += bytesPerRow / bytesPerElement;
        }
        for(let textureIndex = 0; textureIndex < textureCount; ++textureIndex){
            const texture = this.textures[textureIndex];
            const textureData = textureDataArrays[textureIndex];
            const bandCount = textureData.length / pixelCount;
            uploadDataTexture(helper, texture, textureData, pixelSize, bandCount, tile.interpolate);
        }
        this.setReady();
    }
    disposeInternal() {
        const gl = this.helper_.getGL();
        this.helper_.deleteBuffer(this.coords);
        for(let i = 0; i < this.textures.length; ++i)gl.deleteTexture(this.textures[i]);
        this.tile.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, this.handleTileChange_);
    }
    /**
   * @param {import("../DataTile.js").ImageLike} image The image.
   * @param {number} renderCol The column index (in rendered tile space).
   * @param {number} renderRow The row index (in rendered tile space).
   * @return {Uint8ClampedArray|null} The data.
   * @private
   */ getImagePixelData_(image, renderCol, renderRow) {
        const gutter = this.gutter_;
        const renderWidth = this.renderSize_[0];
        const renderHeight = this.renderSize_[1];
        if (!pixelContext) createPixelContext();
        pixelContext.clearRect(0, 0, 1, 1);
        const sourceWidth = image.width;
        const sourceHeight = image.height;
        const sourceWidthWithoutGutter = sourceWidth - 2 * gutter;
        const sourceHeightWithoutGutter = sourceHeight - 2 * gutter;
        const sourceCol = gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));
        const sourceRow = gutter + Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));
        let data;
        try {
            pixelContext.drawImage(image, sourceCol, sourceRow, 1, 1, 0, 0, 1, 1);
            data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch (err) {
            pixelContext = null;
            return null;
        }
        return data;
    }
    /**
   * @param {import("../DataTile.js").ArrayLike} data The data.
   * @param {import("../size.js").Size} sourceSize The size.
   * @param {number} renderCol The column index (in rendered tile space).
   * @param {number} renderRow The row index (in rendered tile space).
   * @return {import("../DataTile.js").ArrayLike|null} The data.
   * @private
   */ getArrayPixelData_(data, sourceSize, renderCol, renderRow) {
        const gutter = this.gutter_;
        const renderWidth = this.renderSize_[0];
        const renderHeight = this.renderSize_[1];
        const sourceWidthWithoutGutter = sourceSize[0];
        const sourceHeightWithoutGutter = sourceSize[1];
        const sourceWidth = sourceWidthWithoutGutter + 2 * gutter;
        const sourceHeight = sourceHeightWithoutGutter + 2 * gutter;
        const sourceCol = gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));
        const sourceRow = gutter + Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));
        if (data instanceof DataView) {
            const bytesPerPixel = data.byteLength / (sourceWidth * sourceHeight);
            const offset = bytesPerPixel * (sourceRow * sourceWidth + sourceCol);
            const buffer = data.buffer.slice(offset, offset + bytesPerPixel);
            return new DataView(buffer);
        }
        const offset = this.bandCount * (sourceRow * sourceWidth + sourceCol);
        return data.slice(offset, offset + this.bandCount);
    }
    /**
   * Get data for a pixel.  If the tile is not loaded, null is returned.
   * @param {number} renderCol The column index (in rendered tile space).
   * @param {number} renderRow The row index (in rendered tile space).
   * @return {import("../DataTile.js").ArrayLike|null} The data.
   */ getPixelData(renderCol, renderRow) {
        if (!this.loaded) return null;
        if (this.tile instanceof (0, _dataTileJsDefault.default)) {
            const data = this.tile.getData();
            const arrayData = (0, _dataTileJs.asArrayLike)(data);
            if (arrayData) {
                const sourceSize = this.tile.getSize();
                return this.getArrayPixelData_(arrayData, sourceSize, renderCol, renderRow);
            }
            return this.getImagePixelData_((0, _dataTileJs.asImageLike)(data), renderCol, renderRow);
        }
        return this.getImagePixelData_(this.tile.getImage(), renderCol, renderRow);
    }
}
exports.default = TileTexture;

},{"./BaseTileRepresentation.js":"cn6Ra","../DataTile.js":"9S3Xd","../events/EventType.js":"3uT2C","../ImageTile.js":"3IBrO","../reproj/Tile.js":"dqATW","./Buffer.js":"esyMP","../webgl.js":"auzQ5","../dom.js":"h98kD","../size.js":"fXEON","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cn6Ra":[function(require,module,exports,__globalThis) {
/**
 * @module ol/webgl/BaseTileRepresentation
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _targetJs = require("../events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageTileJs = require("../ImageTile.js");
var _imageTileJsDefault = parcelHelpers.interopDefault(_imageTileJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _utilJs = require("../util.js");
/**
 * @typedef {import("../Tile.js").default} BaseTileType
 */ /**
 * @template {BaseTileType} TileType
 * @typedef {Object} TileRepresentationOptions
 * @property {TileType} tile The tile.
 * @property {import("../tilegrid/TileGrid.js").default} grid Tile grid.
 * @property {import("../webgl/Helper.js").default} helper WebGL helper.
 * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
 */ /**
 * @classdesc
 * Base class for representing a tile in a webgl context
 * @template {import("../Tile.js").default} TileType
 * @abstract
 */ class BaseTileRepresentation extends (0, _targetJsDefault.default) {
    /**
   * @param {TileRepresentationOptions<TileType>} options The tile representation options.
   */ constructor(options){
        super();
        /**
     * @type {TileType}
     */ this.tile;
        this.handleTileChange_ = this.handleTileChange_.bind(this);
        /**
     * @type {number}
     * @protected
     */ this.gutter_ = options.gutter || 0;
        /**
     * @type {import("../webgl/Helper.js").default}
     * @protected
     */ this.helper_ = options.helper;
        this.loaded = false;
        this.ready = false;
    }
    /**
   * @param {TileType} tile Tile.
   */ setTile(tile) {
        if (tile !== this.tile) {
            if (this.tile) this.tile.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, this.handleTileChange_);
            this.tile = tile;
            this.loaded = tile.getState() === (0, _tileStateJsDefault.default).LOADED;
            if (this.loaded) this.uploadTile();
            else {
                if (tile instanceof (0, _imageTileJsDefault.default)) {
                    const image = tile.getImage();
                    if (image instanceof Image && !image.crossOrigin) image.crossOrigin = 'anonymous';
                }
                tile.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.handleTileChange_);
            }
        }
    }
    /**
   * @abstract
   * @protected
   */ uploadTile() {
        (0, _utilJs.abstract)();
    }
    setReady() {
        this.ready = true;
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    handleTileChange_() {
        if (this.tile.getState() === (0, _tileStateJsDefault.default).LOADED) {
            this.loaded = true;
            this.uploadTile();
        }
    }
    disposeInternal() {
        this.tile.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, this.handleTileChange_);
    }
}
exports.default = BaseTileRepresentation;

},{"../events/Target.js":"dZel6","../events/EventType.js":"3uT2C","../ImageTile.js":"3IBrO","../TileState.js":"2J5J5","../util.js":"l1iPW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"esyMP":[function(require,module,exports,__globalThis) {
/**
 * @module ol/webgl/Buffer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BufferUsage", ()=>BufferUsage);
/**
 * Returns a typed array constructor based on the given buffer type
 * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
 * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.
 */ parcelHelpers.export(exports, "getArrayClassForType", ()=>getArrayClassForType);
var _webglJs = require("../webgl.js");
var _assertsJs = require("../asserts.js");
const BufferUsage = {
    STATIC_DRAW: (0, _webglJs.STATIC_DRAW),
    STREAM_DRAW: (0, _webglJs.STREAM_DRAW),
    DYNAMIC_DRAW: (0, _webglJs.DYNAMIC_DRAW)
};
/**
 * @classdesc
 * Object used to store an array of data as well as usage information for that data.
 * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on
 * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.
 *
 * To populate the array, you can either use:
 * * A size using `#ofSize(buffer)`
 * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`
 * * A plain array using `#fromArray(array)`
 *
 * Note:
 * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)
 * for more info on buffer usage.
 */ class WebGLArrayBuffer {
    /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `DYNAMIC_DRAW`.
   */ constructor(type, usage){
        /**
     * @private
     * @type {Float32Array|Uint32Array|null}
     */ this.array_ = null;
        /**
     * @private
     * @type {number}
     */ this.type_ = type;
        (0, _assertsJs.assert)(type === (0, _webglJs.ARRAY_BUFFER) || type === (0, _webglJs.ELEMENT_ARRAY_BUFFER), 'A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`');
        /**
     * @private
     * @type {number}
     */ this.usage_ = usage !== undefined ? usage : BufferUsage.STATIC_DRAW;
    }
    /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   * @return {WebGLArrayBuffer} This
   */ ofSize(size) {
        this.array_ = new (getArrayClassForType(this.type_))(size);
        return this;
    }
    /**
   * Populates the buffer with an array of the given size.
   * @param {Array<number>} array Numerical array
   * @return {WebGLArrayBuffer} This
   */ fromArray(array) {
        this.array_ = getArrayClassForType(this.type_).from(array);
        return this;
    }
    /**
   * Populates the buffer with a raw binary array buffer.
   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
   * initialized for the same typed array class.
   * @return {WebGLArrayBuffer} This
   */ fromArrayBuffer(buffer) {
        this.array_ = new (getArrayClassForType(this.type_))(buffer);
        return this;
    }
    /**
   * @return {number} Buffer type.
   */ getType() {
        return this.type_;
    }
    /**
   * Will return null if the buffer was not initialized
   * @return {Float32Array|Uint32Array|null} Array.
   */ getArray() {
        return this.array_;
    }
    /**
   * @return {number} Usage.
   */ getUsage() {
        return this.usage_;
    }
    /**
   * Will return 0 if the buffer is not initialized
   * @return {number} Array size
   */ getSize() {
        return this.array_ ? this.array_.length : 0;
    }
}
function getArrayClassForType(type) {
    switch(type){
        case 0, _webglJs.ARRAY_BUFFER:
            return Float32Array;
        case 0, _webglJs.ELEMENT_ARRAY_BUFFER:
            return Uint32Array;
        default:
            return Float32Array;
    }
}
exports.default = WebGLArrayBuffer;

},{"../webgl.js":"auzQ5","../asserts.js":"k0OL6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"auzQ5":[function(require,module,exports,__globalThis) {
/**
 * @module ol/webgl
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ARRAY_BUFFER", ()=>ARRAY_BUFFER);
parcelHelpers.export(exports, "ELEMENT_ARRAY_BUFFER", ()=>ELEMENT_ARRAY_BUFFER);
parcelHelpers.export(exports, "STREAM_DRAW", ()=>STREAM_DRAW);
parcelHelpers.export(exports, "STATIC_DRAW", ()=>STATIC_DRAW);
parcelHelpers.export(exports, "DYNAMIC_DRAW", ()=>DYNAMIC_DRAW);
parcelHelpers.export(exports, "UNSIGNED_BYTE", ()=>UNSIGNED_BYTE);
parcelHelpers.export(exports, "UNSIGNED_SHORT", ()=>UNSIGNED_SHORT);
parcelHelpers.export(exports, "UNSIGNED_INT", ()=>UNSIGNED_INT);
parcelHelpers.export(exports, "FLOAT", ()=>FLOAT);
/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object} [attributes] Attributes.
 * @return {WebGLRenderingContext|null} WebGL rendering context.
 */ parcelHelpers.export(exports, "getContext", ()=>getContext);
/**
 * @return {Array<string>|null} List of supported WebGL extensions.
 */ parcelHelpers.export(exports, "getSupportedExtensions", ()=>getSupportedExtensions);
var _hasJs = require("./has.js");
const ARRAY_BUFFER = 0x8892;
const ELEMENT_ARRAY_BUFFER = 0x8893;
const STREAM_DRAW = 0x88e0;
const STATIC_DRAW = 0x88e4;
const DYNAMIC_DRAW = 0x88e8;
const UNSIGNED_BYTE = 0x1401;
const UNSIGNED_SHORT = 0x1403;
const UNSIGNED_INT = 0x1405;
const FLOAT = 0x1406;
/** end of goog.webgl constants
 */ /**
 * @const
 * @type {Array<string>}
 */ const CONTEXT_IDS = [
    'experimental-webgl',
    'webgl',
    'webkit-3d',
    'moz-webgl'
];
function getContext(canvas, attributes) {
    attributes = Object.assign({
        preserveDrawingBuffer: true,
        antialias: (0, _hasJs.SAFARI_BUG_237906) ? false : true
    }, attributes);
    const ii = CONTEXT_IDS.length;
    for(let i = 0; i < ii; ++i)try {
        const context = canvas.getContext(CONTEXT_IDS[i], attributes);
        if (context) return /** @type {!WebGLRenderingContext} */ context;
    } catch (e) {
    // pass
    }
    return null;
}
/**
 * @type {Array<string>|null}
 */ let supportedExtensions = null;
function getSupportedExtensions() {
    if (!supportedExtensions) {
        const canvas = document.createElement('canvas');
        const gl = getContext(canvas);
        if (gl) supportedExtensions = gl.getSupportedExtensions();
    }
    return supportedExtensions;
}

},{"./has.js":"i07p3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9A0lW":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/webgl/TileLayerBase
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Uniforms", ()=>Uniforms);
/**
 * @typedef {import("../../webgl/BaseTileRepresentation.js").default<import("../../Tile.js").default>} AbstractTileRepresentation
 */ /**
 * @typedef {Object} TileRepresentationLookup
 * @property {Set<string>} tileIds The set of tile ids in the lookup.
 * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.
 */ /**
 * @return {TileRepresentationLookup} A new tile representation lookup.
 */ parcelHelpers.export(exports, "newTileRepresentationLookup", ()=>newTileRepresentationLookup);
parcelHelpers.export(exports, "getCacheKey", ()=>getCacheKey);
var _lrucacheJs = require("../../structs/LRUCache.js");
var _lrucacheJsDefault = parcelHelpers.interopDefault(_lrucacheJs);
var _dataTileJs = require("../../reproj/DataTile.js");
var _dataTileJsDefault = parcelHelpers.interopDefault(_dataTileJs);
var _tileJs = require("../../reproj/Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileRangeJs = require("../../TileRange.js");
var _tileRangeJsDefault = parcelHelpers.interopDefault(_tileRangeJs);
var _tileStateJs = require("../../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _utilJs = require("../../util.js");
var _mat4Js = require("../../vec/mat4.js");
var _tilecoordJs = require("../../tilecoord.js");
var _transformJs = require("../../transform.js");
var _arrayJs = require("../../array.js");
var _projJs = require("../../proj.js");
var _extentJs = require("../../extent.js");
var _sizeJs = require("../../size.js");
const Uniforms = {
    TILE_TRANSFORM: 'u_tileTransform',
    TRANSITION_ALPHA: 'u_transitionAlpha',
    DEPTH: 'u_depth',
    RENDER_EXTENT: 'u_renderExtent',
    PATTERN_ORIGIN: 'u_patternOrigin',
    RESOLUTION: 'u_resolution',
    ZOOM: 'u_zoom',
    GLOBAL_ALPHA: 'u_globalAlpha',
    PROJECTION_MATRIX: 'u_projectionMatrix',
    SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix'
};
/**
 * @type {Object<string, boolean>}
 */ const empty = {};
/**
 * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values
 * have a depth trending towards 0
 * @param {number} z A zoom level.
 * @return {number} A depth value.
 */ function depthForZ(z) {
    return 1 / (z + 2);
}
function newTileRepresentationLookup() {
    return {
        tileIds: new Set(),
        representationsByZ: {}
    };
}
/**
 * Check if a tile is already in the tile representation lookup.
 * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.
 * @param {import("../../Tile.js").default} tile A tile.
 * @return {boolean} The tile is already in the lookup.
 */ function lookupHasTile(tileRepresentationLookup, tile) {
    return tileRepresentationLookup.tileIds.has((0, _utilJs.getUid)(tile));
}
/**
 * Add a tile representation to the lookup.
 * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.
 * @param {AbstractTileRepresentation} tileRepresentation A tile representation.
 * @param {number} z The zoom level.
 */ function addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, z) {
    const representationsByZ = tileRepresentationLookup.representationsByZ;
    if (!(z in representationsByZ)) representationsByZ[z] = new Set();
    representationsByZ[z].add(tileRepresentation);
    tileRepresentationLookup.tileIds.add((0, _utilJs.getUid)(tileRepresentation.tile));
}
/**
 * @param {import("../../Map.js").FrameState} frameState Frame state.
 * @param {import("../../extent.js").Extent} extent The frame extent.
 * @return {import("../../extent.js").Extent} Frame extent intersected with layer extents.
 */ function getRenderExtent(frameState, extent) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    if (layerState.extent) extent = (0, _extentJs.getIntersection)(extent, (0, _projJs.fromUserExtent)(layerState.extent, frameState.viewState.projection));
    const source = /** @type {import("../../source/Tile.js").default} */ layerState.layer.getRenderSource();
    if (!source.getWrapX()) {
        const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();
        if (gridExtent) extent = (0, _extentJs.getIntersection)(extent, gridExtent);
    }
    return extent;
}
function getCacheKey(source, tileCoord) {
    return `${source.getKey()},${(0, _tilecoordJs.getKey)(tileCoord)}`;
}
/**
 * @typedef {Object} Options
 * @property {Object<string, import("../../webgl/Helper").UniformValue>} [uniforms] Additional uniforms
 * made available to shaders.
 * @property {number} [cacheSize=512] The tile representation cache size.
 * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.
 */ /**
 * @typedef {import("../../layer/BaseTile.js").default} BaseLayerType
 */ /**
 * @classdesc
 * Base WebGL renderer for tile layers.
 * @template {BaseLayerType} LayerType
 * @template {import("../../Tile.js").default} TileType
 * @template {import("../../webgl/BaseTileRepresentation.js").default<TileType>} TileRepresentation
 * @extends {WebGLLayerRenderer<LayerType>}
 */ class WebGLBaseTileLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} options Options.
   */ constructor(tileLayer, options){
        super(tileLayer, {
            uniforms: options.uniforms,
            postProcesses: options.postProcesses
        });
        /**
     * The last call to `renderFrame` was completed with all tiles loaded
     * @type {boolean}
     */ this.renderComplete = false;
        /**
     * This transform converts representation coordinates to screen coordinates.
     * @type {import("../../transform.js").Transform}
     * @private
     */ this.tileTransform_ = (0, _transformJs.create)();
        /**
     * @type {Array<number>}
     * @protected
     */ this.tempMat4 = (0, _mat4Js.create)();
        /**
     * @type {import("../../TileRange.js").default}
     * @private
     */ this.tempTileRange_ = new (0, _tileRangeJsDefault.default)(0, 0, 0, 0);
        /**
     * @type {import("../../tilecoord.js").TileCoord}
     * @private
     */ this.tempTileCoord_ = (0, _tilecoordJs.createOrUpdate)(0, 0, 0);
        /**
     * @type {import("../../size.js").Size}
     * @private
     */ this.tempSize_ = [
            0,
            0
        ];
        const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;
        /**
     * @type {import("../../structs/LRUCache.js").default<TileRepresentation>}
     * @protected
     */ this.tileRepresentationCache = new (0, _lrucacheJsDefault.default)(cacheSize);
        /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */ this.frameState = null;
        /**
     * @private
     * @type {import("../../proj/Projection.js").default}
     */ this.projection_ = undefined;
    }
    /**
   * @param {Options} options Options.
   */ reset(options) {
        super.reset({
            uniforms: options.uniforms
        });
    }
    /**
   * @param {TileType} tile Tile.
   * @return {boolean} Tile is drawable.
   * @private
   */ isDrawableTile_(tile) {
        const tileLayer = this.getLayer();
        const tileState = tile.getState();
        const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
        return tileState == (0, _tileStateJsDefault.default).LOADED || tileState == (0, _tileStateJsDefault.default).EMPTY || tileState == (0, _tileStateJsDefault.default).ERROR && !useInterimTilesOnError;
    }
    /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrameInternal(frameState) {
        if (!this.projection_) this.projection_ = frameState.viewState.projection;
        else if (frameState.viewState.projection !== this.projection_) {
            this.clearCache();
            this.projection_ = frameState.viewState.projection;
        }
        const layer = this.getLayer();
        const source = layer.getRenderSource();
        if (!source) return false;
        if ((0, _extentJs.isEmpty)(getRenderExtent(frameState, frameState.extent))) return false;
        return source.getState() === 'ready';
    }
    /**
   * @abstract
   * @param {import("../../webgl/BaseTileRepresentation.js").TileRepresentationOptions<TileType>} options tile representation options
   * @return {TileRepresentation} A new tile representation
   * @protected
   */ createTileRepresentation(options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.
   * @param {number} preload Number of additional levels to load.
   */ enqueueTiles(frameState, extent, initialZ, tileRepresentationLookup, preload) {
        const viewState = frameState.viewState;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getRenderSource();
        const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
        const gutter = tileSource.getGutterForProjection(viewState.projection);
        const tileSourceKey = (0, _utilJs.getUid)(tileSource);
        if (!(tileSourceKey in frameState.wantedTiles)) frameState.wantedTiles[tileSourceKey] = {};
        const wantedTiles = frameState.wantedTiles[tileSourceKey];
        const tileRepresentationCache = this.tileRepresentationCache;
        const map = tileLayer.getMapInternal();
        const minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));
        for(let z = initialZ; z >= minZ; --z){
            const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);
            const tileResolution = tileGrid.getResolution(z);
            for(let x = tileRange.minX; x <= tileRange.maxX; ++x)for(let y = tileRange.minY; y <= tileRange.maxY; ++y){
                const tileCoord = (0, _tilecoordJs.createOrUpdate)(z, x, y, this.tempTileCoord_);
                const cacheKey = getCacheKey(tileSource, tileCoord);
                /** @type {TileRepresentation} */ let tileRepresentation;
                /** @type {TileType} */ let tile;
                if (tileRepresentationCache.containsKey(cacheKey)) {
                    tileRepresentation = tileRepresentationCache.get(cacheKey);
                    tile = tileRepresentation.tile;
                }
                if (!tileRepresentation || tileRepresentation.tile.key !== tileSource.getKey()) tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);
                if (lookupHasTile(tileRepresentationLookup, tile)) continue;
                if (!tileRepresentation) {
                    tileRepresentation = this.createTileRepresentation({
                        tile: tile,
                        grid: tileGrid,
                        helper: this.helper,
                        gutter: gutter
                    });
                    tileRepresentationCache.set(cacheKey, tileRepresentation);
                } else if (this.isDrawableTile_(tile)) tileRepresentation.setTile(tile);
                else {
                    const interimTile = /** @type {TileType} */ tile.getInterimTile();
                    tileRepresentation.setTile(interimTile);
                }
                addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, z);
                const tileQueueKey = tile.getKey();
                wantedTiles[tileQueueKey] = true;
                if (tile.getState() === (0, _tileStateJsDefault.default).IDLE) {
                    if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) frameState.tileQueue.enqueue([
                        tile,
                        tileSourceKey,
                        tileGrid.getTileCoordCenter(tileCoord),
                        tileResolution
                    ]);
                }
            }
        }
    }
    /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha
   * @protected
   */ beforeTilesRender(frameState, tilesWithAlpha) {
        this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);
    }
    /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} If returns false, tile mask rendering will be skipped
   * @protected
   */ beforeTilesMaskRender(frameState) {
        return false;
    }
    /**
   * @param {TileRepresentation} tileRepresentation Tile representation
   * @param {import("../../transform.js").Transform} tileTransform Tile transform
   * @param {import("../../Map.js").FrameState} frameState Frame state
   * @param {import("../../extent.js").Extent} renderExtent Render extent
   * @param {number} tileResolution Tile resolution
   * @param {import("../../size.js").Size} tileSize Tile size
   * @param {import("../../coordinate.js").Coordinate} tileOrigin Tile origin
   * @param {import("../../extent.js").Extent} tileExtent tile Extent
   * @param {number} depth Depth
   * @param {number} gutter Gutter
   * @param {number} alpha Alpha
   * @protected
   */ renderTile(tileRepresentation, tileTransform, frameState, renderExtent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha) {}
    /**
   * @param {TileRepresentation} tileRepresentation Tile representation
   * @param {number} tileZ Tile Z
   * @param {import("../../extent.js").Extent} extent Render extent
   * @param {number} depth Depth
   * @protected
   */ renderTileMask(tileRepresentation, tileZ, extent, depth) {}
    drawTile_(frameState, tileRepresentation, tileZ, gutter, extent, alphaLookup, tileGrid) {
        if (!tileRepresentation.ready) return;
        const tile = tileRepresentation.tile;
        const tileCoord = tile.tileCoord;
        const tileCoordKey = (0, _tilecoordJs.getKey)(tileCoord);
        const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;
        const tileResolution = tileGrid.getResolution(tileZ);
        const tileSize = (0, _sizeJs.toSize)(tileGrid.getTileSize(tileZ), this.tempSize_);
        const tileOrigin = tileGrid.getOrigin(tileZ);
        const tileExtent = tileGrid.getTileCoordExtent(tileCoord);
        // tiles with alpha are rendered last to allow blending
        const depth = alpha < 1 ? -1 : depthForZ(tileZ);
        if (alpha < 1) frameState.animate = true;
        const viewState = frameState.viewState;
        const centerX = viewState.center[0];
        const centerY = viewState.center[1];
        const tileWidthWithGutter = tileSize[0] + 2 * gutter;
        const tileHeightWithGutter = tileSize[1] + 2 * gutter;
        const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;
        const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);
        const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);
        const tileScale = viewState.resolution / tileResolution;
        const tileCenterI = tileCoord[1];
        const tileCenterJ = tileCoord[2];
        (0, _transformJs.reset)(this.tileTransform_);
        (0, _transformJs.scale)(this.tileTransform_, 2 / (frameState.size[0] * tileScale / tileWidthWithGutter), -2 / (frameState.size[1] * tileScale / tileWidthWithGutter));
        (0, _transformJs.rotate)(this.tileTransform_, viewState.rotation);
        (0, _transformJs.scale)(this.tileTransform_, 1, 1 / aspectRatio);
        (0, _transformJs.translate)(this.tileTransform_, (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter, (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter);
        this.renderTile(/** @type {TileRepresentation} */ tileRepresentation, this.tileTransform_, frameState, extent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha);
    }
    /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   */ renderFrame(frameState) {
        this.frameState = frameState;
        this.renderComplete = true;
        const gl = this.helper.getGL();
        this.preRender(gl, frameState);
        const viewState = frameState.viewState;
        const tileLayer = this.getLayer();
        const tileSource = tileLayer.getRenderSource();
        const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
        const gutter = tileSource.getGutterForProjection(viewState.projection);
        const extent = getRenderExtent(frameState, frameState.extent);
        const z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
        /**
     * @type {TileRepresentationLookup}
     */ const tileRepresentationLookup = newTileRepresentationLookup();
        const preload = tileLayer.getPreload();
        if (frameState.nextExtent) {
            const targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);
            const nextExtent = getRenderExtent(frameState, frameState.nextExtent);
            this.enqueueTiles(frameState, nextExtent, targetZ, tileRepresentationLookup, preload);
        }
        this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);
        if (preload > 0) setTimeout(()=>{
            this.enqueueTiles(frameState, extent, z - 1, tileRepresentationLookup, preload - 1);
        }, 0);
        /**
     * A lookup of alpha values for tiles at the target rendering resolution
     * for tiles that are in transition.  If a tile coord key is absent from
     * this lookup, the tile should be rendered at alpha 1.
     * @type {Object<string, number>}
     */ const alphaLookup = {};
        const uid = (0, _utilJs.getUid)(this);
        const time = frameState.time;
        let blend = false;
        // look for cached tiles to use if a target tile is not ready
        for (const tileRepresentation of tileRepresentationLookup.representationsByZ[z]){
            const tile = tileRepresentation.tile;
            if ((tile instanceof (0, _tileJsDefault.default) || tile instanceof (0, _dataTileJsDefault.default)) && tile.getState() === (0, _tileStateJsDefault.default).EMPTY) continue;
            const tileCoord = tile.tileCoord;
            if (tileRepresentation.ready) {
                const alpha = tile.getAlpha(uid, time);
                if (alpha === 1) {
                    // no need to look for alt tiles
                    tile.endTransition(uid);
                    continue;
                }
                blend = true;
                const tileCoordKey = (0, _tilecoordJs.getKey)(tileCoord);
                alphaLookup[tileCoordKey] = alpha;
            }
            this.renderComplete = false;
            // first look for child tiles (at z + 1)
            const coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileRepresentationLookup);
            if (coveredByChildren) continue;
            // next look for parent tiles
            const minZoom = tileGrid.getMinZoom();
            for(let parentZ = z - 1; parentZ >= minZoom; --parentZ){
                const coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileRepresentationLookup);
                if (coveredByParent) break;
            }
        }
        const representationsByZ = tileRepresentationLookup.representationsByZ;
        const zs = Object.keys(representationsByZ).map(Number).sort((0, _arrayJs.descending));
        const renderTileMask = this.beforeTilesMaskRender(frameState);
        if (renderTileMask) for(let j = 0, jj = zs.length; j < jj; ++j){
            const tileZ = zs[j];
            for (const tileRepresentation of representationsByZ[tileZ]){
                const tileCoord = tileRepresentation.tile.tileCoord;
                const tileCoordKey = (0, _tilecoordJs.getKey)(tileCoord);
                // do not render the tile mask if alpha < 1
                if (tileCoordKey in alphaLookup) continue;
                const tileExtent = tileGrid.getTileCoordExtent(tileCoord);
                this.renderTileMask(/** @type {TileRepresentation} */ tileRepresentation, tileZ, tileExtent, depthForZ(tileZ));
            }
        }
        this.beforeTilesRender(frameState, blend);
        for(let j = 0, jj = zs.length; j < jj; ++j){
            const tileZ = zs[j];
            for (const tileRepresentation of representationsByZ[tileZ]){
                const tileCoord = tileRepresentation.tile.tileCoord;
                const tileCoordKey = (0, _tilecoordJs.getKey)(tileCoord);
                if (tileCoordKey in alphaLookup) continue;
                this.drawTile_(frameState, tileRepresentation, tileZ, gutter, extent, alphaLookup, tileGrid);
            }
        }
        for (const tileRepresentation of representationsByZ[z]){
            const tileCoord = tileRepresentation.tile.tileCoord;
            const tileCoordKey = (0, _tilecoordJs.getKey)(tileCoord);
            if (tileCoordKey in alphaLookup) this.drawTile_(frameState, tileRepresentation, z, gutter, extent, alphaLookup, tileGrid);
        }
        this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
        const canvas = this.helper.getCanvas();
        const tileRepresentationCache = this.tileRepresentationCache;
        while(tileRepresentationCache.canExpireCache()){
            const tileRepresentation = tileRepresentationCache.pop();
            tileRepresentation.dispose();
        }
        // TODO: let the renderers manage their own cache instead of managing the source cache
        /**
     * Here we unconditionally expire the source cache since the renderer maintains
     * its own cache.
     * @param {import("../../Map.js").default} map Map.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */ const postRenderFunction = function(map, frameState) {
            tileSource.updateCacheSize(0.1, frameState.viewState.projection);
            tileSource.expireCache(frameState.viewState.projection, empty);
        };
        frameState.postRenderFunctions.push(postRenderFunction);
        this.postRender(gl, frameState);
        return canvas;
    }
    /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of
   * tile representations by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */ findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {
        const tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);
        if (!tileRange) return false;
        let covered = true;
        const tileRepresentationCache = this.tileRepresentationCache;
        const source = this.getLayer().getRenderSource();
        for(let x = tileRange.minX; x <= tileRange.maxX; ++x)for(let y = tileRange.minY; y <= tileRange.maxY; ++y){
            const cacheKey = getCacheKey(source, [
                altZ,
                x,
                y
            ]);
            let loaded = false;
            if (tileRepresentationCache.containsKey(cacheKey)) {
                const tileRepresentation = tileRepresentationCache.get(cacheKey);
                if (tileRepresentation.ready && !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)) {
                    addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, altZ);
                    loaded = true;
                }
            }
            if (!loaded) covered = false;
        }
        return covered;
    }
    clearCache() {
        const tileRepresentationCache = this.tileRepresentationCache;
        tileRepresentationCache.forEach((tileRepresentation)=>tileRepresentation.dispose());
        tileRepresentationCache.clear();
    }
    removeHelper() {
        if (this.helper) this.clearCache();
        super.removeHelper();
    }
    /**
   * Clean up.
   */ disposeInternal() {
        super.disposeInternal();
        delete this.frameState;
    }
}
exports.default = WebGLBaseTileLayerRenderer;

},{"../../structs/LRUCache.js":"cdXrp","../../reproj/DataTile.js":"hOKCN","../../reproj/Tile.js":"dqATW","../../TileRange.js":"gx7Pm","../../TileState.js":"2J5J5","./Layer.js":"8eaOz","../../util.js":"l1iPW","../../vec/mat4.js":"EdMck","../../tilecoord.js":"ksONy","../../transform.js":"9LrRk","../../array.js":"hyet5","../../proj.js":"8OK47","../../extent.js":"bGUel","../../size.js":"fXEON","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8eaOz":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/webgl/Layer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _propertyJs = require("../../layer/Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _layerJs = require("../Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _eventJs = require("../../render/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _helperJs = require("../../webgl/Helper.js");
var _helperJsDefault = parcelHelpers.interopDefault(_helperJs);
var _transformJs = require("../../transform.js");
/**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */ /**
 * @typedef {Object} Options
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 */ /**
 * @classdesc
 * Base WebGL renderer class.
 * Holds all logic related to data manipulation & some common rendering logic
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */ class WebGLLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {LayerType} layer Layer.
   * @param {Options} [options] Options.
   */ constructor(layer, options){
        super(layer);
        options = options || {};
        /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform is only
     * set before dispatching rendering events.
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.inversePixelTransform_ = (0, _transformJs.create)();
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.pixelContext_ = null;
        /**
     * @private
     */ this.postProcesses_ = options.postProcesses;
        /**
     * @private
     */ this.uniforms_ = options.uniforms;
        /**
     * @type {WebGLHelper}
     * @protected
     */ this.helper;
        layer.addChangeListener((0, _propertyJsDefault.default).MAP, this.removeHelper.bind(this));
        this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);
        this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
    }
    /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ dispatchPreComposeEvent(context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener((0, _eventTypeJsDefault.default).PRECOMPOSE)) {
            const event = new (0, _eventJsDefault.default)((0, _eventTypeJsDefault.default).PRECOMPOSE, undefined, frameState, context);
            layer.dispatchEvent(event);
        }
    }
    /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ dispatchPostComposeEvent(context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener((0, _eventTypeJsDefault.default).POSTCOMPOSE)) {
            const event = new (0, _eventJsDefault.default)((0, _eventTypeJsDefault.default).POSTCOMPOSE, undefined, frameState, context);
            layer.dispatchEvent(event);
        }
    }
    /**
   * Reset options (only handles uniforms).
   * @param {Options} options Options.
   */ reset(options) {
        this.uniforms_ = options.uniforms;
        if (this.helper) this.helper.setUniforms(this.uniforms_);
    }
    /**
   * @protected
   */ removeHelper() {
        if (this.helper) {
            this.helper.dispose();
            delete this.helper;
        }
    }
    /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        if (this.getLayer().getRenderSource()) {
            let incrementGroup = true;
            let groupNumber = -1;
            let className;
            for(let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++){
                const layer = frameState.layerStatesArray[i].layer;
                const renderer = layer.getRenderer();
                if (!(renderer instanceof WebGLLayerRenderer)) {
                    incrementGroup = true;
                    continue;
                }
                const layerClassName = layer.getClassName();
                if (incrementGroup || layerClassName !== className) {
                    groupNumber += 1;
                    incrementGroup = false;
                }
                className = layerClassName;
                if (renderer === this) break;
            }
            const canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;
            if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey) || this.helper.needsToBeRecreated()) {
                this.removeHelper();
                this.helper = new (0, _helperJsDefault.default)({
                    postProcesses: this.postProcesses_,
                    uniforms: this.uniforms_,
                    canvasCacheKey: canvasCacheKey
                });
                if (className) this.helper.getCanvas().className = className;
                this.afterHelperCreated();
            }
        }
        return this.prepareFrameInternal(frameState);
    }
    /**
   * @protected
   */ afterHelperCreated() {}
    /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @protected
   */ prepareFrameInternal(frameState) {
        return true;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        this.removeHelper();
        super.disposeInternal();
    }
    /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */ dispatchRenderEvent_(type, context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
            (0, _transformJs.compose)(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);
            const event = new (0, _eventJsDefault.default)(type, this.inversePixelTransform_, frameState, context);
            layer.dispatchEvent(event);
        }
    }
    /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ preRender(context, frameState) {
        this.dispatchRenderEvent_((0, _eventTypeJsDefault.default).PRERENDER, context, frameState);
    }
    /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ postRender(context, frameState) {
        this.dispatchRenderEvent_((0, _eventTypeJsDefault.default).POSTRENDER, context, frameState);
    }
}
exports.default = WebGLLayerRenderer;

},{"../../layer/Property.js":"50gL3","../Layer.js":"90Wfg","../../render/Event.js":"e6ARE","../../render/EventType.js":"1ajEk","../../webgl/Helper.js":"38rQm","../../transform.js":"9LrRk","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"38rQm":[function(require,module,exports,__globalThis) {
/**
 * @module ol/webgl/Helper
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ShaderType", ()=>ShaderType);
parcelHelpers.export(exports, "DefaultUniform", ()=>DefaultUniform);
parcelHelpers.export(exports, "AttributeType", ()=>AttributeType);
/**
 * Compute a stride in bytes based on a list of attributes
 * @param {Array<AttributeDescription>} attributes Ordered list of attributes
 * @return {number} Stride, ie amount of values for each vertex in the vertex buffer
 */ parcelHelpers.export(exports, "computeAttributesStride", ()=>computeAttributesStride);
var _contextEventTypeJs = require("../webgl/ContextEventType.js");
var _contextEventTypeJsDefault = parcelHelpers.interopDefault(_contextEventTypeJs);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _postProcessingPassJs = require("./PostProcessingPass.js");
var _postProcessingPassJsDefault = parcelHelpers.interopDefault(_postProcessingPassJs);
var _webglJs = require("../webgl.js");
var _objJs = require("../obj.js");
var _transformJs = require("../transform.js");
var _mat4Js = require("../vec/mat4.js");
var _utilJs = require("../util.js");
const ShaderType = {
    FRAGMENT_SHADER: 0x8b30,
    VERTEX_SHADER: 0x8b31
};
const DefaultUniform = {
    PROJECTION_MATRIX: 'u_projectionMatrix',
    SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',
    TIME: 'u_time',
    ZOOM: 'u_zoom',
    RESOLUTION: 'u_resolution',
    ROTATION: 'u_rotation',
    VIEWPORT_SIZE_PX: 'u_viewportSizePx',
    PIXEL_RATIO: 'u_pixelRatio',
    HIT_DETECTION: 'u_hitDetection'
};
const AttributeType = {
    UNSIGNED_BYTE: (0, _webglJs.UNSIGNED_BYTE),
    UNSIGNED_SHORT: (0, _webglJs.UNSIGNED_SHORT),
    UNSIGNED_INT: (0, _webglJs.UNSIGNED_INT),
    FLOAT: (0, _webglJs.FLOAT)
};
/**
 * Description of an attribute in a buffer
 * @typedef {Object} AttributeDescription
 * @property {string} name Attribute name to use in shaders
 * @property {number} size Number of components per attributes
 * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is
 * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).
 * Default is `FLOAT`.
 */ /**
 * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import("../transform").Transform} UniformLiteralValue
 */ /**
 * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning
 * one of the previous types.
 * @typedef {UniformLiteralValue|function(import("../Map.js").FrameState):UniformLiteralValue} UniformValue
 */ /**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas which will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step
 */ /**
 * @typedef {Object} Options
 * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform
 * names in the provided or default shaders.
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 * @property {string} [canvasCacheKey] The cache key for the canvas.
 */ /**
 * @typedef {Object} UniformInternalDescription
 * @property {string} name Name
 * @property {UniformValue} [value] Value
 * @property {UniformValue} [prevValue] The previous value.
 * @property {WebGLTexture} [texture] Texture
 * @private
 */ /**
 * @typedef {Object} CanvasCacheItem
 * @property {WebGLRenderingContext} context The context of this canvas.
 * @property {number} users The count of users of this canvas.
 */ /**
 * @type {Object<string,CanvasCacheItem>}
 */ const canvasCache = {};
/**
 * @param {string} key The cache key for the canvas.
 * @return {string} The shared cache key.
 */ function getSharedCanvasCacheKey(key) {
    return 'shared/' + key;
}
let uniqueCanvasCacheKeyCount = 0;
/**
 * @return {string} The unique cache key.
 */ function getUniqueCanvasCacheKey() {
    const key = 'unique/' + uniqueCanvasCacheKeyCount;
    uniqueCanvasCacheKeyCount += 1;
    return key;
}
/**
 * @param {string} key The cache key for the canvas.
 * @return {WebGLRenderingContext} The canvas.
 */ function getOrCreateContext(key) {
    let cacheItem = canvasCache[key];
    if (!cacheItem) {
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        canvas.style.position = 'absolute';
        canvas.style.left = '0';
        const context = (0, _webglJs.getContext)(canvas);
        cacheItem = {
            users: 0,
            context
        };
        canvasCache[key] = cacheItem;
    }
    cacheItem.users += 1;
    return cacheItem.context;
}
/**
 * @param {string} key The cache key for the canvas.
 */ function releaseCanvas(key) {
    const cacheItem = canvasCache[key];
    if (!cacheItem) return;
    cacheItem.users -= 1;
    if (cacheItem.users > 0) return;
    const gl = cacheItem.context;
    const extension = gl.getExtension('WEBGL_lose_context');
    if (extension) extension.loseContext();
    const canvas = gl.canvas;
    canvas.width = 1;
    canvas.height = 1;
    delete canvasCache[key];
}
/**
 * @classdesc
 * This class is intended to provide low-level functions related to WebGL rendering, so that accessing
 * directly the WebGL API should not be required anymore.
 *
 * Several operations are handled by the `WebGLHelper` class:
 *
 * ### Define custom shaders and uniforms
 *
 *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:
 *
 *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).
 *   Outputs are:
 *
 *   * `gl_Position`: position of the vertex in screen space
 *
 *   * Varyings usually prefixed with `v_` are passed on to the fragment shader
 *
 *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.
 *
 *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that
 *   can be changed at every frame and can be of type float, arrays of float or images.
 *
 *   Shaders must be compiled and assembled into a program like so:
 *   ```js
 *   // here we simply create two shaders and assemble them in a program which is then used
 *   // for subsequent rendering calls; note how a frameState is required to set up a program,
 *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)
 *   const vertexShader = new WebGLVertex(VERTEX_SHADER);
 *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);
 *   const program = this.context.getProgram(fragmentShader, vertexShader);
 *   helper.useProgram(this.program, frameState);
 *   ```
 *
 *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.
 *   You can also change their value along the way like so:
 *   ```js
 *   helper.setUniformFloatValue('u_value', valueAsNumber);
 *   ```
 *
 * ### Defining post processing passes
 *
 *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas
 *   while applying special effects in screen space.
 *   Typical uses are: blurring, color manipulation, depth of field, filtering...
 *
 *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.
 *   A post process step accepts the following options:
 *
 *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.
 *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.
 *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.
 *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.
 *
 *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.
 *
 * ### Binding WebGL buffers and flushing data into them
 *
 *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.
 *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.
 *   This is done using {@link bindBuffer}.
 *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using
 *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.
 *
 *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}
 *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).
 *
 *   Examples below:
 *   ```js
 *   // at initialization phase
 *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *
 *   // when array values have changed
 *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *
 *   // at rendering phase
 *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *   ```
 *
 * ### Specifying attributes
 *
 *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).
 *   Attributes are used to specify these uses. Specify the attribute names with
 *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).
 *
 *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.
 *   ```js
 *   // here we indicate that the data array has the following structure:
 *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]
 *   helper.enableAttributes([
 *     {
 *        name: 'a_position',
 *        size: 2
 *     },
 *     {
 *       name: 'a_offset',
 *       size: 2
 *     },
 *     {
 *       name: 'a_texCoord',
 *       size: 2
 *     }
 *   ])
 *   ```
 *
 * ### Rendering primitives
 *
 *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.
 *   ```js
 *   // frame preparation step
 *   helper.prepareDraw(frameState);
 *
 *   // call this for every data array that has to be rendered on screen
 *   helper.drawElements(0, this.indicesBuffer.getArray().length);
 *
 *   // finalize the rendering by applying post processes
 *   helper.finalizeDraw(frameState);
 *   ```
 *
 * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 */ class WebGLHelper extends (0, _disposableJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        options = options || {};
        /** @private */ this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this);
        /** @private */ this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this);
        /**
     * @private
     * @type {string}
     */ this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();
        /**
     * @private
     * @type {WebGLRenderingContext}
     */ this.gl_ = getOrCreateContext(this.canvasCacheKey_);
        /**
     * @private
     * @type {!Object<string, BufferCacheEntry>}
     */ this.bufferCache_ = {};
        /**
     * @private
     * @type {Object<string, Object>}
     */ this.extensionCache_ = {};
        /**
     * @private
     * @type {WebGLProgram}
     */ this.currentProgram_ = null;
        /**
     * @private
     * @type boolean
     */ this.needsToBeRecreated_ = false;
        const canvas = this.gl_.canvas;
        canvas.addEventListener((0, _contextEventTypeJsDefault.default).LOST, this.boundHandleWebGLContextLost_);
        canvas.addEventListener((0, _contextEventTypeJsDefault.default).RESTORED, this.boundHandleWebGLContextRestored_);
        /**
     * @private
     * @type {import("../transform.js").Transform}
     */ this.offsetRotateMatrix_ = (0, _transformJs.create)();
        /**
     * @private
     * @type {import("../transform.js").Transform}
     */ this.offsetScaleMatrix_ = (0, _transformJs.create)();
        /**
     * @private
     * @type {Array<number>}
     */ this.tmpMat4_ = (0, _mat4Js.create)();
        /**
     * @private
     * @type {Object<string, Object<string, WebGLUniformLocation>>}
     */ this.uniformLocationsByProgram_ = {};
        /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */ this.attribLocationsByProgram_ = {};
        /**
     * Holds info about custom uniforms used in the post processing pass.
     * If the uniform is a texture, the WebGL Texture object will be stored here.
     * @type {Array<UniformInternalDescription>}
     * @private
     */ this.uniforms_ = [];
        if (options.uniforms) this.setUniforms(options.uniforms);
        /**
     * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the
     * options. If no post process was given, a default one is used (so as not to have to make an exception to
     * the frame buffer logic).
     * @type {Array<WebGLPostProcessingPass>}
     * @private
     */ this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map((options)=>new (0, _postProcessingPassJsDefault.default)({
                webGlContext: this.gl_,
                scaleRatio: options.scaleRatio,
                vertexShader: options.vertexShader,
                fragmentShader: options.fragmentShader,
                uniforms: options.uniforms
            })) : [
            new (0, _postProcessingPassJsDefault.default)({
                webGlContext: this.gl_
            })
        ];
        /**
     * @type {string|null}
     * @private
     */ this.shaderCompileErrors_ = null;
        /**
     * @type {number}
     * @private
     */ this.startTime_ = Date.now();
    }
    /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */ setUniforms(uniforms) {
        this.uniforms_ = [];
        this.addUniforms(uniforms);
    }
    /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */ addUniforms(uniforms) {
        for(const name in uniforms)this.uniforms_.push({
            name: name,
            value: uniforms[name]
        });
    }
    /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */ canvasCacheKeyMatches(canvasCacheKey) {
        return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
    }
    /**
   * Get a WebGL extension.  If the extension is not supported, null is returned.
   * Extensions are cached after they are enabled for the first time.
   * @param {string} name The extension name.
   * @return {Object|null} The extension or null if not supported.
   */ getExtension(name) {
        if (name in this.extensionCache_) return this.extensionCache_[name];
        const extension = this.gl_.getExtension(name);
        this.extensionCache_[name] = extension;
        return extension;
    }
    /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {import("./Buffer").default} buffer Buffer.
   */ bindBuffer(buffer) {
        const gl = this.gl_;
        const bufferKey = (0, _utilJs.getUid)(buffer);
        let bufferCache = this.bufferCache_[bufferKey];
        if (!bufferCache) {
            const webGlBuffer = gl.createBuffer();
            bufferCache = {
                buffer: buffer,
                webGlBuffer: webGlBuffer
            };
            this.bufferCache_[bufferKey] = bufferCache;
        }
        gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);
    }
    /**
   * Update the data contained in the buffer array; this is required for the
   * new data to be rendered
   * @param {import("./Buffer").default} buffer Buffer.
   */ flushBufferData(buffer) {
        const gl = this.gl_;
        this.bindBuffer(buffer);
        gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());
    }
    /**
   * @param {import("./Buffer.js").default} buf Buffer.
   */ deleteBuffer(buf) {
        const gl = this.gl_;
        const bufferKey = (0, _utilJs.getUid)(buf);
        const bufferCacheEntry = this.bufferCache_[bufferKey];
        if (bufferCacheEntry && !gl.isContextLost()) gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
        delete this.bufferCache_[bufferKey];
    }
    /**
   * Clean up.
   */ disposeInternal() {
        const canvas = this.gl_.canvas;
        canvas.removeEventListener((0, _contextEventTypeJsDefault.default).LOST, this.boundHandleWebGLContextLost_);
        canvas.removeEventListener((0, _contextEventTypeJsDefault.default).RESTORED, this.boundHandleWebGLContextRestored_);
        releaseCanvas(this.canvasCacheKey_);
        delete this.gl_;
    }
    /**
   * Clear the buffer & set the viewport to draw.
   * Post process passes will be initialized here, the first one being bound as a render target for
   * subsequent draw calls.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   * @param {boolean} [enableDepth] If true, enables depth testing.
   */ prepareDraw(frameState, disableAlphaBlend, enableDepth) {
        const gl = this.gl_;
        const canvas = this.getCanvas();
        const size = frameState.size;
        const pixelRatio = frameState.pixelRatio;
        if (canvas.width !== size[0] * pixelRatio || canvas.height !== size[1] * pixelRatio) {
            canvas.width = size[0] * pixelRatio;
            canvas.height = size[1] * pixelRatio;
            canvas.style.width = size[0] + 'px';
            canvas.style.height = size[1] + 'px';
        }
        // loop backwards in post processes list
        for(let i = this.postProcessPasses_.length - 1; i >= 0; i--)this.postProcessPasses_[i].init(frameState);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.depthRange(0.0, 1.0);
        gl.clearDepth(1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
        if (enableDepth) {
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
        } else gl.disable(gl.DEPTH_TEST);
    }
    /**
   * Prepare a program to use a texture.
   * @param {WebGLTexture} texture The texture.
   * @param {number} slot The texture slot.
   * @param {string} uniformName The corresponding uniform name.
   */ bindTexture(texture, slot, uniformName) {
        const gl = this.gl_;
        gl.activeTexture(gl.TEXTURE0 + slot);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(this.getUniformLocation(uniformName), slot);
    }
    /**
   * Clear the render target & bind it for future draw operations.
   * This is similar to `prepareDraw`, only post processes will not be applied.
   * Note: the whole viewport will be drawn to the render target, regardless of its size.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   * @param {boolean} [enableDepth] If true, enables depth testing.
   */ prepareDrawToRenderTarget(frameState, renderTarget, disableAlphaBlend, enableDepth) {
        const gl = this.gl_;
        const size = renderTarget.getSize();
        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
        gl.bindRenderbuffer(gl.RENDERBUFFER, renderTarget.getDepthbuffer());
        gl.viewport(0, 0, size[0], size[1]);
        gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.depthRange(0.0, 1.0);
        gl.clearDepth(1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
        if (enableDepth) {
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
        } else gl.disable(gl.DEPTH_TEST);
    }
    /**
   * Execute a draw call based on the currently bound program, texture, buffers, attributes.
   * @param {number} start Start index.
   * @param {number} end End index.
   */ drawElements(start, end) {
        const gl = this.gl_;
        this.getExtension('OES_element_index_uint');
        const elementType = gl.UNSIGNED_INT;
        const elementSize = 4;
        const numItems = end - start;
        const offsetInBytes = start * elementSize;
        gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
    }
    /**
   * Apply the successive post process passes which will eventually render to the actual canvas.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */ finalizeDraw(frameState, preCompose, postCompose) {
        // apply post processes using the next one as target
        for(let i = 0, ii = this.postProcessPasses_.length; i < ii; i++)if (i === ii - 1) this.postProcessPasses_[i].apply(frameState, null, preCompose, postCompose);
        else this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1]);
    }
    /**
   * @return {HTMLCanvasElement} Canvas.
   */ getCanvas() {
        return /** @type {HTMLCanvasElement} */ this.gl_.canvas;
    }
    /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */ getGL() {
        return this.gl_;
    }
    /**
   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ applyFrameState(frameState) {
        const size = frameState.size;
        const rotation = frameState.viewState.rotation;
        const pixelRatio = frameState.pixelRatio;
        this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);
        this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
        this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
        this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);
        this.setUniformFloatVec2(DefaultUniform.VIEWPORT_SIZE_PX, [
            size[0],
            size[1]
        ]);
        this.setUniformFloatValue(DefaultUniform.ROTATION, rotation);
    }
    /**
   * Sets the `u_hitDetection` uniform.
   * @param {boolean} enabled Whether to enable the hit detection code path
   */ applyHitDetectionUniform(enabled) {
        const loc = this.getUniformLocation(DefaultUniform.HIT_DETECTION);
        this.getGL().uniform1i(loc, enabled ? 1 : 0);
        // hit detection uses a fixed pixel ratio
        if (enabled) this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, 0.5);
    }
    /**
   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ applyUniforms(frameState) {
        const gl = this.gl_;
        let value;
        let textureSlot = 0;
        this.uniforms_.forEach((uniform)=>{
            value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value;
            // apply value based on type
            if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
                // create a texture & put data
                if (!uniform.texture) {
                    uniform.prevValue = undefined;
                    uniform.texture = gl.createTexture();
                }
                this.bindTexture(uniform.texture, textureSlot, uniform.name);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                const imageReady = !(value instanceof HTMLImageElement) || /** @type {HTMLImageElement} */ value.complete;
                if (imageReady && uniform.prevValue !== value) {
                    uniform.prevValue = value;
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
                }
                textureSlot++;
            } else if (Array.isArray(value) && value.length === 6) this.setUniformMatrixValue(uniform.name, (0, _mat4Js.fromTransform)(this.tmpMat4_, value));
            else if (Array.isArray(value) && value.length <= 4) switch(value.length){
                case 2:
                    gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);
                    return;
                case 3:
                    gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);
                    return;
                case 4:
                    gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
                    return;
                default:
                    return;
            }
            else if (typeof value === 'number') gl.uniform1f(this.getUniformLocation(uniform.name), value);
        });
    }
    /**
   * Set up a program for use. The program will be set as the current one. Then, the uniforms used
   * in the program will be set based on the current frame state and the helper configuration.
   * @param {WebGLProgram} program Program.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ useProgram(program, frameState) {
        const gl = this.gl_;
        gl.useProgram(program);
        this.currentProgram_ = program;
        this.applyFrameState(frameState);
        this.applyUniforms(frameState);
    }
    /**
   * Will attempt to compile a vertex or fragment shader based on source
   * On error, the shader will be returned but
   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
   * Use `gl.getShaderInfoLog(shader)` to have details
   * @param {string} source Shader source
   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
   * @return {WebGLShader} Shader object
   */ compileShader(source, type) {
        const gl = this.gl_;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
    }
    /**
   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
   * @param {string} fragmentShaderSource Fragment shader source.
   * @param {string} vertexShaderSource Vertex shader source.
   * @return {WebGLProgram} Program
   */ getProgram(fragmentShaderSource, vertexShaderSource) {
        const gl = this.gl_;
        const fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        const vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.linkProgram(program);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            const message = `Fragment shader compilation failed: ${gl.getShaderInfoLog(fragmentShader)}`;
            throw new Error(message);
        }
        gl.deleteShader(fragmentShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            const message = `Vertex shader compilation failed: ${gl.getShaderInfoLog(vertexShader)}`;
            throw new Error(message);
        }
        gl.deleteShader(vertexShader);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            const message = `GL program linking failed: ${gl.getProgramInfoLog(program)}`;
            throw new Error(message);
        }
        return program;
    }
    /**
   * Will get the location from the shader or the cache
   * @param {string} name Uniform name
   * @return {WebGLUniformLocation} uniformLocation
   */ getUniformLocation(name) {
        const programUid = (0, _utilJs.getUid)(this.currentProgram_);
        if (this.uniformLocationsByProgram_[programUid] === undefined) this.uniformLocationsByProgram_[programUid] = {};
        if (this.uniformLocationsByProgram_[programUid][name] === undefined) this.uniformLocationsByProgram_[programUid][name] = this.gl_.getUniformLocation(this.currentProgram_, name);
        return this.uniformLocationsByProgram_[programUid][name];
    }
    /**
   * Will get the location from the shader or the cache
   * @param {string} name Attribute name
   * @return {number} attribLocation
   */ getAttributeLocation(name) {
        const programUid = (0, _utilJs.getUid)(this.currentProgram_);
        if (this.attribLocationsByProgram_[programUid] === undefined) this.attribLocationsByProgram_[programUid] = {};
        if (this.attribLocationsByProgram_[programUid][name] === undefined) this.attribLocationsByProgram_[programUid][name] = this.gl_.getAttribLocation(this.currentProgram_, name);
        return this.attribLocationsByProgram_[programUid][name];
    }
    /**
   * Sets the given transform to apply the rotation/translation/scaling of the given frame state.
   * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../transform").Transform} transform Transform to update.
   * @return {import("../transform").Transform} The updated transform object.
   */ makeProjectionTransform(frameState, transform) {
        const size = frameState.size;
        const rotation = frameState.viewState.rotation;
        const resolution = frameState.viewState.resolution;
        const center = frameState.viewState.center;
        (0, _transformJs.compose)(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
        return transform;
    }
    /**
   * Give a value for a standard float uniform
   * @param {string} uniform Uniform name
   * @param {number} value Value
   */ setUniformFloatValue(uniform, value) {
        this.gl_.uniform1f(this.getUniformLocation(uniform), value);
    }
    /**
   * Give a value for a vec2 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */ setUniformFloatVec2(uniform, value) {
        this.gl_.uniform2fv(this.getUniformLocation(uniform), value);
    }
    /**
   * Give a value for a vec4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */ setUniformFloatVec4(uniform, value) {
        this.gl_.uniform4fv(this.getUniformLocation(uniform), value);
    }
    /**
   * Give a value for a standard matrix4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Matrix value
   */ setUniformMatrixValue(uniform, value) {
        this.gl_.uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
    }
    /**
   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
   * internally.
   * @param {string} attribName Attribute name
   * @param {number} size Number of components per attributes
   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
   * @param {number} stride Stride in bytes (0 means attribs are packed)
   * @param {number} offset Offset in bytes
   * @private
   */ enableAttributeArray_(attribName, size, type, stride, offset) {
        const location = this.getAttributeLocation(attribName);
        // the attribute has not been found in the shaders or is not used; do not enable it
        if (location < 0) return;
        this.gl_.enableVertexAttribArray(location);
        this.gl_.vertexAttribPointer(location, size, type, false, stride, offset);
    }
    /**
   * Will enable the following attributes to be read from the currently bound buffer,
   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   */ enableAttributes(attributes) {
        const stride = computeAttributesStride(attributes);
        let offset = 0;
        for(let i = 0; i < attributes.length; i++){
            const attr = attributes[i];
            this.enableAttributeArray_(attr.name, attr.size, attr.type || (0, _webglJs.FLOAT), stride, offset);
            offset += attr.size * getByteSizeFromType(attr.type);
        }
    }
    /**
   * WebGL context was lost
   * @param {WebGLContextEvent} event The context loss event.
   * @private
   */ handleWebGLContextLost(event) {
        (0, _objJs.clear)(this.bufferCache_);
        this.currentProgram_ = null;
        event.preventDefault();
    }
    /**
   * WebGL context was restored
   * @private
   */ handleWebGLContextRestored() {
        this.needsToBeRecreated_ = true;
    }
    /**
   * Returns whether this helper needs to be recreated, as the context was lost and then restored.
   * @return {boolean} Whether this helper needs to be recreated.
   */ needsToBeRecreated() {
        return this.needsToBeRecreated_;
    }
    /**
   * Will create or reuse a given webgl texture and apply the given size. If no image data
   * specified, the texture will be empty, otherwise image data will be used and the `size`
   * parameter will be ignored.
   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
   * @param {Array<number>} size Expected size of the texture
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture
   * @param {WebGLTexture} [texture] Existing texture to reuse
   * @return {WebGLTexture} The generated texture
   */ createTexture(size, data, texture) {
        const gl = this.gl_;
        texture = texture || gl.createTexture();
        // set params & size
        const level = 0;
        const internalFormat = gl.RGBA;
        const border = 0;
        const format = gl.RGBA;
        const type = gl.UNSIGNED_BYTE;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        if (data) gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);
        else gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        return texture;
    }
}
function computeAttributesStride(attributes) {
    let stride = 0;
    for(let i = 0; i < attributes.length; i++){
        const attr = attributes[i];
        stride += attr.size * getByteSizeFromType(attr.type);
    }
    return stride;
}
/**
 * Computes the size in byte of an attribute type.
 * @param {AttributeType} type Attribute type
 * @return {number} The size in bytes
 */ function getByteSizeFromType(type) {
    switch(type){
        case AttributeType.UNSIGNED_BYTE:
            return Uint8Array.BYTES_PER_ELEMENT;
        case AttributeType.UNSIGNED_SHORT:
            return Uint16Array.BYTES_PER_ELEMENT;
        case AttributeType.UNSIGNED_INT:
            return Uint32Array.BYTES_PER_ELEMENT;
        case AttributeType.FLOAT:
        default:
            return Float32Array.BYTES_PER_ELEMENT;
    }
}
exports.default = WebGLHelper;

},{"../webgl/ContextEventType.js":"35j2K","../Disposable.js":"7pfJR","./PostProcessingPass.js":"w7aHg","../webgl.js":"auzQ5","../obj.js":"7RZD4","../transform.js":"9LrRk","../vec/mat4.js":"EdMck","../util.js":"l1iPW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"35j2K":[function(require,module,exports,__globalThis) {
/**
 * @module ol/webgl/ContextEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    LOST: 'webglcontextlost',
    RESTORED: 'webglcontextrestored'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"w7aHg":[function(require,module,exports,__globalThis) {
/**
 * @module ol/webgl/PostProcessingPass
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilJs = require("../util.js");
const DEFAULT_VERTEX_SHADER = `
  precision mediump float;
  
  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;
  
  uniform vec2 u_screenSize;
   
  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`;
const DEFAULT_FRAGMENT_SHADER = `
  precision mediump float;
   
  uniform sampler2D u_image;
  uniform float u_opacity;
   
  varying vec2 v_texCoord;
   
  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
/**
 * @typedef {Object} Options
 * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("./Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */ /**
 * @typedef {Object} UniformInternalDescription
 * @property {import("./Helper").UniformValue} value Value
 * @property {WebGLUniformLocation} location Location
 * @property {WebGLTexture} [texture] Texture
 * @private
 */ /**
 * @classdesc
 * This class is used to define Post Processing passes with custom shaders and uniforms.
 * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.
 *
 * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that
 * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).
 * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.
 *
 * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be
 * premultiplied.
 *
 * Default shaders are shown hereafter:
 *
 * * Vertex shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   attribute vec2 a_position;
 *   varying vec2 v_texCoord;
 *   varying vec2 v_screenCoord;
 *
 *   uniform vec2 u_screenSize;
 *
 *   void main() {
 *     v_texCoord = a_position * 0.5 + 0.5;
 *     v_screenCoord = v_texCoord * u_screenSize;
 *     gl_Position = vec4(a_position, 0.0, 1.0);
 *   }
 *   ```
 *
 * * Fragment shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   uniform sampler2D u_image;
 *   uniform float u_opacity;
 *
 *   varying vec2 v_texCoord;
 *
 *   void main() {
 *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
 *   }
 *   ```
 */ class WebGLPostProcessingPass {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        this.gl_ = options.webGlContext;
        const gl = this.gl_;
        this.scaleRatio_ = options.scaleRatio || 1;
        this.renderTargetTexture_ = gl.createTexture();
        this.renderTargetTextureSize_ = null;
        this.frameBuffer_ = gl.createFramebuffer();
        this.depthBuffer_ = gl.createRenderbuffer();
        // compile the program for the frame buffer
        // TODO: make compilation errors show up
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
        gl.compileShader(vertexShader);
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
        gl.compileShader(fragmentShader);
        this.renderTargetProgram_ = gl.createProgram();
        gl.attachShader(this.renderTargetProgram_, vertexShader);
        gl.attachShader(this.renderTargetProgram_, fragmentShader);
        gl.linkProgram(this.renderTargetProgram_);
        // bind the vertices buffer for the frame buffer
        this.renderTargetVerticesBuffer_ = gl.createBuffer();
        const verticesArray = [
            -1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            1
        ];
        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
        this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');
        this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');
        this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_opacity');
        this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');
        /**
     * Holds info about custom uniforms used in the post processing pass
     * @type {Array<UniformInternalDescription>}
     * @private
     */ this.uniforms_ = [];
        options.uniforms && Object.keys(options.uniforms).forEach((name)=>{
            this.uniforms_.push({
                value: options.uniforms[name],
                location: gl.getUniformLocation(this.renderTargetProgram_, name)
            });
        });
    }
    /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */ getGL() {
        return this.gl_;
    }
    /**
   * Initialize the render target texture of the post process, make sure it is at the
   * right size and bind it as a render target for the next draw calls.
   * The last step to be initialized will be the one where the primitives are rendered.
   * @param {import("../Map.js").FrameState} frameState current frame state
   */ init(frameState) {
        const gl = this.getGL();
        const textureSize = [
            gl.drawingBufferWidth * this.scaleRatio_,
            gl.drawingBufferHeight * this.scaleRatio_
        ];
        // rendering goes to my buffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.getDepthBuffer());
        gl.viewport(0, 0, textureSize[0], textureSize[1]);
        // if size has changed: adjust canvas & render target texture
        if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
            this.renderTargetTextureSize_ = textureSize;
            // create a new texture
            const level = 0;
            const internalFormat = gl.RGBA;
            const border = 0;
            const format = gl.RGBA;
            const type = gl.UNSIGNED_BYTE;
            const data = null;
            gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            // bind the texture to the framebuffer
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, textureSize[0], textureSize[1]);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer_);
        }
    }
    /**
   * Render to the next postprocessing pass (or to the canvas if final pass).
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */ apply(frameState, nextPass, preCompose, postCompose) {
        const gl = this.getGL();
        const size = frameState.size;
        gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
        if (!nextPass) {
            // clear the canvas if we are the first to render to it
            // and preserveDrawingBuffer is true
            const canvasId = (0, _utilJs.getUid)(gl.canvas);
            if (!frameState.renderTargets[canvasId]) {
                const attributes = gl.getContextAttributes();
                if (attributes && attributes.preserveDrawingBuffer) {
                    gl.clearColor(0.0, 0.0, 0.0, 0.0);
                    gl.clearDepth(1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                }
                frameState.renderTargets[canvasId] = true;
            }
        }
        gl.disable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
        gl.useProgram(this.renderTargetProgram_);
        gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
        gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
        gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
        gl.uniform1i(this.renderTargetTextureLocation_, 0);
        const opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;
        gl.uniform1f(this.renderTargetOpacityLocation_, opacity);
        this.applyUniforms(frameState);
        if (preCompose) preCompose(gl, frameState);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        if (postCompose) postCompose(gl, frameState);
    }
    /**
   * @return {WebGLFramebuffer} Frame buffer
   */ getFrameBuffer() {
        return this.frameBuffer_;
    }
    /**
   * @return {WebGLRenderbuffer} Depth buffer
   */ getDepthBuffer() {
        return this.depthBuffer_;
    }
    /**
   * Sets the custom uniforms based on what was given in the constructor.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @private
   */ applyUniforms(frameState) {
        const gl = this.getGL();
        let value;
        let textureSlot = 1;
        this.uniforms_.forEach(function(uniform) {
            value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value;
            // apply value based on type
            if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
                // create a texture & put data
                if (!uniform.texture) uniform.texture = gl.createTexture();
                gl.activeTexture(gl[`TEXTURE${textureSlot}`]);
                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                if (value instanceof ImageData) gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
                else gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
                // fill texture slots
                gl.uniform1i(uniform.location, textureSlot++);
            } else if (Array.isArray(value)) switch(value.length){
                case 2:
                    gl.uniform2f(uniform.location, value[0], value[1]);
                    return;
                case 3:
                    gl.uniform3f(uniform.location, value[0], value[1], value[2]);
                    return;
                case 4:
                    gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
                    return;
                default:
                    return;
            }
            else if (typeof value === 'number') gl.uniform1f(uniform.location, value);
        });
    }
}
exports.default = WebGLPostProcessingPass;

},{"../util.js":"l1iPW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"EdMck":[function(require,module,exports,__globalThis) {
/**
 * @module ol/vec/mat4
 */ /**
 * @return {Array<number>} "4x4 matrix representing a 3D identity transform."
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
/**
 * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.
 * @param {import("../transform.js").Transform} transform Transformation matrix.
 * @return {Array<number>} "2D transformation matrix as flattened 4x4 matrix."
 */ parcelHelpers.export(exports, "fromTransform", ()=>fromTransform);
function create() {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
function fromTransform(mat4, transform) {
    mat4[0] = transform[0];
    mat4[1] = transform[1];
    mat4[4] = transform[2];
    mat4[5] = transform[3];
    mat4[12] = transform[4];
    mat4[13] = transform[5];
    return mat4;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7Mz5N":[function(require,module,exports,__globalThis) {
/**
 * @module ol/expr/gpu
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Will return the number as a float with a dot separator, which is required by GLSL.
 * @param {number} v Numerical value.
 * @return {string} The value as string.
 */ parcelHelpers.export(exports, "numberToGlsl", ()=>numberToGlsl);
/**
 * Will return the number array as a float with a dot separator, concatenated with ', '.
 * @param {Array<number>} array Numerical values array.
 * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.
 */ parcelHelpers.export(exports, "arrayToGlsl", ()=>arrayToGlsl);
/**
 * Will normalize and converts to string a `vec4` color array compatible with GLSL.
 * @param {string|import("../color.js").Color} color Color either in string format or [r, g, b, a] array format,
 * with RGB components in the 0..255 range and the alpha component in the 0..1 range.
 * Note that the final array will always have 4 components.
 * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.
 */ parcelHelpers.export(exports, "colorToGlsl", ()=>colorToGlsl);
/**
 * Returns a stable equivalent number for the string literal.
 * @param {string} string String literal value
 * @return {number} Number equivalent
 */ parcelHelpers.export(exports, "getStringNumberEquivalent", ()=>getStringNumberEquivalent);
/**
 * Returns a stable equivalent number for the string literal, for use in shaders. This number is then
 * converted to be a GLSL-compatible string.
 * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216
 * @param {string} string String literal value
 * @return {string} GLSL-compatible string containing a number
 */ parcelHelpers.export(exports, "stringToGlsl", ()=>stringToGlsl);
/**
 * Get the uniform name given a variable name.
 * @param {string} variableName The variable name.
 * @return {string} The uniform name.
 */ parcelHelpers.export(exports, "uniformNameForVariable", ()=>uniformNameForVariable);
/**
 * @typedef {import('./expression.js').ParsingContext} ParsingContext
 */ /**
 *
 * @typedef {import("./expression.js").Expression} Expression
 */ /**
 *
 * @typedef {import("./expression.js").LiteralExpression} LiteralExpression
 */ /**
 * @typedef {Object} CompilationContextProperty
 * @property {string} name Name
 * @property {number} type Resolved property type
 * @property {function(import("../Feature.js").FeatureLike): *} [evaluator] Function used for evaluating the value;
 */ /**
 * @typedef {Object} CompilationContextVariable
 * @property {string} name Name
 * @property {number} type Resolved variable type
 * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object
 */ /**
 * @typedef {Object} CompilationContext
 * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader
 * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.
 * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.
 * @property {Object<string, string>} functions Lookup of functions used by the style.
 * @property {number} [bandCount] Number of bands per pixel.
 * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.
 * @property {import("../style/webgl.js").WebGLStyle} style Literal style.
 */ /**
 * @return {CompilationContext} A new compilation context.
 */ parcelHelpers.export(exports, "newCompilationContext", ()=>newCompilationContext);
parcelHelpers.export(exports, "PALETTE_TEXTURE_ARRAY", ()=>PALETTE_TEXTURE_ARRAY);
/**
 * @typedef {string} CompiledExpression
 */ /**
 * @typedef {function(CompilationContext, CallExpression, number): string} Compiler
 * Third argument is the expected value types
 */ /**
 * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.
 * @param {number} type The expected type.
 * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.
 * @param {CompilationContext} compilationContext An existing compilation context
 * @return {CompiledExpression} The compiled expression.
 */ parcelHelpers.export(exports, "buildExpression", ()=>buildExpression);
var _paletteTextureJs = require("../webgl/PaletteTexture.js");
var _paletteTextureJsDefault = parcelHelpers.interopDefault(_paletteTextureJs);
var _expressionJs = require("./expression.js");
var _tileLayerJs = require("../renderer/webgl/TileLayer.js");
var _colorJs = require("../color.js");
/**
 * @param {string} operator Operator
 * @param {CompilationContext} context Compilation context
 * @return {string} A function name based on the operator, unique in the given context
 */ function computeOperatorFunctionName(operator, context) {
    return `operator_${operator}_${Object.keys(context.functions).length}`;
}
function numberToGlsl(v) {
    const s = v.toString();
    return s.includes('.') ? s : s + '.0';
}
function arrayToGlsl(array) {
    if (array.length < 2 || array.length > 4) throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');
    return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;
}
function colorToGlsl(color) {
    const array = (0, _colorJs.asArray)(color);
    const alpha = array.length > 3 ? array[3] : 1;
    // all components are premultiplied with alpha value
    return arrayToGlsl([
        array[0] / 255 * alpha,
        array[1] / 255 * alpha,
        array[2] / 255 * alpha,
        alpha
    ]);
}
/** @type {Object<string, number>} */ const stringToFloatMap = {};
let stringToFloatCounter = 0;
function getStringNumberEquivalent(string) {
    if (!(string in stringToFloatMap)) stringToFloatMap[string] = stringToFloatCounter++;
    return stringToFloatMap[string];
}
function stringToGlsl(string) {
    return numberToGlsl(getStringNumberEquivalent(string));
}
function uniformNameForVariable(variableName) {
    return 'u_var_' + variableName;
}
function newCompilationContext() {
    return {
        inFragmentShader: false,
        variables: {},
        properties: {},
        functions: {},
        bandCount: 0,
        style: {}
    };
}
const GET_BAND_VALUE_FUNC = 'getBandValue';
const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';
function buildExpression(encoded, type, parsingContext, compilationContext) {
    const expression = (0, _expressionJs.parse)(encoded, parsingContext, type);
    if ((0, _expressionJs.isType)(expression.type, (0, _expressionJs.NoneType))) throw new Error(`No matching type was found`);
    if (!(0, _expressionJs.overlapsType)(type, expression.type)) {
        const expected = (0, _expressionJs.typeName)(type);
        const actual = (0, _expressionJs.typeName)(expression.type);
        throw new Error(`Expected expression to be of type ${expected}, got ${actual}`);
    }
    return compile(expression, type, compilationContext);
}
/**
 * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string
 * @return {function(CompilationContext, import("./expression.js").CallExpression, number): string} Compiler for the call expression
 */ function createCompiler(output) {
    return (context, expression, type)=>{
        const length = expression.args.length;
        const args = new Array(length);
        for(let i = 0; i < length; ++i)args[i] = compile(expression.args[i], type, context);
        return output(args, context);
    };
}
/**
 * @type {Object<string, Compiler>}
 */ const compilers = {
    [(0, _expressionJs.Ops).Get]: (context, expression)=>{
        const firstArg = /** @type {LiteralExpression} */ expression.args[0];
        const propName = /** @type {string} */ firstArg.value;
        const isExisting = propName in context.properties;
        if (!isExisting) context.properties[propName] = {
            name: propName,
            type: expression.type
        };
        const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';
        return prefix + propName;
    },
    [(0, _expressionJs.Ops).GeometryType]: (context, expression, type)=>{
        const propName = 'geometryType';
        const computeType = (geometry)=>{
            const type = geometry.getType();
            switch(type){
                case 'Point':
                case 'LineString':
                case 'Polygon':
                    return type;
                case 'MultiPoint':
                case 'MultiLineString':
                case 'MultiPolygon':
                    return type.substring(5);
                case 'Circle':
                    return 'Polygon';
                case 'GeometryCollection':
                    return computeType(geometry.getGeometries()[0]);
                default:
            }
        };
        const isExisting = propName in context.properties;
        if (!isExisting) context.properties[propName] = {
            name: propName,
            type: (0, _expressionJs.StringType),
            evaluator: (feature)=>{
                return computeType(feature.getGeometry());
            }
        };
        const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';
        return prefix + propName;
    },
    [(0, _expressionJs.Ops).Var]: (context, expression)=>{
        const firstArg = /** @type {LiteralExpression} */ expression.args[0];
        const varName = /** @type {string} */ firstArg.value;
        const isExisting = varName in context.variables;
        if (!isExisting) context.variables[varName] = {
            name: varName,
            type: expression.type
        };
        return uniformNameForVariable(varName);
    },
    [(0, _expressionJs.Ops).Resolution]: ()=>'u_resolution',
    [(0, _expressionJs.Ops).Zoom]: ()=>'u_zoom',
    [(0, _expressionJs.Ops).Time]: ()=>'u_time',
    [(0, _expressionJs.Ops).Any]: createCompiler((compiledArgs)=>`(${compiledArgs.join(` || `)})`),
    [(0, _expressionJs.Ops).All]: createCompiler((compiledArgs)=>`(${compiledArgs.join(` && `)})`),
    [(0, _expressionJs.Ops).Not]: createCompiler(([value])=>`(!${value})`),
    [(0, _expressionJs.Ops).Equal]: createCompiler(([firstValue, secondValue])=>`(${firstValue} == ${secondValue})`),
    [(0, _expressionJs.Ops).NotEqual]: createCompiler(([firstValue, secondValue])=>`(${firstValue} != ${secondValue})`),
    [(0, _expressionJs.Ops).GreaterThan]: createCompiler(([firstValue, secondValue])=>`(${firstValue} > ${secondValue})`),
    [(0, _expressionJs.Ops).GreaterThanOrEqualTo]: createCompiler(([firstValue, secondValue])=>`(${firstValue} >= ${secondValue})`),
    [(0, _expressionJs.Ops).LessThan]: createCompiler(([firstValue, secondValue])=>`(${firstValue} < ${secondValue})`),
    [(0, _expressionJs.Ops).LessThanOrEqualTo]: createCompiler(([firstValue, secondValue])=>`(${firstValue} <= ${secondValue})`),
    [(0, _expressionJs.Ops).Multiply]: createCompiler((compiledArgs)=>`(${compiledArgs.join(' * ')})`),
    [(0, _expressionJs.Ops).Divide]: createCompiler(([firstValue, secondValue])=>`(${firstValue} / ${secondValue})`),
    [(0, _expressionJs.Ops).Add]: createCompiler((compiledArgs)=>`(${compiledArgs.join(' + ')})`),
    [(0, _expressionJs.Ops).Subtract]: createCompiler(([firstValue, secondValue])=>`(${firstValue} - ${secondValue})`),
    [(0, _expressionJs.Ops).Clamp]: createCompiler(([value, min, max])=>`clamp(${value}, ${min}, ${max})`),
    [(0, _expressionJs.Ops).Mod]: createCompiler(([value, modulo])=>`mod(${value}, ${modulo})`),
    [(0, _expressionJs.Ops).Pow]: createCompiler(([value, power])=>`pow(${value}, ${power})`),
    [(0, _expressionJs.Ops).Abs]: createCompiler(([value])=>`abs(${value})`),
    [(0, _expressionJs.Ops).Floor]: createCompiler(([value])=>`floor(${value})`),
    [(0, _expressionJs.Ops).Ceil]: createCompiler(([value])=>`ceil(${value})`),
    [(0, _expressionJs.Ops).Round]: createCompiler(([value])=>`floor(${value} + 0.5)`),
    [(0, _expressionJs.Ops).Sin]: createCompiler(([value])=>`sin(${value})`),
    [(0, _expressionJs.Ops).Cos]: createCompiler(([value])=>`cos(${value})`),
    [(0, _expressionJs.Ops).Atan]: createCompiler(([firstValue, secondValue])=>{
        return secondValue !== undefined ? `atan(${firstValue}, ${secondValue})` : `atan(${firstValue})`;
    }),
    [(0, _expressionJs.Ops).Sqrt]: createCompiler(([value])=>`sqrt(${value})`),
    [(0, _expressionJs.Ops).Match]: createCompiler((compiledArgs)=>{
        const input = compiledArgs[0];
        const fallback = compiledArgs[compiledArgs.length - 1];
        let result = null;
        for(let i = compiledArgs.length - 3; i >= 1; i -= 2){
            const match = compiledArgs[i];
            const output = compiledArgs[i + 1];
            result = `(${input} == ${match} ? ${output} : ${result || fallback})`;
        }
        return result;
    }),
    [(0, _expressionJs.Ops).Between]: createCompiler(([value, min, max])=>`(${value} >= ${min} && ${value} <= ${max})`),
    [(0, _expressionJs.Ops).Interpolate]: createCompiler(([exponent, input, ...compiledArgs])=>{
        let result = '';
        for(let i = 0; i < compiledArgs.length - 2; i += 2){
            const stop1 = compiledArgs[i];
            const output1 = result || compiledArgs[i + 1];
            const stop2 = compiledArgs[i + 2];
            const output2 = compiledArgs[i + 3];
            let ratio;
            if (exponent === numberToGlsl(1)) ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;
            else ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;
            result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;
        }
        return result;
    }),
    [(0, _expressionJs.Ops).Case]: createCompiler((compiledArgs)=>{
        const fallback = compiledArgs[compiledArgs.length - 1];
        let result = null;
        for(let i = compiledArgs.length - 3; i >= 0; i -= 2){
            const condition = compiledArgs[i];
            const output = compiledArgs[i + 1];
            result = `(${condition} ? ${output} : ${result || fallback})`;
        }
        return result;
    }),
    [(0, _expressionJs.Ops).In]: createCompiler(([needle, ...haystack], context)=>{
        const funcName = computeOperatorFunctionName('in', context);
        const tests = [];
        for(let i = 0; i < haystack.length; i += 1)tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);
        context.functions[funcName] = `bool ${funcName}(float inputValue) {
${tests.join('\n')}
  return false;
}`;
        return `${funcName}(${needle})`;
    }),
    [(0, _expressionJs.Ops).Array]: createCompiler((args)=>`vec${args.length}(${args.join(', ')})`),
    [(0, _expressionJs.Ops).Color]: createCompiler((compiledArgs)=>{
        const rgb = compiledArgs.slice(0, 3).map((color)=>`${color} / 255.0`);
        if (compiledArgs.length === 3) return `vec4(${rgb.join(', ')}, 1.0)`;
        const alpha = compiledArgs[3];
        return `(${alpha} * vec4(${rgb.join(', ')}, 1.0))`;
    }),
    [(0, _expressionJs.Ops).Band]: createCompiler(([band, xOffset, yOffset], context)=>{
        if (!(GET_BAND_VALUE_FUNC in context.functions)) {
            let ifBlocks = '';
            const bandCount = context.bandCount || 1;
            for(let i = 0; i < bandCount; i++){
                const colorIndex = Math.floor(i / 4);
                let bandIndex = i % 4;
                if (i === bandCount - 1 && bandIndex === 1) // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha
                bandIndex = 3;
                const textureName = `${(0, _tileLayerJs.Uniforms).TILE_TEXTURE_ARRAY}[${colorIndex}]`;
                ifBlocks += `  if (band == ${i + 1}.0) {
    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];
  }
`;
            }
            context.functions[GET_BAND_VALUE_FUNC] = `float getBandValue(float band, float xOffset, float yOffset) {
  float dx = xOffset / ${(0, _tileLayerJs.Uniforms).TEXTURE_PIXEL_WIDTH};
  float dy = yOffset / ${(0, _tileLayerJs.Uniforms).TEXTURE_PIXEL_HEIGHT};
${ifBlocks}
}`;
        }
        return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${yOffset ?? '0.0'})`;
    }),
    [(0, _expressionJs.Ops).Palette]: (context, expression)=>{
        const [index, ...colors] = expression.args;
        const numColors = colors.length;
        const palette = new Uint8Array(numColors * 4);
        for(let i = 0; i < colors.length; i++){
            const parsedValue = /** @type {string | Array<number>} */ /** @type {LiteralExpression} */ colors[i].value;
            const color = (0, _colorJs.asArray)(parsedValue);
            const offset = i * 4;
            palette[offset] = color[0];
            palette[offset + 1] = color[1];
            palette[offset + 2] = color[2];
            palette[offset + 3] = color[3] * 255;
        }
        if (!context.paletteTextures) context.paletteTextures = [];
        const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;
        const paletteTexture = new (0, _paletteTextureJsDefault.default)(paletteName, palette);
        context.paletteTextures.push(paletteTexture);
        const compiledIndex = compile(index, (0, _expressionJs.NumberType), context);
        return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;
    }
};
/**
 * @param {Expression} expression The expression.
 * @param {number} returnType The expected return type.
 * @param {CompilationContext} context The compilation context.
 * @return {CompiledExpression} The compiled expression
 */ function compile(expression, returnType, context) {
    // operator
    if (expression instanceof (0, _expressionJs.CallExpression)) {
        const compiler = compilers[expression.operator];
        if (compiler === undefined) throw new Error(`No compiler defined for this operator: ${JSON.stringify(expression.operator)}`);
        return compiler(context, expression, returnType);
    }
    if ((expression.type & (0, _expressionJs.NumberType)) > 0) return numberToGlsl(/** @type {number} */ expression.value);
    if ((expression.type & (0, _expressionJs.BooleanType)) > 0) return expression.value.toString();
    if ((expression.type & (0, _expressionJs.StringType)) > 0) return stringToGlsl(expression.value.toString());
    if ((expression.type & (0, _expressionJs.ColorType)) > 0) return colorToGlsl(/** @type {Array<number> | string} */ expression.value);
    if ((expression.type & (0, _expressionJs.NumberArrayType)) > 0) return arrayToGlsl(/** @type {Array<number>} */ expression.value);
    throw new Error(`Unexpected expression ${expression.value} (expected type ${(0, _expressionJs.typeName)(returnType)})`);
}

},{"../webgl/PaletteTexture.js":"ecKwV","./expression.js":"8u0Bf","../renderer/webgl/TileLayer.js":"5DBmj","../color.js":"h6hAX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ecKwV":[function(require,module,exports,__globalThis) {
/**
 * @module ol/webgl/PaletteTexture
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class PaletteTexture {
    /**
   * @param {string} name The name of the texture.
   * @param {Uint8Array} data The texture data.
   */ constructor(name, data){
        this.name = name;
        this.data = data;
        /**
     * @type {WebGLTexture|null}
     * @private
     */ this.texture_ = null;
    }
    /**
   * @param {WebGLRenderingContext} gl Rendering context.
   * @return {WebGLTexture} The texture.
   */ getTexture(gl) {
        if (!this.texture_) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.data.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
            this.texture_ = texture;
        }
        return this.texture_;
    }
}
exports.default = PaletteTexture;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"irFsa":[function(require,module,exports,__globalThis) {
/**
 * Utilities for parsing literal style objects
 * @module ol/webgl/styleparser
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that
 * will be read and modified during the parsing operation.
 * @param {import("../expr/gpu.js").CompilationContext} compilationContext Compilation context
 * @param {import("../expr/expression.js").EncodedExpression} value Value
 * @param {number} [expectedType] Expected final type (can be several types combined)
 * @return {string} GLSL-compatible output
 */ parcelHelpers.export(exports, "expressionToGlsl", ()=>expressionToGlsl);
/**
 * Packs all components of a color into a two-floats array
 * @param {import("../color.js").Color|string} color Color as array of numbers or string
 * @return {Array<number>} Vec2 array containing the color in compressed form
 */ parcelHelpers.export(exports, "packColor", ()=>packColor);
/**
 * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript
 * @param {Object|string} input The hash input, either an object or string
 * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)
 */ parcelHelpers.export(exports, "computeHash", ()=>computeHash);
/**
 * @typedef {Object} StyleParseResult
 * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style
 * @property {import("../render/webgl/VectorStyleRenderer.js").UniformDefinitions} uniforms Uniform definitions
 * @property {import("../render/webgl/VectorStyleRenderer.js").AttributeDefinitions} attributes Attribute definitions
 */ /**
 * Parses a {@link import("../style/webgl.js").WebGLStyle} object and returns a {@link ShaderBuilder}
 * object that has been configured according to the given style, as well as `attributes` and `uniforms`
 * arrays to be fed to the `WebGLPointsRenderer` class.
 *
 * Also returns `uniforms` and `attributes` properties as expected by the
 * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 *
 * @param {import("../style/webgl.js").WebGLStyle} style Literal style.
 * @return {StyleParseResult} Result containing shader params, attributes and uniforms.
 */ parcelHelpers.export(exports, "parseLiteralStyle", ()=>parseLiteralStyle);
var _expressionJs = require("../expr/expression.js");
var _shaderBuilderJs = require("./ShaderBuilder.js");
var _gpuJs = require("../expr/gpu.js");
var _colorJs = require("../color.js");
function expressionToGlsl(compilationContext, value, expectedType) {
    const parsingContext = (0, _expressionJs.newParsingContext)();
    parsingContext.style = compilationContext.style;
    return (0, _gpuJs.buildExpression)(value, expectedType, parsingContext, compilationContext);
}
function packColor(color) {
    const array = (0, _colorJs.asArray)(color);
    const r = array[0] * 256;
    const g = array[1];
    const b = array[2] * 256;
    const a = Math.round(array[3] * 255);
    return [
        r + g,
        b + a
    ];
}
const UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {
  return fract(packedColor[1] / 256.0) * vec4(
    fract(floor(packedColor[0] / 256.0) / 256.0),
    fract(packedColor[0] / 256.0),
    fract(floor(packedColor[1] / 256.0) / 256.0),
    1.0
  );
}`;
/**
 * @param {number} type Value type
 * @return {1|2|3|4} The amount of components for this value
 */ function getGlslSizeFromType(type) {
    if (type === (0, _expressionJs.ColorType)) return 2;
    if (type === (0, _expressionJs.NumberArrayType)) return 4;
    return 1;
}
/**
 * @param {number} type Value type
 * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value
 */ function getGlslTypeFromType(type) {
    const size = getGlslSizeFromType(type);
    if (size > 1) return /** @type {'vec2'|'vec3'|'vec4'} */ `vec${size}`;
    return 'float';
}
function computeHash(input) {
    const hash = JSON.stringify(input).split('').reduce((prev, curr)=>(prev << 5) - prev + curr.charCodeAt(0), 0);
    return (hash >>> 0).toString();
}
/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader builder
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix
 */ function parseCommonSymbolProperties(style, builder, vertContext, prefix) {
    let radius;
    if (`${prefix}radius` in style && prefix !== 'icon-') radius = expressionToGlsl(vertContext, style[`${prefix}radius`], (0, _expressionJs.NumberType));
    else if (`${prefix}radius1` in style && prefix === 'shape-') radius = expressionToGlsl(vertContext, style[`${prefix}radius1`], (0, _expressionJs.NumberType));
    if (radius !== undefined) {
        if (`${prefix}stroke-width` in style) radius = `(${radius} + ${expressionToGlsl(vertContext, style[`${prefix}stroke-width`], (0, _expressionJs.NumberType))} * 0.5)`;
        builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing
    }
    if (`${prefix}scale` in style) {
        const scale = expressionToGlsl(vertContext, style[`${prefix}scale`], (0, _expressionJs.NumberType) | (0, _expressionJs.NumberArrayType));
        builder.setSymbolSizeExpression(`${builder.getSymbolSizeExpression()} * ${scale}`);
    }
    if (`${prefix}displacement` in style) builder.setSymbolOffsetExpression(expressionToGlsl(vertContext, style[`${prefix}displacement`], (0, _expressionJs.NumberArrayType)));
    if (`${prefix}rotation` in style) builder.setSymbolRotationExpression(expressionToGlsl(vertContext, style[`${prefix}rotation`], (0, _expressionJs.NumberType)));
    if (`${prefix}rotate-with-view` in style) builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);
}
/**
 * @param {string} distanceField The distance field expression
 * @param {string|null} fillColor The fill color expression; null if no fill
 * @param {string|null} strokeColor The stroke color expression; null if no stroke
 * @param {string|null} strokeWidth The stroke width expression; null if no stroke
 * @param {string|null} opacity The opacity expression; null if no stroke
 * @return {string} The final color expression, based on the distance field and given params
 */ function getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity) {
    let color = 'vec4(0.)';
    if (fillColor !== null) color = fillColor;
    if (strokeColor !== null && strokeWidth !== null) {
        const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;
        color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;
    }
    const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;
    let result = `${color} * ${shapeOpacity}`;
    if (opacity !== null) result = `${result} * ${opacity}`;
    return result;
}
/**
 * This will parse an image property provided by `<prefix>-src`
 * The image size expression in GLSL will be returned
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix
 * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`
 * @return {string} The image size expression
 */ function parseImageProperties(style, builder, uniforms, prefix, textureId) {
    const image = new Image();
    let size;
    image.crossOrigin = style[`${prefix}cross-origin`] === undefined ? 'anonymous' : style[`${prefix}cross-origin`];
    image.src = style[`${prefix}src`];
    if (image.complete && image.width && image.height) size = (0, _gpuJs.arrayToGlsl)([
        image.width,
        image.height
    ]);
    else {
        // the size is provided asynchronously using a uniform
        uniforms[`u_texture${textureId}_size`] = ()=>{
            return image.complete ? [
                image.width,
                image.height
            ] : [
                0,
                0
            ];
        };
        builder.addUniform(`vec2 u_texture${textureId}_size`);
        size = `u_texture${textureId}_size`;
    }
    uniforms[`u_texture${textureId}`] = image;
    builder.addUniform(`sampler2D u_texture${textureId}`);
    return size;
}
/**
 * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix
 * @param {import("../expr/gpu.js").CompilationContext} context Shader compilation context (vertex or fragment)
 * @param {string} imageSize Pixel size of the full image as a GLSL expression
 * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression
 * @return {string} The offset expression
 */ function parseImageOffsetProperties(style, prefix, context, imageSize, sampleSize) {
    let offsetExpression = expressionToGlsl(context, style[`${prefix}offset`], (0, _expressionJs.NumberArrayType));
    if (`${prefix}offset-origin` in style) switch(style[`${prefix}offset-origin`]){
        case 'top-right':
            offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;
            break;
        case 'bottom-left':
            offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;
            break;
        case 'bottom-right':
            offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;
            break;
        default:
    }
    return offsetExpression;
}
/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {import("../expr/gpu.js").CompilationContext} fragContext Fragment shader compilation context
 */ function parseCircleProperties(style, builder, uniforms, vertContext, fragContext) {
    // this function takes in screen coordinates in pixels and returns the signed distance field
    // (0 on the boundary, negative inside the circle, positive outside, values in pixels)
    fragContext.functions['circleDistanceField'] = `float circleDistanceField(vec2 point, float radius) {
  return length(point) - radius;
}`;
    parseCommonSymbolProperties(style, builder, vertContext, 'circle-');
    // OPACITY
    let opacity = null;
    if ('circle-opacity' in style) opacity = expressionToGlsl(fragContext, style['circle-opacity'], (0, _expressionJs.NumberType));
    // SCALE
    let currentPoint = 'coordsPx';
    if ('circle-scale' in style) {
        const scale = expressionToGlsl(fragContext, style['circle-scale'], (0, _expressionJs.NumberType) | (0, _expressionJs.NumberArrayType));
        currentPoint = `coordsPx / ${scale}`;
    }
    // FILL COLOR
    let fillColor = null;
    if ('circle-fill-color' in style) fillColor = expressionToGlsl(fragContext, style['circle-fill-color'], (0, _expressionJs.ColorType));
    // STROKE COLOR
    let strokeColor = null;
    if ('circle-stroke-color' in style) strokeColor = expressionToGlsl(fragContext, style['circle-stroke-color'], (0, _expressionJs.ColorType));
    // RADIUS
    let radius = expressionToGlsl(fragContext, style['circle-radius'], (0, _expressionJs.NumberType));
    // STROKE WIDTH
    let strokeWidth = null;
    if ('circle-stroke-width' in style) {
        strokeWidth = expressionToGlsl(fragContext, style['circle-stroke-width'], (0, _expressionJs.NumberType));
        radius = `(${radius} + ${strokeWidth} * 0.5)`;
    }
    // FINAL COLOR
    const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;
    const colorExpression = getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity);
    builder.setSymbolColorExpression(colorExpression);
}
/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {import("../expr/gpu.js").CompilationContext} fragContext Fragment shader compilation context
 */ function parseShapeProperties(style, builder, uniforms, vertContext, fragContext) {
    fragContext.functions['round'] = `float round(float v) {
  return sign(v) * floor(abs(v) + 0.5);
}`;
    // these functions take in screen coordinates in pixels and returns the signed distance field
    // (0 on the boundary, negative inside the circle, positive outside, values in pixels)
    // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon
    fragContext.functions['starDistanceField'] = `float starDistanceField(vec2 point, float numPoints, float radiusIn, float radiusOut, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); 
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round(beta / alpha) * alpha; // angle in sector
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  vec2 tipToPoint = inSector + vec2(-radiusOut, 0.);
  vec2 edgeNormal = vec2(radiusIn * sin(alpha * 0.5), -radiusIn * cos(alpha * 0.5) + radiusOut);
  return dot(normalize(edgeNormal), tipToPoint);
}`;
    fragContext.functions['regularDistanceField'] = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {
  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle
  float c = cos(startAngle);
  float s = sin(startAngle);
  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); 
  float alpha = TWO_PI / numPoints; // the angle of one sector
  float radiusIn = radius * cos(PI / numPoints);
  float beta = atan(pointRotated.y, pointRotated.x);
  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid
  c = cos(-gamma);
  s = sin(-gamma);
  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));
  return inSector.x - radiusIn;
}`;
    parseCommonSymbolProperties(style, builder, vertContext, 'shape-');
    // OPACITY
    let opacity = null;
    if ('shape-opacity' in style) opacity = expressionToGlsl(fragContext, style['shape-opacity'], (0, _expressionJs.NumberType));
    // SCALE
    let currentPoint = 'coordsPx';
    if ('shape-scale' in style) {
        const scale = expressionToGlsl(fragContext, style['shape-scale'], (0, _expressionJs.NumberType) | (0, _expressionJs.NumberArrayType));
        currentPoint = `coordsPx / ${scale}`;
    }
    // FILL COLOR
    let fillColor = null;
    if ('shape-fill-color' in style) fillColor = expressionToGlsl(fragContext, style['shape-fill-color'], (0, _expressionJs.ColorType));
    // STROKE COLOR
    let strokeColor = null;
    if ('shape-stroke-color' in style) strokeColor = expressionToGlsl(fragContext, style['shape-stroke-color'], (0, _expressionJs.ColorType));
    // STROKE WIDTH
    let strokeWidth = null;
    if ('shape-stroke-width' in style) strokeWidth = expressionToGlsl(fragContext, style['shape-stroke-width'], (0, _expressionJs.NumberType));
    // SHAPE TYPE
    const numPoints = expressionToGlsl(fragContext, style['shape-points'], (0, _expressionJs.NumberType));
    let angle = '0.';
    if ('shape-angle' in style) angle = expressionToGlsl(fragContext, style['shape-angle'], (0, _expressionJs.NumberType));
    let shapeField;
    if ('shape-radius' in style) {
        let radius = expressionToGlsl(fragContext, style['shape-radius'], (0, _expressionJs.NumberType));
        if (strokeWidth !== null) radius = `${radius} + ${strokeWidth} * 0.5`;
        shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;
    } else {
        let radiusOuter = expressionToGlsl(fragContext, style['shape-radius1'], (0, _expressionJs.NumberType));
        let radiusInner = expressionToGlsl(fragContext, style['shape-radius2'], (0, _expressionJs.NumberType));
        if (strokeWidth !== null) {
            radiusOuter = `${radiusOuter} + ${strokeWidth} * 0.5`;
            radiusInner = `${radiusInner} + ${strokeWidth} * 0.5`;
        }
        shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radiusInner}, ${radiusOuter}, ${angle})`;
    }
    // FINAL COLOR
    const colorExpression = getColorFromDistanceField(shapeField, fillColor, strokeColor, strokeWidth, opacity);
    builder.setSymbolColorExpression(colorExpression);
}
/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {import("../expr/gpu.js").CompilationContext} fragContext Fragment shader compilation context
 */ function parseIconProperties(style, builder, uniforms, vertContext, fragContext) {
    // COLOR
    let color = 'vec4(1.0)';
    if ('icon-color' in style) color = expressionToGlsl(fragContext, style['icon-color'], (0, _expressionJs.ColorType));
    // OPACITY
    if ('icon-opacity' in style) color = `${color} * ${expressionToGlsl(fragContext, style['icon-opacity'], (0, _expressionJs.NumberType))}`;
    // IMAGE & SIZE
    const textureId = computeHash(style['icon-src']);
    const sizeExpression = parseImageProperties(style, builder, uniforms, 'icon-', textureId);
    builder.setSymbolColorExpression(`${color} * samplePremultiplied(u_texture${textureId}, v_texCoord)`).setSymbolSizeExpression(sizeExpression);
    // override size if width/height were specified
    if ('icon-width' in style && 'icon-height' in style) builder.setSymbolSizeExpression(`vec2(${expressionToGlsl(vertContext, style['icon-width'], (0, _expressionJs.NumberType))}, ${expressionToGlsl(vertContext, style['icon-height'], (0, _expressionJs.NumberType))})`);
    // tex coord
    if ('icon-offset' in style && 'icon-size' in style) {
        const sampleSize = expressionToGlsl(vertContext, style['icon-size'], (0, _expressionJs.NumberArrayType));
        const fullsize = builder.getSymbolSizeExpression();
        builder.setSymbolSizeExpression(sampleSize);
        const offset = parseImageOffsetProperties(style, 'icon-', vertContext, 'v_quadSizePx', sampleSize);
        builder.setTextureCoordinateExpression(`(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`);
    }
    parseCommonSymbolProperties(style, builder, vertContext, 'icon-');
    if ('icon-anchor' in style) {
        const anchor = expressionToGlsl(vertContext, style['icon-anchor'], (0, _expressionJs.NumberArrayType));
        let scale = `1.0`;
        if (`icon-scale` in style) scale = expressionToGlsl(vertContext, style[`icon-scale`], (0, _expressionJs.NumberType) | (0, _expressionJs.NumberArrayType));
        let shiftPx;
        if (style['icon-anchor-x-units'] === 'pixels' && style['icon-anchor-y-units'] === 'pixels') shiftPx = `${anchor} * ${scale}`;
        else if (style['icon-anchor-x-units'] === 'pixels') shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;
        else if (style['icon-anchor-y-units'] === 'pixels') shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;
        else shiftPx = `${anchor} * v_quadSizePx`;
        // default origin is top-left
        let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;
        if ('icon-anchor-origin' in style) switch(style['icon-anchor-origin']){
            case 'top-right':
                offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;
                break;
            case 'bottom-left':
                offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;
                break;
            case 'bottom-right':
                offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;
                break;
            default:
        }
        builder.setSymbolOffsetExpression(`${builder.getSymbolOffsetExpression()} + ${offsetPx}`);
    }
}
/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader Builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {import("../expr/gpu.js").CompilationContext} fragContext Fragment shader compilation context
 */ function parseStrokeProperties(style, builder, uniforms, vertContext, fragContext) {
    if ('stroke-color' in style) builder.setStrokeColorExpression(expressionToGlsl(fragContext, style['stroke-color'], (0, _expressionJs.ColorType)));
    if ('stroke-pattern-src' in style) {
        const textureId = computeHash(style['stroke-pattern-src']);
        const sizeExpression = parseImageProperties(style, builder, uniforms, 'stroke-pattern-', textureId);
        let sampleSizeExpression = sizeExpression;
        let offsetExpression = 'vec2(0.)';
        if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {
            sampleSizeExpression = expressionToGlsl(fragContext, style[`stroke-pattern-size`], (0, _expressionJs.NumberArrayType));
            offsetExpression = parseImageOffsetProperties(style, 'stroke-pattern-', fragContext, sizeExpression, sampleSizeExpression);
        }
        let spacingExpression = '0.';
        if ('stroke-pattern-spacing' in style) spacingExpression = expressionToGlsl(fragContext, style['stroke-pattern-spacing'], (0, _expressionJs.NumberType));
        fragContext.functions['sampleStrokePattern'] = `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio) {
      float currentLengthScaled = currentLengthPx * sampleSize.y / v_width;
      float spacingScaled = spacingPx * sampleSize.y / v_width;
      float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));
      float vCoordPx = (currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;
      vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;
      return uCoordPx > sampleSize.x ? vec4(0.) : samplePremultiplied(texture, texCoord);
    }`;
        const textureName = `u_texture${textureId}`;
        let tintExpression = '1.';
        if ('stroke-color' in style) tintExpression = builder.getStrokeColorExpression();
        builder.setStrokeColorExpression(`${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio)`);
    }
    if ('stroke-width' in style) builder.setStrokeWidthExpression(expressionToGlsl(vertContext, style['stroke-width'], (0, _expressionJs.NumberType)));
    if ('stroke-offset' in style) builder.setStrokeOffsetExpression(expressionToGlsl(vertContext, style['stroke-offset'], (0, _expressionJs.NumberType)));
    if ('stroke-line-cap' in style) builder.setStrokeCapExpression(expressionToGlsl(vertContext, style['stroke-line-cap'], (0, _expressionJs.StringType)));
    if ('stroke-line-join' in style) builder.setStrokeJoinExpression(expressionToGlsl(vertContext, style['stroke-line-join'], (0, _expressionJs.StringType)));
    if ('stroke-miter-limit' in style) builder.setStrokeMiterLimitExpression(expressionToGlsl(vertContext, style['stroke-miter-limit'], (0, _expressionJs.NumberType)));
    if ('stroke-line-dash' in style) {
        fragContext.functions['getSingleDashDistance'] = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {
  float localDistance = mod(distance, dashLengthTotal);
  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;
  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);
  if (capType == ${(0, _gpuJs.stringToGlsl)('square')}) {
    distanceSegment -= v_width * 0.5;
  } else if (capType == ${(0, _gpuJs.stringToGlsl)('round')}) {
    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);
  }
  return distanceSegment;
}`;
        let dashPattern = style['stroke-line-dash'].map((v)=>expressionToGlsl(fragContext, v, (0, _expressionJs.NumberType)));
        // if pattern has odd length, concatenate it with itself to be even
        if (dashPattern.length % 2 === 1) dashPattern = [
            ...dashPattern,
            ...dashPattern
        ];
        let offsetExpression = '0.';
        if ('stroke-line-dash-offset' in style) offsetExpression = expressionToGlsl(vertContext, style['stroke-line-dash-offset'], (0, _expressionJs.NumberType));
        // define a function for this dash specifically
        const uniqueDashKey = computeHash(style['stroke-line-dash']);
        const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;
        const dashLengthsDef = dashPattern.map((v, i)=>`float dashLength${i} = ${v};`);
        const totalLengthDef = dashPattern.map((v, i)=>`dashLength${i}`).join(' + ');
        let currentDashOffset = '0.';
        let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;
        for(let i = 2; i < dashPattern.length; i += 2){
            currentDashOffset = `${currentDashOffset} + dashLength${i - 2} + dashLength${i - 1}`;
            distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;
        }
        fragContext.functions[dashFunctionName] = `float ${dashFunctionName}(float distance, float radius, float capType) {
  ${dashLengthsDef.join('\n  ')}
  float totalDashLength = ${totalLengthDef};
  return ${distanceExpression};
}`;
        builder.setStrokeDistanceFieldExpression(`${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`);
    }
}
/**
 * @param {import("../style/webgl.js").WebGLStyle} style Style
 * @param {ShaderBuilder} builder Shader Builder
 * @param {Object<string,import("../webgl/Helper").UniformValue>} uniforms Uniforms
 * @param {import("../expr/gpu.js").CompilationContext} vertContext Vertex shader compilation context
 * @param {import("../expr/gpu.js").CompilationContext} fragContext Fragment shader compilation context
 */ function parseFillProperties(style, builder, uniforms, vertContext, fragContext) {
    if ('fill-color' in style) builder.setFillColorExpression(expressionToGlsl(fragContext, style['fill-color'], (0, _expressionJs.ColorType)));
    if ('fill-pattern-src' in style) {
        const textureId = computeHash(style['fill-pattern-src']);
        const sizeExpression = parseImageProperties(style, builder, uniforms, 'fill-pattern-', textureId);
        let sampleSizeExpression = sizeExpression;
        let offsetExpression = 'vec2(0.)';
        if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {
            sampleSizeExpression = expressionToGlsl(fragContext, style[`fill-pattern-size`], (0, _expressionJs.NumberArrayType));
            offsetExpression = parseImageOffsetProperties(style, 'fill-pattern-', fragContext, sizeExpression, sampleSizeExpression);
        }
        fragContext.functions['sampleFillPattern'] = `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {
  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);
  vec2 samplePos = mod((pxPosition - pxOrigin) / scaleRatio, sampleSize);
  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright
  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);
}`;
        const textureName = `u_texture${textureId}`;
        let tintExpression = '1.';
        if ('fill-color' in style) tintExpression = builder.getFillColorExpression();
        builder.setFillColorExpression(`${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`);
    }
}
function parseLiteralStyle(style) {
    /**
   * @type {import("../expr/gpu.js").CompilationContext}
   */ const vertContext = {
        inFragmentShader: false,
        properties: {},
        variables: {},
        functions: {},
        style
    };
    /**
   * @type {import("../expr/gpu.js").CompilationContext}
   */ const fragContext = {
        inFragmentShader: true,
        variables: vertContext.variables,
        properties: {},
        functions: {},
        style
    };
    const builder = new (0, _shaderBuilderJs.ShaderBuilder)();
    /** @type {Object<string,import("../webgl/Helper").UniformValue>} */ const uniforms = {};
    if ('icon-src' in style) parseIconProperties(style, builder, uniforms, vertContext, fragContext);
    else if ('shape-points' in style) parseShapeProperties(style, builder, uniforms, vertContext, fragContext);
    else if ('circle-radius' in style) parseCircleProperties(style, builder, uniforms, vertContext, fragContext);
    parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);
    parseFillProperties(style, builder, uniforms, vertContext, fragContext);
    if (style.filter) {
        const parsedFilter = expressionToGlsl(fragContext, style.filter, (0, _expressionJs.BooleanType));
        builder.setFragmentDiscardExpression(`!${parsedFilter}`);
    }
    // define one uniform per variable
    Object.keys(fragContext.variables).forEach(function(varName) {
        const variable = fragContext.variables[varName];
        const uniformName = (0, _gpuJs.uniformNameForVariable)(variable.name);
        builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);
        let callback;
        if (variable.type === (0, _expressionJs.StringType)) callback = ()=>(0, _gpuJs.getStringNumberEquivalent)(/** @type {string} */ style.variables[variable.name]);
        else if (variable.type === (0, _expressionJs.ColorType)) callback = ()=>packColor([
                ...(0, _colorJs.asArray)(/** @type {string|Array<number>} */ style.variables[variable.name] || '#eee')
            ]);
        else if (variable.type === (0, _expressionJs.BooleanType)) callback = ()=>/** @type {boolean} */ style.variables[variable.name] ? 1.0 : 0.0;
        else callback = ()=>/** @type {number} */ style.variables[variable.name];
        uniforms[uniformName] = callback;
    });
    // for each feature attribute used in the fragment shader, define a varying that will be used to pass data
    // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)
    Object.keys(fragContext.properties).forEach(function(propName) {
        const property = fragContext.properties[propName];
        if (!vertContext.properties[propName]) vertContext.properties[propName] = property;
        let type = getGlslTypeFromType(property.type);
        let expression = `a_prop_${property.name}`;
        if (property.type === (0, _expressionJs.ColorType)) {
            type = 'vec4';
            expression = `unpackColor(${expression})`;
            builder.addVertexShaderFunction(UNPACK_COLOR_FN);
        }
        builder.addVarying(`v_prop_${property.name}`, type, expression);
    });
    // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.
    Object.keys(vertContext.properties).forEach(function(propName) {
        const property = vertContext.properties[propName];
        builder.addAttribute(`${getGlslTypeFromType(property.type)} a_prop_${property.name}`);
    });
    const attributes = Object.keys(vertContext.properties).map(function(propName) {
        const property = vertContext.properties[propName];
        let callback;
        if (property.evaluator) callback = property.evaluator;
        else if (property.type === (0, _expressionJs.StringType)) callback = (feature)=>(0, _gpuJs.getStringNumberEquivalent)(feature.get(property.name));
        else if (property.type === (0, _expressionJs.ColorType)) callback = (feature)=>packColor([
                ...(0, _colorJs.asArray)(feature.get(property.name) || '#eee')
            ]);
        else if (property.type === (0, _expressionJs.BooleanType)) callback = (feature)=>feature.get(property.name) ? 1.0 : 0.0;
        else callback = (feature)=>feature.get(property.name);
        return {
            name: property.name,
            size: getGlslSizeFromType(property.type),
            callback
        };
    });
    // add functions that were collected in the compilation contexts
    for(const functionName in vertContext.functions)builder.addVertexShaderFunction(vertContext.functions[functionName]);
    for(const functionName in fragContext.functions)builder.addFragmentShaderFunction(fragContext.functions[functionName]);
    return {
        builder: builder,
        attributes: attributes.reduce((prev, curr)=>({
                ...prev,
                [curr.name]: {
                    callback: curr.callback,
                    size: curr.size
                }
            }), {}),
        uniforms: uniforms
    };
}

},{"../expr/expression.js":"8u0Bf","./ShaderBuilder.js":"16z9U","../expr/gpu.js":"7Mz5N","../color.js":"h6hAX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"16z9U":[function(require,module,exports,__globalThis) {
/**
 * Class for generating shaders from literal style objects
 * @module ol/webgl/ShaderBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "COMMON_HEADER", ()=>COMMON_HEADER);
/**
 * @typedef {Object} VaryingDescription
 * @property {string} name Varying name, as will be declared in the header.
 * @property {string} type Varying type, either `float`, `vec2`, `vec4`...
 * @property {string} expression Expression which will be assigned to the varying in the vertex shader, and
 * passed on to the fragment shader.
 */ /**
 * @classdesc
 * This class implements a classic builder pattern for generating many different types of shaders.
 * Methods can be chained, e. g.:
 *
 * ```js
 * const shader = new ShaderBuilder()
 *   .addVarying('v_width', 'float', 'a_width')
 *   .addUniform('u_time')
 *   .setColorExpression('...')
 *   .setSymbolSizeExpression('...')
 *   .getSymbolFragmentShader();
 * ```
 */ parcelHelpers.export(exports, "ShaderBuilder", ()=>ShaderBuilder);
var _utilsJs = require("../render/webgl/utils.js");
var _gpuJs = require("../expr/gpu.js");
var _flatJs = require("../style/flat.js");
const COMMON_HEADER = `#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform mat4 u_projectionMatrix;
uniform mat4 u_screenToWorldMatrix;
uniform vec2 u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
uniform float u_rotation;
uniform vec4 u_renderExtent;
uniform vec2 u_patternOrigin;
uniform float u_depth;
uniform mediump int u_hitDetection;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;

// this used to produce an alpha-premultiplied color from a texture
vec4 samplePremultiplied(sampler2D sampler, vec2 texCoord) {
  vec4 color = texture2D(sampler, texCoord);
  return vec4(color.rgb * color.a, color.a);
}
`;
const DEFAULT_STYLE = (0, _flatJs.createDefaultStyle)();
class ShaderBuilder {
    constructor(){
        /**
     * Uniforms; these will be declared in the header (should include the type).
     * @type {Array<string>}
     * @private
     */ this.uniforms_ = [];
        /**
     * Attributes; these will be declared in the header (should include the type).
     * @type {Array<string>}
     * @private
     */ this.attributes_ = [];
        /**
     * Varyings with a name, a type and an expression.
     * @type {Array<VaryingDescription>}
     * @private
     */ this.varyings_ = [];
        /**
     * @type {boolean}
     * @private
     */ this.hasSymbol_ = false;
        /**
     * @type {string}
     * @private
     */ this.symbolSizeExpression_ = `vec2(${(0, _gpuJs.numberToGlsl)(DEFAULT_STYLE['circle-radius'])} + ${(0, _gpuJs.numberToGlsl)(DEFAULT_STYLE['circle-stroke-width'] * 0.5)})`;
        /**
     * @type {string}
     * @private
     */ this.symbolRotationExpression_ = '0.0';
        /**
     * @type {string}
     * @private
     */ this.symbolOffsetExpression_ = 'vec2(0.0)';
        /**
     * @type {string}
     * @private
     */ this.symbolColorExpression_ = (0, _gpuJs.colorToGlsl)(/** @type {string} */ DEFAULT_STYLE['circle-fill-color']);
        /**
     * @type {string}
     * @private
     */ this.texCoordExpression_ = 'vec4(0.0, 0.0, 1.0, 1.0)';
        /**
     * @type {string}
     * @private
     */ this.discardExpression_ = 'false';
        /**
     * @type {boolean}
     * @private
     */ this.symbolRotateWithView_ = false;
        /**
     * @type {boolean}
     * @private
     */ this.hasStroke_ = false;
        /**
     * @type {string}
     * @private
     */ this.strokeWidthExpression_ = (0, _gpuJs.numberToGlsl)(DEFAULT_STYLE['stroke-width']);
        /**
     * @type {string}
     * @private
     */ this.strokeColorExpression_ = (0, _gpuJs.colorToGlsl)(/** @type {string} */ DEFAULT_STYLE['stroke-color']);
        /**
     * @private
     */ this.strokeOffsetExpression_ = '0.';
        /**
     * @private
     */ this.strokeCapExpression_ = (0, _gpuJs.stringToGlsl)('round');
        /**
     * @private
     */ this.strokeJoinExpression_ = (0, _gpuJs.stringToGlsl)('round');
        /**
     * @private
     */ this.strokeMiterLimitExpression_ = '10.';
        /**
     * @private
     */ this.strokeDistanceFieldExpression_ = '-1000.';
        /**
     * @type {boolean}
     * @private
     */ this.hasFill_ = false;
        /**
     * @type {string}
     * @private
     */ this.fillColorExpression_ = (0, _gpuJs.colorToGlsl)(/** @type {string} */ DEFAULT_STYLE['fill-color']);
        /**
     * @type {Array<string>}
     * @private
     */ this.vertexShaderFunctions_ = [];
        /**
     * @type {Array<string>}
     * @private
     */ this.fragmentShaderFunctions_ = [];
    }
    /**
   * Adds a uniform accessible in both fragment and vertex shaders.
   * The given name should include a type, such as `sampler2D u_texture`.
   * @param {string} name Uniform name
   * @return {ShaderBuilder} the builder object
   */ addUniform(name) {
        this.uniforms_.push(name);
        return this;
    }
    /**
   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.
   * The given name should include a type, such as `vec2 a_position`.
   * @param {string} name Attribute name
   * @return {ShaderBuilder} the builder object
   */ addAttribute(name) {
        this.attributes_.push(name);
        return this;
    }
    /**
   * Adds a varying defined in the vertex shader and accessible from the fragment shader.
   * The type and expression of the varying have to be specified separately.
   * @param {string} name Varying name
   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type
   * @param {string} expression Expression used to assign a value to the varying.
   * @return {ShaderBuilder} the builder object
   */ addVarying(name, type, expression) {
        this.varyings_.push({
            name: name,
            type: type,
            expression: expression
        });
        return this;
    }
    /**
   * Sets an expression to compute the size of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */ setSymbolSizeExpression(expression) {
        this.hasSymbol_ = true;
        this.symbolSizeExpression_ = expression;
        return this;
    }
    /**
   * @return {string} The current symbol size expression
   */ getSymbolSizeExpression() {
        return this.symbolSizeExpression_;
    }
    /**
   * Sets an expression to compute the rotation of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `float` value in radians.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */ setSymbolRotationExpression(expression) {
        this.symbolRotationExpression_ = expression;
        return this;
    }
    /**
   * Sets an expression to compute the offset of the symbol from the point center.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Offset expression
   * @return {ShaderBuilder} the builder object
   */ setSymbolOffsetExpression(expression) {
        this.symbolOffsetExpression_ = expression;
        return this;
    }
    /**
   * @return {string} The current symbol offset expression
   */ getSymbolOffsetExpression() {
        return this.symbolOffsetExpression_;
    }
    /**
   * Sets an expression to compute the color of the shape.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `vec4` value.
   * @param {string} expression Color expression
   * @return {ShaderBuilder} the builder object
   */ setSymbolColorExpression(expression) {
        this.hasSymbol_ = true;
        this.symbolColorExpression_ = expression;
        return this;
    }
    /**
   * @return {string} The current symbol color expression
   */ getSymbolColorExpression() {
        return this.symbolColorExpression_;
    }
    /**
   * Sets an expression to compute the texture coordinates of the vertices.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec4` value.
   * @param {string} expression Texture coordinate expression
   * @return {ShaderBuilder} the builder object
   */ setTextureCoordinateExpression(expression) {
        this.texCoordExpression_ = expression;
        return this;
    }
    /**
   * Sets an expression to determine whether a fragment (pixel) should be discarded,
   * i.e. not drawn at all.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `bool` value (it will be
   * used in an `if` statement)
   * @param {string} expression Fragment discard expression
   * @return {ShaderBuilder} the builder object
   */ setFragmentDiscardExpression(expression) {
        this.discardExpression_ = expression;
        return this;
    }
    /**
   * @return {string} The current fragment discard expression
   */ getFragmentDiscardExpression() {
        return this.discardExpression_;
    }
    /**
   * Sets whether the symbols should rotate with the view or stay aligned with the map.
   * Note: will only be used for point geometry shaders.
   * @param {boolean} rotateWithView Rotate with view
   * @return {ShaderBuilder} the builder object
   */ setSymbolRotateWithView(rotateWithView) {
        this.symbolRotateWithView_ = rotateWithView;
        return this;
    }
    /**
   * @param {string} expression Stroke width expression, returning value in pixels
   * @return {ShaderBuilder} the builder object
   */ setStrokeWidthExpression(expression) {
        this.hasStroke_ = true;
        this.strokeWidthExpression_ = expression;
        return this;
    }
    /**
   * @param {string} expression Stroke color expression, evaluate to `vec4`: can rely on currentLengthPx and currentRadiusPx
   * @return {ShaderBuilder} the builder object
   */ setStrokeColorExpression(expression) {
        this.hasStroke_ = true;
        this.strokeColorExpression_ = expression;
        return this;
    }
    /**
   * @return {string} The current stroke color expression
   */ getStrokeColorExpression() {
        return this.strokeColorExpression_;
    }
    /**
   * @param {string} expression Stroke color expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */ setStrokeOffsetExpression(expression) {
        this.strokeOffsetExpression_ = expression;
        return this;
    }
    /**
   * @param {string} expression Stroke line cap expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */ setStrokeCapExpression(expression) {
        this.strokeCapExpression_ = expression;
        return this;
    }
    /**
   * @param {string} expression Stroke line join expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */ setStrokeJoinExpression(expression) {
        this.strokeJoinExpression_ = expression;
        return this;
    }
    /**
   * @param {string} expression Stroke miter limit expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */ setStrokeMiterLimitExpression(expression) {
        this.strokeMiterLimitExpression_ = expression;
        return this;
    }
    /**
   * @param {string} expression Stroke distance field expression, evaluate to `float`
   * This can override the default distance field; can rely on currentLengthPx and currentRadiusPx
   * @return {ShaderBuilder} the builder object
   */ setStrokeDistanceFieldExpression(expression) {
        this.strokeDistanceFieldExpression_ = expression;
        return this;
    }
    /**
   * @param {string} expression Fill color expression, evaluate to `vec4`
   * @return {ShaderBuilder} the builder object
   */ setFillColorExpression(expression) {
        this.hasFill_ = true;
        this.fillColorExpression_ = expression;
        return this;
    }
    /**
   * @return {string} The current fill color expression
   */ getFillColorExpression() {
        return this.fillColorExpression_;
    }
    addVertexShaderFunction(code) {
        if (this.vertexShaderFunctions_.includes(code)) return;
        this.vertexShaderFunctions_.push(code);
    }
    addFragmentShaderFunction(code) {
        if (this.fragmentShaderFunctions_.includes(code)) return;
        this.fragmentShaderFunctions_.push(code);
    }
    /**
   * Generates a symbol vertex shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */ getSymbolVertexShader() {
        if (!this.hasSymbol_) return null;
        return `${COMMON_HEADER}
${this.uniforms_.map(function(uniform) {
            return 'uniform ' + uniform + ';';
        }).join('\n')}
attribute vec2 a_position;
attribute float a_index;
attribute vec4 a_hitColor;
${this.attributes_.map(function(attribute) {
            return 'attribute ' + attribute + ';';
        }).join('\n')}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
varying vec4 v_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(varying) {
            return 'varying ' + varying.type + ' ' + varying.name + ';';
        }).join('\n')}
${this.vertexShaderFunctions_.join('\n')}
vec2 pxToScreen(vec2 coordPx) {
  vec2 scaled = coordPx / u_viewportSizePx / 0.5;
  return scaled;
}

vec2 screenToPx(vec2 coordScreen) {
  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;
}

void main(void) {
  v_quadSizePx = ${this.symbolSizeExpression_};
  vec2 halfSizePx = v_quadSizePx * 0.5;
  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};
  vec2 offsetPx = centerOffsetPx;
  if (a_index == 0.0) {
    offsetPx -= halfSizePx;
  } else if (a_index == 1.0) {
    offsetPx += halfSizePx * vec2(1., -1.);
  } else if (a_index == 2.0) {
    offsetPx += halfSizePx;
  } else {
    offsetPx += halfSizePx * vec2(-1., 1.);
  }
  float angle = ${this.symbolRotationExpression_};
  ${this.symbolRotateWithView_ ? 'angle += u_rotation;' : ''}
  float c = cos(-angle);
  float s = sin(-angle);
  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);
  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);
  vec4 texCoord = ${this.texCoordExpression_};
  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;
  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;
  v_texCoord = vec2(u, v);
  v_hitColor = a_hitColor;
  v_angle = angle;
  c = cos(-v_angle);
  s = sin(-v_angle);
  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); 
  v_centerPx = screenToPx(center.xy) + centerOffsetPx;
${this.varyings_.map(function(varying) {
            return '  ' + varying.name + ' = ' + varying.expression + ';';
        }).join('\n')}
}`;
    }
    /**
   * Generates a symbol fragment shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */ getSymbolFragmentShader() {
        if (!this.hasSymbol_) return null;
        return `${COMMON_HEADER}
${this.uniforms_.map(function(uniform) {
            return 'uniform ' + uniform + ';';
        }).join('\n')}
varying vec2 v_texCoord;
varying vec4 v_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(varying) {
            return 'varying ' + varying.type + ' ' + varying.name + ';';
        }).join('\n')}
${this.fragmentShaderFunctions_.join('\n')}

void main(void) {
  if (${this.discardExpression_}) { discard; }
  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center
  float c = cos(v_angle);
  float s = sin(v_angle);
  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);
  gl_FragColor = ${this.symbolColorExpression_};
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.05) { discard; };
    gl_FragColor = v_hitColor;
  }
}`;
    }
    /**
   * Generates a stroke vertex shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */ getStrokeVertexShader() {
        if (!this.hasStroke_) return null;
        return `${COMMON_HEADER}
${this.uniforms_.map(function(uniform) {
            return 'uniform ' + uniform + ';';
        }).join('\n')}
attribute vec2 a_position;
attribute float a_index;
attribute vec2 a_segmentStart;
attribute vec2 a_segmentEnd;
attribute float a_parameters;
attribute float a_distance;
attribute vec2 a_joinAngles;
attribute vec4 a_hitColor;
${this.attributes_.map(function(attribute) {
            return 'attribute ' + attribute + ';';
        }).join('\n')}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_hitColor;
varying float v_distanceOffsetPx;
${this.varyings_.map(function(varying) {
            return 'varying ' + varying.type + ' ' + varying.name + ';';
        }).join('\n')}
${this.vertexShaderFunctions_.join('\n')}
vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

vec4 pxToScreen(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return vec4(screenPos, u_depth, 1.0);
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

vec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {
  float halfAngle = joinAngle / 2.0;
  float c = cos(halfAngle);
  float s = sin(halfAngle);
  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);
  float length = 1.0 / s;
  return angleBisectorNormal * length;
}

vec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {
  // if on a cap or the join angle is too high, offset the line along the segment normal
  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {
    return point - normal * offsetPx;
  }
  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)
  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;
}

void main(void) {
  v_angleStart = a_joinAngles.x;
  v_angleEnd = a_joinAngles.y;
  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);
  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)
  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);

  float lineWidth = ${this.strokeWidthExpression_};
  float lineOffsetPx = ${this.strokeOffsetExpression_};

  // compute segment start/end in px with offset
  vec2 segmentStartPx = worldToPx(a_segmentStart);
  vec2 segmentEndPx = worldToPx(a_segmentEnd);
  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),
  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);
  
  // compute current vertex position
  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;
  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;
  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;
  vec2 joinDirection;
  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;
  // if angle is too high, do not make a proper join
  if (cos(angle) > ${0, _utilsJs.LINESTRING_ANGLE_COSINE_CUTOFF} || isCap(angle)) {
    joinDirection = normalPx * normalDir - tangentPx * tangentDir;
  } else {
    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);
  }
  positionPx = positionPx + joinDirection * lineWidth * 0.5;
  gl_Position = pxToScreen(positionPx);

  v_segmentStart = segmentStartPx;
  v_segmentEnd = segmentEndPx;
  v_width = lineWidth;
  v_hitColor = a_hitColor;
  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);
${this.varyings_.map(function(varying) {
            return '  ' + varying.name + ' = ' + varying.expression + ';';
        }).join('\n')}
}`;
    }
    /**
   * Generates a stroke fragment shader from the builder parameters
   *
   * @return {string|null} The full shader as a string; null if no size or color specified
   */ getStrokeFragmentShader() {
        if (!this.hasStroke_) return null;
        return `${COMMON_HEADER}
${this.uniforms_.map(function(uniform) {
            return 'uniform ' + uniform + ';';
        }).join('\n')}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_hitColor;
varying float v_distanceOffsetPx;
${this.varyings_.map(function(varying) {
            return 'varying ' + varying.type + ' ' + varying.name + ';';
        }).join('\n')}
${this.fragmentShaderFunctions_.join('\n')}

vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

float segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  vec2 tangent = normalize(end - start);
  vec2 normal = vec2(-tangent.y, tangent.x);
  vec2 startToPoint = point - start;
  return abs(dot(startToPoint, normal)) - width * 0.5;
}

float buttCapDistanceField(vec2 point, vec2 start, vec2 end) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  return dot(startToPoint, -tangent);
}

float squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return buttCapDistanceField(point, start, end) - width * 0.5;
}

float roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment
  return length(point - start) - width * 0.5 - onSegment;
}

float roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return roundCapDistanceField(point, start, end, width);
}

float bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  float c = cos(joinAngle * 0.5);
  float s = sin(joinAngle * 0.5);
  float direction = -sign(sin(joinAngle));
  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);
  float radius = width * 0.5 * s;
  return dot(startToPoint, bisector * direction) - radius;
}

float miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  if (cos(joinAngle) > ${0, _utilsJs.LINESTRING_ANGLE_COSINE_CUTOFF}) { // avoid risking a division by zero
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  float miterLength = 1. / sin(joinAngle * 0.5);
  float miterLimit = ${this.strokeMiterLimitExpression_};
  if (miterLength > miterLimit) {
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  return -1000.;
}

float capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {
   if (capType == ${(0, _gpuJs.stringToGlsl)('butt')}) {
    return buttCapDistanceField(point, start, end);
  } else if (capType == ${(0, _gpuJs.stringToGlsl)('square')}) {
    return squareCapDistanceField(point, start, end, width);
  }
  return roundCapDistanceField(point, start, end, width);
}

float joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {
  if (joinType == ${(0, _gpuJs.stringToGlsl)('bevel')}) {
    return bevelJoinField(point, start, end, width, joinAngle);
  } else if (joinType == ${(0, _gpuJs.stringToGlsl)('miter')}) {
    return miterJoinDistanceField(point, start, end, width, joinAngle);
  }
  return roundJoinDistanceField(point, start, end, width);
}

float computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {
  if (isCap(joinAngle)) {
    return capDistanceField(point, start, end, width, capType);
  }
  return joinDistanceField(point, start, end, width, joinAngle, joinType);
}

void main(void) {
  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(currentPoint);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }

  float segmentLength = length(v_segmentEnd - v_segmentStart);
  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;
  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);
  vec2 startToPoint = currentPoint - v_segmentStart;
  float currentLengthPx = max(0., min(dot(segmentTangent, startToPoint), segmentLength)) + v_distanceOffsetPx; 
  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));
  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;
  vec4 color = ${this.strokeColorExpression_} * u_globalAlpha;
  float capType = ${this.strokeCapExpression_};
  float joinType = ${this.strokeJoinExpression_};
  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);
  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);
  float distance = max(
    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),
    max(segmentStartDistance, segmentEndDistance)
  );
  distance = max(distance, ${this.strokeDistanceFieldExpression_});
  gl_FragColor = color * smoothstep(0., -1., distance);
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_hitColor;
  }
}`;
    }
    /**
   * Generates a fill vertex shader from the builder parameters
   *
   * @return {string|null} The full shader as a string; null if no color specified
   */ getFillVertexShader() {
        if (!this.hasFill_) return null;
        return `${COMMON_HEADER}
${this.uniforms_.map(function(uniform) {
            return 'uniform ' + uniform + ';';
        }).join('\n')}
attribute vec2 a_position;
attribute vec4 a_hitColor;
${this.attributes_.map(function(attribute) {
            return 'attribute ' + attribute + ';';
        }).join('\n')}
varying vec4 v_hitColor;
${this.varyings_.map(function(varying) {
            return 'varying ' + varying.type + ' ' + varying.name + ';';
        }).join('\n')}
${this.vertexShaderFunctions_.join('\n')}
void main(void) {
  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);
  v_hitColor = a_hitColor;
${this.varyings_.map(function(varying) {
            return '  ' + varying.name + ' = ' + varying.expression + ';';
        }).join('\n')}
}`;
    }
    /**
   * Generates a fill fragment shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no color specified
   */ getFillFragmentShader() {
        if (!this.hasFill_) return null;
        return `${COMMON_HEADER}
${this.uniforms_.map(function(uniform) {
            return 'uniform ' + uniform + ';';
        }).join('\n')}
varying vec4 v_hitColor;
${this.varyings_.map(function(varying) {
            return 'varying ' + varying.type + ' ' + varying.name + ';';
        }).join('\n')}
${this.fragmentShaderFunctions_.join('\n')}
vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

void main(void) {
  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;
  vec2 pxOrigin = worldToPx(u_patternOrigin);
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(pxPos);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }
  gl_FragColor = ${this.fillColorExpression_} * u_globalAlpha;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_hitColor;
  }
}`;
    }
}

},{"../render/webgl/utils.js":"5SJid","../expr/gpu.js":"7Mz5N","../style/flat.js":"9bCpu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5SJid":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/webgl/utils
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LINESTRING_ANGLE_COSINE_CUTOFF", ()=>LINESTRING_ANGLE_COSINE_CUTOFF);
/**
 * Pushes a quad (two triangles) based on a point geometry
 * @param {Float32Array} instructions Array of render instructions for points.
 * @param {number} elementIndex Index from which render instructions will be read.
 * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.
 * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.
 * @param {number} customAttributesSize Amount of custom attributes for each element.
 * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.
 * @return {BufferPositions} New buffer positions where to write next
 * @property {number} vertexPosition New position in the vertex buffer where future writes should start.
 * @property {number} indexPosition New position in the index buffer where future writes should start.
 * @private
 */ parcelHelpers.export(exports, "writePointFeatureToBuffers", ()=>writePointFeatureToBuffers);
/**
 * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next
 * segment, in order to be able to offset the vertices correctly in the shader.
 * Join angles are between 0 and 2PI.
 * This also computes the length of the current segment and the sum of the join angle tangents in order
 * to store this information on each subsequent segment along the line. This is necessary to correctly render dashes
 * and symbols along the line.
 *
 *   pB (before)                          pA (after)
 *    X             negative             X
 *     \             offset             /
 *      \                              /
 *       \   join              join   /
 *        \ angle 0          angle 1 /
 *         \←---                ←---/      positive
 *          \   ←--          ←--   /        offset
 *           \     ↑       ↓      /
 *            X────┴───────┴─────X
 *            p0                  p1
 *
 * @param {Float32Array} instructions Array of render instructions for lines.s
 * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.
 * @param {number} segmentEndIndex Index of the segment end point from which render instructions will be read.
 * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)
 * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)
 * @param {Array<number>} vertexArray Array containing vertices.
 * @param {Array<number>} indexArray Array containing indices.
 * @param {Array<number>} customAttributes Array of custom attributes value
 * @param {import('../../transform.js').Transform} toWorldTransform Transform matrix used to obtain world coordinates from instructions
 * @param {number} currentLength Cumulated length of segments processed so far
 * @param {number} currentAngleTangentSum Cumulated tangents of the join angles processed so far
 * @return {{length: number, angle: number}} Cumulated length with the newly processed segment (in world units), new sum of the join angle tangents
 * @private
 */ parcelHelpers.export(exports, "writeLineSegmentToBuffers", ()=>writeLineSegmentToBuffers);
/**
 * Pushes several triangles to form a polygon, including holes
 * @param {Float32Array} instructions Array of render instructions for lines.
 * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.
 * @param {Array<number>} vertexArray Array containing vertices.
 * @param {Array<number>} indexArray Array containing indices.
 * @param {number} customAttributesSize Amount of custom attributes for each element.
 * @return {number} Next polygon instructions index
 * @private
 */ parcelHelpers.export(exports, "writePolygonTrianglesToBuffers", ()=>writePolygonTrianglesToBuffers);
/**
 * Returns a texture of 1x1 pixel, white
 * @private
 * @return {ImageData} Image data.
 */ parcelHelpers.export(exports, "getBlankImageData", ()=>getBlankImageData);
/**
 * Generates a color array based on a numerical id
 * Note: the range for each component is 0 to 1 with 256 steps
 * @param {number} id Id
 * @param {Array<number>} [array] Reusable array
 * @return {Array<number>} Color array containing the encoded id
 */ parcelHelpers.export(exports, "colorEncodeId", ()=>colorEncodeId);
/**
 * Reads an id from a color-encoded array
 * Note: the expected range for each component is 0 to 1 with 256 steps.
 * @param {Array<number>} color Color array containing the encoded id
 * @return {number} Decoded id
 */ parcelHelpers.export(exports, "colorDecodeId", ()=>colorDecodeId);
var _earcut = require("earcut");
var _earcutDefault = parcelHelpers.interopDefault(_earcut);
var _transformJs = require("../../transform.js");
var _mathJs = require("../../math.js");
const LINESTRING_ANGLE_COSINE_CUTOFF = 0.985;
/** @type {Array<number>} */ const tmpArray_ = [];
/**
 * An object holding positions both in an index and a vertex buffer.
 * @typedef {Object} BufferPositions
 * @property {number} vertexPosition Position in the vertex buffer
 * @property {number} indexPosition Position in the index buffer
 */ const bufferPositions_ = {
    vertexPosition: 0,
    indexPosition: 0
};
/**
 * @param {Float32Array} buffer Buffer
 * @param {number} pos Position
 * @param {number} x X
 * @param {number} y Y
 * @param {number} index Index
 */ function writePointVertex(buffer, pos, x, y, index) {
    buffer[pos + 0] = x;
    buffer[pos + 1] = y;
    buffer[pos + 2] = index;
}
function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesSize, bufferPositions) {
    // This is for x, y and index
    const baseVertexAttrsCount = 3;
    const baseInstructionsCount = 2;
    const stride = baseVertexAttrsCount + customAttributesSize;
    const x = instructions[elementIndex + 0];
    const y = instructions[elementIndex + 1];
    // read custom numerical attributes on the feature
    const customAttrs = tmpArray_;
    customAttrs.length = customAttributesSize;
    for(let i = 0; i < customAttrs.length; i++)customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];
    let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;
    let iPos = bufferPositions ? bufferPositions.indexPosition : 0;
    const baseIndex = vPos / stride;
    // push vertices for each of the four quad corners (first standard then custom attributes)
    writePointVertex(vertexBuffer, vPos, x, y, 0);
    customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
    vPos += stride;
    writePointVertex(vertexBuffer, vPos, x, y, 1);
    customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
    vPos += stride;
    writePointVertex(vertexBuffer, vPos, x, y, 2);
    customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
    vPos += stride;
    writePointVertex(vertexBuffer, vPos, x, y, 3);
    customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
    vPos += stride;
    indexBuffer[iPos++] = baseIndex;
    indexBuffer[iPos++] = baseIndex + 1;
    indexBuffer[iPos++] = baseIndex + 3;
    indexBuffer[iPos++] = baseIndex + 1;
    indexBuffer[iPos++] = baseIndex + 2;
    indexBuffer[iPos++] = baseIndex + 3;
    bufferPositions_.vertexPosition = vPos;
    bufferPositions_.indexPosition = iPos;
    return bufferPositions_;
}
function writeLineSegmentToBuffers(instructions, segmentStartIndex, segmentEndIndex, beforeSegmentIndex, afterSegmentIndex, vertexArray, indexArray, customAttributes, toWorldTransform, currentLength, currentAngleTangentSum) {
    // compute the stride to determine how many vertices were already pushed
    const baseVertexAttrsCount = 8; // base attributes: x0, y0, x1, y1, angle0, angle1, distance, params
    const stride = baseVertexAttrsCount + customAttributes.length;
    const baseIndex = vertexArray.length / stride;
    // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]
    // Depending on whether there are points before and after the segment, its final shape
    // will be different
    const p0 = [
        instructions[segmentStartIndex + 0],
        instructions[segmentStartIndex + 1]
    ];
    const p1 = [
        instructions[segmentEndIndex],
        instructions[segmentEndIndex + 1]
    ];
    // to compute join angles we need to reproject coordinates back in world units
    const p0world = (0, _transformJs.apply)(toWorldTransform, [
        ...p0
    ]);
    const p1world = (0, _transformJs.apply)(toWorldTransform, [
        ...p1
    ]);
    /**
   * Compute the angle between p0pA and p0pB
   * @param {import("../../coordinate.js").Coordinate} p0 Point 0
   * @param {import("../../coordinate.js").Coordinate} pA Point A
   * @param {import("../../coordinate.js").Coordinate} pB Point B
   * @return {number} a value in [0, 2PI]
   */ function angleBetween(p0, pA, pB) {
        const lenA = Math.sqrt((pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1]));
        const tangentA = [
            (pA[0] - p0[0]) / lenA,
            (pA[1] - p0[1]) / lenA
        ];
        const orthoA = [
            -tangentA[1],
            tangentA[0]
        ];
        const lenB = Math.sqrt((pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1]));
        const tangentB = [
            (pB[0] - p0[0]) / lenB,
            (pB[1] - p0[1]) / lenB
        ];
        // this angle can be clockwise or anticlockwise; hence the computation afterwards
        const angle = lenA === 0 || lenB === 0 ? 0 : Math.acos((0, _mathJs.clamp)(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1));
        const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;
        return !isClockwise ? Math.PI * 2 - angle : angle;
    }
    // a negative angle indicates a line cap
    let angle0 = -1;
    let angle1 = -1;
    let newAngleTangentSum = currentAngleTangentSum;
    const joinBefore = beforeSegmentIndex !== null;
    const joinAfter = afterSegmentIndex !== null;
    // add vertices and adapt offsets for P0 in case of join
    if (joinBefore) {
        // B for before
        const pB = [
            instructions[beforeSegmentIndex],
            instructions[beforeSegmentIndex + 1]
        ];
        const pBworld = (0, _transformJs.apply)(toWorldTransform, [
            ...pB
        ]);
        angle0 = angleBetween(p0world, p1world, pBworld);
        // only add to the sum if the angle isn't too close to 0 or 2PI
        if (Math.cos(angle0) <= LINESTRING_ANGLE_COSINE_CUTOFF) newAngleTangentSum += Math.tan((angle0 - Math.PI) / 2);
    }
    // adapt offsets for P1 in case of join; add to angle sum
    if (joinAfter) {
        // A for after
        const pA = [
            instructions[afterSegmentIndex],
            instructions[afterSegmentIndex + 1]
        ];
        const pAworld = (0, _transformJs.apply)(toWorldTransform, [
            ...pA
        ]);
        angle1 = angleBetween(p1world, p0world, pAworld);
        // only add to the sum if the angle isn't too close to 0 or 2PI
        if (Math.cos(angle1) <= LINESTRING_ANGLE_COSINE_CUTOFF) newAngleTangentSum += Math.tan((Math.PI - angle1) / 2);
    }
    /**
   * @param {number} vertexIndex From 0 to 3, indicating position in the quad
   * @param {number} angleSum Sum of the join angles encountered so far (used to compute distance offset
   * @return {number} A float value containing both information
   */ function computeParameters(vertexIndex, angleSum) {
        if (angleSum === 0) return vertexIndex * 10000;
        return Math.sign(angleSum) * (vertexIndex * 10000 + Math.abs(angleSum));
    }
    // add main segment triangles
    vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(0, currentAngleTangentSum));
    vertexArray.push(...customAttributes);
    vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(1, currentAngleTangentSum));
    vertexArray.push(...customAttributes);
    vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(2, currentAngleTangentSum));
    vertexArray.push(...customAttributes);
    vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, computeParameters(3, currentAngleTangentSum));
    vertexArray.push(...customAttributes);
    indexArray.push(baseIndex, baseIndex + 1, baseIndex + 2, baseIndex + 1, baseIndex + 3, baseIndex + 2);
    return {
        length: currentLength + Math.sqrt((p1world[0] - p0world[0]) * (p1world[0] - p0world[0]) + (p1world[1] - p0world[1]) * (p1world[1] - p0world[1])),
        angle: newAngleTangentSum
    };
}
function writePolygonTrianglesToBuffers(instructions, polygonStartIndex, vertexArray, indexArray, customAttributesSize) {
    const instructionsPerVertex = 2; // x, y
    const attributesPerVertex = 2 + customAttributesSize;
    let instructionsIndex = polygonStartIndex;
    const customAttributes = instructions.slice(instructionsIndex, instructionsIndex + customAttributesSize);
    instructionsIndex += customAttributesSize;
    const ringsCount = instructions[instructionsIndex++];
    let verticesCount = 0;
    const holes = new Array(ringsCount - 1);
    for(let i = 0; i < ringsCount; i++){
        verticesCount += instructions[instructionsIndex++];
        if (i < ringsCount - 1) holes[i] = verticesCount;
    }
    const flatCoords = instructions.slice(instructionsIndex, instructionsIndex + verticesCount * instructionsPerVertex);
    // pushing to vertices and indices!! this is where the magic happens
    const result = (0, _earcutDefault.default)(flatCoords, holes, instructionsPerVertex);
    for(let i = 0; i < result.length; i++)indexArray.push(result[i] + vertexArray.length / attributesPerVertex);
    for(let i = 0; i < flatCoords.length; i += 2)vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);
    return instructionsIndex + verticesCount * instructionsPerVertex;
}
function getBlankImageData() {
    const canvas = document.createElement('canvas');
    const image = canvas.getContext('2d').createImageData(1, 1);
    image.data[0] = 255;
    image.data[1] = 255;
    image.data[2] = 255;
    image.data[3] = 255;
    return image;
}
function colorEncodeId(id, array) {
    array = array || [];
    const radix = 256;
    const divide = radix - 1;
    array[0] = Math.floor(id / radix / radix / radix) / divide;
    array[1] = Math.floor(id / radix / radix) % radix / divide;
    array[2] = Math.floor(id / radix) % radix / divide;
    array[3] = id % radix / divide;
    return array;
}
function colorDecodeId(color) {
    let id = 0;
    const radix = 256;
    const mult = radix - 1;
    id += Math.round(color[0] * radix * radix * radix * mult);
    id += Math.round(color[1] * radix * radix * mult);
    id += Math.round(color[2] * radix * mult);
    id += Math.round(color[3] * mult);
    return id;
}

},{"earcut":"4F20W","../../transform.js":"9LrRk","../../math.js":"d8zSj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4F20W":[function(require,module,exports,__globalThis) {
'use strict';
module.exports = earcut;
module.exports.default = earcut;
function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for(var i = dim; i < outerLen; i += dim){
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }
        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
}
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) for(i = start; i < end; i += dim)last = insertNode(i, data[i], data[i + 1], last);
    else for(i = end - dim; i >= start; i -= dim)last = insertNode(i, data[i], data[i + 1], last);
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start, again;
    do {
        again = false;
        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else p = p.next;
    }while (again || p !== end);
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) splitEarcut(ear, triangles, dim, minX, minY, invSize);
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p = c.next;
    while(p !== a){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
    var p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);
            p = start = b;
        }
        p = p.next;
    }while (p !== start);
    return filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while(b !== a.prev){
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);
                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);
                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    }while (a !== start);
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start, end, list;
    for(i = 0, len = holeIndices.length; i < len; i++){
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i = 0; i < queue.length; i++)outerNode = eliminateHole(queue[i], outerNode);
    return outerNode;
}
function compareX(a, b) {
    return a.x - b.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) return outerNode;
    var bridgeReverse = splitPolygon(bridge, hole);
    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    }while (p !== outerNode);
    if (!m) return null;
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop);
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i = 0; i < inSize; i++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1);
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start);
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
    (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
    (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
    }while (p !== a);
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a);
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;
    // vertex coordinates
    this.x = x;
    this.y = y;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = 0;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) for(var i = 0, len = holeIndices.length; i < len; i++){
        var start = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
    var trianglesArea = 0;
    for(i = 0; i < triangles.length; i += 3){
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }
    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
    var sum = 0;
    for(var i = start, j = end - dim; i < end; i += dim){
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}
// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function(data) {
    var dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
    }, holeIndex = 0;
    for(var i = 0; i < data.length; i++){
        for(var j = 0; j < data[i].length; j++)for(var d = 0; d < dim; d++)result.vertices.push(data[i][j][d]);
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],"9bCpu":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/flat
 */ /**
 * @api
 * @fileoverview Vector layers can be styled with an object literal containing properties for
 * stroke, fill, image, and text styles.  The types below can be composed into a single object.
 * For example, a style with both stroke and fill properties could look like this:
 *
 *     const style = {
 *       'stroke-color': 'yellow',
 *       'stroke-width': 1.5,
 *       'fill-color': 'orange',
 *     };
 *
 * See details about the available properties depending on what type of symbolizer should be applied:
 *  * {@link module:ol/style/flat~FlatStroke Stroke} - properties for applying a stroke to lines and polygons
 *  * {@link module:ol/style/flat~FlatFill Fill} - properties for filling polygons
 *  * {@link module:ol/style/flat~FlatText Text} - properties for labeling points, lines, and polygons
 *  * {@link module:ol/style/flat~FlatIcon Icon} - properties for rendering points with an icon
 *  * {@link module:ol/style/flat~FlatCircle Circle} - properties for rendering points with a circle
 *  * {@link module:ol/style/flat~FlatShape Shape} - properties for rendering points with a regular shape
 *
 * To conditionally apply styles based on a filter, a list of {@link module:ol/style/flat~Rule rules} can be used.
 * For example, to style points with a big orange circle if the population is greater than 1 million and
 * a smaller blue circle otherwise:
 *
 *     const rules = [
 *       {
 *         filter: ['>', ['get', 'population'], 1_000_000],
 *         style: {
 *           'circle-radius': 10,
 *           'circle-fill-color': 'red',
 *         }
 *       },
 *       {
 *         else: true,
 *         style: {
 *           'circle-radius': 5,
 *           'circle-fill-color': 'blue',
 *         },
 *       },
 *     ];
 */ /**
 * A literal boolean (e.g. `true`) or an expression that evaluates to a boolean (e.g. `['>', ['get', 'population'], 1_000_000]`).
 *
 * @typedef {boolean|Array} BooleanExpression
 */ /**
 * A literal string (e.g. `'hello'`) or an expression that evaluates to a string (e.g. `['get', 'greeting']`).
 *
 * @typedef {string|Array} StringExpression
 */ /**
 * A literal number (e.g. `42`) or an expression that evaluates to a number (e.g. `['+', 40, 2]`).
 *
 * @typedef {number|Array} NumberExpression
 */ /**
 * A CSS named color (e.g. `'blue'`), an array of 3 RGB values (e.g. `[0, 255, 0]`), an array of 4 RGBA values
 * (e.g. `[0, 255, 0, 0.5]`), or an expression that evaluates to one of these color types (e.g. `['get', 'color']`).
 *
 * @typedef {import("../color.js").Color|string|Array} ColorExpression
 */ /**
 * An array of numbers (e.g. `[1, 2, 3]`) or an expression that evaluates to the same (e.g. `['get', 'values']`).
 *
 * @typedef {Array<number>|Array} NumberArrayExpression
 */ /**
 * An array of two numbers (e.g. `[10, 20]`) or an expression that evaluates to the same (e.g. `['get', 'size']`).
 *
 * @typedef {number|Array<number>|Array} SizeExpression
 */ /**
 * For static styling, the [layer.setStyle()]{@link module:ol/layer/Vector~VectorLayer#setStyle} method
 * can be called with an object literal that has fill, stroke, text, icon, regular shape, and/or circle properties.
 * @api
 *
 * @typedef {FlatFill & FlatStroke & FlatText & FlatIcon & FlatShape & FlatCircle} FlatStyle
 */ /**
 * A flat style literal or an array of the same.
 *
 * @typedef {FlatStyle|Array<FlatStyle>|Array<Rule>} FlatStyleLike
 */ /**
 * Fill style properties applied to polygon features.
 *
 * @typedef {Object} FlatFill
 * @property {ColorExpression} [fill-color] The fill color.
 */ /**
 * Stroke style properties applied to line strings and polygon boundaries.  To apply a stroke, at least one of
 * `stroke-color` or `stroke-width` must be provided.
 *
 * @typedef {Object} FlatStroke
 * @property {ColorExpression} [stroke-color] The stroke color.
 * @property {NumberExpression} [stroke-width] Stroke pixel width.
 * @property {StringExpression} [stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [stroke-miter-limit=10] Miter limit.
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */ /**
 * Label style properties applied to all features.  At a minimum, a `text-value` must be provided.
 *
 * @typedef {Object} FlatText
 * @property {StringExpression} [text-value] Text content (with `\n` for line breaks).
 * @property {StringExpression} [text-font='10px sans-serif'] Font style as [CSS `font`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font) value.
 * @property {NumberExpression} [text-max-angle=Math.PI/4] When `text-placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {NumberExpression} [text-offset-x=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {NumberExpression} [text-offset-y=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {BooleanExpression} [text-overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {StringExpression} [text-placement='point'] Text placement.
 * @property {NumberExpression} [text-repeat] Repeat interval in pixels. When set, the text will be repeated at this interval. Only available when
 * `text-placement` is set to `'line'`. Overrides `text-align`.
 * @property {SizeExpression} [text-scale] Scale.
 * @property {BooleanExpression} [text-rotate-with-view=false] Whether to rotate the text with the view.
 * @property {NumberExpression} [text-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {StringExpression} [text-align] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `'text-placement': 'point'`. For `'text-placement': 'line'`, the default is to let the renderer choose a
 * placement where `text-max-angle` is not exceeded.
 * @property {StringExpression} [text-justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `text-justify` is ignored for immediate rendering and also for `'text-placement': 'line'`.
 * @property {StringExpression} [text-baseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {NumberArrayExpression} [text-padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 * @property {ColorExpression} [text-fill-color] The fill color. Specify `'none'` to avoid hit detection on the fill.
 * @property {ColorExpression} [text-background-fill-color] The fill color.
 * @property {ColorExpression} [text-stroke-color] The stroke color.
 * @property {StringExpression} [text-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [text-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [text-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [text-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [text-stroke-miter-limit=10] Miter limit.
 * @property {NumberExpression} [text-stroke-width] Stroke pixel width.
 * @property {ColorExpression} [text-background-stroke-color] The stroke color.
 * @property {StringExpression} [text-background-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [text-background-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [text-background-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [text-background-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [text-background-stroke-miter-limit=10] Miter limit.
 * @property {NumberExpression} [text-background-stroke-width] Stroke pixel width.
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */ /**
 * Icon style properties applied to point features. `icon-src` must be provided to render
 * points with an icon.
 *
 * @typedef {Object} FlatIcon
 * @property {string} [icon-src] Image source URI.
 * @property {NumberArrayExpression} [icon-anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./Icon.js").IconOrigin} [icon-anchor-origin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-x-units='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./Icon.js").IconAnchorUnits} [icon-anchor-y-units='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [icon-color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [icon-cross-origin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `icon-cross-origin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {Array<number>} [icon-offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {NumberArrayExpression} [icon-displacement=[0,0]] Displacement of the icon.
 * @property {import("./Icon.js").IconOrigin} [icon-offset-origin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {NumberExpression} [icon-opacity=1] Opacity of the icon.
 * @property {SizeExpression} [icon-scale=1] Scale.
 * @property {number} [icon-width] Width of the icon. If not specified, the actual image width will be used. Cannot be combined
 * with `scale`.
 * @property {number} [icon-height] Height of the icon. If not specified, the actual image height will be used. Cannot be combined
 * with `scale`.
 * @property {NumberExpression} [icon-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {BooleanExpression} [icon-rotate-with-view=false] Whether to rotate the icon with the view.
 * @property {import("../size.js").Size} [icon-size] Icon size in pixel. Can be used together with `icon-offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {"declutter"|"obstacle"|"none"|undefined} [icon-declutter-mode] Declutter mode
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */ /**
 * Regular shape style properties for rendering point features.  At least `shape-points` must be provided.
 *
 * @typedef {Object} FlatShape
 * @property {number} [shape-points] Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {ColorExpression} [shape-fill-color] The fill color.
 * @property {ColorExpression} [shape-stroke-color] The stroke color.
 * @property {NumberExpression} [shape-stroke-width] Stroke pixel width.
 * @property {StringExpression} [shape-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [shape-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [shape-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [shape-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [shape-stroke-miter-limit=10] Miter limit.
 * @property {number} [shape-radius] Radius of a regular polygon.
 * @property {number} [shape-radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [shape-radius2] Second radius of a star.
 * @property {number} [shape-angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {NumberArrayExpression} [shape-displacement=[0,0]] Displacement of the shape
 * @property {NumberExpression} [shape-rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {BooleanExpression} [shape-rotate-with-view=false] Whether to rotate the shape with the view.
 * @property {SizeExpression} [shape-scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `shape-radius`, `shape-radius1` and `shape-radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [shape-declutter-mode] Declutter mode.
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */ /**
 * Circle style properties for rendering point features.  At least `circle-radius` must be provided.
 *
 * @typedef {Object} FlatCircle
 * @property {number} [circle-radius] Circle radius.
 * @property {ColorExpression} [circle-fill-color] The fill color.
 * @property {ColorExpression} [circle-stroke-color] The stroke color.
 * @property {NumberExpression} [circle-stroke-width] Stroke pixel width.
 * @property {StringExpression} [circle-stroke-line-cap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {StringExpression} [circle-stroke-line-join='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {NumberArrayExpression} [circle-stroke-line-dash] Line dash pattern.
 * @property {NumberExpression} [circle-stroke-line-dash-offset=0] Line dash offset.
 * @property {NumberExpression} [circle-stroke-miter-limit=10] Miter limit.
 * @property {NumberArrayExpression} [circle-displacement=[0,0]] displacement
 * @property {SizeExpression} [circle-scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `circle-radius`.
 * @property {NumberExpression} [circle-rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {BooleanExpression} [circle-rotate-with-view=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [circle-declutter-mode] Declutter mode
 * @property {NumberExpression} [z-index] The zIndex of the style.
 */ /**
 * These default style properties are applied when no other style is given.
 *
 * @typedef {Object} DefaultStyle
 * @property {string} fill-color `'rgba(255,255,255,0.4)'`
 * @property {string} stroke-color `'#3399CC'`
 * @property {number} stroke-width `1.25`
 * @property {number} circle-radius `5`
 * @property {string} circle-fill-color `'rgba(255,255,255,0.4)'`
 * @property {number} circle-stroke-width `1.25`
 * @property {string} circle-stroke-color `'#3399CC'`
 */ /**
 * @return {DefaultStyle} The default flat style.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createDefaultStyle", ()=>createDefaultStyle) /**
 * A rule is used to conditionally apply a style.  If the rule's filter evaluates to true,
 * the style will be applied.
 *
 * @typedef {Object} Rule
 * @property {FlatStyle|Array<FlatStyle>} style The style to be applied if the filter matches.
 * @property {import("../expr/expression.js").EncodedExpression} [filter] The filter used
 * to determine if a style applies.  If no filter is included, the rule always applies
 * (unless it is an else rule).
 * @property {boolean} [else] If true, the rule applies only if no other previous rule applies.
 * If the else rule also has a filter, the rule will not apply if the filter does not match.
 */ ;
function createDefaultStyle() {
    return {
        'fill-color': 'rgba(255,255,255,0.4)',
        'stroke-color': '#3399CC',
        'stroke-width': 1.25,
        'circle-radius': 5,
        'circle-fill-color': 'rgba(255,255,255,0.4)',
        'circle-stroke-width': 1.25,
        'circle-stroke-color': '#3399CC'
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lpmgp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Save drawn features to GeoServer
 * @param {Array} features - Array of OpenLayers features to save
 * @param {string} workspace - GeoServer workspace name
 * @param {string} layerName - GeoServer layer name
 * @param {string} srs - Spatial reference system (default: 'EPSG:3857')
 * @param {string} username - GeoServer username
 * @param {string} password - GeoServer password
 * @param {string} geoserverURL - GeoServer URL
 * @returns {Promise} - Promise resolving to the result of the operation
 */ parcelHelpers.export(exports, "saveDrawing", ()=>saveDrawing);
var _geoserverCrudJs = require("./geoserver-crud.js");
var _ol = require("ol");
async function saveDrawing(features, workspace, layerName, srs = "EPSG:3857", username, password, geoserverURL) {
    if (features.length === 0) return {
        status: "error",
        message: "No features to save"
    };
    try {
        const preparedFeatures = features.map((feature)=>{
            const newFeat = new (0, _ol.Feature)();
            newFeat.setGeometryName("geom");
            newFeat.setGeometry(feature.getGeometry());
            newFeat.setProperties({
                "name": 'test'
            });
            const props = feature.getProperties();
            delete props.geometry;
            newFeat.setProperties(props);
            if (props.fid) newFeat.setId(props.fid);
            return newFeat;
        });
        const newFeatures = preparedFeatures.filter((f)=>!f.getId());
        const modifiedFeatures = preparedFeatures.filter((f)=>f.getId());
        let result = {
            status: "success",
            totalInserted: 0,
            totalUpdated: 0
        };
        if (newFeatures.length > 0) {
            const insertResult = await (0, _geoserverCrudJs.transactWFS)("insert", newFeatures, workspace, layerName, srs, username, password, geoserverURL);
            if (insertResult.insertedFIDs && insertResult.insertedFIDs.length > 0) insertResult.insertedFIDs.forEach((fid, index)=>{
                const featureId = parseInt(fid.split(".")[1]);
                features[index].setProperties({
                    fid: featureId
                });
            });
            result.totalInserted = insertResult.totalInserted || newFeatures.length;
            result = {
                ...result,
                ...insertResult
            };
        }
        if (modifiedFeatures.length > 0) {
            const updateResult = await (0, _geoserverCrudJs.transactWFS)("update", modifiedFeatures, workspace, layerName, srs, username, password, geoserverURL);
            result.totalUpdated = updateResult.totalUpdated || modifiedFeatures.length;
            result = {
                ...result,
                ...updateResult
            };
        }
        return result;
    // const result = await transactWFS(
    //   'insert',
    //   features,
    //   workspace,
    //   layerName,
    //   srs,
    //   username,
    //   password,
    //   geoserverURL
    // );
    // console.log("Result: ",result)
    // return result;
    } catch (error) {
        console.error("Error saving features:", error);
        return {
            status: "error",
            message: error.message || "Unknown error occurred while saving"
        };
    }
}

},{"./geoserver-crud.js":"7uIM7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT","ol":"7JF0u"}],"cVrUZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Fetch drawings from GeoServer
 * @param {string} geoserverURL - GeoServer URL
 * @param {string} workspace - GeoServer workspace name
 * @param {string} layerName - GeoServer layer name
 * @param {string} username - GeoServer username
 * @param {string} password - GeoServer password
 * @returns {Promise} - Promise resolving to an array of features
 */ parcelHelpers.export(exports, "fetchDrawing", ()=>fetchDrawing);
var _loadWfsJs = require("./load-wfs.js");
async function fetchDrawing(geoserverURL, workspace, layerName, username, password) {
    try {
        const features = await (0, _loadWfsJs.fetchFeatures)(geoserverURL, workspace, layerName, username, password);
        return {
            status: 'success',
            features: features,
            count: features.length
        };
    } catch (error) {
        console.error('Error fetching features:', error);
        return {
            status: 'error',
            message: error.message || 'Unknown error occurred while fetching',
            features: []
        };
    }
}

},{"./load-wfs.js":"bsKzT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3LDLH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Delete features from GeoServer
 * @param {Array} features - Array of OpenLayers features to delete
 * @param {string} workspace - GeoServer workspace name
 * @param {string} layerName - GeoServer layer name
 * @param {string} srs - Spatial reference system (default: 'EPSG:3857')
 * @param {string} username - GeoServer username
 * @param {string} password - GeoServer password
 * @param {string} geoserverURL - GeoServer URL
 * @returns {Promise} - Promise resolving to the result of the operation
 */ parcelHelpers.export(exports, "deleteDrawing", ()=>deleteDrawing);
var _geoserverCrudJs = require("./geoserver-crud.js");
async function deleteDrawing(features, workspace, layerName, srs = 'EPSG:3857', username, password, geoserverURL) {
    if (features.length === 0) return {
        status: 'error',
        message: 'No features selected for deletion'
    };
    try {
        const result = await (0, _geoserverCrudJs.transactWFS)('delete', features, workspace, layerName, srs, username, password, geoserverURL);
        return result;
    } catch (error) {
        console.error('Error deleting features:', error);
        return {
            status: 'error',
            message: error.message || 'Unknown error occurred while deleting'
        };
    }
}

},{"./geoserver-crud.js":"7uIM7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9kyTl":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DoubleClickZoom", ()=>(0, _doubleClickZoomJsDefault.default));
parcelHelpers.export(exports, "DblClickDragZoom", ()=>(0, _dblClickDragZoomJsDefault.default));
parcelHelpers.export(exports, "DragAndDrop", ()=>(0, _dragAndDropJsDefault.default));
parcelHelpers.export(exports, "DragBox", ()=>(0, _dragBoxJsDefault.default));
parcelHelpers.export(exports, "DragPan", ()=>(0, _dragPanJsDefault.default));
parcelHelpers.export(exports, "DragRotate", ()=>(0, _dragRotateJsDefault.default));
parcelHelpers.export(exports, "DragRotateAndZoom", ()=>(0, _dragRotateAndZoomJsDefault.default));
parcelHelpers.export(exports, "DragZoom", ()=>(0, _dragZoomJsDefault.default));
parcelHelpers.export(exports, "Draw", ()=>(0, _drawJsDefault.default));
parcelHelpers.export(exports, "Extent", ()=>(0, _extentJsDefault.default));
parcelHelpers.export(exports, "Interaction", ()=>(0, _interactionJsDefault.default));
parcelHelpers.export(exports, "KeyboardPan", ()=>(0, _keyboardPanJsDefault.default));
parcelHelpers.export(exports, "KeyboardZoom", ()=>(0, _keyboardZoomJsDefault.default));
parcelHelpers.export(exports, "Link", ()=>(0, _linkJsDefault.default));
parcelHelpers.export(exports, "Modify", ()=>(0, _modifyJsDefault.default));
parcelHelpers.export(exports, "MouseWheelZoom", ()=>(0, _mouseWheelZoomJsDefault.default));
parcelHelpers.export(exports, "PinchRotate", ()=>(0, _pinchRotateJsDefault.default));
parcelHelpers.export(exports, "PinchZoom", ()=>(0, _pinchZoomJsDefault.default));
parcelHelpers.export(exports, "Pointer", ()=>(0, _pointerJsDefault.default));
parcelHelpers.export(exports, "Select", ()=>(0, _selectJsDefault.default));
parcelHelpers.export(exports, "Snap", ()=>(0, _snapJsDefault.default));
parcelHelpers.export(exports, "Translate", ()=>(0, _translateJsDefault.default));
parcelHelpers.export(exports, "defaults", ()=>(0, _defaultsJs.defaults));
var _doubleClickZoomJs = require("./interaction/DoubleClickZoom.js");
var _doubleClickZoomJsDefault = parcelHelpers.interopDefault(_doubleClickZoomJs);
var _dblClickDragZoomJs = require("./interaction/DblClickDragZoom.js");
var _dblClickDragZoomJsDefault = parcelHelpers.interopDefault(_dblClickDragZoomJs);
var _dragAndDropJs = require("./interaction/DragAndDrop.js");
var _dragAndDropJsDefault = parcelHelpers.interopDefault(_dragAndDropJs);
var _dragBoxJs = require("./interaction/DragBox.js");
var _dragBoxJsDefault = parcelHelpers.interopDefault(_dragBoxJs);
var _dragPanJs = require("./interaction/DragPan.js");
var _dragPanJsDefault = parcelHelpers.interopDefault(_dragPanJs);
var _dragRotateJs = require("./interaction/DragRotate.js");
var _dragRotateJsDefault = parcelHelpers.interopDefault(_dragRotateJs);
var _dragRotateAndZoomJs = require("./interaction/DragRotateAndZoom.js");
var _dragRotateAndZoomJsDefault = parcelHelpers.interopDefault(_dragRotateAndZoomJs);
var _dragZoomJs = require("./interaction/DragZoom.js");
var _dragZoomJsDefault = parcelHelpers.interopDefault(_dragZoomJs);
var _drawJs = require("./interaction/Draw.js");
var _drawJsDefault = parcelHelpers.interopDefault(_drawJs);
var _extentJs = require("./interaction/Extent.js");
var _extentJsDefault = parcelHelpers.interopDefault(_extentJs);
var _interactionJs = require("./interaction/Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _keyboardPanJs = require("./interaction/KeyboardPan.js");
var _keyboardPanJsDefault = parcelHelpers.interopDefault(_keyboardPanJs);
var _keyboardZoomJs = require("./interaction/KeyboardZoom.js");
var _keyboardZoomJsDefault = parcelHelpers.interopDefault(_keyboardZoomJs);
var _linkJs = require("./interaction/Link.js");
var _linkJsDefault = parcelHelpers.interopDefault(_linkJs);
var _modifyJs = require("./interaction/Modify.js");
var _modifyJsDefault = parcelHelpers.interopDefault(_modifyJs);
var _mouseWheelZoomJs = require("./interaction/MouseWheelZoom.js");
var _mouseWheelZoomJsDefault = parcelHelpers.interopDefault(_mouseWheelZoomJs);
var _pinchRotateJs = require("./interaction/PinchRotate.js");
var _pinchRotateJsDefault = parcelHelpers.interopDefault(_pinchRotateJs);
var _pinchZoomJs = require("./interaction/PinchZoom.js");
var _pinchZoomJsDefault = parcelHelpers.interopDefault(_pinchZoomJs);
var _pointerJs = require("./interaction/Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _selectJs = require("./interaction/Select.js");
var _selectJsDefault = parcelHelpers.interopDefault(_selectJs);
var _snapJs = require("./interaction/Snap.js");
var _snapJsDefault = parcelHelpers.interopDefault(_snapJs);
var _translateJs = require("./interaction/Translate.js");
var _translateJsDefault = parcelHelpers.interopDefault(_translateJs);
var _defaultsJs = require("./interaction/defaults.js");

},{"./interaction/DoubleClickZoom.js":false,"./interaction/DblClickDragZoom.js":false,"./interaction/DragAndDrop.js":false,"./interaction/DragBox.js":false,"./interaction/DragPan.js":false,"./interaction/DragRotate.js":false,"./interaction/DragRotateAndZoom.js":false,"./interaction/DragZoom.js":false,"./interaction/Draw.js":false,"./interaction/Extent.js":false,"./interaction/Interaction.js":false,"./interaction/KeyboardPan.js":false,"./interaction/KeyboardZoom.js":false,"./interaction/Link.js":false,"./interaction/Modify.js":false,"./interaction/MouseWheelZoom.js":false,"./interaction/PinchRotate.js":false,"./interaction/PinchZoom.js":false,"./interaction/Pointer.js":false,"./interaction/Select.js":"7h3Zo","./interaction/Snap.js":false,"./interaction/Translate.js":false,"./interaction/defaults.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7h3Zo":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Select
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A function that takes an {@link module:ol/Feature~Feature} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @typedef {function(import("../Feature.js").default, import("../layer/Layer.js").default<import("../source/Source").default>):boolean} FilterFunction
 */ /**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [addCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition.never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is the event
 * for the selected features as a whole. By default, this is
 * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that
 * feature and removes any that were in the selection. Clicking outside any
 * feature removes all from the selection.
 * See `toggle`, `add`, `remove` options for adding/removing extra features to/
 * from the selection.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} [layers]
 * A list of layers from which features should be selected. Alternatively, a
 * filter function can be provided. The function will be called for each layer
 * in the map and should return `true` for layers that you want to be
 * selectable. If the option is absent, all visible layers will be considered
 * selectable.
 * @property {import("../style/Style.js").StyleLike|null} [style]
 * Style for the selected features. By default the default edit style is used
 * (see {@link module:ol/style/Style~Style}). Set to `null` if this interaction should not apply
 * any style changes for selected features.
 * If set to a falsey value, the selected feature's style will not change.
 * @property {import("../events/condition.js").Condition} [removeCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition.never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [toggleCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is in addition
 * to the `condition` event. By default,
 * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as
 * well as the `condition` event, adds that feature to the current selection if
 * it is not currently selected, and removes it if it is. See `add` and `remove`
 * if you want to use different events instead of a toggle.
 * @property {boolean} [multi=false] A boolean that determines if the default
 * behaviour should select only single features or all (overlapping) features at
 * the clicked map position. The default of `false` means single select.
 * @property {Collection<Feature>} [features]
 * Collection where the interaction will place selected features. Optional. If
 * not set the interaction will create a collection. In any case the collection
 * used by the interaction is returned by
 * {@link module:ol/interaction/Select~Select#getFeatures}.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature~Feature} and an
 * {@link module:ol/layer/Layer~Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
 * the radius around the given position will be checked for features.
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
 * this type.
 */ parcelHelpers.export(exports, "SelectEvent", ()=>SelectEvent);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _vectorJs = require("../layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _functionsJs = require("../functions.js");
var _objJs = require("../obj.js");
var _styleJs = require("../style/Style.js");
var _arrayJs = require("../array.js");
var _utilJs = require("../util.js");
var _conditionJs = require("../events/condition.js");
/**
 * @enum {string}
 */ const SelectEventType = {
    /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */ SELECT: 'select'
};
class SelectEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */ constructor(type, selected, deselected, mapBrowserEvent){
        super(type);
        /**
     * Selected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */ this.selected = selected;
        /**
     * Deselected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */ this.deselected = deselected;
        /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */ this.mapBrowserEvent = mapBrowserEvent;
    }
}
/**
 * Original feature styles to reset to when features are no longer selected.
 * @type {Object<number, import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction>}
 */ const originalFeatureStyles = {};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'select', SelectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'select', Return>} SelectOnSignature
 */ /**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * @fires SelectEvent
 * @api
 */ class Select extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        super();
        /***
     * @type {SelectOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {SelectOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {SelectOnSignature<void>}
     */ this.un;
        options = options ? options : {};
        /**
     * @private
     */ this.boundAddFeature_ = this.addFeature_.bind(this);
        /**
     * @private
     */ this.boundRemoveFeature_ = this.removeFeature_.bind(this);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : (0, _conditionJs.singleClick);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.addCondition_ = options.addCondition ? options.addCondition : (0, _conditionJs.never);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.removeCondition_ = options.removeCondition ? options.removeCondition : (0, _conditionJs.never);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : (0, _conditionJs.shiftKeyOnly);
        /**
     * @private
     * @type {boolean}
     */ this.multi_ = options.multi ? options.multi : false;
        /**
     * @private
     * @type {FilterFunction}
     */ this.filter_ = options.filter ? options.filter : (0, _functionsJs.TRUE);
        /**
     * @private
     * @type {number}
     */ this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
        /**
     * @private
     * @type {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null}
     */ this.style_ = options.style !== undefined ? options.style : getDefaultStyleFunction();
        /**
     * @private
     * @type {Collection<Feature>}
     */ this.features_ = options.features || new (0, _collectionJsDefault.default)();
        /** @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} */ let layerFilter;
        if (options.layers) {
            if (typeof options.layers === 'function') layerFilter = options.layers;
            else {
                const layers = options.layers;
                layerFilter = function(layer) {
                    return layers.includes(layer);
                };
            }
        } else layerFilter = (0, _functionsJs.TRUE);
        /**
     * @private
     * @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean}
     */ this.layerFilter_ = layerFilter;
        /**
     * An association between selected feature (key)
     * and layer (value)
     * @private
     * @type {Object<string, import("../layer/Layer.js").default>}
     */ this.featureLayerAssociation_ = {};
    }
    /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */ addFeatureLayerAssociation_(feature, layer) {
        this.featureLayerAssociation_[(0, _utilJs.getUid)(feature)] = layer;
    }
    /**
   * Get the selected features.
   * @return {Collection<Feature>} Features collection.
   * @api
   */ getFeatures() {
        return this.features_;
    }
    /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */ getHitTolerance() {
        return this.hitTolerance_;
    }
    /**
   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
   * a selected feature.
   * @param {import("../Feature.js").default} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */ getLayer(feature) {
        return /** @type {import('../layer/Vector.js').default} */ this.featureLayerAssociation_[(0, _utilJs.getUid)(feature)];
    }
    /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */ setHitTolerance(hitTolerance) {
        this.hitTolerance_ = hitTolerance;
    }
    /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */ setMap(map) {
        const currentMap = this.getMap();
        if (currentMap && this.style_) this.features_.forEach(this.restorePreviousStyle_.bind(this));
        super.setMap(map);
        if (map) {
            this.features_.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, this.boundAddFeature_);
            this.features_.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, this.boundRemoveFeature_);
            if (this.style_) this.features_.forEach(this.applySelectedStyle_.bind(this));
        } else {
            this.features_.removeEventListener((0, _collectionEventTypeJsDefault.default).ADD, this.boundAddFeature_);
            this.features_.removeEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, this.boundRemoveFeature_);
        }
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */ addFeature_(evt) {
        const feature = evt.element;
        if (this.style_) this.applySelectedStyle_(feature);
        if (!this.getLayer(feature)) {
            const layer = /** @type {VectorLayer} */ this.getMap().getAllLayers().find(function(layer) {
                if (layer instanceof (0, _vectorJsDefault.default) && layer.getSource() && layer.getSource().hasFeature(feature)) return layer;
            });
            if (layer) this.addFeatureLayerAssociation_(feature, layer);
        }
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */ removeFeature_(evt) {
        if (this.style_) this.restorePreviousStyle_(evt.element);
    }
    /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */ getStyle() {
        return this.style_;
    }
    /**
   * @param {Feature} feature Feature
   * @private
   */ applySelectedStyle_(feature) {
        const key = (0, _utilJs.getUid)(feature);
        if (!(key in originalFeatureStyles)) originalFeatureStyles[key] = feature.getStyle();
        feature.setStyle(this.style_);
    }
    /**
   * @param {Feature} feature Feature
   * @private
   */ restorePreviousStyle_(feature) {
        const interactions = this.getMap().getInteractions().getArray();
        for(let i = interactions.length - 1; i >= 0; --i){
            const interaction = interactions[i];
            if (interaction !== this && interaction instanceof Select && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature) !== -1) {
                feature.setStyle(interaction.getStyle());
                return;
            }
        }
        const key = (0, _utilJs.getUid)(feature);
        feature.setStyle(originalFeatureStyles[key]);
        delete originalFeatureStyles[key];
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ removeFeatureLayerAssociation_(feature) {
        delete this.featureLayerAssociation_[(0, _utilJs.getUid)(feature)];
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */ handleEvent(mapBrowserEvent) {
        if (!this.condition_(mapBrowserEvent)) return true;
        const add = this.addCondition_(mapBrowserEvent);
        const remove = this.removeCondition_(mapBrowserEvent);
        const toggle = this.toggleCondition_(mapBrowserEvent);
        const set = !add && !remove && !toggle;
        const map = mapBrowserEvent.map;
        const features = this.getFeatures();
        /**
     * @type {Array<Feature>}
     */ const deselected = [];
        /**
     * @type {Array<Feature>}
     */ const selected = [];
        if (set) {
            // Replace the currently selected feature(s) with the feature(s) at the
            // pixel, or clear the selected feature(s) if there is no feature at
            // the pixel.
            (0, _objJs.clear)(this.featureLayerAssociation_);
            map.forEachFeatureAtPixel(mapBrowserEvent.pixel, /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */ (feature, layer)=>{
                if (!(feature instanceof (0, _featureJsDefault.default)) || !this.filter_(feature, layer)) return;
                this.addFeatureLayerAssociation_(feature, layer);
                selected.push(feature);
                return !this.multi_;
            }, {
                layerFilter: this.layerFilter_,
                hitTolerance: this.hitTolerance_
            });
            for(let i = features.getLength() - 1; i >= 0; --i){
                const feature = features.item(i);
                const index = selected.indexOf(feature);
                if (index > -1) // feature is already selected
                selected.splice(index, 1);
                else {
                    features.remove(feature);
                    deselected.push(feature);
                }
            }
            if (selected.length !== 0) features.extend(selected);
        } else {
            // Modify the currently selected feature(s).
            map.forEachFeatureAtPixel(mapBrowserEvent.pixel, /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */ (feature, layer)=>{
                if (!(feature instanceof (0, _featureJsDefault.default)) || !this.filter_(feature, layer)) return;
                if ((add || toggle) && !features.getArray().includes(feature)) {
                    this.addFeatureLayerAssociation_(feature, layer);
                    selected.push(feature);
                } else if ((remove || toggle) && features.getArray().includes(feature)) {
                    deselected.push(feature);
                    this.removeFeatureLayerAssociation_(feature);
                }
                return !this.multi_;
            }, {
                layerFilter: this.layerFilter_,
                hitTolerance: this.hitTolerance_
            });
            for(let j = deselected.length - 1; j >= 0; --j)features.remove(deselected[j]);
            features.extend(selected);
        }
        if (selected.length > 0 || deselected.length > 0) this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
        return true;
    }
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    const styles = (0, _styleJs.createEditingStyle)();
    (0, _arrayJs.extend)(styles['Polygon'], styles['LineString']);
    (0, _arrayJs.extend)(styles['GeometryCollection'], styles['LineString']);
    return function(feature) {
        if (!feature.getGeometry()) return null;
        return styles[feature.getGeometry().getType()];
    };
}
exports.default = Select;

},{"../Collection.js":"hzcJw","../CollectionEventType.js":"auN7R","../events/Event.js":"kooRA","../Feature.js":"3qocF","./Interaction.js":"kcjGH","../layer/Vector.js":"6bOIK","../functions.js":"1QSsQ","../obj.js":"7RZD4","../style/Style.js":"8opjn","../array.js":"hyet5","../util.js":"l1iPW","../events/condition.js":"gm0iA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ef2iZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createBuffer", ()=>createBuffer);
var _ol3Parser = require("jsts/org/locationtech/jts/io/OL3Parser");
var _ol3ParserDefault = parcelHelpers.interopDefault(_ol3Parser);
var _ol = require("ol");
var _buffer = require("jsts/org/locationtech/jts/operation/buffer");
var _pointJs = require("ol/geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _multiPointJs = require("ol/geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _lineStringJs = require("ol/geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _polygonJs = require("ol/geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _multiPolygonJs = require("ol/geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _multiLineString = require("ol/geom/MultiLineString");
var _multiLineStringDefault = parcelHelpers.interopDefault(_multiLineString);
var _linearRingJs = require("ol/geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
function createBuffer(feature, bufferDistance, layer) {
    const parser = new (0, _ol3ParserDefault.default)();
    parser.inject((0, _pointJsDefault.default), (0, _lineStringJsDefault.default), (0, _linearRingJsDefault.default), (0, _polygonJsDefault.default), (0, _multiPointJsDefault.default), (0, _multiLineStringDefault.default), (0, _multiPolygonJsDefault.default));
    const jstsGeom = parser.read(feature.getGeometry());
    var buffered = (0, _buffer.BufferOp).bufferOp(jstsGeom, parseInt(bufferDistance));
    const geom = parser.write(buffered);
    var geom_buffer_feat = new (0, _ol.Feature)(geom);
    console.log("Geom: ", geom);
    layer.getSource().addFeature(geom_buffer_feat);
}

},{"jsts/org/locationtech/jts/io/OL3Parser":"1NdLK","ol":"7JF0u","jsts/org/locationtech/jts/operation/buffer":"avK2A","ol/geom/Point.js":"6SybV","ol/geom/MultiPoint.js":"gXgmP","ol/geom/LineString.js":"gknRz","ol/geom/Polygon.js":"8Vwps","ol/geom/MultiPolygon.js":"b4GDd","ol/geom/MultiLineString":"4FjXg","ol/geom/LinearRing.js":"gT85H","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"avK2A":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BufferOp", ()=>(0, _bufferOpJsDefault.default));
parcelHelpers.export(exports, "BufferParameters", ()=>(0, _bufferParametersJsDefault.default));
var _bufferOpJs = require("./buffer/BufferOp.js");
var _bufferOpJsDefault = parcelHelpers.interopDefault(_bufferOpJs);
var _bufferParametersJs = require("./buffer/BufferParameters.js");
var _bufferParametersJsDefault = parcelHelpers.interopDefault(_bufferParametersJs);

},{"./buffer/BufferOp.js":"1i41m","./buffer/BufferParameters.js":"idesX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5Qkjh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "activateSelectInteraction", ()=>activateSelectInteraction);
var _conditionJs = require("ol/events/condition.js");
var _selectJs = require("ol/interaction/Select.js");
var _selectJsDefault = parcelHelpers.interopDefault(_selectJs);
var _vectorJs = require("ol/layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _rotationconstraint = require("ol/rotationconstraint");
var _vectorJs1 = require("ol/source/Vector.js");
var _vectorJsDefault1 = parcelHelpers.interopDefault(_vectorJs1);
var _fillJs = require("ol/style/Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _strokeJs = require("ol/style/Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _styleJs = require("ol/style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
function activateSelectInteraction(map) {
    const selected = new (0, _styleJsDefault.default)({
        fill: new (0, _fillJsDefault.default)({
            color: '#eeeeee'
        }),
        stroke: new (0, _strokeJsDefault.default)({
            color: 'rgba(255, 255, 255, 0.7)',
            width: 2
        })
    });
    function selectStyle(feature) {
        const color = feature.get('COLOR') || '#eeeeee';
        selected.getFill().setColor(color);
        return selected;
    }
    const selectAltClick = new (0, _selectJsDefault.default)({
        style: selectStyle,
        condition: function(event) {
            return (0, _conditionJs.click)(event) && (0, _conditionJs.altKeyOnly)(event);
        },
        toggleCondition: function(event) {
            return (0, _conditionJs.click)(event) && (0, _conditionJs.altKeyOnly)(event);
        },
        multi: true
    });
    map.addInteraction(selectAltClick);
    return {
        features: selectAltClick.getFeatures(),
        disable: ()=>{
            map.removeInteraction();
        }
    };
}

},{"ol/events/condition.js":"gm0iA","ol/interaction/Select.js":"7h3Zo","ol/layer/Vector.js":"6bOIK","ol/rotationconstraint":"6TPbY","ol/source/Vector.js":"7wT1g","ol/style/Fill.js":"cHc7U","ol/style/Stroke.js":"1uQwy","ol/style/Style.js":"8opjn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a2P7c":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Class to handle geometry operations like union, intersection, etc.
 */ parcelHelpers.export(exports, "GeometryOperations", ()=>GeometryOperations);
parcelHelpers.export(exports, "geometryOps", ()=>geometryOps);
var _ol3Parser = require("jsts/org/locationtech/jts/io/OL3Parser");
var _ol3ParserDefault = parcelHelpers.interopDefault(_ol3Parser);
var _union = require("jsts/org/locationtech/jts/operation/union");
var _ol = require("ol");
var _point = require("ol/geom/Point");
var _pointDefault = parcelHelpers.interopDefault(_point);
var _lineString = require("ol/geom/LineString");
var _lineStringDefault = parcelHelpers.interopDefault(_lineString);
var _linearRing = require("ol/geom/LinearRing");
var _linearRingDefault = parcelHelpers.interopDefault(_linearRing);
var _polygon = require("ol/geom/Polygon");
var _polygonDefault = parcelHelpers.interopDefault(_polygon);
var _multiPoint = require("ol/geom/MultiPoint");
var _multiPointDefault = parcelHelpers.interopDefault(_multiPoint);
var _multiLineString = require("ol/geom/MultiLineString");
var _multiLineStringDefault = parcelHelpers.interopDefault(_multiLineString);
var _multiPolygon = require("ol/geom/MultiPolygon");
var _multiPolygonDefault = parcelHelpers.interopDefault(_multiPolygon);
var _geometryCollection = require("ol/geom/GeometryCollection");
var _geometryCollectionDefault = parcelHelpers.interopDefault(_geometryCollection);
var _popupMessageJs = require("./popup-message.js"); // Using your existing popup message utility
class GeometryOperations {
    constructor(){
        // Initialize JSTS parser
        this.parser = new (0, _ol3ParserDefault.default)();
        // Inject OpenLayers geometry classes
        this.parser.inject((0, _pointDefault.default), (0, _lineStringDefault.default), (0, _linearRingDefault.default), (0, _polygonDefault.default), (0, _multiPointDefault.default), (0, _multiLineStringDefault.default), (0, _multiPolygonDefault.default), (0, _geometryCollectionDefault.default));
        console.log("GeometryOperations initialized with parser:", this.parser);
    }
    /**
   * Creates a union of multiple features
   * @param {Array<Feature>} features - Array of OpenLayers features
   * @returns {Feature|null} - The union result as an OpenLayers feature, or null if operation fails
   */ unionFeatures(features) {
        console.log("unionFeatures called with:", features);
        if (!features || features.length === 0) {
            (0, _popupMessageJs.showPopupMessage)("No features selected for union", "warning");
            return null;
        }
        if (features.length === 1) {
            (0, _popupMessageJs.showPopupMessage)("Only one feature selected, no union needed", "info");
            return features[0].clone();
        }
        try {
            // Check if all features have valid geometries
            const validFeatures = features.filter((f)=>f.getGeometry() !== null && !f.getGeometry().isEmpty());
            if (validFeatures.length !== features.length) {
                console.warn("Some features have invalid geometries:", features.filter((f)=>f.getGeometry() === null || f.getGeometry().isEmpty()));
                (0, _popupMessageJs.showPopupMessage)("Some features have invalid geometries", "warning");
            }
            if (validFeatures.length < 2) {
                (0, _popupMessageJs.showPopupMessage)("Not enough valid features for union", "warning");
                return null;
            }
            console.log("Valid features for union:", validFeatures);
            // Convert all OL geometries to JSTS geometries
            const jstsGeoms = [];
            for (const feature of validFeatures)try {
                const jstsGeom = this.parser.read(feature.getGeometry());
                console.log("Converted geometry:", jstsGeom);
                jstsGeoms.push(jstsGeom);
            } catch (error) {
                console.error("Error converting geometry:", error, feature.getGeometry());
            }
            if (jstsGeoms.length < 2) {
                (0, _popupMessageJs.showPopupMessage)("Failed to convert geometries for union", "error");
                return null;
            }
            // Perform the union operation using UnaryUnionOp
            console.log("Performing union with geometries:", jstsGeoms);
            const unionGeom = (0, _union.UnaryUnionOp).union(jstsGeoms);
            console.log("Union result:", unionGeom);
            if (!unionGeom) {
                (0, _popupMessageJs.showPopupMessage)("Union operation returned null", "error");
                return null;
            }
            // Convert back to OL geometry
            const olGeometry = this.parser.write(unionGeom);
            console.log("Converted back to OL geometry:", olGeometry);
            if (!olGeometry) {
                (0, _popupMessageJs.showPopupMessage)("Failed to convert union result back to OpenLayers", "error");
                return null;
            }
            // Create a new feature with the union geometry
            const unionFeature = new (0, _ol.Feature)({
                geometry: olGeometry
            });
            // Copy properties from the first feature (optional)
            const properties = validFeatures[0].getProperties();
            delete properties.geometry; // Remove geometry property
            unionFeature.setProperties(properties);
            (0, _popupMessageJs.showPopupMessage)("Union operation completed successfully", "success");
            return unionFeature;
        } catch (error) {
            console.error("Error performing union:", error);
            (0, _popupMessageJs.showPopupMessage)("Failed to create union: " + error.message, "error");
            return null;
        }
    }
}
const geometryOps = new GeometryOperations();

},{"jsts/org/locationtech/jts/io/OL3Parser":"1NdLK","jsts/org/locationtech/jts/operation/union":"b4ekL","ol":"7JF0u","ol/geom/Point":"6SybV","ol/geom/LineString":"gknRz","ol/geom/LinearRing":"gT85H","ol/geom/Polygon":"8Vwps","ol/geom/MultiPoint":"gXgmP","ol/geom/MultiLineString":"4FjXg","ol/geom/MultiPolygon":"b4GDd","ol/geom/GeometryCollection":"6lIhA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT","./popup-message.js":"98E40"}],"bMpAD":[function(require,module,exports,__globalThis) {
/**
 * Shows a popup message to the user
 * @param {string} message - The message to display
 * @param {string} type - The type of message (success, error, warning, info)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showPopupMessage", ()=>showPopupMessage);
function showPopupMessage(message, type = "info") {
    // Check if message container exists, create if not
    let messageContainer = document.getElementById("message-container");
    if (!messageContainer) {
        messageContainer = document.createElement("div");
        messageContainer.id = "message-container";
        messageContainer.style.position = "fixed";
        messageContainer.style.top = "20px";
        messageContainer.style.right = "20px";
        messageContainer.style.zIndex = "1000";
        document.body.appendChild(messageContainer);
    }
    // Create message element
    const messageElement = document.createElement("div");
    messageElement.className = `message ${type}`;
    messageElement.innerHTML = `
    <div class="message-content">
      <span class="message-text">${message}</span>
      <button class="close-btn">&times;</button>
    </div>
  `;
    // Style the message
    messageElement.style.padding = "10px 15px";
    messageElement.style.marginBottom = "10px";
    messageElement.style.borderRadius = "4px";
    messageElement.style.boxShadow = "0 2px 5px rgba(0,0,0,0.2)";
    messageElement.style.display = "flex";
    messageElement.style.justifyContent = "space-between";
    messageElement.style.alignItems = "center";
    // Set color based on type
    switch(type){
        case "success":
            messageElement.style.backgroundColor = "#d4edda";
            messageElement.style.color = "#155724";
            messageElement.style.borderLeft = "4px solid #28a745";
            break;
        case "error":
            messageElement.style.backgroundColor = "#f8d7da";
            messageElement.style.color = "#721c24";
            messageElement.style.borderLeft = "4px solid #dc3545";
            break;
        case "warning":
            messageElement.style.backgroundColor = "#fff3cd";
            messageElement.style.color = "#856404";
            messageElement.style.borderLeft = "4px solid #ffc107";
            break;
        default:
            messageElement.style.backgroundColor = "#d1ecf1";
            messageElement.style.color = "#0c5460";
            messageElement.style.borderLeft = "4px solid #17a2b8";
    }
    // Add close button functionality
    const closeBtn = messageElement.querySelector(".close-btn");
    closeBtn.style.background = "none";
    closeBtn.style.border = "none";
    closeBtn.style.cursor = "pointer";
    closeBtn.style.fontSize = "20px";
    closeBtn.style.marginLeft = "10px";
    closeBtn.addEventListener("click", ()=>{
        messageContainer.removeChild(messageElement);
    });
    // Add to container
    messageContainer.appendChild(messageElement);
    // Auto-remove after 5 seconds
    setTimeout(()=>{
        if (messageElement.parentNode === messageContainer) messageContainer.removeChild(messageElement);
    }, 5000);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5IIWm":[function(require,module,exports,__globalThis) {
module.exports = import("./union-tool.f7f7811a.js").then(()=>module.bundle.root('aZqpL'));

},{"aZqpL":"aZqpL"}]},["93v64","lhpGb"], "lhpGb", "parcelRequired761", {})

//# sourceMappingURL=WebGISTrainingCodeV1.b828852a.js.map
