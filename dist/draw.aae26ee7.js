// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  externals,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        if (externals[name]) {
          return externals[name];
        }
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  // INSERT_LOAD_HERE

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"2yM6G":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "d8429c73aae26ee7";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            // Ignore cloudflare workers error.
            if (err.message && !err.message.includes('Disallowed operation called within global scope')) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"hLwk3":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/SimpleGeometry
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {number} stride Stride.
 * @return {import("./Geometry.js").GeometryLayout} layout Layout.
 */ parcelHelpers.export(exports, "getLayoutForStride", ()=>getLayoutForStride);
/**
 * @param {import("./Geometry.js").GeometryLayout} layout Layout.
 * @return {number} Stride.
 */ parcelHelpers.export(exports, "getStrideForLayout", ()=>getStrideForLayout);
/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */ parcelHelpers.export(exports, "transformGeom2D", ()=>transformGeom2D);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _utilJs = require("../util.js");
var _extentJs = require("../extent.js");
var _transformJs = require("./flat/transform.js");
/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */ class SimpleGeometry extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        /**
     * @protected
     * @type {import("./Geometry.js").GeometryLayout}
     */ this.layout = 'XY';
        /**
     * @protected
     * @type {number}
     */ this.stride = 2;
        /**
     * @protected
     * @type {Array<number>}
     */ this.flatCoordinates;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        return (0, _extentJs.createOrUpdateFromFlatCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    }
    /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */ getCoordinates() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */ getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
    }
    /**
   * @return {Array<number>} Flat coordinates.
   */ getFlatCoordinates() {
        return this.flatCoordinates;
    }
    /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */ getLastCoordinate() {
        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
    }
    /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */ getLayout() {
        return this.layout;
    }
    /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */ getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
            this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            this.simplifiedGeometryRevision = this.getRevision();
        }
        // If squaredTolerance is negative or if we know that simplification will not
        // have any effect then just return this.
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) return this;
        const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) return simplifiedGeometry;
        // Simplification did not actually remove any coordinates.  We now know
        // that any calls to getSimplifiedGeometry with a squaredTolerance less
        // than or equal to the current squaredTolerance will also not have any
        // effect.  This allows us to short circuit simplification (saving CPU
        // cycles) and prevents the cache of simplified geometries from filling
        // up with useless identical copies of this geometry (saving memory).
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        return this;
    }
    /**
   * @return {number} Stride.
   */ getStride() {
        return this.stride;
    }
    /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */ setFlatCoordinates(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
    }
    /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ setCoordinates(coordinates, layout) {
        (0, _utilJs.abstract)();
    }
    /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */ setLayout(layout, coordinates, nesting) {
        let stride;
        if (layout) stride = getStrideForLayout(layout);
        else {
            for(let i = 0; i < nesting; ++i){
                if (coordinates.length === 0) {
                    this.layout = 'XY';
                    this.stride = 2;
                    return;
                }
                coordinates = /** @type {Array<unknown>} */ coordinates[0];
            }
            stride = coordinates.length;
            layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */ applyTransform(transformFn) {
        if (this.flatCoordinates) {
            transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
            this.changed();
        }
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            const stride = this.getStride();
            (0, _transformJs.rotate)(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
            this.changed();
        }
    }
    /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */ scale(sx, sy, anchor) {
        if (sy === undefined) sy = sx;
        if (!anchor) anchor = (0, _extentJs.getCenter)(this.getExtent());
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            const stride = this.getStride();
            (0, _transformJs.scale)(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
            this.changed();
        }
    }
    /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */ translate(deltaX, deltaY) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            const stride = this.getStride();
            (0, _transformJs.translate)(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
            this.changed();
        }
    }
}
function getLayoutForStride(stride) {
    let layout;
    if (stride == 2) layout = 'XY';
    else if (stride == 3) layout = 'XYZ';
    else if (stride == 4) layout = 'XYZM';
    return /** @type {import("./Geometry.js").GeometryLayout} */ layout;
}
function getStrideForLayout(layout) {
    let stride;
    if (layout == 'XY') stride = 2;
    else if (layout == 'XYZ' || layout == 'XYM') stride = 3;
    else if (layout == 'XYZM') stride = 4;
    return /** @type {number} */ stride;
}
function transformGeom2D(simpleGeometry, transform, dest) {
    const flatCoordinates = simpleGeometry.getFlatCoordinates();
    if (!flatCoordinates) return null;
    const stride = simpleGeometry.getStride();
    return (0, _transformJs.transform2D)(flatCoordinates, 0, flatCoordinates.length, stride, transform, dest);
}
exports.default = SimpleGeometry;

},{"./Geometry.js":"4ya62","../util.js":"pLBjQ","../extent.js":"6YrVc","./flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ya62":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/Geometry
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _utilJs = require("../util.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _functionsJs = require("../functions.js");
var _transformJs1 = require("./flat/transform.js");
/**
 * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available.
 */ /**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, or `'Circle'`.
 */ /**
 * @type {import("../transform.js").Transform}
 */ const tmpTransform = (0, _transformJs.create)();
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */ class Geometry extends (0, _objectJsDefault.default) {
    constructor(){
        super();
        /**
     * @private
     * @type {import("../extent.js").Extent}
     */ this.extent_ = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {number}
     */ this.extentRevision_ = -1;
        /**
     * @protected
     * @type {number}
     */ this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        /**
     * @protected
     * @type {number}
     */ this.simplifiedGeometryRevision = 0;
        /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */ this.simplifyTransformedInternal = (0, _functionsJs.memoizeOne)((revision, squaredTolerance, transform)=>{
            if (!transform) return this.getSimplifiedGeometry(squaredTolerance);
            const clone = this.clone();
            clone.applyTransform(transform);
            return clone.getSimplifiedGeometry(squaredTolerance);
        });
    }
    /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */ simplifyTransformed(squaredTolerance, transform) {
        return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, transform);
    }
    /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */ clone() {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        const coord = this.getClosestPoint([
            x,
            y
        ]);
        return coord[0] === x && coord[1] === y;
    }
    /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */ getClosestPoint(point, closestPoint) {
        closestPoint = closestPoint ? closestPoint : [
            NaN,
            NaN
        ];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
    }
    /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */ intersectsCoordinate(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
    }
    /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */ getExtent(extent) {
        if (this.extentRevision_ != this.getRevision()) {
            const extent = this.computeExtent(this.extent_);
            if (isNaN(extent[0]) || isNaN(extent[1])) (0, _extentJs.createOrUpdateEmpty)(extent);
            this.extentRevision_ = this.getRevision();
        }
        return (0, _extentJs.returnOrUpdate)(this.extent_, extent);
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        (0, _utilJs.abstract)();
    }
    /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */ scale(sx, sy, anchor) {
        (0, _utilJs.abstract)();
    }
    /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */ simplify(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
    }
    /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */ getSimplifiedGeometry(squaredTolerance) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */ getType() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */ applyTransform(transformFn) {
        (0, _utilJs.abstract)();
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */ intersectsExtent(extent) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */ translate(deltaX, deltaY) {
        (0, _utilJs.abstract)();
    }
    /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */ transform(source, destination) {
        /** @type {import("../proj/Projection.js").default} */ const sourceProj = (0, _projJs.get)(source);
        const transformFn = sourceProj.getUnits() == 'tile-pixels' ? function(inCoordinates, outCoordinates, stride) {
            const pixelExtent = sourceProj.getExtent();
            const projectedExtent = sourceProj.getWorldExtent();
            const scale = (0, _extentJs.getHeight)(projectedExtent) / (0, _extentJs.getHeight)(pixelExtent);
            (0, _transformJs.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
            (0, _transformJs1.transform2D)(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
            return (0, _projJs.getTransform)(sourceProj, destination)(inCoordinates, outCoordinates, stride);
        } : (0, _projJs.getTransform)(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
    }
}
exports.default = Geometry;

},{"../Object.js":"1zG8z","../util.js":"pLBjQ","../transform.js":"1BqUf","../extent.js":"6YrVc","../proj.js":"SznqC","../functions.js":"iqv8I","./flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1zG8z":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Object
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */ parcelHelpers.export(exports, "ObjectEvent", ()=>ObjectEvent);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _objectEventTypeJs = require("./ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _observableJs = require("./Observable.js");
var _observableJsDefault = parcelHelpers.interopDefault(_observableJs);
var _utilJs = require("./util.js");
var _objJs = require("./obj.js");
class ObjectEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */ constructor(type, key, oldValue){
        super(type);
        /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */ this.key = key;
        /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */ this.oldValue = oldValue;
    }
}
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */ class BaseObject extends (0, _observableJsDefault.default) {
    /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */ constructor(values){
        super();
        /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {ObjectOnSignature<void>}
     */ this.un;
        // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
        // the same as the order in which they were created.  This also helps to
        // ensure that object properties are always added in the same order, which
        // helps many JavaScript engines generate faster code.
        (0, _utilJs.getUid)(this);
        /**
     * @private
     * @type {Object<string, *>|null}
     */ this.values_ = null;
        if (values !== undefined) this.setProperties(values);
    }
    /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */ get(key) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key)) value = this.values_[key];
        return value;
    }
    /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */ getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
    }
    /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */ getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
    }
    /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */ getPropertiesInternal() {
        return this.values_;
    }
    /**
   * @return {boolean} The object has properties.
   */ hasProperties() {
        return !!this.values_;
    }
    /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */ notify(key, oldValue) {
        let eventType;
        eventType = `change:${key}`;
        if (this.hasListener(eventType)) this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        eventType = (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE;
        if (this.hasListener(eventType)) this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */ addChangeListener(key, listener) {
        this.addEventListener(`change:${key}`, listener);
    }
    /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */ removeChangeListener(key, listener) {
        this.removeEventListener(`change:${key}`, listener);
    }
    /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */ set(key, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) values[key] = value;
        else {
            const oldValue = values[key];
            values[key] = value;
            if (oldValue !== value) this.notify(key, oldValue);
        }
    }
    /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */ setProperties(values, silent) {
        for(const key in values)this.set(key, values[key], silent);
    }
    /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */ applyProperties(source) {
        if (!source.values_) return;
        Object.assign(this.values_ || (this.values_ = {}), source.values_);
    }
    /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */ unset(key, silent) {
        if (this.values_ && key in this.values_) {
            const oldValue = this.values_[key];
            delete this.values_[key];
            if ((0, _objJs.isEmpty)(this.values_)) this.values_ = null;
            if (!silent) this.notify(key, oldValue);
        }
    }
}
exports.default = BaseObject;

},{"./events/Event.js":"hwXQP","./ObjectEventType.js":"f2U6i","./Observable.js":"cQ2uI","./util.js":"pLBjQ","./obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwXQP":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/Event
 */ /**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Event|import("./Event.js").default} evt Event
 */ parcelHelpers.export(exports, "stopPropagation", ()=>stopPropagation);
/**
 * @param {Event|import("./Event.js").default} evt Event
 */ parcelHelpers.export(exports, "preventDefault", ()=>preventDefault);
class BaseEvent {
    /**
   * @param {string} type Type.
   */ constructor(type){
        /**
     * @type {boolean}
     */ this.propagationStopped;
        /**
     * @type {boolean}
     */ this.defaultPrevented;
        /**
     * The event type.
     * @type {string}
     * @api
     */ this.type = type;
        /**
     * The event target.
     * @type {Object}
     * @api
     */ this.target = null;
    }
    /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */ preventDefault() {
        this.defaultPrevented = true;
    }
    /**
   * Stop event propagation.
   * @api
   */ stopPropagation() {
        this.propagationStopped = true;
    }
}
function stopPropagation(evt) {
    evt.stopPropagation();
}
function preventDefault(evt) {
    evt.preventDefault();
}
exports.default = BaseEvent;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"f2U6i":[function(require,module,exports,__globalThis) {
/**
 * @module ol/ObjectEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */ PROPERTYCHANGE: 'propertychange'
}; /**
 * @typedef {'propertychange'} Types
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cQ2uI":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Observable
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */ parcelHelpers.export(exports, "unByKey", ()=>unByKey);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _eventsJs = require("./events.js");
/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */ /***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */ /**
 * @typedef {'change'|'error'} EventTypes
 */ /***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */ class Observable extends (0, _targetJsDefault.default) {
    constructor(){
        super();
        this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */ this.onInternal;
        this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */ this.onceInternal;
        this.un = /** @type {ObservableOnSignature<void>} */ this.unInternal;
        /**
     * @private
     * @type {number}
     */ this.revision_ = 0;
    }
    /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */ changed() {
        ++this.revision_;
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */ getRevision() {
        return this.revision_;
    }
    /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */ onInternal(type, listener) {
        if (Array.isArray(type)) {
            const len = type.length;
            const keys = new Array(len);
            for(let i = 0; i < len; ++i)keys[i] = (0, _eventsJs.listen)(this, type[i], listener);
            return keys;
        }
        return (0, _eventsJs.listen)(this, /** @type {string} */ type, listener);
    }
    /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */ onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
            const len = type.length;
            key = new Array(len);
            for(let i = 0; i < len; ++i)key[i] = (0, _eventsJs.listenOnce)(this, type[i], listener);
        } else key = (0, _eventsJs.listenOnce)(this, /** @type {string} */ type, listener);
        /** @type {Object} */ listener.ol_key = key;
        return key;
    }
    /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */ unInternal(type, listener) {
        const key = /** @type {Object} */ listener.ol_key;
        if (key) unByKey(key);
        else if (Array.isArray(type)) for(let i = 0, ii = type.length; i < ii; ++i)this.removeEventListener(type[i], listener);
        else this.removeEventListener(type, listener);
    }
}
/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */ Observable.prototype.on;
/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */ Observable.prototype.once;
/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */ Observable.prototype.un;
function unByKey(key) {
    if (Array.isArray(key)) for(let i = 0, ii = key.length; i < ii; ++i)(0, _eventsJs.unlistenByKey)(key[i]);
    else (0, _eventsJs.unlistenByKey)(/** @type {import("./events.js").EventsKey} */ key);
}
exports.default = Observable;

},{"./events/Target.js":"7T5Yi","./events/EventType.js":"hrQJ6","./events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7T5Yi":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/Target
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _eventJs = require("./Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _functionsJs = require("../functions.js");
var _objJs = require("../obj.js");
/**
 * @typedef {EventTarget|Target} EventTargetLike
 */ /**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */ class Target extends (0, _disposableJsDefault.default) {
    /**
   * @param {*} [target] Default event target for dispatched events.
   */ constructor(target){
        super();
        /**
     * @private
     * @type {*}
     */ this.eventTarget_ = target;
        /**
     * @private
     * @type {Object<string, number>|null}
     */ this.pendingRemovals_ = null;
        /**
     * @private
     * @type {Object<string, number>|null}
     */ this.dispatching_ = null;
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>|null}
     */ this.listeners_ = null;
    }
    /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */ addEventListener(type, listener) {
        if (!type || !listener) return;
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) listenersForType.push(listener);
    }
    /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */ dispatchEvent(event) {
        const isString = typeof event === 'string';
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) return;
        const evt = isString ? new (0, _eventJsDefault.default)(event) : /** @type {Event} */ event;
        if (!evt.target) evt.target = this.eventTarget_ || this;
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
            dispatching[type] = 0;
            pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for(let i = 0, ii = listeners.length; i < ii; ++i){
            if ('handleEvent' in listeners[i]) propagate = /** @type {import("../events.js").ListenerObject} */ listeners[i].handleEvent(evt);
            else propagate = /** @type {import("../events.js").ListenerFunction} */ listeners[i].call(this, evt);
            if (propagate === false || evt.propagationStopped) {
                propagate = false;
                break;
            }
        }
        if (--dispatching[type] === 0) {
            let pr = pendingRemovals[type];
            delete pendingRemovals[type];
            while(pr--)this.removeEventListener(type, (0, _functionsJs.VOID));
            delete dispatching[type];
        }
        return propagate;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        this.listeners_ && (0, _objJs.clear)(this.listeners_);
    }
    /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */ getListeners(type) {
        return this.listeners_ && this.listeners_[type] || undefined;
    }
    /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */ hasListener(type) {
        if (!this.listeners_) return false;
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
    }
    /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */ removeEventListener(type, listener) {
        if (!this.listeners_) return;
        const listeners = this.listeners_[type];
        if (!listeners) return;
        const index = listeners.indexOf(listener);
        if (index !== -1) {
            if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                // make listener a no-op, and remove later in #dispatchEvent()
                listeners[index] = (0, _functionsJs.VOID);
                ++this.pendingRemovals_[type];
            } else {
                listeners.splice(index, 1);
                if (listeners.length === 0) delete this.listeners_[type];
            }
        }
    }
}
exports.default = Target;

},{"../Disposable.js":"c0oTM","./Event.js":"hwXQP","../functions.js":"iqv8I","../obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c0oTM":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Disposable
 */ /**
 * @classdesc
 * Objects that need to clean up after themselves.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Disposable {
    constructor(){
        /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */ this.disposed = false;
    }
    /**
   * Clean up.
   */ dispose() {
        if (!this.disposed) {
            this.disposed = true;
            this.disposeInternal();
        }
    }
    /**
   * Extension point for disposable objects.
   * @protected
   */ disposeInternal() {}
}
exports.default = Disposable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iqv8I":[function(require,module,exports,__globalThis) {
/**
 * @module ol/functions
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Always returns true.
 * @return {boolean} true.
 */ parcelHelpers.export(exports, "TRUE", ()=>TRUE);
/**
 * Always returns false.
 * @return {boolean} false.
 */ parcelHelpers.export(exports, "FALSE", ()=>FALSE);
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */ parcelHelpers.export(exports, "VOID", ()=>VOID);
/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */ parcelHelpers.export(exports, "memoizeOne", ()=>memoizeOne);
/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */ parcelHelpers.export(exports, "toPromise", ()=>toPromise);
var _arrayJs = require("./array.js");
function TRUE() {
    return true;
}
function FALSE() {
    return false;
}
function VOID() {}
function memoizeOne(fn) {
    let called = false;
    /** @type {ReturnType} */ let lastResult;
    /** @type {Array<any>} */ let lastArgs;
    let lastThis;
    return function() {
        const nextArgs = Array.prototype.slice.call(arguments);
        if (!called || this !== lastThis || !(0, _arrayJs.equals)(nextArgs, lastArgs)) {
            called = true;
            lastThis = this;
            lastArgs = nextArgs;
            lastResult = fn.apply(this, arguments);
        }
        return lastResult;
    };
}
function toPromise(getter) {
    function promiseGetter() {
        let value;
        try {
            value = getter();
        } catch (err) {
            return Promise.reject(err);
        }
        if (value instanceof Promise) return value;
        return Promise.resolve(value);
    }
    return promiseGetter();
}

},{"./array.js":"1Fbic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Fbic":[function(require,module,exports,__globalThis) {
/**
 * @module ol/array
 */ /**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "binarySearch", ()=>binarySearch);
/**
 * Compare function sorting arrays in ascending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */ parcelHelpers.export(exports, "ascending", ()=>ascending);
/**
 * Compare function sorting arrays in descending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is greater than, equal to, or less than the second.
 */ parcelHelpers.export(exports, "descending", ()=>descending);
/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */ /**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */ parcelHelpers.export(exports, "linearFindNearest", ()=>linearFindNearest);
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */ parcelHelpers.export(exports, "reverseSubArray", ()=>reverseSubArray);
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */ parcelHelpers.export(exports, "extend", ()=>extend);
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */ parcelHelpers.export(exports, "remove", ()=>remove);
/**
 * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */ parcelHelpers.export(exports, "equals", ()=>equals);
/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */ parcelHelpers.export(exports, "stableSort", ()=>stableSort);
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [func] Comparison function.
 * @param {boolean} [strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */ parcelHelpers.export(exports, "isSorted", ()=>isSorted);
function binarySearch(haystack, needle, comparator) {
    let mid, cmp;
    comparator = comparator || ascending;
    let low = 0;
    let high = haystack.length;
    let found = false;
    while(low < high){
        /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */ mid = low + (high - low >> 1);
        cmp = +comparator(haystack[mid], needle);
        if (cmp < 0.0) /* Too low. */ low = mid + 1;
        else {
            /* Key found or too high */ high = mid;
            found = !cmp;
        }
    }
    /* Key not found. */ return found ? low : ~low;
}
function ascending(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
}
function descending(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
    if (arr[0] <= target) return 0;
    const n = arr.length;
    if (target <= arr[n - 1]) return n - 1;
    if (typeof direction === 'function') {
        for(let i = 1; i < n; ++i){
            const candidate = arr[i];
            if (candidate === target) return i;
            if (candidate < target) {
                if (direction(target, arr[i - 1], candidate) > 0) return i - 1;
                return i;
            }
        }
        return n - 1;
    }
    if (direction > 0) {
        for(let i = 1; i < n; ++i){
            if (arr[i] < target) return i - 1;
        }
        return n - 1;
    }
    if (direction < 0) {
        for(let i = 1; i < n; ++i){
            if (arr[i] <= target) return i;
        }
        return n - 1;
    }
    for(let i = 1; i < n; ++i){
        if (arr[i] == target) return i;
        if (arr[i] < target) {
            if (arr[i - 1] - target < target - arr[i]) return i - 1;
            return i;
        }
    }
    return n - 1;
}
function reverseSubArray(arr, begin, end) {
    while(begin < end){
        const tmp = arr[begin];
        arr[begin] = arr[end];
        arr[end] = tmp;
        ++begin;
        --end;
    }
}
function extend(arr, data) {
    const extension = Array.isArray(data) ? data : [
        data
    ];
    const length = extension.length;
    for(let i = 0; i < length; i++)arr[arr.length] = extension[i];
}
function remove(arr, obj) {
    const i = arr.indexOf(obj);
    const found = i > -1;
    if (found) arr.splice(i, 1);
    return found;
}
function equals(arr1, arr2) {
    const len1 = arr1.length;
    if (len1 !== arr2.length) return false;
    for(let i = 0; i < len1; i++){
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}
function stableSort(arr, compareFnc) {
    const length = arr.length;
    const tmp = Array(arr.length);
    let i;
    for(i = 0; i < length; i++)tmp[i] = {
        index: i,
        value: arr[i]
    };
    tmp.sort(function(a, b) {
        return compareFnc(a.value, b.value) || a.index - b.index;
    });
    for(i = 0; i < arr.length; i++)arr[i] = tmp[i].value;
}
function isSorted(arr, func, strict) {
    const compare = func || ascending;
    return arr.every(function(currentVal, index) {
        if (index === 0) return true;
        const res = compare(arr[index - 1], currentVal);
        return !(res > 0 || strict && res === 0);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ssAG":[function(require,module,exports,__globalThis) {
/**
 * @module ol/obj
 */ /**
 * Removes all properties from an object.
 * @param {Object<string, unknown>} object The object to clear.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clear", ()=>clear);
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */ parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
function clear(object) {
    for(const property in object)delete object[property];
}
function isEmpty(object) {
    let property;
    for(property in object)return false;
    return !property;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hrQJ6":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/EventType
 */ /**
 * @enum {string}
 * @const
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */ CHANGE: 'change',
    /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */ ERROR: 'error',
    BLUR: 'blur',
    CLEAR: 'clear',
    CONTEXTMENU: 'contextmenu',
    CLICK: 'click',
    DBLCLICK: 'dblclick',
    DRAGENTER: 'dragenter',
    DRAGOVER: 'dragover',
    DROP: 'drop',
    FOCUS: 'focus',
    KEYDOWN: 'keydown',
    KEYPRESS: 'keypress',
    LOAD: 'load',
    RESIZE: 'resize',
    TOUCHMOVE: 'touchmove',
    WHEEL: 'wheel'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dcspA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Key to use with {@link module:ol/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */ /**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */ /**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */ /**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */ /**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */ parcelHelpers.export(exports, "listen", ()=>listen);
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */ parcelHelpers.export(exports, "listenOnce", ()=>listenOnce);
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */ parcelHelpers.export(exports, "unlistenByKey", ()=>unlistenByKey);
var _objJs = require("./obj.js");
function listen(target, type, listener, thisArg, once) {
    if (thisArg && thisArg !== target) listener = listener.bind(thisArg);
    if (once) {
        const originalListener = listener;
        listener = function() {
            target.removeEventListener(type, listener);
            originalListener.apply(this, arguments);
        };
    }
    const eventsKey = {
        target: target,
        type: type,
        listener: listener
    };
    target.addEventListener(type, listener);
    return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
    return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
    if (key && key.target) {
        key.target.removeEventListener(key.type, key.listener);
        (0, _objJs.clear)(key);
    }
}

},{"./obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"pLBjQ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/util
 */ /**
 * @return {never} Any return.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "abstract", ()=>abstract);
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */ parcelHelpers.export(exports, "getUid", ()=>getUid);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
function abstract() {
    throw new Error('Unimplemented abstract method.');
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */ let uidCounter_ = 0;
function getUid(obj) {
    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
const VERSION = '8.2.0';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1BqUf":[function(require,module,exports,__globalThis) {
/**
 * @module ol/transform
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */ parcelHelpers.export(exports, "create", ()=>create);
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */ parcelHelpers.export(exports, "reset", ()=>reset);
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */ parcelHelpers.export(exports, "multiply", ()=>multiply);
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */ parcelHelpers.export(exports, "set", ()=>set);
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */ parcelHelpers.export(exports, "setFromArray", ()=>setFromArray);
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */ parcelHelpers.export(exports, "apply", ()=>apply);
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */ parcelHelpers.export(exports, "makeScale", ()=>makeScale);
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */ parcelHelpers.export(exports, "translate", ()=>translate);
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */ parcelHelpers.export(exports, "compose", ()=>compose);
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */ parcelHelpers.export(exports, "composeCssTransform", ()=>composeCssTransform);
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */ parcelHelpers.export(exports, "invert", ()=>invert);
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */ parcelHelpers.export(exports, "makeInverse", ()=>makeInverse);
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */ parcelHelpers.export(exports, "determinant", ()=>determinant);
/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */ parcelHelpers.export(exports, "toString", ()=>toString);
var _hasJs = require("./has.js");
var _assertsJs = require("./asserts.js");
/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */ /**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */ /**
 * @private
 * @type {Transform}
 */ const tmp_ = new Array(6);
function create() {
    return [
        1,
        0,
        0,
        1,
        0,
        0
    ];
}
function reset(transform) {
    return set(transform, 1, 0, 0, 1, 0, 0);
}
function multiply(transform1, transform2) {
    const a1 = transform1[0];
    const b1 = transform1[1];
    const c1 = transform1[2];
    const d1 = transform1[3];
    const e1 = transform1[4];
    const f1 = transform1[5];
    const a2 = transform2[0];
    const b2 = transform2[1];
    const c2 = transform2[2];
    const d2 = transform2[3];
    const e2 = transform2[4];
    const f2 = transform2[5];
    transform1[0] = a1 * a2 + c1 * b2;
    transform1[1] = b1 * a2 + d1 * b2;
    transform1[2] = a1 * c2 + c1 * d2;
    transform1[3] = b1 * c2 + d1 * d2;
    transform1[4] = a1 * e2 + c1 * f2 + e1;
    transform1[5] = b1 * e2 + d1 * f2 + f1;
    return transform1;
}
function set(transform, a, b, c, d, e, f) {
    transform[0] = a;
    transform[1] = b;
    transform[2] = c;
    transform[3] = d;
    transform[4] = e;
    transform[5] = f;
    return transform;
}
function setFromArray(transform1, transform2) {
    transform1[0] = transform2[0];
    transform1[1] = transform2[1];
    transform1[2] = transform2[2];
    transform1[3] = transform2[3];
    transform1[4] = transform2[4];
    transform1[5] = transform2[5];
    return transform1;
}
function apply(transform, coordinate) {
    const x = coordinate[0];
    const y = coordinate[1];
    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
    return coordinate;
}
function rotate(transform, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
function scale(transform, x, y) {
    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
function makeScale(target, x, y) {
    return set(target, x, 0, 0, y, 0, 0);
}
function translate(transform, dx, dy) {
    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    transform[0] = sx * cos;
    transform[1] = sy * sin;
    transform[2] = -sx * sin;
    transform[3] = sy * cos;
    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
    return transform;
}
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
function invert(source) {
    return makeInverse(source, source);
}
function makeInverse(target, source) {
    const det = determinant(source);
    (0, _assertsJs.assert)(det !== 0, 'Transformation matrix cannot be inverted');
    const a = source[0];
    const b = source[1];
    const c = source[2];
    const d = source[3];
    const e = source[4];
    const f = source[5];
    target[0] = d / det;
    target[1] = -b / det;
    target[2] = -c / det;
    target[3] = a / det;
    target[4] = (c * f - d * e) / det;
    target[5] = -(a * f - b * e) / det;
    return target;
}
function determinant(mat) {
    return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * @type {HTMLElement}
 * @private
 */ let transformStringDiv;
function toString(mat) {
    const transformString = 'matrix(' + mat.join(', ') + ')';
    if (0, _hasJs.WORKER_OFFSCREEN_CANVAS) return transformString;
    const node = transformStringDiv || (transformStringDiv = document.createElement('div'));
    node.style.transform = transformString;
    return node.style.transform;
}

},{"./has.js":"6BDNi","./asserts.js":"e4TiF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6BDNi":[function(require,module,exports,__globalThis) {
/**
 * @module ol/has
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FIREFOX", ()=>FIREFOX);
parcelHelpers.export(exports, "SAFARI", ()=>SAFARI);
parcelHelpers.export(exports, "SAFARI_BUG_237906", ()=>SAFARI_BUG_237906);
parcelHelpers.export(exports, "WEBKIT", ()=>WEBKIT);
parcelHelpers.export(exports, "MAC", ()=>MAC);
parcelHelpers.export(exports, "DEVICE_PIXEL_RATIO", ()=>DEVICE_PIXEL_RATIO);
parcelHelpers.export(exports, "WORKER_OFFSCREEN_CANVAS", ()=>WORKER_OFFSCREEN_CANVAS);
parcelHelpers.export(exports, "IMAGE_DECODE", ()=>IMAGE_DECODE);
parcelHelpers.export(exports, "CREATE_IMAGE_BITMAP", ()=>CREATE_IMAGE_BITMAP);
parcelHelpers.export(exports, "PASSIVE_EVENT_LISTENERS", ()=>PASSIVE_EVENT_LISTENERS);
const ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
const FIREFOX = ua.includes('firefox');
const SAFARI = ua.includes('safari') && !ua.includes('chrom');
const SAFARI_BUG_237906 = SAFARI && (ua.includes('version/15.4') || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
const WEBKIT = ua.includes('webkit') && !ua.includes('edge');
const MAC = ua.includes('macintosh');
const DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
const WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' && typeof OffscreenCanvas !== 'undefined' && self instanceof WorkerGlobalScope; //eslint-disable-line
const IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
const CREATE_IMAGE_BITMAP = typeof createImageBitmap === 'function';
const PASSIVE_EVENT_LISTENERS = function() {
    let passive = false;
    try {
        const options = Object.defineProperty({}, 'passive', {
            get: function() {
                passive = true;
            }
        });
        // @ts-ignore Ignore invalid event type '_'
        window.addEventListener('_', null, options);
        // @ts-ignore Ignore invalid event type '_'
        window.removeEventListener('_', null, options);
    } catch (error) {
    // passive not supported
    }
    return passive;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e4TiF":[function(require,module,exports,__globalThis) {
/**
 * @module ol/asserts
 */ /**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {string} errorMessage Error message.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assert", ()=>assert);
function assert(assertion, errorMessage) {
    if (!assertion) throw new Error(errorMessage);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6YrVc":[function(require,module,exports,__globalThis) {
/**
 * @module ol/extent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */ /**
 * Extent corner.
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner
 */ /**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */ parcelHelpers.export(exports, "boundingExtent", ()=>boundingExtent);
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 * @api
 */ parcelHelpers.export(exports, "buffer", ()=>buffer);
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [dest] Extent.
 * @return {Extent} The clone.
 */ parcelHelpers.export(exports, "clone", ()=>clone);
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */ parcelHelpers.export(exports, "closestSquaredDistanceXY", ()=>closestSquaredDistanceXY);
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */ parcelHelpers.export(exports, "containsCoordinate", ()=>containsCoordinate);
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */ parcelHelpers.export(exports, "containsExtent", ()=>containsExtent);
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */ parcelHelpers.export(exports, "containsXY", ()=>containsXY);
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */ parcelHelpers.export(exports, "coordinateRelationship", ()=>coordinateRelationship);
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */ parcelHelpers.export(exports, "createEmpty", ()=>createEmpty);
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdate", ()=>createOrUpdate);
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateEmpty", ()=>createOrUpdateEmpty);
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromCoordinate", ()=>createOrUpdateFromCoordinate);
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromCoordinates", ()=>createOrUpdateFromCoordinates);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromFlatCoordinates", ()=>createOrUpdateFromFlatCoordinates);
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromRings", ()=>createOrUpdateFromRings);
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */ parcelHelpers.export(exports, "equals", ()=>equals);
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */ parcelHelpers.export(exports, "approximatelyEquals", ()=>approximatelyEquals);
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */ parcelHelpers.export(exports, "extend", ()=>extend);
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */ parcelHelpers.export(exports, "extendCoordinate", ()=>extendCoordinate);
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendCoordinates", ()=>extendCoordinates);
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendFlatCoordinates", ()=>extendFlatCoordinates);
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendRings", ()=>extendRings);
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */ parcelHelpers.export(exports, "extendXY", ()=>extendXY);
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */ parcelHelpers.export(exports, "forEachCorner", ()=>forEachCorner);
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */ parcelHelpers.export(exports, "getArea", ()=>getArea);
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */ parcelHelpers.export(exports, "getBottomLeft", ()=>getBottomLeft);
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */ parcelHelpers.export(exports, "getBottomRight", ()=>getBottomRight);
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */ parcelHelpers.export(exports, "getCenter", ()=>getCenter);
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */ parcelHelpers.export(exports, "getCorner", ()=>getCorner);
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */ parcelHelpers.export(exports, "getEnlargedArea", ()=>getEnlargedArea);
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "getForViewAndSize", ()=>getForViewAndSize);
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @return {Array<number>} Linear ring representing the viewport.
 */ parcelHelpers.export(exports, "getRotatedViewport", ()=>getRotatedViewport);
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */ parcelHelpers.export(exports, "getHeight", ()=>getHeight);
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */ parcelHelpers.export(exports, "getIntersectionArea", ()=>getIntersectionArea);
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [dest] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */ parcelHelpers.export(exports, "getIntersection", ()=>getIntersection);
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */ parcelHelpers.export(exports, "getMargin", ()=>getMargin);
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */ parcelHelpers.export(exports, "getSize", ()=>getSize);
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */ parcelHelpers.export(exports, "getTopLeft", ()=>getTopLeft);
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */ parcelHelpers.export(exports, "getTopRight", ()=>getTopRight);
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */ parcelHelpers.export(exports, "getWidth", ()=>getWidth);
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */ parcelHelpers.export(exports, "intersects", ()=>intersects);
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */ parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
/**
 * @param {Extent} extent Extent.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "returnOrUpdate", ()=>returnOrUpdate);
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */ parcelHelpers.export(exports, "scaleFromCenter", ()=>scaleFromCenter);
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */ parcelHelpers.export(exports, "intersectsSegment", ()=>intersectsSegment);
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [dest] Destination extent.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */ parcelHelpers.export(exports, "applyTransform", ()=>applyTransform);
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX);
/**
 * Fits the extent to the real world
 *
 * If the extent does not cross the anti meridian, this will return the extent in an array
 * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the
 * real world
 *
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Array<Extent>} The extent within the real world extent.
 */ parcelHelpers.export(exports, "wrapAndSliceX", ()=>wrapAndSliceX);
var _relationshipJs = require("./extent/Relationship.js");
var _relationshipJsDefault = parcelHelpers.interopDefault(_relationshipJs);
function boundingExtent(coordinates) {
    const extent = createEmpty();
    for(let i = 0, ii = coordinates.length; i < ii; ++i)extendCoordinate(extent, coordinates[i]);
    return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [dest] Destination extent.
 * @private
 * @return {Extent} Extent.
 */ function _boundingExtentXYs(xs, ys, dest) {
    const minX = Math.min.apply(null, xs);
    const minY = Math.min.apply(null, ys);
    const maxX = Math.max.apply(null, xs);
    const maxY = Math.max.apply(null, ys);
    return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function buffer(extent, value, dest) {
    if (dest) {
        dest[0] = extent[0] - value;
        dest[1] = extent[1] - value;
        dest[2] = extent[2] + value;
        dest[3] = extent[3] + value;
        return dest;
    }
    return [
        extent[0] - value,
        extent[1] - value,
        extent[2] + value,
        extent[3] + value
    ];
}
function clone(extent, dest) {
    if (dest) {
        dest[0] = extent[0];
        dest[1] = extent[1];
        dest[2] = extent[2];
        dest[3] = extent[3];
        return dest;
    }
    return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
    let dx, dy;
    if (x < extent[0]) dx = extent[0] - x;
    else if (extent[2] < x) dx = x - extent[2];
    else dx = 0;
    if (y < extent[1]) dy = extent[1] - y;
    else if (extent[3] < y) dy = y - extent[3];
    else dy = 0;
    return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
    return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
    return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const x = coordinate[0];
    const y = coordinate[1];
    let relationship = (0, _relationshipJsDefault.default).UNKNOWN;
    if (x < minX) relationship = relationship | (0, _relationshipJsDefault.default).LEFT;
    else if (x > maxX) relationship = relationship | (0, _relationshipJsDefault.default).RIGHT;
    if (y < minY) relationship = relationship | (0, _relationshipJsDefault.default).BELOW;
    else if (y > maxY) relationship = relationship | (0, _relationshipJsDefault.default).ABOVE;
    if (relationship === (0, _relationshipJsDefault.default).UNKNOWN) relationship = (0, _relationshipJsDefault.default).INTERSECTING;
    return relationship;
}
function createEmpty() {
    return [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
    if (dest) {
        dest[0] = minX;
        dest[1] = minY;
        dest[2] = maxX;
        dest[3] = maxY;
        return dest;
    }
    return [
        minX,
        minY,
        maxX,
        maxY
    ];
}
function createOrUpdateEmpty(dest) {
    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
    const x = coordinate[0];
    const y = coordinate[1];
    return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromCoordinates(coordinates, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendCoordinates(extent, coordinates);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function createOrUpdateFromRings(rings, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendRings(extent, rings);
}
function equals(extent1, extent2) {
    return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function approximatelyEquals(extent1, extent2, tolerance) {
    return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
function extend(extent1, extent2) {
    if (extent2[0] < extent1[0]) extent1[0] = extent2[0];
    if (extent2[2] > extent1[2]) extent1[2] = extent2[2];
    if (extent2[1] < extent1[1]) extent1[1] = extent2[1];
    if (extent2[3] > extent1[3]) extent1[3] = extent2[3];
    return extent1;
}
function extendCoordinate(extent, coordinate) {
    if (coordinate[0] < extent[0]) extent[0] = coordinate[0];
    if (coordinate[0] > extent[2]) extent[2] = coordinate[0];
    if (coordinate[1] < extent[1]) extent[1] = coordinate[1];
    if (coordinate[1] > extent[3]) extent[3] = coordinate[1];
}
function extendCoordinates(extent, coordinates) {
    for(let i = 0, ii = coordinates.length; i < ii; ++i)extendCoordinate(extent, coordinates[i]);
    return extent;
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
    for(; offset < end; offset += stride)extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
    return extent;
}
function extendRings(extent, rings) {
    for(let i = 0, ii = rings.length; i < ii; ++i)extendCoordinates(extent, rings[i]);
    return extent;
}
function extendXY(extent, x, y) {
    extent[0] = Math.min(extent[0], x);
    extent[1] = Math.min(extent[1], y);
    extent[2] = Math.max(extent[2], x);
    extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
    let val;
    val = callback(getBottomLeft(extent));
    if (val) return val;
    val = callback(getBottomRight(extent));
    if (val) return val;
    val = callback(getTopRight(extent));
    if (val) return val;
    val = callback(getTopLeft(extent));
    if (val) return val;
    return false;
}
function getArea(extent) {
    let area = 0;
    if (!isEmpty(extent)) area = getWidth(extent) * getHeight(extent);
    return area;
}
function getBottomLeft(extent) {
    return [
        extent[0],
        extent[1]
    ];
}
function getBottomRight(extent) {
    return [
        extent[2],
        extent[1]
    ];
}
function getCenter(extent) {
    return [
        (extent[0] + extent[2]) / 2,
        (extent[1] + extent[3]) / 2
    ];
}
function getCorner(extent, corner) {
    let coordinate;
    if (corner === 'bottom-left') coordinate = getBottomLeft(extent);
    else if (corner === 'bottom-right') coordinate = getBottomRight(extent);
    else if (corner === 'top-left') coordinate = getTopLeft(extent);
    else if (corner === 'top-right') coordinate = getTopRight(extent);
    else throw new Error('Invalid corner');
    return coordinate;
}
function getEnlargedArea(extent1, extent2) {
    const minX = Math.min(extent1[0], extent2[0]);
    const minY = Math.min(extent1[1], extent2[1]);
    const maxX = Math.max(extent1[2], extent2[2]);
    const maxY = Math.max(extent1[3], extent2[3]);
    return (maxX - minX) * (maxY - minY);
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
    const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(center, resolution, rotation, size);
    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), dest);
}
function getRotatedViewport(center, resolution, rotation, size) {
    const dx = resolution * size[0] / 2;
    const dy = resolution * size[1] / 2;
    const cosRotation = Math.cos(rotation);
    const sinRotation = Math.sin(rotation);
    const xCos = dx * cosRotation;
    const xSin = dx * sinRotation;
    const yCos = dy * cosRotation;
    const ySin = dy * sinRotation;
    const x = center[0];
    const y = center[1];
    return [
        x - xCos + ySin,
        y - xSin - yCos,
        x - xCos - ySin,
        y - xSin + yCos,
        x + xCos - ySin,
        y + xSin + yCos,
        x + xCos + ySin,
        y + xSin - yCos,
        x - xCos + ySin,
        y - xSin - yCos
    ];
}
function getHeight(extent) {
    return extent[3] - extent[1];
}
function getIntersectionArea(extent1, extent2) {
    const intersection = getIntersection(extent1, extent2);
    return getArea(intersection);
}
function getIntersection(extent1, extent2, dest) {
    const intersection = dest ? dest : createEmpty();
    if (intersects(extent1, extent2)) {
        if (extent1[0] > extent2[0]) intersection[0] = extent1[0];
        else intersection[0] = extent2[0];
        if (extent1[1] > extent2[1]) intersection[1] = extent1[1];
        else intersection[1] = extent2[1];
        if (extent1[2] < extent2[2]) intersection[2] = extent1[2];
        else intersection[2] = extent2[2];
        if (extent1[3] < extent2[3]) intersection[3] = extent1[3];
        else intersection[3] = extent2[3];
    } else createOrUpdateEmpty(intersection);
    return intersection;
}
function getMargin(extent) {
    return getWidth(extent) + getHeight(extent);
}
function getSize(extent) {
    return [
        extent[2] - extent[0],
        extent[3] - extent[1]
    ];
}
function getTopLeft(extent) {
    return [
        extent[0],
        extent[3]
    ];
}
function getTopRight(extent) {
    return [
        extent[2],
        extent[3]
    ];
}
function getWidth(extent) {
    return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
    return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty(extent) {
    return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
    if (dest) {
        dest[0] = extent[0];
        dest[1] = extent[1];
        dest[2] = extent[2];
        dest[3] = extent[3];
        return dest;
    }
    return extent;
}
function scaleFromCenter(extent, value) {
    const deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
    const deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
    extent[0] -= deltaX;
    extent[2] += deltaX;
    extent[1] -= deltaY;
    extent[3] += deltaY;
}
function intersectsSegment(extent, start, end) {
    let intersects = false;
    const startRel = coordinateRelationship(extent, start);
    const endRel = coordinateRelationship(extent, end);
    if (startRel === (0, _relationshipJsDefault.default).INTERSECTING || endRel === (0, _relationshipJsDefault.default).INTERSECTING) intersects = true;
    else {
        const minX = extent[0];
        const minY = extent[1];
        const maxX = extent[2];
        const maxY = extent[3];
        const startX = start[0];
        const startY = start[1];
        const endX = end[0];
        const endY = end[1];
        const slope = (endY - startY) / (endX - startX);
        let x, y;
        if (!!(endRel & (0, _relationshipJsDefault.default).ABOVE) && !(startRel & (0, _relationshipJsDefault.default).ABOVE)) {
            // potentially intersects top
            x = endX - (endY - maxY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects && !!(endRel & (0, _relationshipJsDefault.default).RIGHT) && !(startRel & (0, _relationshipJsDefault.default).RIGHT)) {
            // potentially intersects right
            y = endY - (endX - maxX) * slope;
            intersects = y >= minY && y <= maxY;
        }
        if (!intersects && !!(endRel & (0, _relationshipJsDefault.default).BELOW) && !(startRel & (0, _relationshipJsDefault.default).BELOW)) {
            // potentially intersects bottom
            x = endX - (endY - minY) / slope;
            intersects = x >= minX && x <= maxX;
        }
        if (!intersects && !!(endRel & (0, _relationshipJsDefault.default).LEFT) && !(startRel & (0, _relationshipJsDefault.default).LEFT)) {
            // potentially intersects left
            y = endY - (endX - minX) * slope;
            intersects = y >= minY && y <= maxY;
        }
    }
    return intersects;
}
function applyTransform(extent, transformFn, dest, stops) {
    if (isEmpty(extent)) return createOrUpdateEmpty(dest);
    let coordinates = [];
    if (stops > 1) {
        const width = extent[2] - extent[0];
        const height = extent[3] - extent[1];
        for(let i = 0; i < stops; ++i)coordinates.push(extent[0] + width * i / stops, extent[1], extent[2], extent[1] + height * i / stops, extent[2] - width * i / stops, extent[3], extent[0], extent[3] - height * i / stops);
    } else coordinates = [
        extent[0],
        extent[1],
        extent[2],
        extent[1],
        extent[2],
        extent[3],
        extent[0],
        extent[3]
    ];
    transformFn(coordinates, coordinates, 2);
    const xs = [];
    const ys = [];
    for(let i = 0, l = coordinates.length; i < l; i += 2){
        xs.push(coordinates[i]);
        ys.push(coordinates[i + 1]);
    }
    return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
    const projectionExtent = projection.getExtent();
    const center = getCenter(extent);
    if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
        const worldWidth = getWidth(projectionExtent);
        const worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
        const offset = worldsAway * worldWidth;
        extent[0] -= offset;
        extent[2] -= offset;
    }
    return extent;
}
function wrapAndSliceX(extent, projection) {
    if (projection.canWrapX()) {
        const projectionExtent = projection.getExtent();
        if (!isFinite(extent[0]) || !isFinite(extent[2])) return [
            [
                projectionExtent[0],
                extent[1],
                projectionExtent[2],
                extent[3]
            ]
        ];
        wrapX(extent, projection);
        const worldWidth = getWidth(projectionExtent);
        if (getWidth(extent) > worldWidth) // the extent wraps around on itself
        return [
            [
                projectionExtent[0],
                extent[1],
                projectionExtent[2],
                extent[3]
            ]
        ];
        if (extent[0] < projectionExtent[0]) // the extent crosses the anti meridian, so it needs to be sliced
        return [
            [
                extent[0] + worldWidth,
                extent[1],
                projectionExtent[2],
                extent[3]
            ],
            [
                projectionExtent[0],
                extent[1],
                extent[2],
                extent[3]
            ]
        ];
        if (extent[2] > projectionExtent[2]) // the extent crosses the anti meridian, so it needs to be sliced
        return [
            [
                extent[0],
                extent[1],
                projectionExtent[2],
                extent[3]
            ],
            [
                projectionExtent[0],
                extent[1],
                extent[2] - worldWidth,
                extent[3]
            ]
        ];
    }
    return [
        extent
    ];
}

},{"./extent/Relationship.js":"9q0e7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9q0e7":[function(require,module,exports,__globalThis) {
/**
 * @module ol/extent/Relationship
 */ /**
 * Relationship to an extent.
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"SznqC":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj
 */ /**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection~Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */ /**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */ parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>(0, _unitsJs.METERS_PER_UNIT));
parcelHelpers.export(exports, "Projection", ()=>(0, _projectionJsDefault.default));
/**
 * @param {boolean} [disable = true] Disable console info about `useGeographic()`
 */ parcelHelpers.export(exports, "disableCoordinateWarning", ()=>disableCoordinateWarning);
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */ parcelHelpers.export(exports, "cloneTransform", ()=>cloneTransform);
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Input coordinate array (same array as input).
 */ parcelHelpers.export(exports, "identityTransform", ()=>identityTransform);
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */ parcelHelpers.export(exports, "addProjection", ()=>addProjection);
/**
 * @param {Array<Projection>} projections Projections.
 */ parcelHelpers.export(exports, "addProjections", ()=>addProjections);
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */ parcelHelpers.export(exports, "get", ()=>get);
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */ parcelHelpers.export(exports, "getPointResolution", ()=>getPointResolution);
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */ parcelHelpers.export(exports, "addEquivalentProjections", ()=>addEquivalentProjections);
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */ parcelHelpers.export(exports, "addEquivalentTransforms", ()=>addEquivalentTransforms);
/**
 * Clear all cached projections and transforms.
 */ parcelHelpers.export(exports, "clearAllProjections", ()=>clearAllProjections);
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */ parcelHelpers.export(exports, "createProjection", ()=>createProjection);
/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */ parcelHelpers.export(exports, "createTransformFromCoordinateTransform", ()=>createTransformFromCoordinateTransform);
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only
 *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate
 *     with only the length it can transform. The other dimensions will be taken unchanged from the
 *     source.
 * @api
 */ parcelHelpers.export(exports, "addCoordinateTransforms", ()=>addCoordinateTransforms);
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */ parcelHelpers.export(exports, "fromLonLat", ()=>fromLonLat);
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */ parcelHelpers.export(exports, "toLonLat", ()=>toLonLat);
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */ parcelHelpers.export(exports, "equivalent", ()=>equivalent);
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */ parcelHelpers.export(exports, "getTransformFromProjections", ()=>getTransformFromProjections);
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */ parcelHelpers.export(exports, "getTransform", ()=>getTransform);
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */ parcelHelpers.export(exports, "transform", ()=>transform);
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */ parcelHelpers.export(exports, "transformExtent", ()=>transformExtent);
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */ parcelHelpers.export(exports, "transformWithProjections", ()=>transformWithProjections);
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */ parcelHelpers.export(exports, "setUserProjection", ()=>setUserProjection);
/**
 * Clear the user projection if set.
 * @api
 */ parcelHelpers.export(exports, "clearUserProjection", ()=>clearUserProjection);
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */ parcelHelpers.export(exports, "getUserProjection", ()=>getUserProjection);
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @api
 */ parcelHelpers.export(exports, "useGeographic", ()=>useGeographic);
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */ parcelHelpers.export(exports, "toUserCoordinate", ()=>toUserCoordinate);
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */ parcelHelpers.export(exports, "fromUserCoordinate", ()=>fromUserCoordinate);
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */ parcelHelpers.export(exports, "toUserExtent", ()=>toUserExtent);
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */ parcelHelpers.export(exports, "fromUserExtent", ()=>fromUserExtent);
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */ parcelHelpers.export(exports, "toUserResolution", ()=>toUserResolution);
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */ parcelHelpers.export(exports, "fromUserResolution", ()=>fromUserResolution);
/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destination).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destination).
 */ parcelHelpers.export(exports, "createSafeCoordinateTransform", ()=>createSafeCoordinateTransform);
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */ parcelHelpers.export(exports, "addCommon", ()=>addCommon);
var _projectionJs = require("./proj/Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
var _epsg3857Js = require("./proj/epsg3857.js");
var _epsg4326Js = require("./proj/epsg4326.js");
var _unitsJs = require("./proj/Units.js");
var _projectionsJs = require("./proj/projections.js");
var _transformsJs = require("./proj/transforms.js");
var _extentJs = require("./extent.js");
var _mathJs = require("./math.js");
var _coordinateJs = require("./coordinate.js");
var _sphereJs = require("./sphere.js");
var _consoleJs = require("./console.js");
let showCoordinateWarning = true;
function disableCoordinateWarning(disable) {
    const hide = disable === undefined ? true : disable;
    showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
    if (output !== undefined) {
        for(let i = 0, ii = input.length; i < ii; ++i)output[i] = input[i];
        output;
    } else output = input.slice();
    return output;
}
function identityTransform(input, output) {
    if (output !== undefined && input !== output) {
        for(let i = 0, ii = input.length; i < ii; ++i)output[i] = input[i];
        input = output;
    }
    return input;
}
function addProjection(projection) {
    (0, _projectionsJs.add)(projection.getCode(), projection);
    (0, _transformsJs.add)(projection, projection, cloneTransform);
}
function addProjections(projections) {
    projections.forEach(addProjection);
}
function get(projectionLike) {
    return typeof projectionLike === 'string' ? (0, _projectionsJs.get)(/** @type {string} */ projectionLike) : /** @type {Projection} */ projectionLike || null;
}
function getPointResolution(projection, resolution, point, units) {
    projection = get(projection);
    let pointResolution;
    const getter = projection.getPointResolutionFunc();
    if (getter) {
        pointResolution = getter(resolution, point);
        if (units && units !== projection.getUnits()) {
            const metersPerUnit = projection.getMetersPerUnit();
            if (metersPerUnit) pointResolution = pointResolution * metersPerUnit / (0, _unitsJs.METERS_PER_UNIT)[units];
        }
    } else {
        const projUnits = projection.getUnits();
        if (projUnits == 'degrees' && !units || units == 'degrees') pointResolution = resolution;
        else {
            // Estimate point resolution by transforming the center pixel to EPSG:4326,
            // measuring its width and height on the normal sphere, and taking the
            // average of the width and height.
            const toEPSG4326 = getTransformFromProjections(projection, get('EPSG:4326'));
            if (toEPSG4326 === identityTransform && projUnits !== 'degrees') // no transform is available
            pointResolution = resolution * projection.getMetersPerUnit();
            else {
                let vertices = [
                    point[0] - resolution / 2,
                    point[1],
                    point[0] + resolution / 2,
                    point[1],
                    point[0],
                    point[1] - resolution / 2,
                    point[0],
                    point[1] + resolution / 2
                ];
                vertices = toEPSG4326(vertices, vertices, 2);
                const width = (0, _sphereJs.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
                const height = (0, _sphereJs.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
                pointResolution = (width + height) / 2;
            }
            const metersPerUnit = units ? (0, _unitsJs.METERS_PER_UNIT)[units] : projection.getMetersPerUnit();
            if (metersPerUnit !== undefined) pointResolution /= metersPerUnit;
        }
    }
    return pointResolution;
}
function addEquivalentProjections(projections) {
    addProjections(projections);
    projections.forEach(function(source) {
        projections.forEach(function(destination) {
            if (source !== destination) (0, _transformsJs.add)(source, destination, cloneTransform);
        });
    });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
    projections1.forEach(function(projection1) {
        projections2.forEach(function(projection2) {
            (0, _transformsJs.add)(projection1, projection2, forwardTransform);
            (0, _transformsJs.add)(projection2, projection1, inverseTransform);
        });
    });
}
function clearAllProjections() {
    (0, _projectionsJs.clear)();
    (0, _transformsJs.clear)();
}
function createProjection(projection, defaultCode) {
    if (!projection) return get(defaultCode);
    if (typeof projection === 'string') return get(projection);
    return /** @type {Projection} */ projection;
}
function createTransformFromCoordinateTransform(coordTransform) {
    return(/**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */ function(input, output, dimension) {
        const length = input.length;
        dimension = dimension !== undefined ? dimension : 2;
        output = output !== undefined ? output : new Array(length);
        for(let i = 0; i < length; i += dimension){
            const point = coordTransform(input.slice(i, i + dimension));
            const pointLength = point.length;
            for(let j = 0, jj = dimension; j < jj; ++j)output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
        return output;
    });
}
function addCoordinateTransforms(source, destination, forward, inverse) {
    const sourceProj = get(source);
    const destProj = get(destination);
    (0, _transformsJs.add)(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
    (0, _transformsJs.add)(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
function fromLonLat(coordinate, projection) {
    disableCoordinateWarning();
    return transform(coordinate, 'EPSG:4326', projection !== undefined ? projection : 'EPSG:3857');
}
function toLonLat(coordinate, projection) {
    const lonLat = transform(coordinate, projection !== undefined ? projection : 'EPSG:3857', 'EPSG:4326');
    const lon = lonLat[0];
    if (lon < -180 || lon > 180) lonLat[0] = (0, _mathJs.modulo)(lon + 180, 360) - 180;
    return lonLat;
}
function equivalent(projection1, projection2) {
    if (projection1 === projection2) return true;
    const equalUnits = projection1.getUnits() === projection2.getUnits();
    if (projection1.getCode() === projection2.getCode()) return equalUnits;
    const transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
    const sourceCode = sourceProjection.getCode();
    const destinationCode = destinationProjection.getCode();
    let transformFunc = (0, _transformsJs.get)(sourceCode, destinationCode);
    if (!transformFunc) transformFunc = identityTransform;
    return transformFunc;
}
function getTransform(source, destination) {
    const sourceProjection = get(source);
    const destinationProjection = get(destination);
    return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
    const transformFunc = getTransform(source, destination);
    return transformFunc(coordinate, undefined, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
    const transformFunc = getTransform(source, destination);
    return (0, _extentJs.applyTransform)(extent, transformFunc, undefined, stops);
}
function transformWithProjections(point, sourceProjection, destinationProjection) {
    const transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
    return transformFunc(point);
}
/**
 * @type {Projection|null}
 */ let userProjection = null;
function setUserProjection(projection) {
    userProjection = get(projection);
}
function clearUserProjection() {
    userProjection = null;
}
function getUserProjection() {
    return userProjection;
}
function useGeographic() {
    setUserProjection('EPSG:4326');
}
function toUserCoordinate(coordinate, sourceProjection) {
    if (!userProjection) return coordinate;
    return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
    if (!userProjection) {
        if (showCoordinateWarning && !(0, _coordinateJs.equals)(coordinate, [
            0,
            0
        ]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
            showCoordinateWarning = false;
            (0, _consoleJs.warn)('Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.');
        }
        return coordinate;
    }
    return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
    if (!userProjection) return extent;
    return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
    if (!userProjection) return extent;
    return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
    if (!userProjection) return resolution;
    const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();
    const userMetersPerUnit = userProjection.getMetersPerUnit();
    return sourceMetersPerUnit && userMetersPerUnit ? resolution * sourceMetersPerUnit / userMetersPerUnit : resolution;
}
function fromUserResolution(resolution, destProjection) {
    if (!userProjection) return resolution;
    const destMetersPerUnit = get(destProjection).getMetersPerUnit();
    const userMetersPerUnit = userProjection.getMetersPerUnit();
    return destMetersPerUnit && userMetersPerUnit ? resolution * userMetersPerUnit / destMetersPerUnit : resolution;
}
function createSafeCoordinateTransform(sourceProj, destProj, transform) {
    return function(coord) {
        let transformed, worldsAway;
        if (sourceProj.canWrapX()) {
            const sourceExtent = sourceProj.getExtent();
            const sourceExtentWidth = (0, _extentJs.getWidth)(sourceExtent);
            coord = coord.slice(0);
            worldsAway = (0, _coordinateJs.getWorldsAway)(coord, sourceProj, sourceExtentWidth);
            if (worldsAway) // Move x to the real world
            coord[0] = coord[0] - worldsAway * sourceExtentWidth;
            coord[0] = (0, _mathJs.clamp)(coord[0], sourceExtent[0], sourceExtent[2]);
            coord[1] = (0, _mathJs.clamp)(coord[1], sourceExtent[1], sourceExtent[3]);
            transformed = transform(coord);
        } else transformed = transform(coord);
        if (worldsAway && destProj.canWrapX()) // Move transformed coordinate back to the offset world
        transformed[0] += worldsAway * (0, _extentJs.getWidth)(destProj.getExtent());
        return transformed;
    };
}
function addCommon() {
    // Add transformations that don't alter coordinates to convert within set of
    // projections with equal meaning.
    addEquivalentProjections((0, _epsg3857Js.PROJECTIONS));
    addEquivalentProjections((0, _epsg4326Js.PROJECTIONS));
    // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
    // coordinates and back.
    addEquivalentTransforms((0, _epsg4326Js.PROJECTIONS), (0, _epsg3857Js.PROJECTIONS), (0, _epsg3857Js.fromEPSG4326), (0, _epsg3857Js.toEPSG4326));
}
addCommon();

},{"./proj/Projection.js":false,"./proj/epsg3857.js":"3MTbx","./proj/epsg4326.js":"6Thur","./proj/Units.js":"gOgy6","./proj/projections.js":"9svUu","./proj/transforms.js":"gPHoN","./extent.js":"6YrVc","./math.js":"5jEFr","./coordinate.js":"85Vu7","./sphere.js":"eJjHw","./console.js":"25bqN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7HvLt":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/Projection
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _unitsJs = require("./Units.js");
/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").Units} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution} function will be used.
 */ /**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4.register} function.
 *
 * @api
 */ class Projection {
    /**
   * @param {Options} options Projection options.
   */ constructor(options){
        /**
     * @private
     * @type {string}
     */ this.code_ = options.code;
        /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").Units}
     */ this.units_ = /** @type {import("./Units.js").Units} */ options.units;
        /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */ this.extent_ = options.extent !== undefined ? options.extent : null;
        /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */ this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
        /**
     * @private
     * @type {string}
     */ this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
        /**
     * @private
     * @type {boolean}
     */ this.global_ = options.global !== undefined ? options.global : false;
        /**
     * @private
     * @type {boolean}
     */ this.canWrapX_ = !!(this.global_ && this.extent_);
        /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */ this.getPointResolutionFunc_ = options.getPointResolution;
        /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */ this.defaultTileGrid_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.metersPerUnit_ = options.metersPerUnit;
    }
    /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */ canWrapX() {
        return this.canWrapX_;
    }
    /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */ getCode() {
        return this.code_;
    }
    /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent() {
        return this.extent_;
    }
    /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */ getUnits() {
        return this.units_;
    }
    /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */ getMetersPerUnit() {
        return this.metersPerUnit_ || (0, _unitsJs.METERS_PER_UNIT)[this.units_];
    }
    /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getWorldExtent() {
        return this.worldExtent_;
    }
    /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */ getAxisOrientation() {
        return this.axisOrientation_;
    }
    /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */ isGlobal() {
        return this.global_;
    }
    /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */ setGlobal(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
    }
    /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */ getDefaultTileGrid() {
        return this.defaultTileGrid_;
    }
    /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */ setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
    }
    /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */ setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
    }
    /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */ setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
    }
    /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */ setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
    }
    /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */ getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
    }
}
exports.default = Projection;

},{"./Units.js":"gOgy6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gOgy6":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/Units
 */ /**
 * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units
 * Projection units.
 */ /**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */ parcelHelpers.export(exports, "fromCode", ()=>fromCode);
parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>METERS_PER_UNIT);
const unitByCode = {
    '9001': 'm',
    '9002': 'ft',
    '9003': 'us-ft',
    '9101': 'radians',
    '9102': 'degrees'
};
function fromCode(code) {
    return unitByCode[code];
}
const METERS_PER_UNIT = {
    // use the radius of the Normal sphere
    'radians': 6370997 / (2 * Math.PI),
    'degrees': 2 * Math.PI * 6370997 / 360,
    'ft': 0.3048,
    'm': 1,
    'us-ft': 1200 / 3937
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3MTbx":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/epsg3857
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RADIUS", ()=>RADIUS);
parcelHelpers.export(exports, "HALF_SIZE", ()=>HALF_SIZE);
parcelHelpers.export(exports, "EXTENT", ()=>EXTENT);
parcelHelpers.export(exports, "WORLD_EXTENT", ()=>WORLD_EXTENT);
parcelHelpers.export(exports, "MAX_SAFE_Y", ()=>MAX_SAFE_Y);
parcelHelpers.export(exports, "PROJECTIONS", ()=>PROJECTIONS);
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */ parcelHelpers.export(exports, "fromEPSG4326", ()=>fromEPSG4326);
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */ parcelHelpers.export(exports, "toEPSG4326", ()=>toEPSG4326);
var _projectionJs = require("./Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
const RADIUS = 6378137;
const HALF_SIZE = Math.PI * RADIUS;
const EXTENT = [
    -HALF_SIZE,
    -HALF_SIZE,
    HALF_SIZE,
    HALF_SIZE
];
const WORLD_EXTENT = [
    -180,
    -85,
    180,
    85
];
const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */ class EPSG3857Projection extends (0, _projectionJsDefault.default) {
    /**
   * @param {string} code Code.
   */ constructor(code){
        super({
            code: code,
            units: 'm',
            extent: EXTENT,
            global: true,
            worldExtent: WORLD_EXTENT,
            getPointResolution: function(resolution, point) {
                return resolution / Math.cosh(point[1] / RADIUS);
            }
        });
    }
}
const PROJECTIONS = [
    new EPSG3857Projection('EPSG:3857'),
    new EPSG3857Projection('EPSG:102100'),
    new EPSG3857Projection('EPSG:102113'),
    new EPSG3857Projection('EPSG:900913'),
    new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),
    new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')
];
function fromEPSG4326(input, output, dimension) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    if (output === undefined) {
        if (dimension > 2) // preserve values beyond second dimension
        output = input.slice();
        else output = new Array(length);
    }
    for(let i = 0; i < length; i += dimension){
        output[i] = HALF_SIZE * input[i] / 180;
        let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
        if (y > MAX_SAFE_Y) y = MAX_SAFE_Y;
        else if (y < -MAX_SAFE_Y) y = -MAX_SAFE_Y;
        output[i + 1] = y;
    }
    return output;
}
function toEPSG4326(input, output, dimension) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    if (output === undefined) {
        if (dimension > 2) // preserve values beyond second dimension
        output = input.slice();
        else output = new Array(length);
    }
    for(let i = 0; i < length; i += dimension){
        output[i] = 180 * input[i] / HALF_SIZE;
        output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
    }
    return output;
}

},{"./Projection.js":"7HvLt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Thur":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/epsg4326
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RADIUS", ()=>RADIUS);
parcelHelpers.export(exports, "EXTENT", ()=>EXTENT);
parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>METERS_PER_UNIT);
parcelHelpers.export(exports, "PROJECTIONS", ()=>PROJECTIONS);
var _projectionJs = require("./Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
const RADIUS = 6378137;
const EXTENT = [
    -180,
    -90,
    180,
    90
];
const METERS_PER_UNIT = Math.PI * RADIUS / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */ class EPSG4326Projection extends (0, _projectionJsDefault.default) {
    /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */ constructor(code, axisOrientation){
        super({
            code: code,
            units: 'degrees',
            extent: EXTENT,
            axisOrientation: axisOrientation,
            global: true,
            metersPerUnit: METERS_PER_UNIT,
            worldExtent: EXTENT
        });
    }
}
const PROJECTIONS = [
    new EPSG4326Projection('CRS:84'),
    new EPSG4326Projection('EPSG:4326', 'neu'),
    new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
    new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
    new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),
    new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
    new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu')
];

},{"./Projection.js":"7HvLt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9svUu":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/projections
 */ /**
 * @type {Object<string, import("./Projection.js").default>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Clear the projections cache.
 */ parcelHelpers.export(exports, "clear", ()=>clear);
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */ parcelHelpers.export(exports, "get", ()=>get);
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */ parcelHelpers.export(exports, "add", ()=>add);
let cache = {};
function clear() {
    cache = {};
}
function get(code) {
    return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] || null;
}
function add(code, projection) {
    cache[code] = projection;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gPHoN":[function(require,module,exports,__globalThis) {
/**
 * @module ol/proj/transforms
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Clear the transform cache.
 */ parcelHelpers.export(exports, "clear", ()=>clear);
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */ parcelHelpers.export(exports, "add", ()=>add);
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */ parcelHelpers.export(exports, "remove", ()=>remove);
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */ parcelHelpers.export(exports, "get", ()=>get);
var _objJs = require("../obj.js");
/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */ let transforms = {};
function clear() {
    transforms = {};
}
function add(source, destination, transformFn) {
    const sourceCode = source.getCode();
    const destinationCode = destination.getCode();
    if (!(sourceCode in transforms)) transforms[sourceCode] = {};
    transforms[sourceCode][destinationCode] = transformFn;
}
function remove(source, destination) {
    const sourceCode = source.getCode();
    const destinationCode = destination.getCode();
    const transform = transforms[sourceCode][destinationCode];
    delete transforms[sourceCode][destinationCode];
    if ((0, _objJs.isEmpty)(transforms[sourceCode])) delete transforms[sourceCode];
    return transform;
}
function get(sourceCode, destinationCode) {
    let transform;
    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) transform = transforms[sourceCode][destinationCode];
    return transform;
}

},{"../obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5jEFr":[function(require,module,exports,__globalThis) {
/**
 * @module ol/math
 */ /**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clamp", ()=>clamp);
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */ parcelHelpers.export(exports, "squaredSegmentDistance", ()=>squaredSegmentDistance);
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance);
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>|null} The resulting vector.
 */ parcelHelpers.export(exports, "solveLinearSystem", ()=>solveLinearSystem);
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */ parcelHelpers.export(exports, "toDegrees", ()=>toDegrees);
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */ parcelHelpers.export(exports, "toRadians", ()=>toRadians);
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */ parcelHelpers.export(exports, "modulo", ()=>modulo);
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */ parcelHelpers.export(exports, "lerp", ()=>lerp);
/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */ parcelHelpers.export(exports, "toFixed", ()=>toFixed);
/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */ parcelHelpers.export(exports, "round", ()=>round);
/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */ parcelHelpers.export(exports, "floor", ()=>floor);
/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */ parcelHelpers.export(exports, "ceil", ()=>ceil);
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    if (dx !== 0 || dy !== 0) {
        const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x1 = x2;
            y1 = y2;
        } else if (t > 0) {
            x1 += dx * t;
            y1 += dy * t;
        }
    }
    return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
    const n = mat.length;
    for(let i = 0; i < n; i++){
        // Find max in the i-th column (ignoring i - 1 first rows)
        let maxRow = i;
        let maxEl = Math.abs(mat[i][i]);
        for(let r = i + 1; r < n; r++){
            const absValue = Math.abs(mat[r][i]);
            if (absValue > maxEl) {
                maxEl = absValue;
                maxRow = r;
            }
        }
        if (maxEl === 0) return null; // matrix is singular
        // Swap max row with i-th (current) row
        const tmp = mat[maxRow];
        mat[maxRow] = mat[i];
        mat[i] = tmp;
        // Subtract the i-th row to make all the remaining rows 0 in the i-th column
        for(let j = i + 1; j < n; j++){
            const coef = -mat[j][i] / mat[i][i];
            for(let k = i; k < n + 1; k++)if (i == k) mat[j][k] = 0;
            else mat[j][k] += coef * mat[i][k];
        }
    }
    // Solve Ax=b for upper triangular matrix A (mat)
    const x = new Array(n);
    for(let l = n - 1; l >= 0; l--){
        x[l] = mat[l][n] / mat[l][l];
        for(let m = l - 1; m >= 0; m--)mat[m][n] -= mat[m][l] * x[l];
    }
    return x;
}
function toDegrees(angleInRadians) {
    return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
    return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
    const r = a % b;
    return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
    return a + x * (b - a);
}
function toFixed(n, decimals) {
    const factor = Math.pow(10, decimals);
    return Math.round(n * factor) / factor;
}
function round(n, decimals) {
    return Math.round(toFixed(n, decimals));
}
function floor(n, decimals) {
    return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
    return Math.ceil(toFixed(n, decimals));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"85Vu7":[function(require,module,exports,__globalThis) {
/**
 * @module ol/coordinate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.
 * Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */ /**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */ /**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */ parcelHelpers.export(exports, "add", ()=>add);
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */ parcelHelpers.export(exports, "closestOnCircle", ()=>closestOnCircle);
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */ parcelHelpers.export(exports, "closestOnSegment", ()=>closestOnSegment);
/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY();
 *     const out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY(2);
 *     const out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */ parcelHelpers.export(exports, "createStringXY", ()=>createStringXY);
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */ parcelHelpers.export(exports, "degreesToStringHDMS", ()=>degreesToStringHDMS);
/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */ parcelHelpers.export(exports, "format", ()=>format);
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */ parcelHelpers.export(exports, "equals", ()=>equals);
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance);
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */ parcelHelpers.export(exports, "distance", ()=>distance);
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */ parcelHelpers.export(exports, "squaredDistanceToSegment", ()=>squaredDistanceToSegment);
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */ parcelHelpers.export(exports, "toStringHDMS", ()=>toStringHDMS);
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */ parcelHelpers.export(exports, "toStringXY", ()=>toStringXY);
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX);
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */ parcelHelpers.export(exports, "getWorldsAway", ()=>getWorldsAway);
var _extentJs = require("./extent.js");
var _mathJs = require("./math.js");
var _stringJs = require("./string.js");
function add(coordinate, delta) {
    coordinate[0] += +delta[0];
    coordinate[1] += +delta[1];
    return coordinate;
}
function closestOnCircle(coordinate, circle) {
    const r = circle.getRadius();
    const center = circle.getCenter();
    const x0 = center[0];
    const y0 = center[1];
    const x1 = coordinate[0];
    const y1 = coordinate[1];
    let dx = x1 - x0;
    const dy = y1 - y0;
    if (dx === 0 && dy === 0) dx = 1;
    const d = Math.sqrt(dx * dx + dy * dy);
    const x = x0 + r * dx / d;
    const y = y0 + r * dy / d;
    return [
        x,
        y
    ];
}
function closestOnSegment(coordinate, segment) {
    const x0 = coordinate[0];
    const y0 = coordinate[1];
    const start = segment[0];
    const end = segment[1];
    const x1 = start[0];
    const y1 = start[1];
    const x2 = end[0];
    const y2 = end[1];
    const dx = x2 - x1;
    const dy = y2 - y1;
    const along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
    let x, y;
    if (along <= 0) {
        x = x1;
        y = y1;
    } else if (along >= 1) {
        x = x2;
        y = y2;
    } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return [
        x,
        y
    ];
}
function createStringXY(fractionDigits) {
    return(/**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */ function(coordinate) {
        return toStringXY(coordinate, fractionDigits);
    });
}
function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
    const normalizedDegrees = (0, _mathJs.modulo)(degrees + 180, 360) - 180;
    const x = Math.abs(3600 * normalizedDegrees);
    const decimals = fractionDigits || 0;
    let deg = Math.floor(x / 3600);
    let min = Math.floor((x - deg * 3600) / 60);
    let sec = (0, _mathJs.toFixed)(x - deg * 3600 - min * 60, decimals);
    if (sec >= 60) {
        sec = 0;
        min += 1;
    }
    if (min >= 60) {
        min = 0;
        deg += 1;
    }
    let hdms = deg + '\u00b0';
    if (min !== 0 || sec !== 0) hdms += ' ' + (0, _stringJs.padNumber)(min, 2) + '\u2032';
    if (sec !== 0) hdms += ' ' + (0, _stringJs.padNumber)(sec, 2, decimals) + '\u2033';
    if (normalizedDegrees !== 0) hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
    return hdms;
}
function format(coordinate, template, fractionDigits) {
    if (coordinate) return template.replace('{x}', coordinate[0].toFixed(fractionDigits)).replace('{y}', coordinate[1].toFixed(fractionDigits));
    return '';
}
function equals(coordinate1, coordinate2) {
    let equals = true;
    for(let i = coordinate1.length - 1; i >= 0; --i)if (coordinate1[i] != coordinate2[i]) {
        equals = false;
        break;
    }
    return equals;
}
function rotate(coordinate, angle) {
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    coordinate[0] = x;
    coordinate[1] = y;
    return coordinate;
}
function scale(coordinate, scale) {
    coordinate[0] *= scale;
    coordinate[1] *= scale;
    return coordinate;
}
function squaredDistance(coord1, coord2) {
    const dx = coord1[0] - coord2[0];
    const dy = coord1[1] - coord2[1];
    return dx * dx + dy * dy;
}
function distance(coord1, coord2) {
    return Math.sqrt(squaredDistance(coord1, coord2));
}
function squaredDistanceToSegment(coordinate, segment) {
    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
function toStringHDMS(coordinate, fractionDigits) {
    if (coordinate) return degreesToStringHDMS('NS', coordinate[1], fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], fractionDigits);
    return '';
}
function toStringXY(coordinate, fractionDigits) {
    return format(coordinate, '{x}, {y}', fractionDigits);
}
function wrapX(coordinate, projection) {
    if (projection.canWrapX()) {
        const worldWidth = (0, _extentJs.getWidth)(projection.getExtent());
        const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
        if (worldsAway) coordinate[0] -= worldsAway * worldWidth;
    }
    return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
    const projectionExtent = projection.getExtent();
    let worldsAway = 0;
    if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
        sourceExtentWidth = sourceExtentWidth || (0, _extentJs.getWidth)(projectionExtent);
        worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
    }
    return worldsAway;
}

},{"./extent.js":"6YrVc","./math.js":"5jEFr","./string.js":"fIYwS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fIYwS":[function(require,module,exports,__globalThis) {
/**
 * @module ol/string
 */ /**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "padNumber", ()=>padNumber);
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */ parcelHelpers.export(exports, "compareVersions", ()=>compareVersions);
function padNumber(number, width, precision) {
    const numberString = precision !== undefined ? number.toFixed(precision) : '' + number;
    let decimal = numberString.indexOf('.');
    decimal = decimal === -1 ? numberString.length : decimal;
    return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}
function compareVersions(v1, v2) {
    const s1 = ('' + v1).split('.');
    const s2 = ('' + v2).split('.');
    for(let i = 0; i < Math.max(s1.length, s2.length); i++){
        const n1 = parseInt(s1[i] || '0', 10);
        const n2 = parseInt(s2[i] || '0', 10);
        if (n1 > n2) return 1;
        if (n2 > n1) return -1;
    }
    return 0;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eJjHw":[function(require,module,exports,__globalThis) {
/**
 * @module ol/sphere
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_RADIUS", ()=>DEFAULT_RADIUS);
/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */ parcelHelpers.export(exports, "getDistance", ()=>getDistance);
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */ parcelHelpers.export(exports, "getLength", ()=>getLength);
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */ parcelHelpers.export(exports, "getArea", ()=>getArea);
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */ parcelHelpers.export(exports, "offset", ()=>offset);
var _mathJs = require("./math.js");
const DEFAULT_RADIUS = 6371008.8;
function getDistance(c1, c2, radius) {
    radius = radius || DEFAULT_RADIUS;
    const lat1 = (0, _mathJs.toRadians)(c1[1]);
    const lat2 = (0, _mathJs.toRadians)(c2[1]);
    const deltaLatBy2 = (lat2 - lat1) / 2;
    const deltaLonBy2 = (0, _mathJs.toRadians)(c2[0] - c1[0]) / 2;
    const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */ function getLengthInternal(coordinates, radius) {
    let length = 0;
    for(let i = 0, ii = coordinates.length; i < ii - 1; ++i)length += getDistance(coordinates[i], coordinates[i + 1], radius);
    return length;
}
function getLength(geometry, options) {
    options = options || {};
    const radius = options.radius || DEFAULT_RADIUS;
    const projection = options.projection || 'EPSG:3857';
    const type = geometry.getType();
    if (type !== 'GeometryCollection') geometry = geometry.clone().transform(projection, 'EPSG:4326');
    let length = 0;
    let coordinates, coords, i, ii, j, jj;
    switch(type){
        case 'Point':
        case 'MultiPoint':
            break;
        case 'LineString':
        case 'LinearRing':
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            length = getLengthInternal(coordinates, radius);
            break;
        case 'MultiLineString':
        case 'Polygon':
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i)length += getLengthInternal(coordinates[i], radius);
            break;
        case 'MultiPolygon':
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i){
                coords = coordinates[i];
                for(j = 0, jj = coords.length; j < jj; ++j)length += getLengthInternal(coords[j], radius);
            }
            break;
        case 'GeometryCollection':
            {
                const geometries = /** @type {import("./geom/GeometryCollection.js").default} */ geometry.getGeometries();
                for(i = 0, ii = geometries.length; i < ii; ++i)length += getLength(geometries[i], options);
                break;
            }
        default:
            throw new Error('Unsupported geometry type: ' + type);
    }
    return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */ function getAreaInternal(coordinates, radius) {
    let area = 0;
    const len = coordinates.length;
    let x1 = coordinates[len - 1][0];
    let y1 = coordinates[len - 1][1];
    for(let i = 0; i < len; i++){
        const x2 = coordinates[i][0];
        const y2 = coordinates[i][1];
        area += (0, _mathJs.toRadians)(x2 - x1) * (2 + Math.sin((0, _mathJs.toRadians)(y1)) + Math.sin((0, _mathJs.toRadians)(y2)));
        x1 = x2;
        y1 = y2;
    }
    return area * radius * radius / 2.0;
}
function getArea(geometry, options) {
    options = options || {};
    const radius = options.radius || DEFAULT_RADIUS;
    const projection = options.projection || 'EPSG:3857';
    const type = geometry.getType();
    if (type !== 'GeometryCollection') geometry = geometry.clone().transform(projection, 'EPSG:4326');
    let area = 0;
    let coordinates, coords, i, ii, j, jj;
    switch(type){
        case 'Point':
        case 'MultiPoint':
        case 'LineString':
        case 'MultiLineString':
        case 'LinearRing':
            break;
        case 'Polygon':
            coordinates = /** @type {import("./geom/Polygon.js").default} */ geometry.getCoordinates();
            area = Math.abs(getAreaInternal(coordinates[0], radius));
            for(i = 1, ii = coordinates.length; i < ii; ++i)area -= Math.abs(getAreaInternal(coordinates[i], radius));
            break;
        case 'MultiPolygon':
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i){
                coords = coordinates[i];
                area += Math.abs(getAreaInternal(coords[0], radius));
                for(j = 1, jj = coords.length; j < jj; ++j)area -= Math.abs(getAreaInternal(coords[j], radius));
            }
            break;
        case 'GeometryCollection':
            {
                const geometries = /** @type {import("./geom/GeometryCollection.js").default} */ geometry.getGeometries();
                for(i = 0, ii = geometries.length; i < ii; ++i)area += getArea(geometries[i], options);
                break;
            }
        default:
            throw new Error('Unsupported geometry type: ' + type);
    }
    return area;
}
function offset(c1, distance, bearing, radius) {
    radius = radius || DEFAULT_RADIUS;
    const lat1 = (0, _mathJs.toRadians)(c1[1]);
    const lon1 = (0, _mathJs.toRadians)(c1[0]);
    const dByR = distance / radius;
    const lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
    const lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
    return [
        (0, _mathJs.toDegrees)(lon),
        (0, _mathJs.toDegrees)(lat)
    ];
}

},{"./math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"25bqN":[function(require,module,exports,__globalThis) {
/**
 * @module ol/console
 */ /**
 * @typedef {'info'|'warn'|'error'|'none'} Level
 */ /**
 * @type {Object<Level, number>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Set the logging level.  By default, the level is set to 'info' and all
 * messages will be logged.  Set to 'warn' to only display warnings and errors.
 * Set to 'error' to only display errors.  Set to 'none' to silence all messages.
 *
 * @param {Level} l The new level.
 */ parcelHelpers.export(exports, "setLevel", ()=>setLevel);
/**
 * @param  {...any} args Arguments to log
 */ parcelHelpers.export(exports, "log", ()=>log);
/**
 * @param  {...any} args Arguments to log
 */ parcelHelpers.export(exports, "warn", ()=>warn);
/**
 * @param  {...any} args Arguments to log
 */ parcelHelpers.export(exports, "error", ()=>error);
const levels = {
    info: 1,
    warn: 2,
    error: 3,
    none: 4
};
/**
 * @type {number}
 */ let level = levels.info;
function setLevel(l) {
    level = levels[l];
}
function log(...args) {
    if (level > levels.info) return;
    console.log(...args); // eslint-disable-line no-console
}
function warn(...args) {
    if (level > levels.warn) return;
    console.warn(...args); // eslint-disable-line no-console
}
function error(...args) {
    if (level > levels.error) return;
    console.error(...args); // eslint-disable-line no-console
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cDA2L":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/transform
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transform2D", ()=>transform2D);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "translate", ()=>translate);
function transform2D(flatCoordinates, offset, end, stride, transform, dest) {
    dest = dest ? dest : [];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        const x = flatCoordinates[j];
        const y = flatCoordinates[j + 1];
        dest[i++] = transform[0] * x + transform[2] * y + transform[4];
        dest[i++] = transform[1] * x + transform[3] * y + transform[5];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}
function rotate(flatCoordinates, offset, end, stride, angle, anchor, dest) {
    dest = dest ? dest : [];
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const anchorX = anchor[0];
    const anchorY = anchor[1];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        const deltaX = flatCoordinates[j] - anchorX;
        const deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + deltaX * cos - deltaY * sin;
        dest[i++] = anchorY + deltaX * sin + deltaY * cos;
        for(let k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
    dest = dest ? dest : [];
    const anchorX = anchor[0];
    const anchorY = anchor[1];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        const deltaX = flatCoordinates[j] - anchorX;
        const deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + sx * deltaX;
        dest[i++] = anchorY + sy * deltaY;
        for(let k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
    dest = dest ? dest : [];
    let i = 0;
    for(let j = offset; j < end; j += stride){
        dest[i++] = flatCoordinates[j] + deltaX;
        dest[i++] = flatCoordinates[j + 1] + deltaY;
        for(let k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (dest && dest.length != i) dest.length = i;
    return dest;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3TE5l":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/deflate
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "deflateCoordinate", ()=>deflateCoordinate);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */ parcelHelpers.export(exports, "deflateCoordinates", ()=>deflateCoordinates);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [ends] Ends.
 * @return {Array<number>} Ends.
 */ parcelHelpers.export(exports, "deflateCoordinatesArray", ()=>deflateCoordinatesArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */ parcelHelpers.export(exports, "deflateMultiCoordinatesArray", ()=>deflateMultiCoordinatesArray);
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
    for(let i = 0, ii = coordinate.length; i < ii; ++i)flatCoordinates[offset++] = coordinate[i];
    return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
    for(let i = 0, ii = coordinates.length; i < ii; ++i){
        const coordinate = coordinates[i];
        for(let j = 0; j < stride; ++j)flatCoordinates[offset++] = coordinate[j];
    }
    return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
    ends = ends ? ends : [];
    let i = 0;
    for(let j = 0, jj = coordinatess.length; j < jj; ++j){
        const end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
        ends[i++] = end;
        offset = end;
    }
    ends.length = i;
    return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, endss) {
    endss = endss ? endss : [];
    let i = 0;
    for(let j = 0, jj = coordinatesss.length; j < jj; ++j){
        const ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
        if (ends.length === 0) ends[0] = offset;
        endss[i++] = ends;
        offset = ends[ends.length - 1];
    }
    endss.length = i;
    return endss;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"liabO":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Feature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */ parcelHelpers.export(exports, "createStyleFunction", ()=>createStyleFunction);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _assertsJs = require("./asserts.js");
var _eventsJs = require("./events.js");
/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */ /**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */ /***
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */ /**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature.js';
 * import Polygon from 'ol/geom/Polygon.js';
 * import Point from 'ol/geom/Point.js';
 *
 * const feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon',
 * });
 *
 * // get the polygon geometry
 * const poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * const point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */ class Feature extends (0, _objectJsDefault.default) {
    /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */ constructor(geometryOrProperties){
        super();
        /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {FeatureOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {number|string|undefined}
     */ this.id_ = undefined;
        /**
     * @type {string}
     * @private
     */ this.geometryName_ = 'geometry';
        /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */ this.style_ = null;
        /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */ this.styleFunction_ = undefined;
        /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */ this.geometryChangeKey_ = null;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        if (geometryOrProperties) {
            if (typeof /** @type {?} */ geometryOrProperties.getSimplifiedGeometry === 'function') {
                const geometry = /** @type {Geometry} */ geometryOrProperties;
                this.setGeometry(geometry);
            } else {
                /** @type {Object<string, *>} */ const properties = geometryOrProperties;
                this.setProperties(properties);
            }
        }
    }
    /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */ clone() {
        const clone = /** @type {Feature<Geometry>} */ new Feature(this.hasProperties() ? this.getProperties() : null);
        clone.setGeometryName(this.getGeometryName());
        const geometry = this.getGeometry();
        if (geometry) clone.setGeometry(/** @type {Geometry} */ geometry.clone());
        const style = this.getStyle();
        if (style) clone.setStyle(style);
        return clone;
    }
    /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */ getGeometry() {
        return /** @type {Geometry|undefined} */ this.get(this.geometryName_);
    }
    /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */ getId() {
        return this.id_;
    }
    /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */ getGeometryName() {
        return this.geometryName_;
    }
    /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */ getStyle() {
        return this.style_;
    }
    /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */ getStyleFunction() {
        return this.styleFunction_;
    }
    /**
   * @private
   */ handleGeometryChange_() {
        this.changed();
    }
    /**
   * @private
   */ handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
            (0, _eventsJs.unlistenByKey)(this.geometryChangeKey_);
            this.geometryChangeKey_ = null;
        }
        const geometry = this.getGeometry();
        if (geometry) this.geometryChangeKey_ = (0, _eventsJs.listen)(geometry, (0, _eventTypeJsDefault.default).CHANGE, this.handleGeometryChange_, this);
        this.changed();
    }
    /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */ setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
    }
    /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */ setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? undefined : createStyleFunction(style);
        this.changed();
    }
    /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */ setId(id) {
        this.id_ = id;
        this.changed();
    }
    /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */ setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
    }
}
function createStyleFunction(obj) {
    if (typeof obj === 'function') return obj;
    /**
   * @type {Array<import("./style/Style.js").default>}
   */ let styles;
    if (Array.isArray(obj)) styles = obj;
    else {
        (0, _assertsJs.assert)(typeof /** @type {?} */ obj.getZIndex === 'function', 'Expected an `ol/style/Style` or an array of `ol/style/Style.js`');
        const style = /** @type {import("./style/Style.js").default} */ obj;
        styles = [
            style
        ];
    }
    return function() {
        return styles;
    };
}
exports.default = Feature;

},{"./Object.js":"1zG8z","./events/EventType.js":"hrQJ6","./asserts.js":"e4TiF","./events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fDMaj":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/GeometryCollection
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
/**
 * @classdesc
 * An array of {@link module:ol/geom/Geometry~Geometry} objects.
 *
 * @api
 */ class GeometryCollection extends (0, _geometryJsDefault.default) {
    /**
   * @param {Array<Geometry>} [geometries] Geometries.
   */ constructor(geometries){
        super();
        /**
     * @private
     * @type {Array<Geometry>}
     */ this.geometries_ = geometries ? geometries : null;
        /**
     * @type {Array<import("../events.js").EventsKey>}
     */ this.changeEventsKeys_ = [];
        this.listenGeometriesChange_();
    }
    /**
   * @private
   */ unlistenGeometriesChange_() {
        this.changeEventsKeys_.forEach((0, _eventsJs.unlistenByKey));
        this.changeEventsKeys_.length = 0;
    }
    /**
   * @private
   */ listenGeometriesChange_() {
        if (!this.geometries_) return;
        for(let i = 0, ii = this.geometries_.length; i < ii; ++i)this.changeEventsKeys_.push((0, _eventsJs.listen)(this.geometries_[i], (0, _eventTypeJsDefault.default).CHANGE, this.changed, this));
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */ clone() {
        const geometryCollection = new GeometryCollection(null);
        geometryCollection.setGeometries(this.geometries_);
        geometryCollection.applyProperties(this);
        return geometryCollection;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
        return minSquaredDistance;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i){
            if (geometries[i].containsXY(x, y)) return true;
        }
        return false;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        (0, _extentJs.createOrUpdateEmpty)(extent);
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)(0, _extentJs.extend)(extent, geometries[i].getExtent());
        return extent;
    }
    /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */ getGeometries() {
        return cloneGeometries(this.geometries_);
    }
    /**
   * @return {Array<Geometry>} Geometries.
   */ getGeometriesArray() {
        return this.geometries_;
    }
    /**
   * @return {Array<Geometry>} Geometries.
   */ getGeometriesArrayRecursive() {
        /** @type {Array<Geometry>} */ let geometriesArray = [];
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)if (geometries[i].getType() === this.getType()) geometriesArray = geometriesArray.concat(/** @type {GeometryCollection} */ geometries[i].getGeometriesArrayRecursive());
        else geometriesArray.push(geometries[i]);
        return geometriesArray;
    }
    /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */ getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
            this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) return this;
        const simplifiedGeometries = [];
        const geometries = this.geometries_;
        let simplified = false;
        for(let i = 0, ii = geometries.length; i < ii; ++i){
            const geometry = geometries[i];
            const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
            simplifiedGeometries.push(simplifiedGeometry);
            if (simplifiedGeometry !== geometry) simplified = true;
        }
        if (simplified) {
            const simplifiedGeometryCollection = new GeometryCollection(null);
            simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
            return simplifiedGeometryCollection;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'GeometryCollection';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i){
            if (geometries[i].intersectsExtent(extent)) return true;
        }
        return false;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return this.geometries_.length === 0;
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].rotate(angle, anchor);
        this.changed();
    }
    /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */ scale(sx, sy, anchor) {
        if (!anchor) anchor = (0, _extentJs.getCenter)(this.getExtent());
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].scale(sx, sy, anchor);
        this.changed();
    }
    /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */ setGeometries(geometries) {
        this.setGeometriesArray(cloneGeometries(geometries));
    }
    /**
   * @param {Array<Geometry>} geometries Geometries.
   */ setGeometriesArray(geometries) {
        this.unlistenGeometriesChange_();
        this.geometries_ = geometries;
        this.listenGeometriesChange_();
        this.changed();
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */ applyTransform(transformFn) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].applyTransform(transformFn);
        this.changed();
    }
    /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */ translate(deltaX, deltaY) {
        const geometries = this.geometries_;
        for(let i = 0, ii = geometries.length; i < ii; ++i)geometries[i].translate(deltaX, deltaY);
        this.changed();
    }
    /**
   * Clean up.
   */ disposeInternal() {
        this.unlistenGeometriesChange_();
        super.disposeInternal();
    }
}
/**
 * @param {Array<Geometry>} geometries Geometries.
 * @return {Array<Geometry>} Cloned geometries.
 */ function cloneGeometries(geometries) {
    const clonedGeometries = [];
    for(let i = 0, ii = geometries.length; i < ii; ++i)clonedGeometries.push(geometries[i].clone());
    return clonedGeometries;
}
exports.default = GeometryCollection;

},{"../events/EventType.js":"hrQJ6","./Geometry.js":"4ya62","../extent.js":"6YrVc","../events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jLUiq":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/LineString
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _arrayJs = require("../array.js");
var _segmentsJs = require("./flat/segments.js");
var _inflateJs = require("./flat/inflate.js");
var _interpolateJs = require("./flat/interpolate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _lengthJs = require("./flat/length.js");
/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */ class LineString extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */ this.flatMidpoint_ = null;
        /**
     * @private
     * @type {number}
     */ this.flatMidpointRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        if (layout !== undefined && !Array.isArray(coordinates[0])) this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
        else this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ coordinates, layout);
    }
    /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */ appendCoordinate(coordinate) {
        (0, _arrayJs.extend)(this.flatCoordinates, coordinate);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */ clone() {
        const lineString = new LineString(this.flatCoordinates.slice(), this.layout);
        lineString.applyProperties(this);
        return lineString;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */ forEachSegment(callback) {
        return (0, _segmentsJs.forEach)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
    }
    /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */ getCoordinateAtM(m, extrapolate) {
        if (this.layout != 'XYM' && this.layout != 'XYZM') return null;
        extrapolate = extrapolate !== undefined ? extrapolate : false;
        return (0, _interpolateJs.lineStringCoordinateAtM)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
    }
    /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */ getCoordinateAt(fraction, dest) {
        return (0, _interpolateJs.interpolatePoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, dest, this.stride);
    }
    /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */ getLength() {
        return (0, _lengthJs.lineStringLength)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * @return {Array<number>} Flat midpoint.
   */ getFlatMidpoint() {
        if (this.flatMidpointRevision_ != this.getRevision()) {
            this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_ ?? undefined);
            this.flatMidpointRevision_ = this.getRevision();
        }
        return /** @type {Array<number>} */ this.flatMidpoint_;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        /** @type {Array<number>} */ const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LineString(simplifiedFlatCoordinates, 'XY');
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'LineString';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLineString)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    }
    /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = LineString;

},{"./SimpleGeometry.js":"hLwk3","./flat/closest.js":"fi6H5","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","./flat/simplify.js":"jsqc5","../array.js":"1Fbic","./flat/segments.js":"e7gWa","./flat/inflate.js":"4Rpju","./flat/interpolate.js":"dh8ns","./flat/intersectsextent.js":"7x08H","./flat/length.js":"X5sUU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fi6H5":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/closest
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "maxSquaredDelta", ()=>maxSquaredDelta);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "arrayMaxSquaredDelta", ()=>arrayMaxSquaredDelta);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "multiArrayMaxSquaredDelta", ()=>multiArrayMaxSquaredDelta);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestPoint", ()=>assignClosestPoint);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestArrayPoint", ()=>assignClosestArrayPoint);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestMultiArrayPoint", ()=>assignClosestMultiArrayPoint);
var _mathJs = require("../../math.js");
/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */ function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
    const x1 = flatCoordinates[offset1];
    const y1 = flatCoordinates[offset1 + 1];
    const dx = flatCoordinates[offset2] - x1;
    const dy = flatCoordinates[offset2 + 1] - y1;
    let offset;
    if (dx === 0 && dy === 0) offset = offset1;
    else {
        const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) offset = offset2;
        else if (t > 0) {
            for(let i = 0; i < stride; ++i)closestPoint[i] = (0, _mathJs.lerp)(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
            closestPoint.length = stride;
            return;
        } else offset = offset1;
    }
    for(let i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[offset + i];
    closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    for(offset += stride; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        const squaredDelta = (0, _mathJs.squaredDistance)(x1, y1, x2, y2);
        if (squaredDelta > max) max = squaredDelta;
        x1 = x2;
        y1 = y2;
    }
    return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
        offset = end;
    }
    return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
        offset = ends[ends.length - 1];
    }
    return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    if (offset == end) return minSquaredDistance;
    let i, squaredDistance;
    if (maxDelta === 0) {
        // All points are identical, so just test the first point.
        squaredDistance = (0, _mathJs.squaredDistance)(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
        if (squaredDistance < minSquaredDistance) {
            for(i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[offset + i];
            closestPoint.length = stride;
            return squaredDistance;
        }
        return minSquaredDistance;
    }
    tmpPoint = tmpPoint ? tmpPoint : [
        NaN,
        NaN
    ];
    let index = offset + stride;
    while(index < end){
        assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
        squaredDistance = (0, _mathJs.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance < minSquaredDistance) {
            minSquaredDistance = squaredDistance;
            for(i = 0; i < stride; ++i)closestPoint[i] = tmpPoint[i];
            closestPoint.length = stride;
            index += stride;
        } else // Skip ahead multiple points, because we know that all the skipped
        // points cannot be any closer than the closest point we have found so
        // far.  We know this because we know how close the current point is, how
        // close the closest point we have found so far is, and the maximum
        // distance between consecutive points.  For example, if we're currently
        // at distance 10, the best we've found so far is 3, and that the maximum
        // distance between consecutive points is 2, then we'll need to skip at
        // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
        // finding a closer point.  We use Math.max(..., 1) to ensure that we
        // always advance at least one point, to avoid an infinite loop.
        index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
    if (isRing) {
        // Check the closing segment.
        assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
        squaredDistance = (0, _mathJs.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance < minSquaredDistance) {
            minSquaredDistance = squaredDistance;
            for(i = 0; i < stride; ++i)closestPoint[i] = tmpPoint[i];
            closestPoint.length = stride;
        }
    }
    return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [
        NaN,
        NaN
    ];
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = end;
    }
    return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [
        NaN,
        NaN
    ];
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = ends[ends.length - 1];
    }
    return minSquaredDistance;
}

},{"../../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jsqc5":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/simplify
 */ // Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */ parcelHelpers.export(exports, "simplifyLineString", ()=>simplifyLineString);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeucker", ()=>douglasPeucker);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeuckerArray", ()=>douglasPeuckerArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeuckerMultiArray", ()=>douglasPeuckerMultiArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "radialDistance", ()=>radialDistance);
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */ parcelHelpers.export(exports, "snap", ()=>snap);
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantize", ()=>quantize);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantizeArray", ()=>quantizeArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantizeMultiArray", ()=>quantizeMultiArray);
var _mathJs = require("../../math.js");
function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, simplifiedFlatCoordinates) {
    simplifiedFlatCoordinates = simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];
    if (!highQuality) {
        end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        flatCoordinates = simplifiedFlatCoordinates;
        offset = 0;
        stride = 2;
    }
    simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return simplifiedFlatCoordinates;
}
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    const n = (end - offset) / stride;
    if (n < 3) {
        for(; offset < end; offset += stride){
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
    }
    /** @type {Array<number>} */ const markers = new Array(n);
    markers[0] = 1;
    markers[n - 1] = 1;
    /** @type {Array<number>} */ const stack = [
        offset,
        end - stride
    ];
    let index = 0;
    while(stack.length > 0){
        const last = stack.pop();
        const first = stack.pop();
        let maxSquaredDistance = 0;
        const x1 = flatCoordinates[first];
        const y1 = flatCoordinates[first + 1];
        const x2 = flatCoordinates[last];
        const y2 = flatCoordinates[last + 1];
        for(let i = first + stride; i < last; i += stride){
            const x = flatCoordinates[i];
            const y = flatCoordinates[i + 1];
            const squaredDistance = (0, _mathJs.squaredSegmentDistance)(x, y, x1, y1, x2, y2);
            if (squaredDistance > maxSquaredDistance) {
                index = i;
                maxSquaredDistance = squaredDistance;
            }
        }
        if (maxSquaredDistance > squaredTolerance) {
            markers[(index - offset) / stride] = 1;
            if (first + stride < index) stack.push(first, index);
            if (index + stride < last) stack.push(index, last);
        }
    }
    for(let i = 0; i < n; ++i)if (markers[i]) {
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
    return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
    }
    return simplifiedOffset;
}
function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        /** @type {Array<number>} */ const simplifiedEnds = [];
        simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
}
function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    if (end <= offset + stride) {
        // zero or one point, no simplification possible, so copy and return
        for(; offset < end; offset += stride){
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
    }
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    // copy first point
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    let x2 = x1;
    let y2 = y1;
    for(offset += stride; offset < end; offset += stride){
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        if ((0, _mathJs.squaredDistance)(x1, y1, x2, y2) > squaredTolerance) {
            // copy point at offset
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            x1 = x2;
            y1 = y2;
        }
    }
    if (x2 != x1 || y2 != y1) {
        // copy last point
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    }
    return simplifiedOffset;
}
function snap(value, tolerance) {
    return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    // do nothing if the line is empty
    if (offset == end) return simplifiedOffset;
    // snap the first coordinate (P1)
    let x1 = snap(flatCoordinates[offset], tolerance);
    let y1 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // add the first coordinate to the output
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    // find the next coordinate that does not snap to the same value as the first
    // coordinate (P2)
    let x2, y2;
    do {
        x2 = snap(flatCoordinates[offset], tolerance);
        y2 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        if (offset == end) {
            // all coordinates snap to the same value, the line collapses to a point
            // push the last snapped value anyway to ensure that the output contains
            // at least two points
            // FIXME should we really return at least two points anyway?
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            return simplifiedOffset;
        }
    }while (x2 == x1 && y2 == y1);
    while(offset < end){
        // snap the next coordinate (P3)
        const x3 = snap(flatCoordinates[offset], tolerance);
        const y3 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        // skip P3 if it is equal to P2
        if (x3 == x2 && y3 == y2) continue;
        // calculate the delta between P1 and P2
        const dx1 = x2 - x1;
        const dy1 = y2 - y1;
        // calculate the delta between P3 and P1
        const dx2 = x3 - x1;
        const dy2 = y3 - y1;
        // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
        // P1 in the same direction then P2 is on the straight line between P1 and
        // P3
        if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
            // discard P2 and set P2 = P3
            x2 = x3;
            y2 = y3;
            continue;
        }
        // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
        // between P3 and P1 or on the opposite half of the line to P2.  add P2,
        // and continue with P1 = P2 and P2 = P3
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
        x1 = x2;
        y1 = y2;
        x2 = x3;
        y2 = y3;
    }
    // add the last point (P2)
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
    }
    return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        /** @type {Array<number>} */ const simplifiedEnds = [];
        simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
}

},{"../../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e7gWa":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/segments
 */ /**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "forEach", ()=>forEach);
function forEach(flatCoordinates, offset, end, stride, callback) {
    let ret;
    offset += stride;
    for(; offset < end; offset += stride){
        ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));
        if (ret) return ret;
    }
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4Rpju":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/inflate
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inflateCoordinates", ()=>inflateCoordinates);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */ parcelHelpers.export(exports, "inflateCoordinatesArray", ()=>inflateCoordinatesArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */ parcelHelpers.export(exports, "inflateMultiCoordinatesArray", ()=>inflateMultiCoordinatesArray);
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates) {
    coordinates = coordinates !== undefined ? coordinates : [];
    let i = 0;
    for(let j = offset; j < end; j += stride)coordinates[i++] = flatCoordinates.slice(j, j + stride);
    coordinates.length = i;
    return coordinates;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
    coordinatess = coordinatess !== undefined ? coordinatess : [];
    let i = 0;
    for(let j = 0, jj = ends.length; j < jj; ++j){
        const end = ends[j];
        coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
        offset = end;
    }
    coordinatess.length = i;
    return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
    coordinatesss = coordinatesss !== undefined ? coordinatesss : [];
    let i = 0;
    for(let j = 0, jj = endss.length; j < jj; ++j){
        const ends = endss[j];
        coordinatesss[i++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
        offset = ends[ends.length - 1];
    }
    coordinatesss.length = i;
    return coordinatesss;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dh8ns":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/interpolate
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */ parcelHelpers.export(exports, "interpolatePoint", ()=>interpolatePoint);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */ parcelHelpers.export(exports, "lineStringCoordinateAtM", ()=>lineStringCoordinateAtM);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */ parcelHelpers.export(exports, "lineStringsCoordinateAtM", ()=>lineStringsCoordinateAtM);
var _arrayJs = require("../../array.js");
var _mathJs = require("../../math.js");
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
    let o, t;
    const n = (end - offset) / stride;
    if (n === 1) o = offset;
    else if (n === 2) {
        o = offset;
        t = fraction;
    } else if (n !== 0) {
        let x1 = flatCoordinates[offset];
        let y1 = flatCoordinates[offset + 1];
        let length = 0;
        const cumulativeLengths = [
            0
        ];
        for(let i = offset + stride; i < end; i += stride){
            const x2 = flatCoordinates[i];
            const y2 = flatCoordinates[i + 1];
            length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            cumulativeLengths.push(length);
            x1 = x2;
            y1 = y2;
        }
        const target = fraction * length;
        const index = (0, _arrayJs.binarySearch)(cumulativeLengths, target);
        if (index < 0) {
            t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
            o = offset + (-index - 2) * stride;
        } else o = offset + index * stride;
    }
    dimension = dimension > 1 ? dimension : 2;
    dest = dest ? dest : new Array(dimension);
    for(let i = 0; i < dimension; ++i)dest[i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + i] : (0, _mathJs.lerp)(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
    return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
    if (end == offset) return null;
    let coordinate;
    if (m < flatCoordinates[offset + stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(offset, offset + stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        return null;
    }
    if (flatCoordinates[end - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(end - stride, end);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        return null;
    }
    // FIXME use O(1) search
    if (m == flatCoordinates[offset + stride - 1]) return flatCoordinates.slice(offset, offset + stride);
    let lo = offset / stride;
    let hi = end / stride;
    while(lo < hi){
        const mid = lo + hi >> 1;
        if (m < flatCoordinates[(mid + 1) * stride - 1]) hi = mid;
        else lo = mid + 1;
    }
    const m0 = flatCoordinates[lo * stride - 1];
    if (m == m0) return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
    const m1 = flatCoordinates[(lo + 1) * stride - 1];
    const t = (m - m0) / (m1 - m0);
    coordinate = [];
    for(let i = 0; i < stride - 1; ++i)coordinate.push((0, _mathJs.lerp)(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
    coordinate.push(m);
    return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
    if (interpolate) return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
    let coordinate;
    if (m < flatCoordinates[stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(0, stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        return null;
    }
    if (flatCoordinates[flatCoordinates.length - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
            coordinate[stride - 1] = m;
            return coordinate;
        }
        return null;
    }
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        if (offset == end) continue;
        if (m < flatCoordinates[offset + stride - 1]) return null;
        if (m <= flatCoordinates[end - 1]) return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
        offset = end;
    }
    return null;
}

},{"../../array.js":"1Fbic","../../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7x08H":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/intersectsextent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLineString", ()=>intersectsLineString);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLineStringArray", ()=>intersectsLineStringArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRing", ()=>intersectsLinearRing);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRingArray", ()=>intersectsLinearRingArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRingMultiArray", ()=>intersectsLinearRingMultiArray);
var _extentJs = require("../../extent.js");
var _segmentsJs = require("./segments.js");
var _containsJs = require("./contains.js");
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
    const coordinatesExtent = (0, _extentJs.extendFlatCoordinates)((0, _extentJs.createEmpty)(), flatCoordinates, offset, end, stride);
    if (!(0, _extentJs.intersects)(extent, coordinatesExtent)) return false;
    if ((0, _extentJs.containsExtent)(extent, coordinatesExtent)) return true;
    if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) return true;
    if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) return true;
    return (0, _segmentsJs.forEach)(flatCoordinates, offset, end, stride, /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */ function(point1, point2) {
        return (0, _extentJs.intersectsSegment)(extent, point1, point2);
    });
}
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
    for(let i = 0, ii = ends.length; i < ii; ++i){
        if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) return true;
        offset = ends[i];
    }
    return false;
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
    if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[1])) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[3])) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[1])) return true;
    if ((0, _containsJs.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[3])) return true;
    return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
    if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) return false;
    if (ends.length === 1) return true;
    for(let i = 1, ii = ends.length; i < ii; ++i)if ((0, _containsJs.linearRingContainsExtent)(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) return false;
    }
    return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) return true;
        offset = ends[ends.length - 1];
    }
    return false;
}

},{"../../extent.js":"6YrVc","./segments.js":"e7gWa","./contains.js":"eArlN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eArlN":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/contains
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */ parcelHelpers.export(exports, "linearRingContainsExtent", ()=>linearRingContainsExtent);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingContainsXY", ()=>linearRingContainsXY);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingsContainsXY", ()=>linearRingsContainsXY);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingssContainsXY", ()=>linearRingssContainsXY);
var _extentJs = require("../../extent.js");
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
    const outside = (0, _extentJs.forEachCorner)(extent, /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */ function(coordinate) {
        return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
    });
    return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
    // https://geomalgorithms.com/a03-_inclusion.html
    // Copyright 2000 softSurfer, 2012 Dan Sunday
    // This code may be freely used and modified for any purpose
    // providing that this copyright notice is included with it.
    // SoftSurfer makes no warranty for this code, and cannot be held
    // liable for any real or imagined damage resulting from its use.
    // Users of this code must verify correctness for their application.
    let wn = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        if (y1 <= y) {
            if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) wn++;
        } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) wn--;
        x1 = x2;
        y1 = y2;
    }
    return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
    if (ends.length === 0) return false;
    if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) return false;
    for(let i = 1, ii = ends.length; i < ii; ++i){
        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) return false;
    }
    return true;
}
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
    if (endss.length === 0) return false;
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) return true;
        offset = ends[ends.length - 1];
    }
    return false;
}

},{"../../extent.js":"6YrVc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"X5sUU":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/length
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lineStringLength", ()=>lineStringLength);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */ parcelHelpers.export(exports, "linearRingLength", ()=>linearRingLength);
function lineStringLength(flatCoordinates, offset, end, stride) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    let length = 0;
    for(let i = offset + stride; i < end; i += stride){
        const x2 = flatCoordinates[i];
        const y2 = flatCoordinates[i + 1];
        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        x1 = x2;
        y1 = y2;
    }
    return length;
}
function linearRingLength(flatCoordinates, offset, end, stride) {
    let perimeter = lineStringLength(flatCoordinates, offset, end, stride);
    const dx = flatCoordinates[end - stride] - flatCoordinates[offset];
    const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
    perimeter += Math.sqrt(dx * dx + dy * dy);
    return perimeter;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"030lt":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/MultiLineString
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("./LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _arrayJs = require("../array.js");
var _inflateJs = require("./flat/inflate.js");
var _interpolateJs = require("./flat/interpolate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */ class MultiLineString extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */ constructor(coordinates, layout, ends){
        super();
        /**
     * @type {Array<number>}
     * @private
     */ this.ends_ = [];
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        if (Array.isArray(coordinates[0])) this.setCoordinates(/** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ coordinates, layout);
        else if (layout !== undefined && ends) {
            this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
            this.ends_ = ends;
        } else {
            const lineStrings = /** @type {Array<LineString>} */ coordinates;
            /** @type {Array<number>} */ const flatCoordinates = [];
            const ends = [];
            for(let i = 0, ii = lineStrings.length; i < ii; ++i){
                const lineString = lineStrings[i];
                (0, _arrayJs.extend)(flatCoordinates, lineString.getFlatCoordinates());
                ends.push(flatCoordinates.length);
            }
            const layout = lineStrings.length === 0 ? this.getLayout() : lineStrings[0].getLayout();
            this.setFlatCoordinates(layout, flatCoordinates);
            this.ends_ = ends;
        }
    }
    /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */ appendLineString(lineString) {
        (0, _arrayJs.extend)(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */ clone() {
        const multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        multiLineString.applyProperties(this);
        return multiLineString;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */ getCoordinateAtM(m, extrapolate, interpolate) {
        if (this.layout != 'XYM' && this.layout != 'XYZM' || this.flatCoordinates.length === 0) return null;
        extrapolate = extrapolate !== undefined ? extrapolate : false;
        interpolate = interpolate !== undefined ? interpolate : false;
        return (0, _interpolateJs.lineStringsCoordinateAtM)(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
    }
    /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinatesArray)(this.flatCoordinates, 0, this.ends_, this.stride);
    }
    /**
   * @return {Array<number>} Ends.
   */ getEnds() {
        return this.ends_;
    }
    /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */ getLineString(index) {
        if (index < 0 || this.ends_.length <= index) return null;
        return new (0, _lineStringJsDefault.default)(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    }
    /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */ getLineStrings() {
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const layout = this.layout;
        /** @type {Array<LineString>} */ const lineStrings = [];
        let offset = 0;
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const lineString = new (0, _lineStringJsDefault.default)(flatCoordinates.slice(offset, end), layout);
            lineStrings.push(lineString);
            offset = end;
        }
        return lineStrings;
    }
    /**
   * @return {Array<number>} Flat midpoints.
   */ getFlatMidpoints() {
        /** @type {Array<number>} */ const midpoints = [];
        const flatCoordinates = this.flatCoordinates;
        let offset = 0;
        const ends = this.ends_;
        const stride = this.stride;
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const midpoint = (0, _interpolateJs.interpolatePoint)(flatCoordinates, offset, end, stride, 0.5);
            (0, _arrayJs.extend)(midpoints, midpoint);
            offset = end;
        }
        return midpoints;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        /** @type {Array<number>} */ const simplifiedFlatCoordinates = [];
        /** @type {Array<number>} */ const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeuckerArray)(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'MultiLineString';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLineStringArray)(this.flatCoordinates, 0, this.ends_, this.stride, extent);
    }
    /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 2);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        const ends = (0, _deflateJs.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
    }
}
exports.default = MultiLineString;

},{"./LineString.js":"jLUiq","./SimpleGeometry.js":"hLwk3","./flat/closest.js":"fi6H5","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","./flat/simplify.js":"jsqc5","../array.js":"1Fbic","./flat/inflate.js":"4Rpju","./flat/interpolate.js":"dh8ns","./flat/intersectsextent.js":"7x08H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k4LcJ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/MultiPoint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointJs = require("./Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _inflateJs = require("./flat/inflate.js");
var _mathJs = require("../math.js");
/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */ class MultiPoint extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        if (layout && !Array.isArray(coordinates[0])) this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
        else this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ coordinates, layout);
    }
    /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */ appendPoint(point) {
        (0, _arrayJs.extend)(this.flatCoordinates, point.getFlatCoordinates());
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */ clone() {
        const multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
        multiPoint.applyProperties(this);
        return multiPoint;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            const squaredDistance = (0, _mathJs.squaredDistance)(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
            if (squaredDistance < minSquaredDistance) {
                minSquaredDistance = squaredDistance;
                for(let j = 0; j < stride; ++j)closestPoint[j] = flatCoordinates[i + j];
                closestPoint.length = stride;
            }
        }
        return minSquaredDistance;
    }
    /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */ getPoint(index) {
        const n = this.flatCoordinates.length / this.stride;
        if (index < 0 || n <= index) return null;
        return new (0, _pointJsDefault.default)(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
    }
    /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */ getPoints() {
        const flatCoordinates = this.flatCoordinates;
        const layout = this.layout;
        const stride = this.stride;
        /** @type {Array<Point>} */ const points = [];
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            const point = new (0, _pointJsDefault.default)(flatCoordinates.slice(i, i + stride), layout);
            points.push(point);
        }
        return points;
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'MultiPoint';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            const x = flatCoordinates[i];
            const y = flatCoordinates[i + 1];
            if ((0, _extentJs.containsXY)(extent, x, y)) return true;
        }
        return false;
    }
    /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = MultiPoint;

},{"./Point.js":"hx2Ar","./SimpleGeometry.js":"hLwk3","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","../array.js":"1Fbic","./flat/inflate.js":"4Rpju","../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hx2Ar":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/Point
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _mathJs = require("../math.js");
/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */ class Point extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        this.setCoordinates(coordinates, layout);
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */ clone() {
        const point = new Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const squaredDistance = (0, _mathJs.squaredDistance)(x, y, flatCoordinates[0], flatCoordinates[1]);
        if (squaredDistance < minSquaredDistance) {
            const stride = this.stride;
            for(let i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[i];
            closestPoint.length = stride;
            return squaredDistance;
        }
        return minSquaredDistance;
    }
    /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */ getCoordinates() {
        return this.flatCoordinates.slice();
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        return (0, _extentJs.createOrUpdateFromCoordinate)(this.flatCoordinates, extent);
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'Point';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _extentJs.containsXY)(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
    }
    /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 0);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinate)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = Point;

},{"./SimpleGeometry.js":"hLwk3","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2XIqx":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/MultiPolygon
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _multiPointJs = require("./MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _polygonJs = require("./Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("./flat/interiorpoint.js");
var _inflateJs = require("./flat/inflate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _orientJs = require("./flat/orient.js");
var _areaJs = require("./flat/area.js");
var _centerJs = require("./flat/center.js");
var _containsJs = require("./flat/contains.js");
var _simplifyJs = require("./flat/simplify.js");
/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */ class MultiPolygon extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */ constructor(coordinates, layout, endss){
        super();
        /**
     * @type {Array<Array<number>>}
     * @private
     */ this.endss_ = [];
        /**
     * @private
     * @type {number}
     */ this.flatInteriorPointsRevision_ = -1;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.flatInteriorPoints_ = null;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.orientedRevision_ = -1;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.orientedFlatCoordinates_ = null;
        if (!endss && !Array.isArray(coordinates[0])) {
            const polygons = /** @type {Array<Polygon>} */ coordinates;
            /** @type {Array<number>} */ const flatCoordinates = [];
            const thisEndss = [];
            for(let i = 0, ii = polygons.length; i < ii; ++i){
                const polygon = polygons[i];
                const offset = flatCoordinates.length;
                const ends = polygon.getEnds();
                for(let j = 0, jj = ends.length; j < jj; ++j)ends[j] += offset;
                (0, _arrayJs.extend)(flatCoordinates, polygon.getFlatCoordinates());
                thisEndss.push(ends);
            }
            layout = polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();
            coordinates = flatCoordinates;
            endss = thisEndss;
        }
        if (layout !== undefined && endss) {
            this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
            this.endss_ = endss;
        } else this.setCoordinates(/** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ coordinates, layout);
    }
    /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */ appendPolygon(polygon) {
        /** @type {Array<number>} */ let ends;
        if (!this.flatCoordinates) {
            this.flatCoordinates = polygon.getFlatCoordinates().slice();
            ends = polygon.getEnds().slice();
            this.endss_.push();
        } else {
            const offset = this.flatCoordinates.length;
            (0, _arrayJs.extend)(this.flatCoordinates, polygon.getFlatCoordinates());
            ends = polygon.getEnds().slice();
            for(let i = 0, ii = ends.length; i < ii; ++i)ends[i] += offset;
        }
        this.endss_.push(ends);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */ clone() {
        const len = this.endss_.length;
        const newEndss = new Array(len);
        for(let i = 0; i < len; ++i)newEndss[i] = this.endss_[i].slice();
        const multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
        multiPolygon.applyProperties(this);
        return multiPolygon;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.multiArrayMaxSquaredDelta)(this.flatCoordinates, 0, this.endss_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestMultiArrayPoint)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        return (0, _containsJs.linearRingssContainsXY)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
    }
    /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */ getArea() {
        return (0, _areaJs.linearRingss)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
    }
    /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */ getCoordinates(right) {
        let flatCoordinates;
        if (right !== undefined) {
            flatCoordinates = this.getOrientedFlatCoordinates().slice();
            (0, _orientJs.orientLinearRingsArray)(flatCoordinates, 0, this.endss_, this.stride, right);
        } else flatCoordinates = this.flatCoordinates;
        return (0, _inflateJs.inflateMultiCoordinatesArray)(flatCoordinates, 0, this.endss_, this.stride);
    }
    /**
   * @return {Array<Array<number>>} Endss.
   */ getEndss() {
        return this.endss_;
    }
    /**
   * @return {Array<number>} Flat interior points.
   */ getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
            const flatCenters = (0, _centerJs.linearRingss)(this.flatCoordinates, 0, this.endss_, this.stride);
            this.flatInteriorPoints_ = (0, _interiorpointJs.getInteriorPointsOfMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
            this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return /** @type {Array<number>} */ this.flatInteriorPoints_;
    }
    /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */ getInteriorPoints() {
        return new (0, _multiPointJsDefault.default)(this.getFlatInteriorPoints().slice(), 'XYM');
    }
    /**
   * @return {Array<number>} Oriented flat coordinates.
   */ getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
            const flatCoordinates = this.flatCoordinates;
            if ((0, _orientJs.linearRingssAreOriented)(flatCoordinates, 0, this.endss_, this.stride)) this.orientedFlatCoordinates_ = flatCoordinates;
            else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = (0, _orientJs.orientLinearRingsArray)(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
            }
            this.orientedRevision_ = this.getRevision();
        }
        return /** @type {Array<number>} */ this.orientedFlatCoordinates_;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        /** @type {Array<number>} */ const simplifiedFlatCoordinates = [];
        /** @type {Array<Array<number>>} */ const simplifiedEndss = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.quantizeMultiArray)(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
        return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);
    }
    /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */ getPolygon(index) {
        if (index < 0 || this.endss_.length <= index) return null;
        let offset;
        if (index === 0) offset = 0;
        else {
            const prevEnds = this.endss_[index - 1];
            offset = prevEnds[prevEnds.length - 1];
        }
        const ends = this.endss_[index].slice();
        const end = ends[ends.length - 1];
        if (offset !== 0) for(let i = 0, ii = ends.length; i < ii; ++i)ends[i] -= offset;
        return new (0, _polygonJsDefault.default)(this.flatCoordinates.slice(offset, end), this.layout, ends);
    }
    /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */ getPolygons() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const endss = this.endss_;
        const polygons = [];
        let offset = 0;
        for(let i = 0, ii = endss.length; i < ii; ++i){
            const ends = endss[i].slice();
            const end = ends[ends.length - 1];
            if (offset !== 0) for(let j = 0, jj = ends.length; j < jj; ++j)ends[j] -= offset;
            const polygon = new (0, _polygonJsDefault.default)(flatCoordinates.slice(offset, end), layout, ends);
            polygons.push(polygon);
            offset = end;
        }
        return polygons;
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'MultiPolygon';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLinearRingMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
    }
    /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 3);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        const endss = (0, _deflateJs.deflateMultiCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
        if (endss.length === 0) this.flatCoordinates.length = 0;
        else {
            const lastEnds = endss[endss.length - 1];
            this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
    }
}
exports.default = MultiPolygon;

},{"./MultiPoint.js":"k4LcJ","./Polygon.js":"cJuQF","./SimpleGeometry.js":"hLwk3","./flat/closest.js":"fi6H5","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","../array.js":"1Fbic","./flat/interiorpoint.js":"59VP9","./flat/inflate.js":"4Rpju","./flat/intersectsextent.js":"7x08H","./flat/orient.js":"btd6s","./flat/area.js":"7fT8A","./flat/center.js":"9OVXr","./flat/contains.js":"eArlN","./flat/simplify.js":"jsqc5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cJuQF":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/Polygon
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */ parcelHelpers.export(exports, "circular", ()=>circular);
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */ parcelHelpers.export(exports, "fromExtent", ()=>fromExtent);
/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [sides] Number of sides of the polygon. Default is 32.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */ parcelHelpers.export(exports, "fromCircle", ()=>fromCircle);
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */ parcelHelpers.export(exports, "makeRegular", ()=>makeRegular);
var _linearRingJs = require("./LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _pointJs = require("./Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("./flat/interiorpoint.js");
var _inflateJs = require("./flat/inflate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _orientJs = require("./flat/orient.js");
var _areaJs = require("./flat/area.js");
var _containsJs = require("./flat/contains.js");
var _mathJs = require("../math.js");
var _simplifyJs = require("./flat/simplify.js");
var _sphereJs = require("../sphere.js");
/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */ class Polygon extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */ constructor(coordinates, layout, ends){
        super();
        /**
     * @type {Array<number>}
     * @private
     */ this.ends_ = [];
        /**
     * @private
     * @type {number}
     */ this.flatInteriorPointRevision_ = -1;
        /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */ this.flatInteriorPoint_ = null;
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.orientedRevision_ = -1;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.orientedFlatCoordinates_ = null;
        if (layout !== undefined && ends) {
            this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
            this.ends_ = ends;
        } else this.setCoordinates(/** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ coordinates, layout);
    }
    /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */ appendLinearRing(linearRing) {
        if (!this.flatCoordinates) this.flatCoordinates = linearRing.getFlatCoordinates().slice();
        else (0, _arrayJs.extend)(this.flatCoordinates, linearRing.getFlatCoordinates());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */ clone() {
        const polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        polygon.applyProperties(this);
        return polygon;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        return (0, _containsJs.linearRingsContainsXY)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
    }
    /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */ getArea() {
        return (0, _areaJs.linearRings)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
    }
    /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */ getCoordinates(right) {
        let flatCoordinates;
        if (right !== undefined) {
            flatCoordinates = this.getOrientedFlatCoordinates().slice();
            (0, _orientJs.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, right);
        } else flatCoordinates = this.flatCoordinates;
        return (0, _inflateJs.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
    }
    /**
   * @return {Array<number>} Ends.
   */ getEnds() {
        return this.ends_;
    }
    /**
   * @return {Array<number>} Interior point.
   */ getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
            const flatCenter = (0, _extentJs.getCenter)(this.getExtent());
            this.flatInteriorPoint_ = (0, _interiorpointJs.getInteriorPointOfArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
            this.flatInteriorPointRevision_ = this.getRevision();
        }
        return /** @type {import("../coordinate.js").Coordinate} */ this.flatInteriorPoint_;
    }
    /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */ getInteriorPoint() {
        return new (0, _pointJsDefault.default)(this.getFlatInteriorPoint(), 'XYM');
    }
    /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */ getLinearRingCount() {
        return this.ends_.length;
    }
    /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */ getLinearRing(index) {
        if (index < 0 || this.ends_.length <= index) return null;
        return new (0, _linearRingJsDefault.default)(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    }
    /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */ getLinearRings() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const linearRings = [];
        let offset = 0;
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const linearRing = new (0, _linearRingJsDefault.default)(flatCoordinates.slice(offset, end), layout);
            linearRings.push(linearRing);
            offset = end;
        }
        return linearRings;
    }
    /**
   * @return {Array<number>} Oriented flat coordinates.
   */ getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
            const flatCoordinates = this.flatCoordinates;
            if ((0, _orientJs.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride)) this.orientedFlatCoordinates_ = flatCoordinates;
            else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = (0, _orientJs.orientLinearRings)(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
            }
            this.orientedRevision_ = this.getRevision();
        }
        return /** @type {Array<number>} */ this.orientedFlatCoordinates_;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        /** @type {Array<number>} */ const simplifiedFlatCoordinates = [];
        /** @type {Array<number>} */ const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.quantizeArray)(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'Polygon';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return (0, _intersectsextentJs.intersectsLinearRingArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
    }
    /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 2);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        const ends = (0, _deflateJs.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
    }
}
exports.default = Polygon;
function circular(center, radius, n, sphereRadius) {
    n = n ? n : 32;
    /** @type {Array<number>} */ const flatCoordinates = [];
    for(let i = 0; i < n; ++i)(0, _arrayJs.extend)(flatCoordinates, (0, _sphereJs.offset)(center, radius, 2 * Math.PI * i / n, sphereRadius));
    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
    return new Polygon(flatCoordinates, 'XY', [
        flatCoordinates.length
    ]);
}
function fromExtent(extent) {
    if ((0, _extentJs.isEmpty)(extent)) throw new Error('Cannot create polygon from empty extent');
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const flatCoordinates = [
        minX,
        minY,
        minX,
        maxY,
        maxX,
        maxY,
        maxX,
        minY,
        minX,
        minY
    ];
    return new Polygon(flatCoordinates, 'XY', [
        flatCoordinates.length
    ]);
}
function fromCircle(circle, sides, angle) {
    sides = sides ? sides : 32;
    const stride = circle.getStride();
    const layout = circle.getLayout();
    const center = circle.getCenter();
    const arrayLength = stride * (sides + 1);
    const flatCoordinates = new Array(arrayLength);
    for(let i = 0; i < arrayLength; i += stride){
        flatCoordinates[i] = 0;
        flatCoordinates[i + 1] = 0;
        for(let j = 2; j < stride; j++)flatCoordinates[i + j] = center[j];
    }
    const ends = [
        flatCoordinates.length
    ];
    const polygon = new Polygon(flatCoordinates, layout, ends);
    makeRegular(polygon, center, circle.getRadius(), angle);
    return polygon;
}
function makeRegular(polygon, center, radius, angle) {
    const flatCoordinates = polygon.getFlatCoordinates();
    const stride = polygon.getStride();
    const sides = flatCoordinates.length / stride - 1;
    const startAngle = angle ? angle : 0;
    for(let i = 0; i <= sides; ++i){
        const offset = i * stride;
        const angle = startAngle + (0, _mathJs.modulo)(i, sides) * 2 * Math.PI / sides;
        flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
        flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
    }
    polygon.changed();
}

},{"./LinearRing.js":"jg1hj","./Point.js":"hx2Ar","./SimpleGeometry.js":"hLwk3","./flat/closest.js":"fi6H5","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","../array.js":"1Fbic","./flat/interiorpoint.js":"59VP9","./flat/inflate.js":"4Rpju","./flat/intersectsextent.js":"7x08H","./flat/orient.js":"btd6s","./flat/area.js":"7fT8A","./flat/contains.js":"eArlN","../math.js":"5jEFr","./flat/simplify.js":"jsqc5","../sphere.js":"eJjHw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jg1hj":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/LinearRing
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _inflateJs = require("./flat/inflate.js");
var _areaJs = require("./flat/area.js");
/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */ class LinearRing extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(coordinates, layout){
        super();
        /**
     * @private
     * @type {number}
     */ this.maxDelta_ = -1;
        /**
     * @private
     * @type {number}
     */ this.maxDeltaRevision_ = -1;
        if (layout !== undefined && !Array.isArray(coordinates[0])) this.setFlatCoordinates(layout, /** @type {Array<number>} */ coordinates);
        else this.setCoordinates(/** @type {Array<import("../coordinate.js").Coordinate>} */ coordinates, layout);
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */ clone() {
        return new LinearRing(this.flatCoordinates.slice(), this.layout);
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < (0, _extentJs.closestSquaredDistanceXY)(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt((0, _closestJs.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return (0, _closestJs.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    }
    /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */ getArea() {
        return (0, _areaJs.linearRing)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */ getCoordinates() {
        return (0, _inflateJs.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */ getSimplifiedGeometryInternal(squaredTolerance) {
        /** @type {Array<number>} */ const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LinearRing(simplifiedFlatCoordinates, 'XY');
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'LinearRing';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        return false;
    }
    /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = (0, _deflateJs.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    }
}
exports.default = LinearRing;

},{"./SimpleGeometry.js":"hLwk3","./flat/closest.js":"fi6H5","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","./flat/simplify.js":"jsqc5","./flat/inflate.js":"4Rpju","./flat/area.js":"7fT8A","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7fT8A":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/area
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "linearRing", ()=>linearRing);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ parcelHelpers.export(exports, "linearRings", ()=>linearRings);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ parcelHelpers.export(exports, "linearRingss", ()=>linearRingss);
function linearRing(flatCoordinates, offset, end, stride) {
    let twiceArea = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        twiceArea += y1 * x2 - x1 * y2;
        x1 = x2;
        y1 = y2;
    }
    return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
    let area = 0;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        area += linearRing(flatCoordinates, offset, end, stride);
        offset = end;
    }
    return area;
}
function linearRingss(flatCoordinates, offset, endss, stride) {
    let area = 0;
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        area += linearRings(flatCoordinates, offset, ends, stride);
        offset = ends[ends.length - 1];
    }
    return area;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"59VP9":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/interiorpoint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */ parcelHelpers.export(exports, "getInteriorPointOfArray", ()=>getInteriorPointOfArray);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */ parcelHelpers.export(exports, "getInteriorPointsOfMultiArray", ()=>getInteriorPointsOfMultiArray);
var _arrayJs = require("../../array.js");
var _containsJs = require("./contains.js");
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
    let i, ii, x, x1, x2, y1, y2;
    const y = flatCenters[flatCentersOffset + 1];
    /** @type {Array<number>} */ const intersections = [];
    // Calculate intersections with the horizontal line
    for(let r = 0, rr = ends.length; r < rr; ++r){
        const end = ends[r];
        x1 = flatCoordinates[end - stride];
        y1 = flatCoordinates[end - stride + 1];
        for(i = offset; i < end; i += stride){
            x2 = flatCoordinates[i];
            y2 = flatCoordinates[i + 1];
            if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
                x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
                intersections.push(x);
            }
            x1 = x2;
            y1 = y2;
        }
    }
    // Find the longest segment of the horizontal line that has its center point
    // inside the linear ring.
    let pointX = NaN;
    let maxSegmentLength = -Infinity;
    intersections.sort((0, _arrayJs.ascending));
    x1 = intersections[0];
    for(i = 1, ii = intersections.length; i < ii; ++i){
        x2 = intersections[i];
        const segmentLength = Math.abs(x2 - x1);
        if (segmentLength > maxSegmentLength) {
            x = (x1 + x2) / 2;
            if ((0, _containsJs.linearRingsContainsXY)(flatCoordinates, offset, ends, stride, x, y)) {
                pointX = x;
                maxSegmentLength = segmentLength;
            }
        }
        x1 = x2;
    }
    if (isNaN(pointX)) // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
    if (dest) {
        dest.push(pointX, y, maxSegmentLength);
        return dest;
    }
    return [
        pointX,
        y,
        maxSegmentLength
    ];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
    /** @type {Array<number>} */ let interiorPoints = [];
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
        offset = ends[ends.length - 1];
    }
    return interiorPoints;
}

},{"../../array.js":"1Fbic","./contains.js":"eArlN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"btd6s":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/orient
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean|undefined} Is clockwise.
 */ parcelHelpers.export(exports, "linearRingIsClockwise", ()=>linearRingIsClockwise);
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */ parcelHelpers.export(exports, "linearRingsAreOriented", ()=>linearRingsAreOriented);
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */ parcelHelpers.export(exports, "linearRingssAreOriented", ()=>linearRingssAreOriented);
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */ parcelHelpers.export(exports, "orientLinearRings", ()=>orientLinearRings);
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */ parcelHelpers.export(exports, "orientLinearRingsArray", ()=>orientLinearRingsArray);
/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to construct a MultiPolygon
 */ parcelHelpers.export(exports, "inflateEnds", ()=>inflateEnds);
var _reverseJs = require("./reverse.js");
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
    // https://stackoverflow.com/q/1165647/clockwise-method#1165943
    // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
    let edge = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        const x2 = flatCoordinates[offset];
        const y2 = flatCoordinates[offset + 1];
        edge += (x2 - x1) * (y2 + y1);
        x1 = x2;
        y1 = y2;
    }
    return edge === 0 ? undefined : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
    right = right !== undefined ? right : false;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        const isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
        if (i === 0) {
            if (right && isClockwise || !right && !isClockwise) return false;
        } else {
            if (right && !isClockwise || !right && isClockwise) return false;
        }
        offset = end;
    }
    return true;
}
function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) return false;
        if (ends.length) offset = ends[ends.length - 1];
    }
    return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
    right = right !== undefined ? right : false;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        const isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
        const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
        if (reverse) (0, _reverseJs.coordinates)(flatCoordinates, offset, end, stride);
        offset = end;
    }
    return offset;
}
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {
    for(let i = 0, ii = endss.length; i < ii; ++i)offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, right);
    return offset;
}
function inflateEnds(flatCoordinates, ends) {
    const endss = [];
    let offset = 0;
    let prevEndIndex = 0;
    let startOrientation;
    for(let i = 0, ii = ends.length; i < ii; ++i){
        const end = ends[i];
        // classifies an array of rings into polygons with outer rings and holes
        const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
        if (startOrientation === undefined) startOrientation = orientation;
        if (orientation === startOrientation) endss.push(ends.slice(prevEndIndex, i + 1));
        else {
            if (endss.length === 0) continue;
            endss[endss.length - 1].push(ends[prevEndIndex]);
        }
        prevEndIndex = i + 1;
        offset = end;
    }
    return endss;
}

},{"./reverse.js":"hksTe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hksTe":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/reverse
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "coordinates", ()=>coordinates);
function coordinates(flatCoordinates, offset, end, stride) {
    while(offset < end - stride){
        for(let i = 0; i < stride; ++i){
            const tmp = flatCoordinates[offset + i];
            flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
            flatCoordinates[end - stride + i] = tmp;
        }
        offset += stride;
        end -= stride;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9OVXr":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/center
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */ parcelHelpers.export(exports, "linearRingss", ()=>linearRingss);
var _extentJs = require("../../extent.js");
function linearRingss(flatCoordinates, offset, endss, stride) {
    const flatCenters = [];
    let extent = (0, _extentJs.createEmpty)();
    for(let i = 0, ii = endss.length; i < ii; ++i){
        const ends = endss[i];
        extent = (0, _extentJs.createOrUpdateFromFlatCoordinates)(flatCoordinates, offset, ends[0], stride);
        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
        offset = ends[ends.length - 1];
    }
    return flatCenters;
}

},{"../../extent.js":"6YrVc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Oc3i":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/Feature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a geometry from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature
 * Render Feature
 * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}
 * New geometry instance.
 * @api
 */ parcelHelpers.export(exports, "toGeometry", ()=>toGeometry);
/**
 * Create an `ol/Feature` from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature RenderFeature
 * @param {string} [geometryName='geometry'] Geometry name to use
 * when creating the Feature.
 * @return {Feature} Newly constructed `ol/Feature` with properties,
 * geometry, and id copied over.
 * @api
 */ parcelHelpers.export(exports, "toFeature", ()=>toFeature);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geomJs = require("../geom.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _simplifyJs = require("../geom/flat/simplify.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("../geom/flat/interiorpoint.js");
var _projJs = require("../proj.js");
var _orientJs = require("../geom/flat/orient.js");
var _interpolateJs = require("../geom/flat/interpolate.js");
var _centerJs = require("../geom/flat/center.js");
var _functionsJs = require("../functions.js");
var _transformJs1 = require("../geom/flat/transform.js");
/**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.
 */ /**
 * @type {import("../transform.js").Transform}
 */ const tmpTransform = (0, _transformJs.create)();
/**
 * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like
 * structure, optimized for vector tile rendering and styling. Geometry access
 * through the API is limited to getting the type and extent of the geometry.
 */ class RenderFeature {
    /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */ constructor(type, flatCoordinates, ends, stride, properties, id){
        /**
     * @type {import("../style/Style.js").StyleFunction|undefined}
     */ this.styleFunction;
        /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */ this.extent_;
        /**
     * @private
     * @type {number|string|undefined}
     */ this.id_ = id;
        /**
     * @private
     * @type {Type}
     */ this.type_ = type;
        /**
     * @private
     * @type {Array<number>}
     */ this.flatCoordinates_ = flatCoordinates;
        /**
     * @private
     * @type {Array<number>}
     */ this.flatInteriorPoints_ = null;
        /**
     * @private
     * @type {Array<number>}
     */ this.flatMidpoints_ = null;
        /**
     * @private
     * @type {Array<number>}
     */ this.ends_ = ends;
        /**
     * @private
     * @type {Object<string, *>}
     */ this.properties_ = properties;
        /**
     * @type {number}
     */ this.squaredTolerance_;
        /**
     * @type {number}
     */ this.stride_ = stride;
        /**
     * @private
     * @type {RenderFeature}
     */ this.simplifiedGeometry_;
    }
    /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */ get(key) {
        return this.properties_[key];
    }
    /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent() {
        if (!this.extent_) this.extent_ = this.type_ === 'Point' ? (0, _extentJs.createOrUpdateFromCoordinate)(this.flatCoordinates_) : (0, _extentJs.createOrUpdateFromFlatCoordinates)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
        return this.extent_;
    }
    /**
   * @return {Array<number>} Flat interior points.
   */ getFlatInteriorPoint() {
        if (!this.flatInteriorPoints_) {
            const flatCenter = (0, _extentJs.getCenter)(this.getExtent());
            this.flatInteriorPoints_ = (0, _interiorpointJs.getInteriorPointOfArray)(this.flatCoordinates_, 0, /** @type {Array<number>} */ this.ends_, 2, flatCenter, 0);
        }
        return this.flatInteriorPoints_;
    }
    /**
   * @return {Array<number>} Flat interior points.
   */ getFlatInteriorPoints() {
        if (!this.flatInteriorPoints_) {
            const ends = (0, _orientJs.inflateEnds)(this.flatCoordinates_, this.ends_);
            const flatCenters = (0, _centerJs.linearRingss)(this.flatCoordinates_, 0, ends, 2);
            this.flatInteriorPoints_ = (0, _interiorpointJs.getInteriorPointsOfMultiArray)(this.flatCoordinates_, 0, ends, 2, flatCenters);
        }
        return this.flatInteriorPoints_;
    }
    /**
   * @return {Array<number>} Flat midpoint.
   */ getFlatMidpoint() {
        if (!this.flatMidpoints_) this.flatMidpoints_ = (0, _interpolateJs.interpolatePoint)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
        return this.flatMidpoints_;
    }
    /**
   * @return {Array<number>} Flat midpoints.
   */ getFlatMidpoints() {
        if (!this.flatMidpoints_) {
            this.flatMidpoints_ = [];
            const flatCoordinates = this.flatCoordinates_;
            let offset = 0;
            const ends = /** @type {Array<number>} */ this.ends_;
            for(let i = 0, ii = ends.length; i < ii; ++i){
                const end = ends[i];
                const midpoint = (0, _interpolateJs.interpolatePoint)(flatCoordinates, offset, end, 2, 0.5);
                (0, _arrayJs.extend)(this.flatMidpoints_, midpoint);
                offset = end;
            }
        }
        return this.flatMidpoints_;
    }
    /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */ getId() {
        return this.id_;
    }
    /**
   * @return {Array<number>} Flat coordinates.
   */ getOrientedFlatCoordinates() {
        return this.flatCoordinates_;
    }
    /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */ getGeometry() {
        return this;
    }
    /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */ getSimplifiedGeometry(squaredTolerance) {
        return this;
    }
    /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */ simplifyTransformed(squaredTolerance, transform) {
        return this;
    }
    /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */ getProperties() {
        return this.properties_;
    }
    /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */ getPropertiesInternal() {
        return this.properties_;
    }
    /**
   * @return {number} Stride.
   */ getStride() {
        return this.stride_;
    }
    /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */ getStyleFunction() {
        return this.styleFunction;
    }
    /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */ getType() {
        return this.type_;
    }
    /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */ transform(projection) {
        projection = (0, _projJs.get)(projection);
        const pixelExtent = projection.getExtent();
        const projectedExtent = projection.getWorldExtent();
        if (pixelExtent && projectedExtent) {
            const scale = (0, _extentJs.getHeight)(projectedExtent) / (0, _extentJs.getHeight)(pixelExtent);
            (0, _transformJs.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
            (0, _transformJs1.transform2D)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);
        }
    }
    /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */ applyTransform(transformFn) {
        transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
    }
    /**
   * @return {RenderFeature} A cloned render feature.
   */ clone() {
        return new RenderFeature(this.type_, this.flatCoordinates_.slice(), this.ends_.slice(), this.stride_, Object.assign({}, this.properties_), this.id_);
    }
    /**
   * @return {Array<number>} Ends.
   */ getEnds() {
        return this.ends_;
    }
    /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */ enableSimplifyTransformed() {
        this.simplifyTransformed = (0, _functionsJs.memoizeOne)((squaredTolerance, transform)=>{
            if (squaredTolerance === this.squaredTolerance_) return this.simplifiedGeometry_;
            this.simplifiedGeometry_ = this.clone();
            if (transform) this.simplifiedGeometry_.applyTransform(transform);
            const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();
            let simplifiedEnds;
            switch(this.type_){
                case 'LineString':
                    simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeucker)(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.flatCoordinates_.length, this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0);
                    simplifiedEnds = [
                        simplifiedFlatCoordinates.length
                    ];
                    break;
                case 'MultiLineString':
                    simplifiedEnds = [];
                    simplifiedFlatCoordinates.length = (0, _simplifyJs.douglasPeuckerArray)(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
                    break;
                case 'Polygon':
                    simplifiedEnds = [];
                    simplifiedFlatCoordinates.length = (0, _simplifyJs.quantizeArray)(simplifiedFlatCoordinates, 0, this.simplifiedGeometry_.ends_, this.simplifiedGeometry_.stride_, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
                    break;
                default:
            }
            if (simplifiedEnds) this.simplifiedGeometry_ = new RenderFeature(this.type_, simplifiedFlatCoordinates, simplifiedEnds, 2, this.properties_, this.id_);
            this.squaredTolerance_ = squaredTolerance;
            return this.simplifiedGeometry_;
        });
        return this;
    }
}
/**
 * @return {Array<number>} Flat coordinates.
 */ RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
function toGeometry(renderFeature) {
    const geometryType = renderFeature.getType();
    switch(geometryType){
        case 'Point':
            return new (0, _geomJs.Point)(renderFeature.getFlatCoordinates());
        case 'MultiPoint':
            return new (0, _geomJs.MultiPoint)(renderFeature.getFlatCoordinates(), 'XY');
        case 'LineString':
            return new (0, _geomJs.LineString)(renderFeature.getFlatCoordinates(), 'XY');
        case 'MultiLineString':
            return new (0, _geomJs.MultiLineString)(renderFeature.getFlatCoordinates(), 'XY', /** @type {Array<number>} */ renderFeature.getEnds());
        case 'Polygon':
            const flatCoordinates = renderFeature.getFlatCoordinates();
            const ends = /** @type {Array<number>} */ renderFeature.getEnds();
            const endss = (0, _orientJs.inflateEnds)(flatCoordinates, ends);
            return endss.length > 1 ? new (0, _geomJs.MultiPolygon)(flatCoordinates, 'XY', endss) : new (0, _geomJs.Polygon)(flatCoordinates, 'XY', ends);
        default:
            throw new Error('Invalid geometry type:' + geometryType);
    }
}
function toFeature(renderFeature, geometryName) {
    const id = renderFeature.getId();
    const geometry = toGeometry(renderFeature);
    const properties = renderFeature.getProperties();
    const feature = new (0, _featureJsDefault.default)();
    if (geometryName !== undefined) feature.setGeometryName(geometryName);
    feature.setGeometry(geometry);
    if (id !== undefined) feature.setId(id);
    feature.setProperties(properties, true);
    return feature;
}
exports.default = RenderFeature;

},{"../Feature.js":"liabO","../geom.js":"8Nc7o","../transform.js":"1BqUf","../extent.js":"6YrVc","../geom/flat/simplify.js":"jsqc5","../array.js":"1Fbic","../geom/flat/interiorpoint.js":"59VP9","../proj.js":"SznqC","../geom/flat/orient.js":"btd6s","../geom/flat/interpolate.js":"dh8ns","../geom/flat/center.js":"9OVXr","../functions.js":"iqv8I","../geom/flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Nc7o":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Circle", ()=>(0, _circleJsDefault.default));
parcelHelpers.export(exports, "Geometry", ()=>(0, _geometryJsDefault.default));
parcelHelpers.export(exports, "GeometryCollection", ()=>(0, _geometryCollectionJsDefault.default));
parcelHelpers.export(exports, "LinearRing", ()=>(0, _linearRingJsDefault.default));
parcelHelpers.export(exports, "LineString", ()=>(0, _lineStringJsDefault.default));
parcelHelpers.export(exports, "MultiLineString", ()=>(0, _multiLineStringJsDefault.default));
parcelHelpers.export(exports, "MultiPoint", ()=>(0, _multiPointJsDefault.default));
parcelHelpers.export(exports, "MultiPolygon", ()=>(0, _multiPolygonJsDefault.default));
parcelHelpers.export(exports, "Point", ()=>(0, _pointJsDefault.default));
parcelHelpers.export(exports, "Polygon", ()=>(0, _polygonJsDefault.default));
parcelHelpers.export(exports, "SimpleGeometry", ()=>(0, _simpleGeometryJsDefault.default));
var _circleJs = require("./geom/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _geometryJs = require("./geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _geometryCollectionJs = require("./geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _linearRingJs = require("./geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _lineStringJs = require("./geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _multiLineStringJs = require("./geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPointJs = require("./geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _multiPolygonJs = require("./geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _pointJs = require("./geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("./geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _simpleGeometryJs = require("./geom/SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);

},{"./geom/Circle.js":false,"./geom/Geometry.js":false,"./geom/GeometryCollection.js":"fDMaj","./geom/LinearRing.js":false,"./geom/LineString.js":"jLUiq","./geom/MultiLineString.js":"030lt","./geom/MultiPoint.js":"k4LcJ","./geom/MultiPolygon.js":"2XIqx","./geom/Point.js":"hx2Ar","./geom/Polygon.js":"cJuQF","./geom/SimpleGeometry.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"FZbV5":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/Feature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @template {import("../geom/Geometry.js").default|RenderFeature} T
 * @param {T} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {WriteOptions|ReadOptions} [options] Options.
 * @return {T} Transformed geometry.
 */ parcelHelpers.export(exports, "transformGeometryWithOptions", ()=>transformGeometryWithOptions);
/**
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {ReadOptions} [options] Read options.
 * @return {import("../extent.js").Extent} Transformed extent.
 */ parcelHelpers.export(exports, "transformExtentWithOptions", ()=>transformExtentWithOptions);
/**
 * @param {FeatureObject} object Feature object.
 * @param {WriteOptions|ReadOptions} [options] Options.
 * @return {RenderFeature|Array<RenderFeature>} Render feature.
 */ parcelHelpers.export(exports, "createRenderFeature", ()=>createRenderFeature);
/**
 * @param {GeometryObject|null} object Geometry object.
 * @param {WriteOptions|ReadOptions} [options] Options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */ parcelHelpers.export(exports, "createGeometry", ()=>createGeometry);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _featureJs1 = require("../render/Feature.js");
var _featureJsDefault1 = parcelHelpers.interopDefault(_featureJs1);
var _geomJs = require("../geom.js");
var _utilJs = require("../util.js");
var _projJs = require("../proj.js");
var _orientJs = require("../geom/flat/orient.js");
/**
 * @typedef {Object} ReadOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
 * If not provided, the projection will be derived from the data (where possible) or
 * the `dataProjection` of the format is assigned (where set). If the projection
 * can not be derived from the data and if no `dataProjection` is set for a format,
 * the features will not be reprojected.
 * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
 * This is only required when reading data with tile pixels as geometry units. When configured,
 * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
 * provided.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * created by the format reader. If not provided, features will be returned in the
 * `dataProjection`.
 */ /**
 * @typedef {Object} WriteOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
 * If not provided, the `dataProjection` of the format is assigned (where set).
 * If no `dataProjection` is set for a format, the features will be returned
 * in the `featureProjection`.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * that will be serialized by the format writer. If not provided, geometries are assumed
 * to be in the `dataProjection` if that is set; in other words, they are not transformed.
 * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
 * rule for linear ring orientation.  This means that polygons will have counter-clockwise
 * exterior rings and clockwise interior rings.  By default, coordinates are serialized
 * as they are provided at construction.  If `true`, the right-hand rule will
 * be applied.  If `false`, the left-hand rule will be applied (clockwise for
 * exterior and counter-clockwise for interior rings).  Note that not all
 * formats support this.  The GeoJSON format does use this property when writing
 * geometries.
 * @property {number} [decimals] Maximum number of decimal places for coordinates.
 * Coordinates are stored internally as floats, but floating-point arithmetic can create
 * coordinates with a large number of decimal places, not generally wanted on output.
 * Set a number here to round coordinates. Can also be used to ensure that
 * coordinates read in can be written back out with the same number of decimals.
 * Default is no rounding.
 */ /**
 * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type
 */ /**
 * @typedef {Object} SimpleGeometryObject
 * @property {import('../geom/Geometry.js').Type} type Type.
 * @property {Array<number>} flatCoordinates Flat coordinates.
 * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.
 * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.
 */ /**
 * @typedef {Array<GeometryObject>} GeometryCollectionObject
 */ /**
 * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject
 */ /**
 * @typedef {Object} FeatureObject
 * @property {string|number} [id] Id.
 * @property {GeometryObject} [geometry] Geometry.
 * @property {Object<string, *>} [properties] Properties.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
 * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @abstract
 * @api
 */ class FeatureFormat {
    constructor(){
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */ this.dataProjection = undefined;
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|undefined}
     */ this.defaultFeatureProjection = undefined;
        /**
     * @protected
     * @type {import("../Feature.js").FeatureClass}
     */ this.featureClass = (0, _featureJsDefault.default);
        /**
     * A list media types supported by the format in descending order of preference.
     * @type {Array<string>}
     */ this.supportedMediaTypes = null;
    }
    /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */ getReadOptions(source, options) {
        if (options) {
            let dataProjection = options.dataProjection ? (0, _projJs.get)(options.dataProjection) : this.readProjection(source);
            if (options.extent && dataProjection && dataProjection.getUnits() === 'tile-pixels') {
                dataProjection = (0, _projJs.get)(dataProjection);
                dataProjection.setWorldExtent(options.extent);
            }
            options = {
                dataProjection: dataProjection,
                featureProjection: options.featureProjection
            };
        }
        return this.adaptOptions(options);
    }
    /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */ adaptOptions(options) {
        return Object.assign({
            dataProjection: this.dataProjection,
            featureProjection: this.defaultFeatureProjection,
            featureClass: this.featureClass
        }, options);
    }
    /**
   * @abstract
   * @return {Type} The format type.
   */ getType() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike|Array<import("../render/Feature.js").default>} Feature.
   */ readFeature(source, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */ readFeatures(source, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometry(source, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */ readProjection(source) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeFeature(feature, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeFeatures(features, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */ writeGeometry(geometry, options) {
        return (0, _utilJs.abstract)();
    }
}
exports.default = FeatureFormat;
function transformGeometryWithOptions(geometry, write, options) {
    const featureProjection = options ? (0, _projJs.get)(options.featureProjection) : null;
    const dataProjection = options ? (0, _projJs.get)(options.dataProjection) : null;
    let transformed = geometry;
    if (featureProjection && dataProjection && !(0, _projJs.equivalent)(featureProjection, dataProjection)) {
        if (write) transformed = /** @type {T} */ geometry.clone();
        const fromProjection = write ? featureProjection : dataProjection;
        const toProjection = write ? dataProjection : featureProjection;
        if (fromProjection.getUnits() === 'tile-pixels') transformed.transform(fromProjection, toProjection);
        else transformed.applyTransform((0, _projJs.getTransform)(fromProjection, toProjection));
    }
    if (write && options && /** @type {WriteOptions} */ options.decimals !== undefined) {
        const power = Math.pow(10, /** @type {WriteOptions} */ options.decimals);
        // if decimals option on write, round each coordinate appropriately
        /**
     * @param {Array<number>} coordinates Coordinates.
     * @return {Array<number>} Transformed coordinates.
     */ const transform = function(coordinates) {
            for(let i = 0, ii = coordinates.length; i < ii; ++i)coordinates[i] = Math.round(coordinates[i] * power) / power;
            return coordinates;
        };
        if (transformed === geometry) transformed = /** @type {T} */ geometry.clone();
        transformed.applyTransform(transform);
    }
    return transformed;
}
function transformExtentWithOptions(extent, options) {
    const featureProjection = options ? (0, _projJs.get)(options.featureProjection) : null;
    const dataProjection = options ? (0, _projJs.get)(options.dataProjection) : null;
    if (featureProjection && dataProjection && !(0, _projJs.equivalent)(featureProjection, dataProjection)) return (0, _projJs.transformExtent)(extent, dataProjection, featureProjection);
    return extent;
}
const GeometryConstructor = {
    Point: (0, _geomJs.Point),
    LineString: (0, _geomJs.LineString),
    Polygon: (0, _geomJs.Polygon),
    MultiPoint: (0, _geomJs.MultiPoint),
    MultiLineString: (0, _geomJs.MultiLineString),
    MultiPolygon: (0, _geomJs.MultiPolygon)
};
function orientFlatCoordinates(flatCoordinates, ends, stride) {
    if (Array.isArray(ends[0])) {
        // MultiPolagon
        if (!(0, _orientJs.linearRingssAreOriented)(flatCoordinates, 0, ends, stride)) {
            flatCoordinates = flatCoordinates.slice();
            (0, _orientJs.orientLinearRingsArray)(flatCoordinates, 0, ends, stride);
        }
        return flatCoordinates;
    }
    if (!(0, _orientJs.linearRingsAreOriented)(flatCoordinates, 0, ends, stride)) {
        flatCoordinates = flatCoordinates.slice();
        (0, _orientJs.orientLinearRings)(flatCoordinates, 0, ends, stride);
    }
    return flatCoordinates;
}
function createRenderFeature(object, options) {
    const geometry = object.geometry;
    if (!geometry) return [];
    if (Array.isArray(geometry)) return geometry.map((geometry)=>createRenderFeature({
            ...object,
            geometry
        })).flat();
    const geometryType = geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;
    if (geometryType === 'GeometryCollection' || geometryType === 'Circle') throw new Error('Unsupported geometry type: ' + geometryType);
    const stride = geometry.layout.length;
    return transformGeometryWithOptions(new (0, _featureJsDefault1.default)(geometryType, geometryType === 'Polygon' ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride) : geometry.flatCoordinates, geometry.ends?.flat(), stride, object.properties || {}, object.id).enableSimplifyTransformed(), false, options);
}
function createGeometry(object, options) {
    if (!object) return null;
    if (Array.isArray(object)) {
        const geometries = object.map((geometry)=>createGeometry(geometry, options));
        return new (0, _geomJs.GeometryCollection)(geometries);
    }
    const Geometry = GeometryConstructor[object.type];
    return transformGeometryWithOptions(new Geometry(object.flatCoordinates, object.layout, object.ends), false, options);
}

},{"../Feature.js":"liabO","../render/Feature.js":"3Oc3i","../geom.js":"8Nc7o","../util.js":"pLBjQ","../proj.js":"SznqC","../geom/flat/orient.js":"btd6s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3a1E4":[function(require,module,exports,__globalThis) {
/**
 * @module ol
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Collection", ()=>(0, _collectionJsDefault.default));
parcelHelpers.export(exports, "Disposable", ()=>(0, _disposableJsDefault.default));
parcelHelpers.export(exports, "Feature", ()=>(0, _featureJsDefault.default));
parcelHelpers.export(exports, "Geolocation", ()=>(0, _geolocationJsDefault.default));
parcelHelpers.export(exports, "Graticule", ()=>(0, _graticuleJsDefault.default));
parcelHelpers.export(exports, "Image", ()=>(0, _imageJsDefault.default));
parcelHelpers.export(exports, "ImageWrapper", ()=>(0, _imageJsDefault.default));
parcelHelpers.export(exports, "ImageCanvas", ()=>(0, _imageCanvasJsDefault.default));
parcelHelpers.export(exports, "ImageTile", ()=>(0, _imageTileJsDefault.default));
parcelHelpers.export(exports, "Kinetic", ()=>(0, _kineticJsDefault.default));
parcelHelpers.export(exports, "Map", ()=>(0, _mapJsDefault.default));
parcelHelpers.export(exports, "MapBrowserEvent", ()=>(0, _mapBrowserEventJsDefault.default));
parcelHelpers.export(exports, "MapBrowserEventHandler", ()=>(0, _mapBrowserEventHandlerJsDefault.default));
parcelHelpers.export(exports, "MapEvent", ()=>(0, _mapEventJsDefault.default));
parcelHelpers.export(exports, "Object", ()=>(0, _objectJsDefault.default));
parcelHelpers.export(exports, "Observable", ()=>(0, _observableJsDefault.default));
parcelHelpers.export(exports, "Overlay", ()=>(0, _overlayJsDefault.default));
parcelHelpers.export(exports, "Tile", ()=>(0, _tileJsDefault.default));
parcelHelpers.export(exports, "TileCache", ()=>(0, _tileCacheJsDefault.default));
parcelHelpers.export(exports, "TileQueue", ()=>(0, _tileQueueJsDefault.default));
parcelHelpers.export(exports, "TileRange", ()=>(0, _tileRangeJsDefault.default));
parcelHelpers.export(exports, "VectorRenderTile", ()=>(0, _vectorRenderTileJsDefault.default));
parcelHelpers.export(exports, "VectorTile", ()=>(0, _vectorTileJsDefault.default));
parcelHelpers.export(exports, "View", ()=>(0, _viewJsDefault.default));
parcelHelpers.export(exports, "getUid", ()=>(0, _utilJs.getUid));
parcelHelpers.export(exports, "VERSION", ()=>(0, _utilJs.VERSION));
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _disposableJs = require("./Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _featureJs = require("./Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geolocationJs = require("./Geolocation.js");
var _geolocationJsDefault = parcelHelpers.interopDefault(_geolocationJs);
var _graticuleJs = require("./layer/Graticule.js");
var _graticuleJsDefault = parcelHelpers.interopDefault(_graticuleJs);
var _imageJs = require("./Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _imageCanvasJs = require("./ImageCanvas.js");
var _imageCanvasJsDefault = parcelHelpers.interopDefault(_imageCanvasJs);
var _imageTileJs = require("./ImageTile.js");
var _imageTileJsDefault = parcelHelpers.interopDefault(_imageTileJs);
var _kineticJs = require("./Kinetic.js");
var _kineticJsDefault = parcelHelpers.interopDefault(_kineticJs);
var _mapJs = require("./Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _mapBrowserEventJs = require("./MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventHandlerJs = require("./MapBrowserEventHandler.js");
var _mapBrowserEventHandlerJsDefault = parcelHelpers.interopDefault(_mapBrowserEventHandlerJs);
var _mapEventJs = require("./MapEvent.js");
var _mapEventJsDefault = parcelHelpers.interopDefault(_mapEventJs);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _observableJs = require("./Observable.js");
var _observableJsDefault = parcelHelpers.interopDefault(_observableJs);
var _overlayJs = require("./Overlay.js");
var _overlayJsDefault = parcelHelpers.interopDefault(_overlayJs);
var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileCacheJs = require("./TileCache.js");
var _tileCacheJsDefault = parcelHelpers.interopDefault(_tileCacheJs);
var _tileQueueJs = require("./TileQueue.js");
var _tileQueueJsDefault = parcelHelpers.interopDefault(_tileQueueJs);
var _tileRangeJs = require("./TileRange.js");
var _tileRangeJsDefault = parcelHelpers.interopDefault(_tileRangeJs);
var _vectorRenderTileJs = require("./VectorRenderTile.js");
var _vectorRenderTileJsDefault = parcelHelpers.interopDefault(_vectorRenderTileJs);
var _vectorTileJs = require("./VectorTile.js");
var _vectorTileJsDefault = parcelHelpers.interopDefault(_vectorTileJs);
var _viewJs = require("./View.js");
var _viewJsDefault = parcelHelpers.interopDefault(_viewJs);
var _utilJs = require("./util.js");

},{"./Collection.js":false,"./Disposable.js":false,"./Feature.js":"liabO","./Geolocation.js":false,"./layer/Graticule.js":false,"./Image.js":false,"./ImageCanvas.js":false,"./ImageTile.js":false,"./Kinetic.js":false,"./Map.js":false,"./MapBrowserEvent.js":false,"./MapBrowserEventHandler.js":false,"./MapEvent.js":false,"./Object.js":false,"./Observable.js":false,"./Overlay.js":false,"./Tile.js":false,"./TileCache.js":false,"./TileQueue.js":false,"./TileRange.js":false,"./VectorRenderTile.js":false,"./VectorTile.js":false,"./View.js":false,"./util.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gi4gx":[function(require,module,exports,__globalThis) {
/**
 * Show a popup message that automatically disappears
 * @param {string} message - The message to display
 * @param {string} type - Message type: 'success', 'error', 'warning', or 'info'
 * @param {number} duration - Duration in milliseconds before the message disappears
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showPopupMessage", ()=>showPopupMessage);
function showPopupMessage(message, type = 'info', duration = 5000) {
    // Create popup element
    const popup = document.createElement('div');
    popup.className = `popup-message ${type}`;
    popup.textContent = message;
    // Add to document
    document.body.appendChild(popup);
    // Remove after duration
    setTimeout(()=>{
        popup.style.opacity = '0';
        setTimeout(()=>{
            document.body.removeChild(popup);
        }, 500); // Wait for fade out animation
    }, duration);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1bsdX":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/GeoJSON
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _jsonfeatureJs = require("./JSONFeature.js");
var _jsonfeatureJsDefault = parcelHelpers.interopDefault(_jsonfeatureJs);
var _featureJs1 = require("../render/Feature.js");
var _featureJsDefault1 = parcelHelpers.interopDefault(_featureJs1);
var _featureJs2 = require("./Feature.js");
var _deflateJs = require("../geom/flat/deflate.js");
var _simpleGeometryJs = require("../geom/SimpleGeometry.js");
var _projJs = require("../proj.js");
var _objJs = require("../obj.js");
/**
 * @typedef {import("geojson").GeoJSON} GeoJSONObject
 * @typedef {import("geojson").Feature} GeoJSONFeature
 * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
 * @typedef {import("geojson").Geometry} GeoJSONGeometry
 * @typedef {import("geojson").Point} GeoJSONPoint
 * @typedef {import("geojson").LineString} GeoJSONLineString
 * @typedef {import("geojson").Polygon} GeoJSONPolygon
 * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
 * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
 * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
 * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
 */ /**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
 * written by the format.  Options passed to read or write methods will take precedence.
 * @property {string} [geometryName] Geometry name to use when creating features.
 * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
 * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
 * will look for that field to set the geometry name. If both this field is set to `true`
 * and a `geometryName` is provided, the `geometryName` will take precedence.
 * @property {import("../Feature.js").FeatureClass} [featureClass] Feature class
 * to be used when reading features. The default is {@link module:ol/Feature~Feature}. If performance is
 * the primary concern, and features are not going to be modified or round-tripped through the format,
 * consider using {@link module:ol/render/Feature~RenderFeature}
 */ /**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @api
 */ class GeoJSON extends (0, _jsonfeatureJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super();
        /**
     * @type {import("../proj/Projection.js").default}
     */ this.dataProjection = (0, _projJs.get)(options.dataProjection ? options.dataProjection : 'EPSG:4326');
        if (options.featureProjection) /**
       * @type {import("../proj/Projection.js").default}
       */ this.defaultFeatureProjection = (0, _projJs.get)(options.featureProjection);
        if (options.featureClass) this.featureClass = options.featureClass;
        /**
     * Name of the geometry attribute for features.
     * @type {string|undefined}
     * @private
     */ this.geometryName_ = options.geometryName;
        /**
     * Look for the geometry name in the feature GeoJSON
     * @type {boolean|undefined}
     * @private
     */ this.extractGeometryName_ = options.extractGeometryName;
        this.supportedMediaTypes = [
            'application/geo+json',
            'application/vnd.geo+json'
        ];
    }
    /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Feature|RenderFeature|Array<RenderFeature>}.default} Feature.
   */ readFeatureFromObject(object, options) {
        /**
     * @type {GeoJSONFeature}
     */ let geoJSONFeature = null;
        if (object['type'] === 'Feature') geoJSONFeature = /** @type {GeoJSONFeature} */ object;
        else geoJSONFeature = {
            'type': 'Feature',
            'geometry': /** @type {GeoJSONGeometry} */ object,
            'properties': null
        };
        const geometry = readGeometryInternal(geoJSONFeature['geometry'], options);
        if (this.featureClass === (0, _featureJsDefault1.default)) return (0, _featureJs2.createRenderFeature)({
            geometry,
            id: geoJSONFeature['id'],
            properties: geoJSONFeature['properties']
        }, options);
        const feature = new (0, _featureJsDefault.default)();
        if (this.geometryName_) feature.setGeometryName(this.geometryName_);
        else if (this.extractGeometryName_ && true) feature.setGeometryName(geoJSONFeature['geometry_name']);
        feature.setGeometry((0, _featureJs2.createGeometry)(geometry, options));
        if ('id' in geoJSONFeature) feature.setId(geoJSONFeature['id']);
        if (geoJSONFeature['properties']) feature.setProperties(geoJSONFeature['properties'], true);
        return feature;
    }
    /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature|RenderFeature>} Features.
   */ readFeaturesFromObject(object, options) {
        const geoJSONObject = /** @type {GeoJSONObject} */ object;
        /** @type {Array<Feature|RenderFeature|Array<RenderFeature>>} */ let features = null;
        if (geoJSONObject['type'] === 'FeatureCollection') {
            const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ object;
            features = [];
            const geoJSONFeatures = geoJSONFeatureCollection['features'];
            for(let i = 0, ii = geoJSONFeatures.length; i < ii; ++i){
                const featureObject = this.readFeatureFromObject(geoJSONFeatures[i], options);
                if (!featureObject) continue;
                features.push(featureObject);
            }
        } else features = [
            this.readFeatureFromObject(object, options)
        ];
        return features.flat();
    }
    /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromObject(object, options) {
        return readGeometry(object, options);
    }
    /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromObject(object) {
        const crs = object['crs'];
        let projection;
        if (crs) {
            if (crs['type'] == 'name') projection = (0, _projJs.get)(crs['properties']['name']);
            else if (crs['type'] === 'EPSG') projection = (0, _projJs.get)('EPSG:' + crs['properties']['code']);
            else throw new Error('Unknown SRS type');
        } else projection = this.dataProjection;
        return /** @type {import("../proj/Projection.js").default} */ projection;
    }
    /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */ writeFeatureObject(feature, options) {
        options = this.adaptOptions(options);
        /** @type {GeoJSONFeature} */ const object = {
            'type': 'Feature',
            geometry: null,
            properties: null
        };
        const id = feature.getId();
        if (id !== undefined) object.id = id;
        if (!feature.hasProperties()) return object;
        const properties = feature.getProperties();
        const geometry = feature.getGeometry();
        if (geometry) {
            object.geometry = writeGeometry(geometry, options);
            delete properties[feature.getGeometryName()];
        }
        if (!(0, _objJs.isEmpty)(properties)) object.properties = properties;
        return object;
    }
    /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */ writeFeaturesObject(features, options) {
        options = this.adaptOptions(options);
        const objects = [];
        for(let i = 0, ii = features.length; i < ii; ++i)objects.push(this.writeFeatureObject(features[i], options));
        return {
            type: 'FeatureCollection',
            features: objects
        };
    }
    /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */ writeGeometryObject(geometry, options) {
        return writeGeometry(geometry, this.adaptOptions(options));
    }
}
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("./Feature.js").GeometryObject} Geometry.
 */ function readGeometryInternal(object, options) {
    if (!object) return null;
    /** @type {import("./Feature.js").GeometryObject} */ let geometry;
    switch(object['type']){
        case 'Point':
            geometry = readPointGeometry(/** @type {GeoJSONPoint} */ object);
            break;
        case 'LineString':
            geometry = readLineStringGeometry(/** @type {GeoJSONLineString} */ object);
            break;
        case 'Polygon':
            geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ object);
            break;
        case 'MultiPoint':
            geometry = readMultiPointGeometry(/** @type {GeoJSONMultiPoint} */ object);
            break;
        case 'MultiLineString':
            geometry = readMultiLineStringGeometry(/** @type {GeoJSONMultiLineString} */ object);
            break;
        case 'MultiPolygon':
            geometry = readMultiPolygonGeometry(/** @type {GeoJSONMultiPolygon} */ object);
            break;
        case 'GeometryCollection':
            geometry = readGeometryCollectionGeometry(/** @type {GeoJSONGeometryCollection} */ object);
            break;
        default:
            throw new Error('Unsupported GeoJSON type: ' + object['type']);
    }
    return geometry;
}
/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("../geom/Geometry.js").default} Geometry.
 */ function readGeometry(object, options) {
    const geometryObject = readGeometryInternal(object, options);
    return (0, _featureJs2.createGeometry)(geometryObject, options);
}
/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {import("./Feature.js").ReadOptions} [options] Read options.
 * @return {import("./Feature.js").GeometryCollectionObject} Geometry collection.
 */ function readGeometryCollectionGeometry(object, options) {
    const geometries = object['geometries'].map(/**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */ function(geometry) {
        return readGeometryInternal(geometry, options);
    });
    return geometries;
}
/**
 * @param {GeoJSONPoint} object Input object.
 * @return {import("./Feature.js").GeometryObject} Point geometry.
 */ function readPointGeometry(object) {
    const flatCoordinates = object['coordinates'];
    return {
        type: 'Point',
        flatCoordinates,
        layout: (0, _simpleGeometryJs.getLayoutForStride)(flatCoordinates.length)
    };
}
/**
 * @param {GeoJSONLineString} object Object.
 * @return {import("./Feature.js").GeometryObject} LineString geometry.
 */ function readLineStringGeometry(object) {
    const coordinates = object['coordinates'];
    const flatCoordinates = coordinates.flat();
    return {
        type: 'LineString',
        flatCoordinates,
        ends: [
            flatCoordinates.length
        ],
        layout: (0, _simpleGeometryJs.getLayoutForStride)(coordinates[0].length)
    };
}
/**
 * @param {GeoJSONMultiLineString} object Object.
 * @return {import("./Feature.js").GeometryObject} MultiLineString geometry.
 */ function readMultiLineStringGeometry(object) {
    const coordinates = object['coordinates'];
    const stride = coordinates[0][0].length;
    const flatCoordinates = [];
    const ends = (0, _deflateJs.deflateCoordinatesArray)(flatCoordinates, 0, coordinates, stride);
    return {
        type: 'MultiLineString',
        flatCoordinates,
        ends,
        layout: (0, _simpleGeometryJs.getLayoutForStride)(stride)
    };
}
/**
 * @param {GeoJSONMultiPoint} object Object.
 * @return {import("./Feature.js").GeometryObject} MultiPoint geometry.
 */ function readMultiPointGeometry(object) {
    const coordinates = object['coordinates'];
    return {
        type: 'MultiPoint',
        flatCoordinates: coordinates.flat(),
        layout: (0, _simpleGeometryJs.getLayoutForStride)(coordinates[0].length)
    };
}
/**
 * @param {GeoJSONMultiPolygon} object Object.
 * @return {import("./Feature.js").GeometryObject} MultiPolygon geometry.
 */ function readMultiPolygonGeometry(object) {
    const coordinates = object['coordinates'];
    const flatCoordinates = [];
    const stride = coordinates[0][0][0].length;
    const endss = (0, _deflateJs.deflateMultiCoordinatesArray)(flatCoordinates, 0, coordinates, stride);
    return {
        type: 'MultiPolygon',
        flatCoordinates,
        ends: endss,
        layout: (0, _simpleGeometryJs.getLayoutForStride)(stride)
    };
}
/**
 * @param {GeoJSONPolygon} object Object.
 * @return {import("./Feature.js").GeometryObject} Polygon.
 */ function readPolygonGeometry(object) {
    const coordinates = object['coordinates'];
    const flatCoordinates = [];
    const stride = coordinates[0][0].length;
    const ends = (0, _deflateJs.deflateCoordinatesArray)(flatCoordinates, 0, coordinates, stride);
    return {
        type: 'Polygon',
        flatCoordinates,
        ends,
        layout: (0, _simpleGeometryJs.getLayoutForStride)(stride)
    };
}
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeGeometry(geometry, options) {
    geometry = (0, _featureJs2.transformGeometryWithOptions)(geometry, true, options);
    const type = geometry.getType();
    /** @type {GeoJSONGeometry} */ let geoJSON;
    switch(type){
        case 'Point':
            geoJSON = writePointGeometry(/** @type {import("../geom/Point.js").default} */ geometry, options);
            break;
        case 'LineString':
            geoJSON = writeLineStringGeometry(/** @type {import("../geom/LineString.js").default} */ geometry, options);
            break;
        case 'Polygon':
            geoJSON = writePolygonGeometry(/** @type {import("../geom/Polygon.js").default} */ geometry, options);
            break;
        case 'MultiPoint':
            geoJSON = writeMultiPointGeometry(/** @type {import("../geom/MultiPoint.js").default} */ geometry, options);
            break;
        case 'MultiLineString':
            geoJSON = writeMultiLineStringGeometry(/** @type {import("../geom/MultiLineString.js").default} */ geometry, options);
            break;
        case 'MultiPolygon':
            geoJSON = writeMultiPolygonGeometry(/** @type {import("../geom/MultiPolygon.js").default} */ geometry, options);
            break;
        case 'GeometryCollection':
            geoJSON = writeGeometryCollectionGeometry(/** @type {import("../geom/GeometryCollection.js").default} */ geometry, options);
            break;
        case 'Circle':
            geoJSON = {
                type: 'GeometryCollection',
                geometries: []
            };
            break;
        default:
            throw new Error('Unsupported geometry type: ' + type);
    }
    return geoJSON;
}
/**
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */ function writeGeometryCollectionGeometry(geometry, options) {
    options = Object.assign({}, options);
    delete options.featureProjection;
    const geometries = geometry.getGeometriesArray().map(function(geometry) {
        return writeGeometry(geometry, options);
    });
    return {
        type: 'GeometryCollection',
        geometries: geometries
    };
}
/**
 * @param {import("../geom/LineString.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeLineStringGeometry(geometry, options) {
    return {
        type: 'LineString',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiLineStringGeometry(geometry, options) {
    return {
        type: 'MultiLineString',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiPointGeometry(geometry, options) {
    return {
        type: 'MultiPoint',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writeMultiPolygonGeometry(geometry, options) {
    let right;
    if (options) right = options.rightHanded;
    return {
        type: 'MultiPolygon',
        coordinates: geometry.getCoordinates(right)
    };
}
/**
 * @param {import("../geom/Point.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writePointGeometry(geometry, options) {
    return {
        type: 'Point',
        coordinates: geometry.getCoordinates()
    };
}
/**
 * @param {import("../geom/Polygon.js").default} geometry Geometry.
 * @param {import("./Feature.js").WriteOptions} [options] Write options.
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */ function writePolygonGeometry(geometry, options) {
    let right;
    if (options) right = options.rightHanded;
    return {
        type: 'Polygon',
        coordinates: geometry.getCoordinates(right)
    };
}
exports.default = GeoJSON;

},{"../Feature.js":"liabO","./JSONFeature.js":"aCFnK","../render/Feature.js":"3Oc3i","./Feature.js":"FZbV5","../geom/flat/deflate.js":"3TE5l","../geom/SimpleGeometry.js":"hLwk3","../proj.js":"SznqC","../obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aCFnK":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/JSONFeature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _featureJs = require("./Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _utilJs = require("../util.js");
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @abstract
 */ class JSONFeature extends (0, _featureJsDefault.default) {
    constructor(){
        super();
    }
    /**
   * @return {import("./Feature.js").Type} Format.
   */ getType() {
        return 'json';
    }
    /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike|Array<import("../render/Feature.js").default>} Feature.
   * @api
   */ readFeature(source, options) {
        return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */ readFeatures(source, options) {
        return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default|import("../render/Feature.js").default|Array<import("../render/Feature.js").default>} Feature.
   */ readFeatureFromObject(object, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default|import("../render/Feature.js").default>} Features.
   */ readFeaturesFromObject(object, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */ readGeometry(source, options) {
        return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, options));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromObject(object, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */ readProjection(source) {
        return this.readProjectionFromObject(getObject(source));
    }
    /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromObject(object) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */ writeFeature(feature, options) {
        return JSON.stringify(this.writeFeatureObject(feature, options));
    }
    /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeFeatureObject(feature, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */ writeFeatures(features, options) {
        return JSON.stringify(this.writeFeaturesObject(features, options));
    }
    /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeFeaturesObject(features, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */ writeGeometry(geometry, options) {
        return JSON.stringify(this.writeGeometryObject(geometry, options));
    }
    /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */ writeGeometryObject(geometry, options) {
        return (0, _utilJs.abstract)();
    }
}
/**
 * @param {Document|Element|Object|string} source Source.
 * @return {Object} Object.
 */ function getObject(source) {
    if (typeof source === 'string') {
        const object = JSON.parse(source);
        return object ? /** @type {Object} */ object : null;
    }
    if (source !== null) return source;
    return null;
}
exports.default = JSONFeature;

},{"./Feature.js":"FZbV5","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5NDio":[function(require,module,exports,__globalThis) {
/**
 * @module org/locationtech/jts/io/OL3Parser
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _geometryFactoryJs = require("../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
function p2c(p) {
    return [
        p.x,
        p.y
    ];
}
class OL3Parser {
    /**
   * OpenLayers Geometry parser and writer
   * @param {GeometryFactory} geometryFactory
   * @param {ol} olReference
   */ constructor(geometryFactory, olReference){
        this.geometryFactory = geometryFactory || new (0, _geometryFactoryJsDefault.default)();
        this.ol = olReference || typeof ol !== 'undefined' && ol;
    }
    /**
   * Inject OpenLayers geom classes
   */ inject(Point, LineString, LinearRing, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection) {
        this.ol = {
            geom: {
                Point,
                LineString,
                LinearRing,
                Polygon,
                MultiPoint,
                MultiLineString,
                MultiPolygon,
                GeometryCollection
            }
        };
    }
    /**
   * @param geometry {ol.geom.Geometry}
   * @return {Geometry}
   * @memberof module:org/locationtech/jts/io/OL3Parser#
   */ read(geometry) {
        const ol1 = this.ol;
        if (geometry instanceof ol1.geom.Point) return this.convertFromPoint(geometry);
        else if (geometry instanceof ol1.geom.LineString) return this.convertFromLineString(geometry);
        else if (geometry instanceof ol1.geom.LinearRing) return this.convertFromLinearRing(geometry);
        else if (geometry instanceof ol1.geom.Polygon) return this.convertFromPolygon(geometry);
        else if (geometry instanceof ol1.geom.MultiPoint) return this.convertFromMultiPoint(geometry);
        else if (geometry instanceof ol1.geom.MultiLineString) return this.convertFromMultiLineString(geometry);
        else if (geometry instanceof ol1.geom.MultiPolygon) return this.convertFromMultiPolygon(geometry);
        else if (geometry instanceof ol1.geom.GeometryCollection) return this.convertFromCollection(geometry);
    }
    convertFromPoint(point) {
        const coordinates = point.getCoordinates();
        return this.geometryFactory.createPoint(new (0, _coordinateJsDefault.default)(coordinates[0], coordinates[1]));
    }
    convertFromLineString(lineString) {
        return this.geometryFactory.createLineString(lineString.getCoordinates().map(function(coordinates) {
            return new (0, _coordinateJsDefault.default)(coordinates[0], coordinates[1]);
        }));
    }
    convertFromLinearRing(linearRing) {
        return this.geometryFactory.createLinearRing(linearRing.getCoordinates().map(function(coordinates) {
            return new (0, _coordinateJsDefault.default)(coordinates[0], coordinates[1]);
        }));
    }
    convertFromPolygon(polygon) {
        const linearRings = polygon.getLinearRings();
        let shell = null;
        const holes = [];
        for(let i = 0; i < linearRings.length; i++){
            const linearRing = this.convertFromLinearRing(linearRings[i]);
            if (i === 0) shell = linearRing;
            else holes.push(linearRing);
        }
        return this.geometryFactory.createPolygon(shell, holes);
    }
    convertFromMultiPoint(multiPoint) {
        const points = multiPoint.getPoints().map(function(point) {
            return this.convertFromPoint(point);
        }, this);
        return this.geometryFactory.createMultiPoint(points);
    }
    convertFromMultiLineString(multiLineString) {
        const lineStrings = multiLineString.getLineStrings().map(function(lineString) {
            return this.convertFromLineString(lineString);
        }, this);
        return this.geometryFactory.createMultiLineString(lineStrings);
    }
    convertFromMultiPolygon(multiPolygon) {
        const polygons = multiPolygon.getPolygons().map(function(polygon) {
            return this.convertFromPolygon(polygon);
        }, this);
        return this.geometryFactory.createMultiPolygon(polygons);
    }
    convertFromCollection(collection) {
        const geometries = collection.getGeometries().map(function(geometry) {
            return this.read(geometry);
        }, this);
        return this.geometryFactory.createGeometryCollection(geometries);
    }
    /**
   * @param geometry
   *          {Geometry}
   * @return {ol.geom.Geometry}
   * @memberof module:org/locationtech/jts/io/OL3Parser#
   */ write(geometry) {
        if (geometry.getGeometryType() === 'Point') return this.convertToPoint(geometry.getCoordinate());
        else if (geometry.getGeometryType() === 'LineString') return this.convertToLineString(geometry);
        else if (geometry.getGeometryType() === 'LinearRing') return this.convertToLinearRing(geometry);
        else if (geometry.getGeometryType() === 'Polygon') return this.convertToPolygon(geometry);
        else if (geometry.getGeometryType() === 'MultiPoint') return this.convertToMultiPoint(geometry);
        else if (geometry.getGeometryType() === 'MultiLineString') return this.convertToMultiLineString(geometry);
        else if (geometry.getGeometryType() === 'MultiPolygon') return this.convertToMultiPolygon(geometry);
        else if (geometry.getGeometryType() === 'GeometryCollection') return this.convertToCollection(geometry);
    }
    convertToPoint(coordinate) {
        return new this.ol.geom.Point([
            coordinate.x,
            coordinate.y
        ]);
    }
    convertToLineString(lineString) {
        const points = lineString._points._coordinates.map(p2c);
        return new this.ol.geom.LineString(points);
    }
    convertToLinearRing(linearRing) {
        const points = linearRing._points._coordinates.map(p2c);
        return new this.ol.geom.LinearRing(points);
    }
    convertToPolygon(polygon) {
        const rings = [
            polygon._shell._points._coordinates.map(p2c)
        ];
        for(let i = 0; i < polygon._holes.length; i++)rings.push(polygon._holes[i]._points._coordinates.map(p2c));
        return new this.ol.geom.Polygon(rings);
    }
    convertToMultiPoint(multiPoint) {
        return new this.ol.geom.MultiPoint(multiPoint.getCoordinates().map(p2c));
    }
    convertToMultiLineString(multiLineString) {
        const lineStrings = [];
        for(let i = 0; i < multiLineString._geometries.length; i++)lineStrings.push(this.convertToLineString(multiLineString._geometries[i]).getCoordinates());
        return new this.ol.geom.MultiLineString(lineStrings);
    }
    convertToMultiPolygon(multiPolygon) {
        const polygons = [];
        for(let i = 0; i < multiPolygon._geometries.length; i++)polygons.push(this.convertToPolygon(multiPolygon._geometries[i]).getCoordinates());
        return new this.ol.geom.MultiPolygon(polygons);
    }
    convertToCollection(geometryCollection) {
        const geometries = [];
        for(let i = 0; i < geometryCollection._geometries.length; i++){
            const geometry = geometryCollection._geometries[i];
            geometries.push(this.write(geometry));
        }
        return new this.ol.geom.GeometryCollection(geometries);
    }
}
exports.default = OL3Parser;

},{"../geom/Coordinate.js":"3REUb","../geom/GeometryFactory.js":"6Ct9y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3REUb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _numberUtilJs = require("../util/NumberUtil.js");
var _numberUtilJsDefault = parcelHelpers.interopDefault(_numberUtilJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _cloneableJs = require("../../../../java/lang/Cloneable.js");
var _cloneableJsDefault = parcelHelpers.interopDefault(_cloneableJs);
var _comparatorJs = require("../../../../java/util/Comparator.js");
var _comparatorJsDefault = parcelHelpers.interopDefault(_comparatorJs);
const kBuf = new ArrayBuffer(8);
const kBufAsF64 = new Float64Array(kBuf);
const kBufAsI32 = new Int32Array(kBuf);
class Coordinate {
    constructor(){
        Coordinate.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.x = null;
        this.y = null;
        this.z = null;
        if (arguments.length === 0) Coordinate.constructor_.call(this, 0.0, 0.0);
        else if (arguments.length === 1) {
            const c = arguments[0];
            Coordinate.constructor_.call(this, c.x, c.y, c.getZ());
        } else if (arguments.length === 2) {
            const x = arguments[0], y = arguments[1];
            Coordinate.constructor_.call(this, x, y, Coordinate.NULL_ORDINATE);
        } else if (arguments.length === 3) {
            const x = arguments[0], y = arguments[1], z = arguments[2];
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }
    static hashCode(n) {
        kBufAsF64[0] = n;
        return kBufAsI32[0] ^ kBufAsI32[1];
    }
    equals2D() {
        if (arguments.length === 1) {
            const other = arguments[0];
            if (this.x !== other.x) return false;
            if (this.y !== other.y) return false;
            return true;
        } else if (arguments.length === 2) {
            const c = arguments[0], tolerance = arguments[1];
            if (!(0, _numberUtilJsDefault.default).equalsWithTolerance(this.x, c.x, tolerance)) return false;
            if (!(0, _numberUtilJsDefault.default).equalsWithTolerance(this.y, c.y, tolerance)) return false;
            return true;
        }
    }
    setM(m) {
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + Coordinate.M);
    }
    equals3D(other) {
        return this.x === other.x && this.y === other.y && (this.getZ() === other.getZ() || (0, _doubleJsDefault.default).isNaN(this.getZ()) && (0, _doubleJsDefault.default).isNaN(other.getZ()));
    }
    setX(x) {
        this.x = x;
    }
    compareTo(o) {
        const other = o;
        if (this.x < other.x) return -1;
        if (this.x > other.x) return 1;
        if (this.y < other.y) return -1;
        if (this.y > other.y) return 1;
        return 0;
    }
    getX() {
        return this.x;
    }
    copy() {
        return new Coordinate(this);
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ')';
    }
    distance3D(c) {
        const dx = this.x - c.x;
        const dy = this.y - c.y;
        const dz = this.getZ() - c.getZ();
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    getY() {
        return this.y;
    }
    getM() {
        return (0, _doubleJsDefault.default).NaN;
    }
    setOrdinate(ordinateIndex, value) {
        switch(ordinateIndex){
            case Coordinate.X:
                this.x = value;
                break;
            case Coordinate.Y:
                this.y = value;
                break;
            case Coordinate.Z:
                this.setZ(value);
                break;
            default:
                throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
        }
    }
    getZ() {
        return this.z;
    }
    getOrdinate(ordinateIndex) {
        switch(ordinateIndex){
            case Coordinate.X:
                return this.x;
            case Coordinate.Y:
                return this.y;
            case Coordinate.Z:
                return this.getZ();
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
    }
    equals(other) {
        if (!(other instanceof Coordinate)) return false;
        return this.equals2D(other);
    }
    equalInZ(c, tolerance) {
        return (0, _numberUtilJsDefault.default).equalsWithTolerance(this.getZ(), c.getZ(), tolerance);
    }
    setZ(z) {
        this.z = z;
    }
    clone() {
        try {
            const coord = null;
            return coord;
        } catch (e) {
            if (e instanceof CloneNotSupportedException) {
                (0, _assertJsDefault.default).shouldNeverReachHere('this shouldn\'t happen because this class is Cloneable');
                return null;
            } else throw e;
        } finally{}
    }
    setY(y) {
        this.y = y;
    }
    distance(c) {
        const dx = this.x - c.x;
        const dy = this.y - c.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    hashCode() {
        let result = 17;
        result = 37 * result + Coordinate.hashCode(this.x);
        result = 37 * result + Coordinate.hashCode(this.y);
        return result;
    }
    setCoordinate(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.getZ();
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default),
            (0, _cloneableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = Coordinate;
class DimensionalComparator {
    constructor(){
        DimensionalComparator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._dimensionsToTest = 2;
        if (arguments.length === 0) DimensionalComparator.constructor_.call(this, 2);
        else if (arguments.length === 1) {
            const dimensionsToTest = arguments[0];
            if (dimensionsToTest !== 2 && dimensionsToTest !== 3) throw new (0, _illegalArgumentExceptionJsDefault.default)('only 2 or 3 dimensions may be specified');
            this._dimensionsToTest = dimensionsToTest;
        }
    }
    static compare(a, b) {
        if (a < b) return -1;
        if (a > b) return 1;
        if ((0, _doubleJsDefault.default).isNaN(a)) {
            if ((0, _doubleJsDefault.default).isNaN(b)) return 0;
            return -1;
        }
        if ((0, _doubleJsDefault.default).isNaN(b)) return 1;
        return 0;
    }
    compare(c1, c2) {
        const compX = DimensionalComparator.compare(c1.x, c2.x);
        if (compX !== 0) return compX;
        const compY = DimensionalComparator.compare(c1.y, c2.y);
        if (compY !== 0) return compY;
        if (this._dimensionsToTest <= 2) return 0;
        const compZ = DimensionalComparator.compare(c1.getZ(), c2.getZ());
        return compZ;
    }
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
}
Coordinate.DimensionalComparator = DimensionalComparator;
Coordinate.NULL_ORDINATE = (0, _doubleJsDefault.default).NaN;
Coordinate.X = 0;
Coordinate.Y = 1;
Coordinate.Z = 2;
Coordinate.M = 3;

},{"../util/NumberUtil.js":"eR6uc","../../../../java/lang/IllegalArgumentException.js":"1VQhm","../../../../java/lang/Double.js":"jCc26","../../../../java/lang/Comparable.js":"6Adw4","../../../../java/io/Serializable.js":"4emqV","../util/Assert.js":"ePbcB","../../../../java/lang/Cloneable.js":"bkkIE","../../../../java/util/Comparator.js":"6CEtH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eR6uc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class NumberUtil {
    static equalsWithTolerance(x1, x2, tolerance) {
        return Math.abs(x1 - x2) <= tolerance;
    }
}
exports.default = NumberUtil;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1VQhm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("./Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class IllegalArgumentException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            IllegalArgumentException
        })[0];
    }
}
exports.default = IllegalArgumentException;

},{"./Exception.js":"gSmog","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gSmog":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Exception extends Error {
    constructor(message){
        super(message);
        this.name = Object.keys({
            Exception
        })[0];
    }
    toString() {
        return this.message;
    }
}
exports.default = Exception;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jCc26":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Double);
var _longJs = require("./Long.js");
var _longJsDefault = parcelHelpers.interopDefault(_longJs);
function Double() {}
Double.NaN = NaN;
Double.isNaN = (n)=>Number.isNaN(n);
Double.isInfinite = (n)=>!Number.isFinite(n);
Double.MAX_VALUE = Number.MAX_VALUE;
Double.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
Double.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
if (typeof Float64Array === 'function' && typeof Int32Array === 'function') // Simple and fast conversion between double and long bits
// using TypedArrays and ArrayViewBuffers.
(function() {
    const EXP_BIT_MASK = 0x7ff00000;
    const SIGNIF_BIT_MASK = 0xFFFFF;
    const f64buf = new Float64Array(1);
    const i32buf = new Int32Array(f64buf.buffer);
    Double.doubleToLongBits = function(value) {
        f64buf[0] = value;
        let low = i32buf[0] | 0;
        let high = i32buf[1] | 0;
        // Check for NaN based on values of bit fields, maximum
        // exponent and nonzero significand.
        if ((high & EXP_BIT_MASK) === EXP_BIT_MASK && (high & SIGNIF_BIT_MASK) !== 0 && low !== 0) {
            low = 0;
            high = 2146959360;
        }
        return new (0, _longJsDefault.default)(high, low);
    };
    Double.longBitsToDouble = function(bits) {
        i32buf[0] = bits.low;
        i32buf[1] = bits.high;
        return f64buf[0];
    };
})();
else // More complex and slower fallback implementation using
// math and the divide-by-two and multiply-by-two algorithms.
(function() {
    const BIAS = 1023;
    const log2 = Math.log2;
    const floor = Math.floor;
    const pow = Math.pow;
    const MAX_REL_BITS_INTEGER = function() {
        for(let i = 53; i > 0; i--){
            const bits = pow(2, i) - 1;
            if (floor(log2(bits)) + 1 === i) return bits;
        }
        return 0;
    }();
    Double.doubleToLongBits = function(value) {
        let x, y, f, bits, skip;
        let sign, exp, high, low;
        // Get the sign bit and absolute value.
        if (value < 0 || 1 / value === Number.NEGATIVE_INFINITY) {
            sign = -2147483648;
            value = -value;
        } else sign = 0;
        // Handle some special values.
        if (value === 0) {
            // Handle zeros (+/-0).
            low = 0;
            high = sign // exponent: 00..00, significand: 00..00
            ;
            return new (0, _longJsDefault.default)(high, low);
        }
        if (value === Infinity) {
            // Handle infinity (only positive values for value possible).
            low = 0;
            high = sign | 0x7ff00000 // exponent: 11..11, significand: 00..00
            ;
            return new (0, _longJsDefault.default)(high, low);
        }
        if (value !== value) {
            // Handle NaNs (boiled down to only one distinct NaN).
            low = 0;
            high = 0x7ff80000 // exponent: 11..11, significand: 10..00
            ;
            return new (0, _longJsDefault.default)(high, low);
        }
        // Preinitialize variables, that are not neccessarily set by
        // the algorithm.
        bits = 0;
        low = 0;
        // Get the (always positive) integer part of value.
        x = floor(value);
        // Process the integer part if it's greater than 1. Zero requires
        // no bits at all, 1 represents the implicit (hidden) leading bit,
        // which must not be written as well.
        if (x > 1) {
            // If we can reliably determine the number of bits required for
            // the integer part,
            if (x <= MAX_REL_BITS_INTEGER) {
                // get the number of bits required to represent it minus 1
                bits = floor(log2(x));
                /* + 1 - 1 */ // and simply copy/shift the integer bits into low and high.
                // That's much faster than the divide-by-two algorithm (saves
                // up to ~60%).
                // We always need to mask out the most significant bit, which
                // is the implicit (aka hidden) bit.
                if (bits <= 20) {
                    // The simple case in which the integer fits into the
                    // lower 20 bits of the high word is worth to be handled
                    // separately (saves ~25%).
                    low = 0;
                    high = x << 20 - bits & 0xfffff;
                } else {
                    // Here, the integer part is split into low and high.
                    // Since its value may require more than 32 bits, we
                    // cannot use bitwise operators (which implicitly cast
                    // to Int32), but use arithmetic operators % and / to
                    // get low and high parts. The uppper 20 bits go to high,
                    // the remaining bits (in f) to low.
                    f = bits - 20;
                    // Like (1 << f) but safe with even more than 32 bits.
                    y = pow(2, f);
                    low = x % y << 32 - f;
                    high = x / y & 0xfffff;
                }
            } else {
                // For greater values, we must use the much slower divide-by-two
                // algorithm. Bits are generated from right to left, that is from
                // least to most significant bit. For each bit, we left-shift both
                // low and high by one and carry bit #0 from high to #31 in low.
                // The next bit is then copied into bit #19 in high, the leftmost
                // bit of the double's significand.
                // Preserve x for later user, so work with f.
                f = x;
                low = 0;
                for(;;){
                    y = f / 2;
                    f = floor(y);
                    if (f === 0) break;
                    // Count this bit, shift low and carry bit #0 from high.
                    bits++;
                    low >>>= 1;
                    low |= (high & 0x1) << 31;
                    // Shift high.
                    high >>>= 1;
                    if (y !== f) // Copy the new bit into bit #19 in high (only required if 1).
                    high |= 0x80000;
                }
            }
        }
        // Bias the exponent.
        exp = bits + BIAS;
        // If the integer part is zero, we've not yet seen the implicit
        // leading bit. Variable skip is later used while processing the
        // fractional part (if any).
        skip = x === 0;
        // Get fraction only into x.
        x = value - x;
        // If some significand bits are still left to be filled and
        // the fractional part is not zero, convert the fraction using
        // the multiply-by-2 algorithm.
        if (bits < 52 && x !== 0) {
            // Initialize 'buffer' f, into which newly created bits get
            // shifted from right to left.
            f = 0;
            for(;;){
                y = x * 2;
                if (y >= 1) {
                    // This is a new 1-bit. Add and count this bit, if not
                    // prohibited by skip.
                    x = y - 1;
                    if (!skip) {
                        f <<= 1;
                        f |= 1;
                        bits++;
                    } else {
                        // Otherwise, decrement the exponent and unset
                        // skip, so that all following bits get written.
                        exp--;
                        skip = false;
                    }
                } else {
                    // This is a new 0-bit. Add and count this bit, if not
                    // prohibited by skip.
                    x = y;
                    if (!skip) {
                        f <<= 1;
                        bits++;
                    } else if (--exp === 0) {
                        // Otherwise we've just decremented the exponent. If the
                        // biased exponent is zero now (-1023), we process a
                        // subnormal number, which has no impled leading 1-bit.
                        // So, count this 0-bit and unset skip to write out
                        // all the following bits.
                        bits++;
                        skip = false;
                    }
                }
                if (bits === 20) {
                    // When 20 bits have been created in total, we're done with
                    // the high word. Copy the bits from 'buffer' f into high
                    // and reset 'buffer' f. Following bits will end up in the
                    // low word.
                    high |= f;
                    f = 0;
                } else if (bits === 52) {
                    // When 52 bits have been created in total, we're done with
                    // low word as well. Copy the bits from 'buffer' f into low
                    // and exit the loop.
                    low |= f;
                    break;
                }
                if (y === 1) {
                    // When y is exactly 1, there is no remainder and the process
                    // is complete (the number is finite). Copy the bits from
                    // 'buffer' f into either low or high and exit the loop.
                    if (bits < 20) high |= f << 20 - bits;
                    else if (bits < 52) low |= f << 52 - bits;
                    break;
                }
            }
        }
        // Copy/shift the exponent and sign bits into the high word.
        high |= exp << 20;
        high |= sign;
        return new (0, _longJsDefault.default)(high, low);
    };
    Double.longBitsToDouble = function(bits) {
        let i;
        let x, exp, fract;
        const high = bits.high;
        const low = bits.low;
        // Extract the sign.
        const sign = high & -2147483648 ? -1 : 1;
        // Extract the unbiased exponent.
        exp = ((high & 0x7ff00000) >> 20) - BIAS;
        // Calculate the fraction from left to right. Start
        // off with the 20 lower bits from the high word.
        fract = 0;
        x = 524288;
        for(i = 1; i <= 20; i++){
            if (high & x) fract += pow(2, -i);
            x >>>= 1;
        }
        // Continue with all 32 bits from the low word.
        x = -2147483648;
        for(i = 21; i <= 52; i++){
            if (low & x) fract += pow(2, -i);
            x >>>= 1;
        }
        // Handle special values.
        // Check for zero and subnormal values.
        if (exp === -BIAS) {
            if (fract === 0) // +/-1.0 * 0.0 => +/-0.0
            return sign * 0;
            exp = -1022;
        } else if (exp === BIAS + 1) {
            if (fract === 0) // +/-1.0 / 0.0 => +/-Infinity
            return sign / 0;
            return NaN;
        } else // Add the implicit leading bit (1*2^0).
        fract += 1;
        return sign * fract * pow(2, exp);
    };
})();

},{"./Long.js":"lCWie","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lCWie":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Long {
    constructor(high, low){
        this.low = low || 0;
        this.high = high || 0;
    }
    static toBinaryString(i) {
        let mask;
        let result = '';
        for(mask = 0x80000000; mask > 0; mask >>>= 1)result += (i.high & mask) === mask ? '1' : '0';
        for(mask = 0x80000000; mask > 0; mask >>>= 1)result += (i.low & mask) === mask ? '1' : '0';
        return result;
    }
}
exports.default = Long;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Adw4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Comparable);
function Comparable() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4emqV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Serializable);
function Serializable() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ePbcB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assertionFailedExceptionJs = require("./AssertionFailedException.js");
var _assertionFailedExceptionJsDefault = parcelHelpers.interopDefault(_assertionFailedExceptionJs);
class Assert {
    static isTrue() {
        if (arguments.length === 1) {
            const assertion = arguments[0];
            Assert.isTrue(assertion, null);
        } else if (arguments.length === 2) {
            const assertion = arguments[0], message = arguments[1];
            if (!assertion) {
                if (message === null) throw new (0, _assertionFailedExceptionJsDefault.default)();
                else throw new (0, _assertionFailedExceptionJsDefault.default)(message);
            }
        }
    }
    static shouldNeverReachHere() {
        if (arguments.length === 0) Assert.shouldNeverReachHere(null);
        else if (arguments.length === 1) {
            const message = arguments[0];
            throw new (0, _assertionFailedExceptionJsDefault.default)('Should never reach here' + (message !== null ? ': ' + message : ''));
        }
    }
    static equals() {
        if (arguments.length === 2) {
            const expectedValue = arguments[0], actualValue = arguments[1];
            Assert.equals(expectedValue, actualValue, null);
        } else if (arguments.length === 3) {
            const expectedValue = arguments[0], actualValue = arguments[1], message = arguments[2];
            if (!actualValue.equals(expectedValue)) throw new (0, _assertionFailedExceptionJsDefault.default)('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''));
        }
    }
}
exports.default = Assert;

},{"./AssertionFailedException.js":"aEG2h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aEG2h":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _runtimeExceptionJs = require("../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
class AssertionFailedException extends (0, _runtimeExceptionJsDefault.default) {
    constructor(){
        super();
        AssertionFailedException.constructor_.apply(this, arguments);
    }
    static constructor_() {
        if (arguments.length === 0) (0, _runtimeExceptionJsDefault.default).constructor_.call(this);
        else if (arguments.length === 1) {
            const message = arguments[0];
            (0, _runtimeExceptionJsDefault.default).constructor_.call(this, message);
        }
    }
}
exports.default = AssertionFailedException;

},{"../../../../java/lang/RuntimeException.js":"1sBnT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1sBnT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("./Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class RuntimeException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            RuntimeException
        })[0];
    }
}
exports.default = RuntimeException;

},{"./Exception.js":"gSmog","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bkkIE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Clonable);
function Clonable() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6CEtH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Comparator);
function Comparator() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Ct9y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _linearRingJs = require("./LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _coordinateArraySequenceFactoryJs = require("./impl/CoordinateArraySequenceFactory.js");
var _coordinateArraySequenceFactoryJsDefault = parcelHelpers.interopDefault(_coordinateArraySequenceFactoryJs);
var _multiPolygonJs = require("./MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _coordinateSequencesJs = require("./CoordinateSequences.js");
var _coordinateSequencesJsDefault = parcelHelpers.interopDefault(_coordinateSequencesJs);
var _precisionModelJs = require("./PrecisionModel.js");
var _precisionModelJsDefault = parcelHelpers.interopDefault(_precisionModelJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _multiLineStringJs = require("./MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _coordinateSequenceFactoryJs = require("./CoordinateSequenceFactory.js");
var _coordinateSequenceFactoryJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFactoryJs);
var _lineStringJs = require("./LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _pointJs = require("./Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("./Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _multiPointJs = require("./MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _coordinateSequenceJs = require("./CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
var _geometryCollectionJs = require("./GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
class GeometryFactory {
    constructor(){
        GeometryFactory.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._precisionModel = null;
        this._coordinateSequenceFactory = null;
        this._SRID = null;
        if (arguments.length === 0) GeometryFactory.constructor_.call(this, new (0, _precisionModelJsDefault.default)(), 0);
        else if (arguments.length === 1) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceFactoryJsDefault.default))) {
                const coordinateSequenceFactory = arguments[0];
                GeometryFactory.constructor_.call(this, new (0, _precisionModelJsDefault.default)(), 0, coordinateSequenceFactory);
            } else if (arguments[0] instanceof (0, _precisionModelJsDefault.default)) {
                const precisionModel = arguments[0];
                GeometryFactory.constructor_.call(this, precisionModel, 0, GeometryFactory.getDefaultCoordinateSequenceFactory());
            }
        } else if (arguments.length === 2) {
            const precisionModel = arguments[0], SRID = arguments[1];
            GeometryFactory.constructor_.call(this, precisionModel, SRID, GeometryFactory.getDefaultCoordinateSequenceFactory());
        } else if (arguments.length === 3) {
            const precisionModel = arguments[0], SRID = arguments[1], coordinateSequenceFactory = arguments[2];
            this._precisionModel = precisionModel;
            this._coordinateSequenceFactory = coordinateSequenceFactory;
            this._SRID = SRID;
        }
    }
    static toMultiPolygonArray(multiPolygons) {
        const multiPolygonArray = new Array(multiPolygons.size()).fill(null);
        return multiPolygons.toArray(multiPolygonArray);
    }
    static toGeometryArray(geometries) {
        if (geometries === null) return null;
        const geometryArray = new Array(geometries.size()).fill(null);
        return geometries.toArray(geometryArray);
    }
    static getDefaultCoordinateSequenceFactory() {
        return (0, _coordinateArraySequenceFactoryJsDefault.default).instance();
    }
    static toMultiLineStringArray(multiLineStrings) {
        const multiLineStringArray = new Array(multiLineStrings.size()).fill(null);
        return multiLineStrings.toArray(multiLineStringArray);
    }
    static toLineStringArray(lineStrings) {
        const lineStringArray = new Array(lineStrings.size()).fill(null);
        return lineStrings.toArray(lineStringArray);
    }
    static toMultiPointArray(multiPoints) {
        const multiPointArray = new Array(multiPoints.size()).fill(null);
        return multiPoints.toArray(multiPointArray);
    }
    static toLinearRingArray(linearRings) {
        const linearRingArray = new Array(linearRings.size()).fill(null);
        return linearRings.toArray(linearRingArray);
    }
    static toPointArray(points) {
        const pointArray = new Array(points.size()).fill(null);
        return points.toArray(pointArray);
    }
    static toPolygonArray(polygons) {
        const polygonArray = new Array(polygons.size()).fill(null);
        return polygons.toArray(polygonArray);
    }
    static createPointFromInternalCoord(coord, exemplar) {
        exemplar.getPrecisionModel().makePrecise(coord);
        return exemplar.getFactory().createPoint(coord);
    }
    createEmpty(dimension) {
        switch(dimension){
            case -1:
                return this.createGeometryCollection();
            case 0:
                return this.createPoint();
            case 1:
                return this.createLineString();
            case 2:
                return this.createPolygon();
            default:
                throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid dimension: ' + dimension);
        }
    }
    toGeometry(envelope) {
        if (envelope.isNull()) return this.createPoint();
        if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) return this.createPoint(new (0, _coordinateJsDefault.default)(envelope.getMinX(), envelope.getMinY()));
        if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) return this.createLineString([
            new (0, _coordinateJsDefault.default)(envelope.getMinX(), envelope.getMinY()),
            new (0, _coordinateJsDefault.default)(envelope.getMaxX(), envelope.getMaxY())
        ]);
        return this.createPolygon(this.createLinearRing([
            new (0, _coordinateJsDefault.default)(envelope.getMinX(), envelope.getMinY()),
            new (0, _coordinateJsDefault.default)(envelope.getMinX(), envelope.getMaxY()),
            new (0, _coordinateJsDefault.default)(envelope.getMaxX(), envelope.getMaxY()),
            new (0, _coordinateJsDefault.default)(envelope.getMaxX(), envelope.getMinY()),
            new (0, _coordinateJsDefault.default)(envelope.getMinX(), envelope.getMinY())
        ]), null);
    }
    createLineString() {
        if (arguments.length === 0) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
        else if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const coordinates = arguments[0];
                return this.createLineString(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordinates = arguments[0];
                return new (0, _lineStringJsDefault.default)(coordinates, this);
            }
        }
    }
    createMultiLineString() {
        if (arguments.length === 0) return new (0, _multiLineStringJsDefault.default)(null, this);
        else if (arguments.length === 1) {
            const lineStrings = arguments[0];
            return new (0, _multiLineStringJsDefault.default)(lineStrings, this);
        }
    }
    createPolygon() {
        if (arguments.length === 0) return this.createPolygon(null, null);
        else if (arguments.length === 1) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const shell = arguments[0];
                return this.createPolygon(this.createLinearRing(shell));
            } else if (arguments[0] instanceof Array) {
                const shell = arguments[0];
                return this.createPolygon(this.createLinearRing(shell));
            } else if (arguments[0] instanceof (0, _linearRingJsDefault.default)) {
                const shell = arguments[0];
                return this.createPolygon(shell, null);
            }
        } else if (arguments.length === 2) {
            const shell = arguments[0], holes = arguments[1];
            return new (0, _polygonJsDefault.default)(shell, holes, this);
        }
    }
    getSRID() {
        return this._SRID;
    }
    createGeometryCollection() {
        if (arguments.length === 0) return new (0, _geometryCollectionJsDefault.default)(null, this);
        else if (arguments.length === 1) {
            const geometries = arguments[0];
            return new (0, _geometryCollectionJsDefault.default)(geometries, this);
        }
    }
    getPrecisionModel() {
        return this._precisionModel;
    }
    createLinearRing() {
        if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
        else if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const coordinates = arguments[0];
                return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordinates = arguments[0];
                return new (0, _linearRingJsDefault.default)(coordinates, this);
            }
        }
    }
    createMultiPolygon() {
        if (arguments.length === 0) return new (0, _multiPolygonJsDefault.default)(null, this);
        else if (arguments.length === 1) {
            const polygons = arguments[0];
            return new (0, _multiPolygonJsDefault.default)(polygons, this);
        }
    }
    createMultiPoint() {
        if (arguments.length === 0) return new (0, _multiPointJsDefault.default)(null, this);
        else if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const point = arguments[0];
                return new (0, _multiPointJsDefault.default)(point, this);
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordinates = arguments[0];
                if (coordinates === null) return this.createMultiPoint(new Array(0).fill(null));
                const points = new Array(coordinates.size()).fill(null);
                for(let i = 0; i < coordinates.size(); i++){
                    const ptSeq = this.getCoordinateSequenceFactory().create(1, coordinates.getDimension(), coordinates.getMeasures());
                    (0, _coordinateSequencesJsDefault.default).copy(coordinates, i, ptSeq, 0, 1);
                    points[i] = this.createPoint(ptSeq);
                }
                return this.createMultiPoint(points);
            }
        }
    }
    buildGeometry(geomList) {
        let geomType = null;
        let isHeterogeneous = false;
        let hasGeometryCollection = false;
        for(let i = geomList.iterator(); i.hasNext();){
            const geom = i.next();
            const partType = geom.getTypeCode();
            if (geomType === null) geomType = partType;
            if (partType !== geomType) isHeterogeneous = true;
            if (geom instanceof (0, _geometryCollectionJsDefault.default)) hasGeometryCollection = true;
        }
        if (geomType === null) return this.createGeometryCollection();
        if (isHeterogeneous || hasGeometryCollection) return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList));
        const geom0 = geomList.iterator().next();
        const isCollection = geomList.size() > 1;
        if (isCollection) {
            if (geom0 instanceof (0, _polygonJsDefault.default)) return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList));
            else if (geom0 instanceof (0, _lineStringJsDefault.default)) return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList));
            else if (geom0 instanceof (0, _pointJsDefault.default)) return this.createMultiPoint(GeometryFactory.toPointArray(geomList));
            (0, _assertJsDefault.default).shouldNeverReachHere('Unhandled geometry type: ' + geom0.getGeometryType());
        }
        return geom0;
    }
    createMultiPointFromCoords(coordinates) {
        return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null);
    }
    createPoint() {
        if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
        else if (arguments.length === 1) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const coordinate = arguments[0];
                return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([
                    coordinate
                ]) : null);
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordinates = arguments[0];
                return new (0, _pointJsDefault.default)(coordinates, this);
            }
        }
    }
    getCoordinateSequenceFactory() {
        return this._coordinateSequenceFactory;
    }
    get interfaces_() {
        return [
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = GeometryFactory;

},{"../../../../hasInterface.js":"d8mIo","./LinearRing.js":"iks2I","./impl/CoordinateArraySequenceFactory.js":"bKVoa","./MultiPolygon.js":"56YaT","./CoordinateSequences.js":"fFRyy","./PrecisionModel.js":"9xUYw","../../../../java/io/Serializable.js":"4emqV","../util/Assert.js":"ePbcB","./MultiLineString.js":"fdpMS","./CoordinateSequenceFactory.js":"hAZID","./LineString.js":"1Hc8p","./Coordinate.js":"3REUb","../../../../java/lang/IllegalArgumentException.js":"1VQhm","./Point.js":"i9MoJ","./Polygon.js":"jawWe","./MultiPoint.js":"ikww2","./CoordinateSequence.js":"3GfKT","./GeometryCollection.js":"9xeCT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d8mIo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>function(o, i) {
        return o.interfaces_ && o.interfaces_.indexOf(i) > -1;
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iks2I":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("./LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _coordinateSequencesJs = require("./CoordinateSequences.js");
var _coordinateSequencesJsDefault = parcelHelpers.interopDefault(_coordinateSequencesJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
class LinearRing extends (0, _lineStringJsDefault.default) {
    constructor(){
        super();
        LinearRing.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const points = arguments[0], factory = arguments[1];
        (0, _lineStringJsDefault.default).constructor_.call(this, points, factory);
        this.validateConstruction();
    }
    copyInternal() {
        return new LinearRing(this._points.copy(), this._factory);
    }
    getBoundaryDimension() {
        return (0, _dimensionJsDefault.default).FALSE;
    }
    isClosed() {
        if (this.isEmpty()) return true;
        return super.isClosed.call(this);
    }
    reverseInternal() {
        const seq = this._points.copy();
        (0, _coordinateSequencesJsDefault.default).reverse(seq);
        return this.getFactory().createLinearRing(seq);
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_LINEARRING;
    }
    validateConstruction() {
        if (!this.isEmpty() && !super.isClosed.call(this)) throw new (0, _illegalArgumentExceptionJsDefault.default)('Points of LinearRing do not form a closed linestring');
        if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)');
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_LINEARRING;
    }
}
exports.default = LinearRing;
LinearRing.MINIMUM_VALID_SIZE = 4;

},{"./LineString.js":"1Hc8p","./Geometry.js":"d5V2e","../../../../java/lang/IllegalArgumentException.js":"1VQhm","./CoordinateSequences.js":"fFRyy","./Dimension.js":"966Ye","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Hc8p":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _lengthJs = require("../algorithm/Length.js");
var _lengthJsDefault = parcelHelpers.interopDefault(_lengthJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _geometryComponentFilterJs = require("./GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _unsupportedOperationExceptionJs = require("../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
var _coordinateArraysJs = require("./CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _envelopeJs = require("./Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _coordinateFilterJs = require("./CoordinateFilter.js");
var _coordinateFilterJsDefault = parcelHelpers.interopDefault(_coordinateFilterJs);
var _linealJs = require("./Lineal.js");
var _linealJsDefault = parcelHelpers.interopDefault(_linealJs);
var _coordinateSequencesJs = require("./CoordinateSequences.js");
var _coordinateSequencesJsDefault = parcelHelpers.interopDefault(_coordinateSequencesJs);
var _geometryFilterJs = require("./GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
var _coordinateSequenceFilterJs = require("./CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
class LineString extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        LineString.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._points = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 2) {
            const points = arguments[0], factory = arguments[1];
            (0, _geometryJsDefault.default).constructor_.call(this, factory);
            this.init(points);
        }
    }
    computeEnvelopeInternal() {
        if (this.isEmpty()) return new (0, _envelopeJsDefault.default)();
        return this._points.expandEnvelope(new (0, _envelopeJsDefault.default)());
    }
    isRing() {
        return this.isClosed() && (0, _coordinateArraysJsDefault.default).isRing(this.getCoordinates());
    }
    getCoordinates() {
        return this._points.toCoordinateArray();
    }
    copyInternal() {
        return new LineString(this._points.copy(), this._factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            const otherLineString = other;
            if (this._points.size() !== otherLineString._points.size()) return false;
            for(let i = 0; i < this._points.size(); i++)if (!this.equal(this._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) return false;
            return true;
        } else return super.equalsExact.apply(this, arguments);
    }
    isClosed() {
        if (this.isEmpty()) return false;
        return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
    }
    reverseInternal() {
        const seq = this._points.copy();
        (0, _coordinateSequencesJsDefault.default).reverse(seq);
        return this.getFactory().createLineString(seq);
    }
    getEndPoint() {
        if (this.isEmpty()) return null;
        return this.getPointN(this.getNumPoints() - 1);
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_LINESTRING;
    }
    getDimension() {
        return 1;
    }
    getBoundary() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
    isEquivalentClass(other) {
        return other instanceof LineString;
    }
    getCoordinateSequence() {
        return this._points;
    }
    getPointN(n) {
        return this.getFactory().createPoint(this._points.getCoordinate(n));
    }
    normalize() {
        for(let i = 0; i < Math.trunc(this._points.size() / 2); i++){
            const j = this._points.size() - 1 - i;
            if (!this._points.getCoordinate(i).equals(this._points.getCoordinate(j))) {
                if (this._points.getCoordinate(i).compareTo(this._points.getCoordinate(j)) > 0) {
                    const copy = this._points.copy();
                    (0, _coordinateSequencesJsDefault.default).reverse(copy);
                    this._points = copy;
                }
                return null;
            }
        }
    }
    getCoordinate() {
        if (this.isEmpty()) return null;
        return this._points.getCoordinate(0);
    }
    getBoundaryDimension() {
        if (this.isClosed()) return (0, _dimensionJsDefault.default).FALSE;
        return 0;
    }
    getLength() {
        return (0, _lengthJsDefault.default).ofLine(this._points);
    }
    getNumPoints() {
        return this._points.size();
    }
    compareToSameClass() {
        if (arguments.length === 1) {
            const o = arguments[0];
            const line = o;
            let i = 0;
            let j = 0;
            while(i < this._points.size() && j < line._points.size()){
                const comparison = this._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));
                if (comparison !== 0) return comparison;
                i++;
                j++;
            }
            if (i < this._points.size()) return 1;
            if (j < line._points.size()) return -1;
            return 0;
        } else if (arguments.length === 2) {
            const o = arguments[0], comp = arguments[1];
            const line = o;
            return comp.compare(this._points, line._points);
        }
    }
    apply() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateFilterJsDefault.default))) {
            const filter = arguments[0];
            for(let i = 0; i < this._points.size(); i++)filter.filter(this._points.getCoordinate(i));
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceFilterJsDefault.default))) {
            const filter = arguments[0];
            if (this._points.size() === 0) return null;
            for(let i = 0; i < this._points.size(); i++){
                filter.filter(this._points, i);
                if (filter.isDone()) break;
            }
            if (filter.isGeometryChanged()) this.geometryChanged();
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryComponentFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
        }
    }
    getCoordinateN(n) {
        return this._points.getCoordinate(n);
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_LINESTRING;
    }
    isEmpty() {
        return this._points.size() === 0;
    }
    init(points) {
        if (points === null) points = this.getFactory().getCoordinateSequenceFactory().create([]);
        if (points.size() === 1) throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)');
        this._points = points;
    }
    isCoordinate(pt) {
        for(let i = 0; i < this._points.size(); i++)if (this._points.getCoordinate(i).equals(pt)) return true;
        return false;
    }
    getStartPoint() {
        if (this.isEmpty()) return null;
        return this.getPointN(0);
    }
    get interfaces_() {
        return [
            (0, _linealJsDefault.default)
        ];
    }
}
exports.default = LineString;

},{"../../../../hasInterface.js":"d8mIo","../algorithm/Length.js":"2f2sM","../../../../java/lang/IllegalArgumentException.js":"1VQhm","./GeometryComponentFilter.js":"8aMWe","../../../../java/lang/UnsupportedOperationException.js":"fEx26","./CoordinateArrays.js":"hwXsf","./Dimension.js":"966Ye","./Envelope.js":"ha5UZ","./Geometry.js":"d5V2e","./CoordinateFilter.js":"9F02P","./Lineal.js":"fZhBn","./CoordinateSequences.js":"fFRyy","./GeometryFilter.js":"djHvd","./CoordinateSequenceFilter.js":"8HUHX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2f2sM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
class Length {
    static ofLine(pts) {
        const n = pts.size();
        if (n <= 1) return 0.0;
        let len = 0.0;
        const p = new (0, _coordinateJsDefault.default)();
        pts.getCoordinate(0, p);
        let x0 = p.x;
        let y0 = p.y;
        for(let i = 1; i < n; i++){
            pts.getCoordinate(i, p);
            const x1 = p.x;
            const y1 = p.y;
            const dx = x1 - x0;
            const dy = y1 - y0;
            len += Math.sqrt(dx * dx + dy * dy);
            x0 = x1;
            y0 = y1;
        }
        return len;
    }
}
exports.default = Length;

},{"../geom/Coordinate.js":"3REUb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8aMWe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class GeometryComponentFilter {
    filter(geom) {}
}
exports.default = GeometryComponentFilter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fEx26":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("./Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class UnsupportedOperationException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            UnsupportedOperationException
        })[0];
    }
}
exports.default = UnsupportedOperationException;

},{"./Exception.js":"gSmog","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwXsf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateListJs = require("./CoordinateList.js");
var _coordinateListJsDefault = parcelHelpers.interopDefault(_coordinateListJs);
var _coordinatesJs = require("./Coordinates.js");
var _coordinatesJsDefault = parcelHelpers.interopDefault(_coordinatesJs);
var _mathUtilJs = require("../math/MathUtil.js");
var _mathUtilJsDefault = parcelHelpers.interopDefault(_mathUtilJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _comparatorJs = require("../../../../java/util/Comparator.js");
var _comparatorJsDefault = parcelHelpers.interopDefault(_comparatorJs);
var _envelopeJs = require("./Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class CoordinateArrays {
    static scroll(coordinates, firstCoordinate) {
        const i = CoordinateArrays.indexOf(firstCoordinate, coordinates);
        if (i < 0) return null;
        const newCoordinates = new Array(coordinates.length).fill(null);
        (0, _systemJsDefault.default).arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);
        (0, _systemJsDefault.default).arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);
        (0, _systemJsDefault.default).arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);
    }
    static removeRepeatedPoints(coord) {
        if (!CoordinateArrays.hasRepeatedPoints(coord)) return coord;
        const coordList = new (0, _coordinateListJsDefault.default)(coord, false);
        return coordList.toCoordinateArray();
    }
    static reverse(coord) {
        const last = coord.length - 1;
        const mid = Math.trunc(last / 2);
        for(let i = 0; i <= mid; i++){
            const tmp = coord[i];
            coord[i] = coord[last - i];
            coord[last - i] = tmp;
        }
    }
    static removeNull(coord) {
        let nonNull = 0;
        for(let i = 0; i < coord.length; i++)if (coord[i] !== null) nonNull++;
        const newCoord = new Array(nonNull).fill(null);
        if (nonNull === 0) return newCoord;
        let j = 0;
        for(let i = 0; i < coord.length; i++)if (coord[i] !== null) newCoord[j++] = coord[i];
        return newCoord;
    }
    static copyDeep() {
        if (arguments.length === 1) {
            const coordinates = arguments[0];
            const copy = new Array(coordinates.length).fill(null);
            for(let i = 0; i < coordinates.length; i++)copy[i] = coordinates[i].copy();
            return copy;
        } else if (arguments.length === 5) {
            const src = arguments[0], srcStart = arguments[1], dest = arguments[2], destStart = arguments[3], length = arguments[4];
            for(let i = 0; i < length; i++)dest[destStart + i] = src[srcStart + i].copy();
        }
    }
    static isEqualReversed(pts1, pts2) {
        for(let i = 0; i < pts1.length; i++){
            const p1 = pts1[i];
            const p2 = pts2[pts1.length - i - 1];
            if (p1.compareTo(p2) !== 0) return false;
        }
        return true;
    }
    static envelope(coordinates) {
        const env = new (0, _envelopeJsDefault.default)();
        for(let i = 0; i < coordinates.length; i++)env.expandToInclude(coordinates[i]);
        return env;
    }
    static extract(pts, start, end) {
        start = (0, _mathUtilJsDefault.default).clamp(start, 0, pts.length);
        end = (0, _mathUtilJsDefault.default).clamp(end, -1, pts.length);
        let npts = end - start + 1;
        if (end < 0) npts = 0;
        if (start >= pts.length) npts = 0;
        if (end < start) npts = 0;
        const extractPts = new Array(npts).fill(null);
        if (npts === 0) return extractPts;
        let iPts = 0;
        for(let i = start; i <= end; i++)extractPts[iPts++] = pts[i];
        return extractPts;
    }
    static isRing(pts) {
        if (pts.length < 4) return false;
        if (!pts[0].equals2D(pts[pts.length - 1])) return false;
        return true;
    }
    static ptNotInList(testPts, pts) {
        for(let i = 0; i < testPts.length; i++){
            const testPt = testPts[i];
            if (CoordinateArrays.indexOf(testPt, pts) < 0) return testPt;
        }
        return null;
    }
    static equals() {
        if (arguments.length === 2) {
            const coord1 = arguments[0], coord2 = arguments[1];
            if (coord1 === coord2) return true;
            if (coord1 === null || coord2 === null) return false;
            if (coord1.length !== coord2.length) return false;
            for(let i = 0; i < coord1.length; i++)if (!coord1[i].equals(coord2[i])) return false;
            return true;
        } else if (arguments.length === 3) {
            const coord1 = arguments[0], coord2 = arguments[1], coordinateComparator = arguments[2];
            if (coord1 === coord2) return true;
            if (coord1 === null || coord2 === null) return false;
            if (coord1.length !== coord2.length) return false;
            for(let i = 0; i < coord1.length; i++)if (coordinateComparator.compare(coord1[i], coord2[i]) !== 0) return false;
            return true;
        }
    }
    static intersection(coordinates, env) {
        const coordList = new (0, _coordinateListJsDefault.default)();
        for(let i = 0; i < coordinates.length; i++)if (env.intersects(coordinates[i])) coordList.add(coordinates[i], true);
        return coordList.toCoordinateArray();
    }
    static measures(pts) {
        if (pts === null || pts.length === 0) return 0;
        let measures = 0;
        for (const coordinate of pts)measures = Math.max(measures, (0, _coordinatesJsDefault.default).measures(coordinate));
        return measures;
    }
    static hasRepeatedPoints(coord) {
        for(let i = 1; i < coord.length; i++)if (coord[i - 1].equals(coord[i])) return true;
        return false;
    }
    static toCoordinateArray(coordList) {
        return coordList.toArray(CoordinateArrays.coordArrayType);
    }
    static dimension(pts) {
        if (pts === null || pts.length === 0) return 3;
        let dimension = 0;
        for (const coordinate of pts)dimension = Math.max(dimension, (0, _coordinatesJsDefault.default).dimension(coordinate));
        return dimension;
    }
    static atLeastNCoordinatesOrNothing(n, c) {
        return c.length >= n ? c : [];
    }
    static indexOf(coordinate, coordinates) {
        for(let i = 0; i < coordinates.length; i++)if (coordinate.equals(coordinates[i])) return i;
        return -1;
    }
    static increasingDirection(pts) {
        for(let i = 0; i < Math.trunc(pts.length / 2); i++){
            const j = pts.length - 1 - i;
            const comp = pts[i].compareTo(pts[j]);
            if (comp !== 0) return comp;
        }
        return 1;
    }
    static compare(pts1, pts2) {
        let i = 0;
        while(i < pts1.length && i < pts2.length){
            const compare = pts1[i].compareTo(pts2[i]);
            if (compare !== 0) return compare;
            i++;
        }
        if (i < pts2.length) return -1;
        if (i < pts1.length) return 1;
        return 0;
    }
    static minCoordinate(coordinates) {
        let minCoord = null;
        for(let i = 0; i < coordinates.length; i++)if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) minCoord = coordinates[i];
        return minCoord;
    }
}
exports.default = CoordinateArrays;
class ForwardComparator {
    compare(o1, o2) {
        const pts1 = o1;
        const pts2 = o2;
        return CoordinateArrays.compare(pts1, pts2);
    }
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
}
class BidirectionalComparator {
    compare(o1, o2) {
        const pts1 = o1;
        const pts2 = o2;
        if (pts1.length < pts2.length) return -1;
        if (pts1.length > pts2.length) return 1;
        if (pts1.length === 0) return 0;
        const forwardComp = CoordinateArrays.compare(pts1, pts2);
        const isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);
        if (isEqualRev) return 0;
        return forwardComp;
    }
    OLDcompare(o1, o2) {
        const pts1 = o1;
        const pts2 = o2;
        if (pts1.length < pts2.length) return -1;
        if (pts1.length > pts2.length) return 1;
        if (pts1.length === 0) return 0;
        const dir1 = CoordinateArrays.increasingDirection(pts1);
        const dir2 = CoordinateArrays.increasingDirection(pts2);
        let i1 = dir1 > 0 ? 0 : pts1.length - 1;
        let i2 = dir2 > 0 ? 0 : pts1.length - 1;
        for(let i = 0; i < pts1.length; i++){
            const comparePt = pts1[i1].compareTo(pts2[i2]);
            if (comparePt !== 0) return comparePt;
            i1 += dir1;
            i2 += dir2;
        }
        return 0;
    }
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
}
CoordinateArrays.ForwardComparator = ForwardComparator;
CoordinateArrays.BidirectionalComparator = BidirectionalComparator;
CoordinateArrays.coordArrayType = new Array(0).fill(null);

},{"./CoordinateList.js":"39sXT","./Coordinates.js":"iNVOk","../math/MathUtil.js":"hTgav","../../../../java/lang/System.js":"11VqP","../../../../java/util/Comparator.js":"6CEtH","./Envelope.js":"ha5UZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"39sXT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _collectionJs = require("../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class CoordinateList extends (0, _arrayListJsDefault.default) {
    constructor(){
        super();
        CoordinateList.constructor_.apply(this, arguments);
    }
    static constructor_() {
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const coord = arguments[0];
            this.ensureCapacity(coord.length);
            this.add(coord, true);
        } else if (arguments.length === 2) {
            const coord = arguments[0], allowRepeated = arguments[1];
            this.ensureCapacity(coord.length);
            this.add(coord, allowRepeated);
        }
    }
    getCoordinate(i) {
        return this.get(i);
    }
    addAll() {
        if (arguments.length === 2 && typeof arguments[1] === 'boolean' && (0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const coll = arguments[0], allowRepeated = arguments[1];
            let isChanged = false;
            for(let i = coll.iterator(); i.hasNext();){
                this.add(i.next(), allowRepeated);
                isChanged = true;
            }
            return isChanged;
        } else return super.addAll.apply(this, arguments);
    }
    clone() {
        const clone = super.clone.call(this);
        for(let i = 0; i < this.size(); i++)clone.add(i, this.get(i).clone());
        return clone;
    }
    closeRing() {
        if (this.size() > 0) {
            const duplicate = this.get(0).copy();
            this.add(duplicate, false);
        }
    }
    toCoordinateArray() {
        if (arguments.length === 0) return this.toArray(CoordinateList.coordArrayType);
        else if (arguments.length === 1) {
            const isForward = arguments[0];
            if (isForward) return this.toArray(CoordinateList.coordArrayType);
            const size = this.size();
            const pts = new Array(size).fill(null);
            for(let i = 0; i < size; i++)pts[i] = this.get(size - i - 1);
            return pts;
        }
    }
    add() {
        if (arguments.length === 1) {
            const coord = arguments[0];
            return super.add.call(this, coord);
        } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {
                const coord = arguments[0], allowRepeated = arguments[1];
                this.add(coord, allowRepeated, true);
                return true;
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && typeof arguments[1] === 'boolean') {
                const coord = arguments[0], allowRepeated = arguments[1];
                if (!allowRepeated) {
                    if (this.size() >= 1) {
                        const last = this.get(this.size() - 1);
                        if (last.equals2D(coord)) return null;
                    }
                }
                super.add.call(this, coord);
            } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {
                const obj = arguments[0], allowRepeated = arguments[1];
                this.add(obj, allowRepeated);
                return true;
            }
        } else if (arguments.length === 3) {
            if (typeof arguments[2] === 'boolean' && arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {
                const coord = arguments[0], allowRepeated = arguments[1], direction = arguments[2];
                if (direction) for(let i = 0; i < coord.length; i++)this.add(coord[i], allowRepeated);
                else for(let i = coord.length - 1; i >= 0; i--)this.add(coord[i], allowRepeated);
                return true;
            } else if (typeof arguments[2] === 'boolean' && Number.isInteger(arguments[0]) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
                const i = arguments[0], coord = arguments[1], allowRepeated = arguments[2];
                if (!allowRepeated) {
                    const size = this.size();
                    if (size > 0) {
                        if (i > 0) {
                            const prev = this.get(i - 1);
                            if (prev.equals2D(coord)) return null;
                        }
                        if (i < size) {
                            const next = this.get(i);
                            if (next.equals2D(coord)) return null;
                        }
                    }
                }
                super.add.call(this, i, coord);
            }
        } else if (arguments.length === 4) {
            const coord = arguments[0], allowRepeated = arguments[1], start = arguments[2], end = arguments[3];
            let inc = 1;
            if (start > end) inc = -1;
            for(let i = start; i !== end; i += inc)this.add(coord[i], allowRepeated);
            return true;
        }
    }
}
exports.default = CoordinateList;
CoordinateList.coordArrayType = new Array(0).fill(null);

},{"../../../../hasInterface.js":"d8mIo","../../../../java/util/Collection.js":"fbl5V","./Coordinate.js":"3REUb","../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fbl5V":[function(require,module,exports,__globalThis) {
/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Collection {
    /**
     * Ensures that this collection contains the specified element (optional
     * operation).
     * @param {Object} e
     * @return {boolean}
     */ add() {}
    /**
     * Appends all of the elements in the specified collection to the end of this
     * list, in the order that they are returned by the specified collection's
     * iterator (optional operation).
     * @param {javascript.util.Collection} c
     * @return {boolean}
     */ addAll() {}
    /**
     * Returns true if this collection contains no elements.
     * @return {boolean}
     */ isEmpty() {}
    /**
     * Returns an iterator over the elements in this collection.
     * @return {javascript.util.Iterator}
     */ iterator() {}
    /**
     * Returns an iterator over the elements in this collection.
     * @return {number}
     */ size() {}
    /**
     * Returns an array containing all of the elements in this collection.
     * @return {Array}
     */ toArray() {}
    /**
     * Removes a single instance of the specified element from this collection if it
     * is present. (optional)
     * @param {Object} e
     * @return {boolean}
     */ remove() {}
}
exports.default = Collection;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g8omH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _indexOutOfBoundsExceptionJs = require("../lang/IndexOutOfBoundsException.js");
var _indexOutOfBoundsExceptionJsDefault = parcelHelpers.interopDefault(_indexOutOfBoundsExceptionJs);
var _listJs = require("./List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
var _noSuchElementExceptionJs = require("./NoSuchElementException.js");
var _noSuchElementExceptionJsDefault = parcelHelpers.interopDefault(_noSuchElementExceptionJs);
class ArrayList extends (0, _listJsDefault.default) {
    constructor(o){
        super();
        this.array = [];
        if (o instanceof (0, _collectionJsDefault.default)) this.addAll(o);
    }
    get interfaces_() {
        return [
            (0, _listJsDefault.default),
            (0, _collectionJsDefault.default)
        ];
    }
    ensureCapacity() {}
    add(e) {
        if (arguments.length === 1) this.array.push(e);
        else this.array.splice(arguments[0], 0, arguments[1]);
        return true;
    }
    clear() {
        this.array = [];
    }
    addAll(c) {
        for (const e of c)this.array.push(e);
    }
    set(index, element) {
        const oldElement = this.array[index];
        this.array[index] = element;
        return oldElement;
    }
    iterator() {
        return new Iterator(this);
    }
    get(index) {
        if (index < 0 || index >= this.size()) throw new (0, _indexOutOfBoundsExceptionJsDefault.default)();
        return this.array[index];
    }
    isEmpty() {
        return this.array.length === 0;
    }
    sort(comparator) {
        if (comparator) this.array.sort((a, b)=>comparator.compare(a, b));
        else this.array.sort();
    }
    size() {
        return this.array.length;
    }
    toArray() {
        return this.array.slice();
    }
    remove(o) {
        for(let i = 0, len = this.array.length; i < len; i++)if (this.array[i] === o) return !!this.array.splice(i, 1);
        return false;
    }
    [Symbol.iterator]() {
        return this.array.values();
    }
}
exports.default = ArrayList;
class Iterator {
    constructor(arrayList){
        this.arrayList = arrayList;
        this.position = 0;
    }
    next() {
        if (this.position === this.arrayList.size()) throw new (0, _noSuchElementExceptionJsDefault.default)();
        return this.arrayList.get(this.position++);
    }
    hasNext() {
        return this.position < this.arrayList.size();
    }
    set(element) {
        return this.arrayList.set(this.position - 1, element);
    }
    remove() {
        this.arrayList.remove(this.arrayList.get(this.position));
    }
}

},{"./Collection.js":"fbl5V","../lang/IndexOutOfBoundsException.js":"hKwCB","./List.js":"5xM2g","./NoSuchElementException.js":"1NxXp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hKwCB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("./Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class IndexOutOfBoundsException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            IndexOutOfBoundsException
        })[0];
    }
}
exports.default = IndexOutOfBoundsException;

},{"./Exception.js":"gSmog","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5xM2g":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
class List extends (0, _collectionJsDefault.default) {
    /**
     * Returns the element at the specified position in this list.
     * @param {number} index
     * @return {Object}
     */ get() {}
    /**
     * Replaces the element at the specified position in this list with the
     * specified element (optional operation).
     * @param {number} index
     * @param {Object} e
     * @return {Object}
     */ set() {}
    /**
     * Returns true if this collection contains no elements.
     * @return {boolean}
     */ isEmpty() {}
}
exports.default = List;

},{"./Collection.js":"fbl5V","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1NxXp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("../lang/Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class NoSuchElementException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            NoSuchElementException
        })[0];
    }
}
exports.default = NoSuchElementException;

},{"../lang/Exception.js":"gSmog","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iNVOk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateXYJs = require("./CoordinateXY.js");
var _coordinateXYJsDefault = parcelHelpers.interopDefault(_coordinateXYJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _coordinateXYMJs = require("./CoordinateXYM.js");
var _coordinateXYMJsDefault = parcelHelpers.interopDefault(_coordinateXYMJs);
var _coordinateXYZMJs = require("./CoordinateXYZM.js");
var _coordinateXYZMJsDefault = parcelHelpers.interopDefault(_coordinateXYZMJs);
class Coordinates {
    static measures(coordinate) {
        if (coordinate instanceof (0, _coordinateXYJsDefault.default)) return 0;
        else if (coordinate instanceof (0, _coordinateXYMJsDefault.default)) return 1;
        else if (coordinate instanceof (0, _coordinateXYZMJsDefault.default)) return 1;
        else if (coordinate instanceof (0, _coordinateJsDefault.default)) return 0;
        return 0;
    }
    static create() {
        if (arguments.length === 1) {
            const dimension = arguments[0];
            return Coordinates.create(dimension, 0);
        } else if (arguments.length === 2) {
            const dimension = arguments[0], measures = arguments[1];
            if (dimension === 2) return new (0, _coordinateXYJsDefault.default)();
            else if (dimension === 3 && measures === 0) return new (0, _coordinateJsDefault.default)();
            else if (dimension === 3 && measures === 1) return new (0, _coordinateXYMJsDefault.default)();
            else if (dimension === 4 && measures === 1) return new (0, _coordinateXYZMJsDefault.default)();
            return new (0, _coordinateJsDefault.default)();
        }
    }
    static dimension(coordinate) {
        if (coordinate instanceof (0, _coordinateXYJsDefault.default)) return 2;
        else if (coordinate instanceof (0, _coordinateXYMJsDefault.default)) return 3;
        else if (coordinate instanceof (0, _coordinateXYZMJsDefault.default)) return 4;
        else if (coordinate instanceof (0, _coordinateJsDefault.default)) return 3;
        return 3;
    }
}
exports.default = Coordinates;

},{"./CoordinateXY.js":"gufGP","./Coordinate.js":"3REUb","./CoordinateXYM.js":"7v4Sk","./CoordinateXYZM.js":"g5hXR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gufGP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class CoordinateXY extends (0, _coordinateJsDefault.default) {
    constructor(){
        super();
        CoordinateXY.constructor_.apply(this, arguments);
    }
    static constructor_() {
        if (arguments.length === 0) (0, _coordinateJsDefault.default).constructor_.call(this);
        else if (arguments.length === 1) {
            if (arguments[0] instanceof CoordinateXY) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord.x, coord.y);
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord.x, coord.y);
            }
        } else if (arguments.length === 2) {
            const x = arguments[0], y = arguments[1];
            (0, _coordinateJsDefault.default).constructor_.call(this, x, y, (0, _coordinateJsDefault.default).NULL_ORDINATE);
        }
    }
    setOrdinate(ordinateIndex, value) {
        switch(ordinateIndex){
            case CoordinateXY.X:
                this.x = value;
                break;
            case CoordinateXY.Y:
                this.y = value;
                break;
            default:
                throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
        }
    }
    setZ(z) {
        throw new (0, _illegalArgumentExceptionJsDefault.default)('CoordinateXY dimension 2 does not support z-ordinate');
    }
    copy() {
        return new CoordinateXY(this);
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ')';
    }
    setCoordinate(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.getZ();
    }
    getZ() {
        return (0, _coordinateJsDefault.default).NULL_ORDINATE;
    }
    getOrdinate(ordinateIndex) {
        switch(ordinateIndex){
            case CoordinateXY.X:
                return this.x;
            case CoordinateXY.Y:
                return this.y;
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
    }
}
exports.default = CoordinateXY;
CoordinateXY.X = 0;
CoordinateXY.Y = 1;
CoordinateXY.Z = -1;
CoordinateXY.M = -1;

},{"./Coordinate.js":"3REUb","../../../../java/lang/IllegalArgumentException.js":"1VQhm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7v4Sk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class CoordinateXYM extends (0, _coordinateJsDefault.default) {
    constructor(){
        super();
        CoordinateXYM.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._m = null;
        if (arguments.length === 0) {
            (0, _coordinateJsDefault.default).constructor_.call(this);
            this._m = 0.0;
        } else if (arguments.length === 1) {
            if (arguments[0] instanceof CoordinateXYM) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord.x, coord.y);
                this._m = coord._m;
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord.x, coord.y);
                this._m = this.getM();
            }
        } else if (arguments.length === 3) {
            const x = arguments[0], y = arguments[1], m = arguments[2];
            (0, _coordinateJsDefault.default).constructor_.call(this, x, y, (0, _coordinateJsDefault.default).NULL_ORDINATE);
            this._m = m;
        }
    }
    setM(m) {
        this._m = m;
    }
    setZ(z) {
        throw new (0, _illegalArgumentExceptionJsDefault.default)('CoordinateXY dimension 2 does not support z-ordinate');
    }
    copy() {
        return new CoordinateXYM(this);
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ' m=' + this.getM() + ')';
    }
    setCoordinate(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.getZ();
        this._m = other.getM();
    }
    getM() {
        return this._m;
    }
    setOrdinate(ordinateIndex, value) {
        switch(ordinateIndex){
            case CoordinateXYM.X:
                this.x = value;
                break;
            case CoordinateXYM.Y:
                this.y = value;
                break;
            case CoordinateXYM.M:
                this._m = value;
                break;
            default:
                throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
        }
    }
    getZ() {
        return (0, _coordinateJsDefault.default).NULL_ORDINATE;
    }
    getOrdinate(ordinateIndex) {
        switch(ordinateIndex){
            case CoordinateXYM.X:
                return this.x;
            case CoordinateXYM.Y:
                return this.y;
            case CoordinateXYM.M:
                return this._m;
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
    }
}
exports.default = CoordinateXYM;
CoordinateXYM.X = 0;
CoordinateXYM.Y = 1;
CoordinateXYM.Z = -1;
CoordinateXYM.M = 2;

},{"./Coordinate.js":"3REUb","../../../../java/lang/IllegalArgumentException.js":"1VQhm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g5hXR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class CoordinateXYZM extends (0, _coordinateJsDefault.default) {
    constructor(){
        super();
        CoordinateXYZM.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._m = null;
        if (arguments.length === 0) {
            (0, _coordinateJsDefault.default).constructor_.call(this);
            this._m = 0.0;
        } else if (arguments.length === 1) {
            if (arguments[0] instanceof CoordinateXYZM) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord);
                this._m = coord._m;
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const coord = arguments[0];
                (0, _coordinateJsDefault.default).constructor_.call(this, coord);
                this._m = this.getM();
            }
        } else if (arguments.length === 4) {
            const x = arguments[0], y = arguments[1], z = arguments[2], m = arguments[3];
            (0, _coordinateJsDefault.default).constructor_.call(this, x, y, z);
            this._m = m;
        }
    }
    setM(m) {
        this._m = m;
    }
    getOrdinate(ordinateIndex) {
        switch(ordinateIndex){
            case (0, _coordinateJsDefault.default).X:
                return this.x;
            case (0, _coordinateJsDefault.default).Y:
                return this.y;
            case (0, _coordinateJsDefault.default).Z:
                return this.getZ();
            case (0, _coordinateJsDefault.default).M:
                return this.getM();
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
    }
    copy() {
        return new CoordinateXYZM(this);
    }
    toString() {
        return '(' + this.x + ', ' + this.y + ', ' + this.getZ() + ' m=' + this.getM() + ')';
    }
    setCoordinate(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.getZ();
        this._m = other.getM();
    }
    getM() {
        return this._m;
    }
    setOrdinate(ordinateIndex, value) {
        switch(ordinateIndex){
            case (0, _coordinateJsDefault.default).X:
                this.x = value;
                break;
            case (0, _coordinateJsDefault.default).Y:
                this.y = value;
                break;
            case (0, _coordinateJsDefault.default).Z:
                this.z = value;
                break;
            case (0, _coordinateJsDefault.default).M:
                this._m = value;
                break;
            default:
                throw new (0, _illegalArgumentExceptionJsDefault.default)('Invalid ordinate index: ' + ordinateIndex);
        }
    }
}
exports.default = CoordinateXYZM;

},{"./Coordinate.js":"3REUb","../../../../java/lang/IllegalArgumentException.js":"1VQhm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hTgav":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
class MathUtil {
    static log10(x) {
        const ln = Math.log(x);
        if ((0, _doubleJsDefault.default).isInfinite(ln)) return ln;
        if ((0, _doubleJsDefault.default).isNaN(ln)) return ln;
        return ln / MathUtil.LOG_10;
    }
    static min(v1, v2, v3, v4) {
        let min = v1;
        if (v2 < min) min = v2;
        if (v3 < min) min = v3;
        if (v4 < min) min = v4;
        return min;
    }
    static clamp() {
        if (typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            const x = arguments[0], min = arguments[1], max = arguments[2];
            if (x < min) return min;
            if (x > max) return max;
            return x;
        } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            const x = arguments[0], min = arguments[1], max = arguments[2];
            if (x < min) return min;
            if (x > max) return max;
            return x;
        }
    }
    static average(x1, x2) {
        return (x1 + x2) / 2.0;
    }
    static wrap(index, max) {
        if (index < 0) return max - -index % max;
        return index % max;
    }
    static max() {
        if (arguments.length === 3) {
            const v1 = arguments[0], v2 = arguments[1], v3 = arguments[2];
            let max = v1;
            if (v2 > max) max = v2;
            if (v3 > max) max = v3;
            return max;
        } else if (arguments.length === 4) {
            const v1 = arguments[0], v2 = arguments[1], v3 = arguments[2], v4 = arguments[3];
            let max = v1;
            if (v2 > max) max = v2;
            if (v3 > max) max = v3;
            if (v4 > max) max = v4;
            return max;
        }
    }
}
exports.default = MathUtil;
MathUtil.LOG_10 = Math.log(10);

},{"../../../../java/lang/Double.js":"jCc26","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"11VqP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class System {
    static arraycopy(src, srcPos, dest, destPos, len) {
        let c = 0;
        for(let i = srcPos; i < srcPos + len; i++){
            dest[destPos + c] = src[i];
            c++;
        }
    }
    static getProperty(name) {
        return ({
            'line.separator': '\n'
        })[name];
    }
}
exports.default = System;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ha5UZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
class Envelope {
    constructor(){
        Envelope.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._minx = null;
        this._maxx = null;
        this._miny = null;
        this._maxy = null;
        if (arguments.length === 0) this.init();
        else if (arguments.length === 1) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                this.init(p.x, p.x, p.y, p.y);
            } else if (arguments[0] instanceof Envelope) {
                const env = arguments[0];
                this.init(env);
            }
        } else if (arguments.length === 2) {
            const p1 = arguments[0], p2 = arguments[1];
            this.init(p1.x, p2.x, p1.y, p2.y);
        } else if (arguments.length === 4) {
            const x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];
            this.init(x1, x2, y1, y2);
        }
    }
    static intersects() {
        if (arguments.length === 3) {
            const p1 = arguments[0], p2 = arguments[1], q = arguments[2];
            if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y)) return true;
            return false;
        } else if (arguments.length === 4) {
            const p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];
            let minq = Math.min(q1.x, q2.x);
            let maxq = Math.max(q1.x, q2.x);
            let minp = Math.min(p1.x, p2.x);
            let maxp = Math.max(p1.x, p2.x);
            if (minp > maxq) return false;
            if (maxp < minq) return false;
            minq = Math.min(q1.y, q2.y);
            maxq = Math.max(q1.y, q2.y);
            minp = Math.min(p1.y, p2.y);
            maxp = Math.max(p1.y, p2.y);
            if (minp > maxq) return false;
            if (maxp < minq) return false;
            return true;
        }
    }
    getArea() {
        return this.getWidth() * this.getHeight();
    }
    getMinX() {
        return this._minx;
    }
    expandToInclude() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                this.expandToInclude(p.x, p.y);
            } else if (arguments[0] instanceof Envelope) {
                const other = arguments[0];
                if (other.isNull()) return null;
                if (this.isNull()) {
                    this._minx = other.getMinX();
                    this._maxx = other.getMaxX();
                    this._miny = other.getMinY();
                    this._maxy = other.getMaxY();
                } else {
                    if (other._minx < this._minx) this._minx = other._minx;
                    if (other._maxx > this._maxx) this._maxx = other._maxx;
                    if (other._miny < this._miny) this._miny = other._miny;
                    if (other._maxy > this._maxy) this._maxy = other._maxy;
                }
            }
        } else if (arguments.length === 2) {
            const x = arguments[0], y = arguments[1];
            if (this.isNull()) {
                this._minx = x;
                this._maxx = x;
                this._miny = y;
                this._maxy = y;
            } else {
                if (x < this._minx) this._minx = x;
                if (x > this._maxx) this._maxx = x;
                if (y < this._miny) this._miny = y;
                if (y > this._maxy) this._maxy = y;
            }
        }
    }
    compareTo(o) {
        const env = o;
        if (this.isNull()) {
            if (env.isNull()) return 0;
            return -1;
        } else {
            if (env.isNull()) return 1;
        }
        if (this._minx < env._minx) return -1;
        if (this._minx > env._minx) return 1;
        if (this._miny < env._miny) return -1;
        if (this._miny > env._miny) return 1;
        if (this._maxx < env._maxx) return -1;
        if (this._maxx > env._maxx) return 1;
        if (this._maxy < env._maxy) return -1;
        if (this._maxy > env._maxy) return 1;
        return 0;
    }
    translate(transX, transY) {
        if (this.isNull()) return null;
        this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);
    }
    copy() {
        return new Envelope(this);
    }
    expandBy() {
        if (arguments.length === 1) {
            const distance = arguments[0];
            this.expandBy(distance, distance);
        } else if (arguments.length === 2) {
            const deltaX = arguments[0], deltaY = arguments[1];
            if (this.isNull()) return null;
            this._minx -= deltaX;
            this._maxx += deltaX;
            this._miny -= deltaY;
            this._maxy += deltaY;
            if (this._minx > this._maxx || this._miny > this._maxy) this.setToNull();
        }
    }
    contains() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Envelope) {
                const other = arguments[0];
                return this.covers(other);
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                return this.covers(p);
            }
        } else if (arguments.length === 2) {
            const x = arguments[0], y = arguments[1];
            return this.covers(x, y);
        }
    }
    hashCode() {
        let result = 17;
        result = 37 * result + (0, _coordinateJsDefault.default).hashCode(this._minx);
        result = 37 * result + (0, _coordinateJsDefault.default).hashCode(this._maxx);
        result = 37 * result + (0, _coordinateJsDefault.default).hashCode(this._miny);
        result = 37 * result + (0, _coordinateJsDefault.default).hashCode(this._maxy);
        return result;
    }
    equals(other) {
        if (!(other instanceof Envelope)) return false;
        const otherEnvelope = other;
        if (this.isNull()) return otherEnvelope.isNull();
        return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY();
    }
    intersection(env) {
        if (this.isNull() || env.isNull() || !this.intersects(env)) return new Envelope();
        const intMinX = this._minx > env._minx ? this._minx : env._minx;
        const intMinY = this._miny > env._miny ? this._miny : env._miny;
        const intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;
        const intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;
        return new Envelope(intMinX, intMaxX, intMinY, intMaxY);
    }
    isNull() {
        return this._maxx < this._minx;
    }
    getMaxX() {
        return this._maxx;
    }
    covers() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                return this.covers(p.x, p.y);
            } else if (arguments[0] instanceof Envelope) {
                const other = arguments[0];
                if (this.isNull() || other.isNull()) return false;
                return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy;
            }
        } else if (arguments.length === 2) {
            const x = arguments[0], y = arguments[1];
            if (this.isNull()) return false;
            return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy;
        }
    }
    intersects() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Envelope) {
                const other = arguments[0];
                if (this.isNull() || other.isNull()) return false;
                return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny);
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                return this.intersects(p.x, p.y);
            }
        } else if (arguments.length === 2) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
                const a = arguments[0], b = arguments[1];
                if (this.isNull()) return false;
                const envminx = a.x < b.x ? a.x : b.x;
                if (envminx > this._maxx) return false;
                const envmaxx = a.x > b.x ? a.x : b.x;
                if (envmaxx < this._minx) return false;
                const envminy = a.y < b.y ? a.y : b.y;
                if (envminy > this._maxy) return false;
                const envmaxy = a.y > b.y ? a.y : b.y;
                if (envmaxy < this._miny) return false;
                return true;
            } else if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
                const x = arguments[0], y = arguments[1];
                if (this.isNull()) return false;
                return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny);
            }
        }
    }
    getMinY() {
        return this._miny;
    }
    getDiameter() {
        if (this.isNull()) return 0;
        const w = this.getWidth();
        const h = this.getHeight();
        return Math.sqrt(w * w + h * h);
    }
    minExtent() {
        if (this.isNull()) return 0.0;
        const w = this.getWidth();
        const h = this.getHeight();
        if (w < h) return w;
        return h;
    }
    getWidth() {
        if (this.isNull()) return 0;
        return this._maxx - this._minx;
    }
    toString() {
        return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']';
    }
    setToNull() {
        this._minx = 0;
        this._maxx = -1;
        this._miny = 0;
        this._maxy = -1;
    }
    disjoint(other) {
        if (this.isNull() || other.isNull()) return true;
        return other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny;
    }
    getHeight() {
        if (this.isNull()) return 0;
        return this._maxy - this._miny;
    }
    maxExtent() {
        if (this.isNull()) return 0.0;
        const w = this.getWidth();
        const h = this.getHeight();
        if (w > h) return w;
        return h;
    }
    centre() {
        if (this.isNull()) return null;
        return new (0, _coordinateJsDefault.default)((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0);
    }
    init() {
        if (arguments.length === 0) this.setToNull();
        else if (arguments.length === 1) {
            if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
                const p = arguments[0];
                this.init(p.x, p.x, p.y, p.y);
            } else if (arguments[0] instanceof Envelope) {
                const env = arguments[0];
                this._minx = env._minx;
                this._maxx = env._maxx;
                this._miny = env._miny;
                this._maxy = env._maxy;
            }
        } else if (arguments.length === 2) {
            const p1 = arguments[0], p2 = arguments[1];
            this.init(p1.x, p2.x, p1.y, p2.y);
        } else if (arguments.length === 4) {
            const x1 = arguments[0], x2 = arguments[1], y1 = arguments[2], y2 = arguments[3];
            if (x1 < x2) {
                this._minx = x1;
                this._maxx = x2;
            } else {
                this._minx = x2;
                this._maxx = x1;
            }
            if (y1 < y2) {
                this._miny = y1;
                this._maxy = y2;
            } else {
                this._miny = y2;
                this._maxy = y1;
            }
        }
    }
    getMaxY() {
        return this._maxy;
    }
    distance(env) {
        if (this.intersects(env)) return 0;
        let dx = 0.0;
        if (this._maxx < env._minx) dx = env._minx - this._maxx;
        else if (this._minx > env._maxx) dx = this._minx - env._maxx;
        let dy = 0.0;
        if (this._maxy < env._miny) dy = env._miny - this._maxy;
        else if (this._miny > env._maxy) dy = this._miny - env._maxy;
        if (dx === 0.0) return dy;
        if (dy === 0.0) return dx;
        return Math.sqrt(dx * dx + dy * dy);
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = Envelope;

},{"./Coordinate.js":"3REUb","../../../../java/lang/Comparable.js":"6Adw4","../../../../java/io/Serializable.js":"4emqV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"966Ye":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _characterJs = require("../../../../java/lang/Character.js");
var _characterJsDefault = parcelHelpers.interopDefault(_characterJs);
class Dimension {
    static toDimensionSymbol(dimensionValue) {
        switch(dimensionValue){
            case Dimension.FALSE:
                return Dimension.SYM_FALSE;
            case Dimension.TRUE:
                return Dimension.SYM_TRUE;
            case Dimension.DONTCARE:
                return Dimension.SYM_DONTCARE;
            case Dimension.P:
                return Dimension.SYM_P;
            case Dimension.L:
                return Dimension.SYM_L;
            case Dimension.A:
                return Dimension.SYM_A;
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Unknown dimension value: ' + dimensionValue);
    }
    static toDimensionValue(dimensionSymbol) {
        switch((0, _characterJsDefault.default).toUpperCase(dimensionSymbol)){
            case Dimension.SYM_FALSE:
                return Dimension.FALSE;
            case Dimension.SYM_TRUE:
                return Dimension.TRUE;
            case Dimension.SYM_DONTCARE:
                return Dimension.DONTCARE;
            case Dimension.SYM_P:
                return Dimension.P;
            case Dimension.SYM_L:
                return Dimension.L;
            case Dimension.SYM_A:
                return Dimension.A;
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Unknown dimension symbol: ' + dimensionSymbol);
    }
}
exports.default = Dimension;
Dimension.P = 0;
Dimension.L = 1;
Dimension.A = 2;
Dimension.FALSE = -1;
Dimension.TRUE = -2;
Dimension.DONTCARE = -3;
Dimension.SYM_FALSE = 'F';
Dimension.SYM_TRUE = 'T';
Dimension.SYM_DONTCARE = '*';
Dimension.SYM_P = '0';
Dimension.SYM_L = '1';
Dimension.SYM_A = '2';

},{"../../../../java/lang/IllegalArgumentException.js":"1VQhm","../../../../java/lang/Character.js":"kHj8q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kHj8q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Character {
    static isWhitespace(c) {
        return c <= 32 && c >= 0 || c === 127;
    }
    static toUpperCase(c) {
        return c.toUpperCase();
    }
}
exports.default = Character;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5V2e":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _geometryComponentFilterJs = require("./GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _cloneableJs = require("../../../../java/lang/Cloneable.js");
var _cloneableJsDefault = parcelHelpers.interopDefault(_cloneableJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _envelopeJs = require("./Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class Geometry {
    constructor(){
        Geometry.constructor_.apply(this, arguments);
    }
    isGeometryCollection() {
        return this.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION;
    }
    getFactory() {
        return this._factory;
    }
    getGeometryN(n) {
        return this;
    }
    getArea() {
        return 0.0;
    }
    isRectangle() {
        return false;
    }
    equalsExact(other) {
        return this === other || this.equalsExact(other, 0);
    }
    geometryChanged() {
        this.apply(Geometry.geometryChangedFilter);
    }
    geometryChangedAction() {
        this._envelope = null;
    }
    equalsNorm(g) {
        if (g === null) return false;
        return this.norm().equalsExact(g.norm());
    }
    getLength() {
        return 0.0;
    }
    getNumGeometries() {
        return 1;
    }
    compareTo() {
        let other;
        if (arguments.length === 1) {
            const o = arguments[0];
            other = o;
            if (this.getTypeCode() !== other.getTypeCode()) return this.getTypeCode() - other.getTypeCode();
            if (this.isEmpty() && other.isEmpty()) return 0;
            if (this.isEmpty()) return -1;
            if (other.isEmpty()) return 1;
            return this.compareToSameClass(o);
        } else if (arguments.length === 2) {
            const o = arguments[0];
            const comp = arguments[1];
            other = o;
            if (this.getTypeCode() !== other.getTypeCode()) return this.getTypeCode() - other.getTypeCode();
            if (this.isEmpty() && other.isEmpty()) return 0;
            if (this.isEmpty()) return -1;
            if (other.isEmpty()) return 1;
            return this.compareToSameClass(o, comp);
        }
    }
    getUserData() {
        return this._userData;
    }
    getSRID() {
        return this._SRID;
    }
    getEnvelope() {
        return this.getFactory().toGeometry(this.getEnvelopeInternal());
    }
    static checkNotGeometryCollection(g) {
        if (g.getTypeCode() === Geometry.TYPECODE_GEOMETRYCOLLECTION) throw new (0, _illegalArgumentExceptionJsDefault.default)('This method does not support GeometryCollection arguments');
    }
    equal(a, b, tolerance) {
        if (tolerance === 0) return a.equals(b);
        return a.distance(b) <= tolerance;
    }
    norm() {
        const copy = this.copy();
        copy.normalize();
        return copy;
    }
    reverse() {
        const res = this.reverseInternal();
        if (this.envelope != null) res.envelope = this.envelope.copy();
        res.setSRID(this.getSRID());
        return res;
    }
    copy() {
        const copy = this.copyInternal();
        copy.envelope = this._envelope == null ? null : this._envelope.copy();
        copy._SRID = this._SRID;
        copy._userData = this._userData;
        return copy;
    }
    getPrecisionModel() {
        return this._factory.getPrecisionModel();
    }
    getEnvelopeInternal() {
        if (this._envelope === null) this._envelope = this.computeEnvelopeInternal();
        return new (0, _envelopeJsDefault.default)(this._envelope);
    }
    setSRID(SRID) {
        this._SRID = SRID;
    }
    setUserData(userData) {
        this._userData = userData;
    }
    compare(a, b) {
        const i = a.iterator();
        const j = b.iterator();
        while(i.hasNext() && j.hasNext()){
            const aElement = i.next();
            const bElement = j.next();
            const comparison = aElement.compareTo(bElement);
            if (comparison !== 0) return comparison;
        }
        if (i.hasNext()) return 1;
        if (j.hasNext()) return -1;
        return 0;
    }
    hashCode() {
        return this.getEnvelopeInternal().hashCode();
    }
    isEquivalentClass(other) {
        return this.getTypeCode() == other.getTypeCode();
    }
    get interfaces_() {
        return [
            (0, _cloneableJsDefault.default),
            (0, _comparableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
    getClass() {
        return Geometry;
    }
    static hasNonEmptyElements(geometries) {
        for(let i = 0; i < geometries.length; i++)if (!geometries[i].isEmpty()) return true;
        return false;
    }
    static hasNullElements(array) {
        for(let i = 0; i < array.length; i++)if (array[i] === null) return true;
        return false;
    }
}
exports.default = Geometry;
Geometry.constructor_ = function(factory) {
    if (!factory) return;
    this._envelope = null;
    this._userData = null;
    this._factory = factory;
    this._SRID = factory.getSRID();
};
Geometry.TYPECODE_POINT = 0;
Geometry.TYPECODE_MULTIPOINT = 1;
Geometry.TYPECODE_LINESTRING = 2;
Geometry.TYPECODE_LINEARRING = 3;
Geometry.TYPECODE_MULTILINESTRING = 4;
Geometry.TYPECODE_POLYGON = 5;
Geometry.TYPECODE_MULTIPOLYGON = 6;
Geometry.TYPECODE_GEOMETRYCOLLECTION = 7;
Geometry.TYPENAME_POINT = 'Point';
Geometry.TYPENAME_MULTIPOINT = 'MultiPoint';
Geometry.TYPENAME_LINESTRING = 'LineString';
Geometry.TYPENAME_LINEARRING = 'LinearRing';
Geometry.TYPENAME_MULTILINESTRING = 'MultiLineString';
Geometry.TYPENAME_POLYGON = 'Polygon';
Geometry.TYPENAME_MULTIPOLYGON = 'MultiPolygon';
Geometry.TYPENAME_GEOMETRYCOLLECTION = 'GeometryCollection';
Geometry.geometryChangedFilter = {
    get interfaces_ () {
        return [
            (0, _geometryComponentFilterJsDefault.default)
        ];
    },
    filter (geom) {
        geom.geometryChangedAction();
    }
};

},{"../../../../java/lang/IllegalArgumentException.js":"1VQhm","./GeometryComponentFilter.js":"8aMWe","../../../../java/lang/Comparable.js":"6Adw4","../../../../java/lang/Cloneable.js":"bkkIE","../../../../java/io/Serializable.js":"4emqV","./Envelope.js":"ha5UZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9F02P":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class CoordinateFilter {
    filter(coord) {}
}
exports.default = CoordinateFilter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fZhBn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Lineal {
}
exports.default = Lineal;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fFRyy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _coordinateSequenceJs = require("./CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
class CoordinateSequences {
    static scroll() {
        if (arguments.length === 2) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default)) && Number.isInteger(arguments[1])) {
                const seq = arguments[0], indexOfFirstCoordinate = arguments[1];
                CoordinateSequences.scroll(seq, indexOfFirstCoordinate, CoordinateSequences.isRing(seq));
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default)) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
                const seq = arguments[0], firstCoordinate = arguments[1];
                const i = CoordinateSequences.indexOf(firstCoordinate, seq);
                if (i <= 0) return null;
                CoordinateSequences.scroll(seq, i);
            }
        } else if (arguments.length === 3) {
            const seq = arguments[0], indexOfFirstCoordinate = arguments[1], ensureRing = arguments[2];
            const i = indexOfFirstCoordinate;
            if (i <= 0) return null;
            const copy = seq.copy();
            const last = ensureRing ? seq.size() - 1 : seq.size();
            for(let j = 0; j < last; j++)for(let k = 0; k < seq.getDimension(); k++)seq.setOrdinate(j, k, copy.getOrdinate((indexOfFirstCoordinate + j) % last, k));
            if (ensureRing) for(let k = 0; k < seq.getDimension(); k++)seq.setOrdinate(last, k, seq.getOrdinate(0, k));
        }
    }
    static isEqual(cs1, cs2) {
        const cs1Size = cs1.size();
        const cs2Size = cs2.size();
        if (cs1Size !== cs2Size) return false;
        const dim = Math.min(cs1.getDimension(), cs2.getDimension());
        for(let i = 0; i < cs1Size; i++)for(let d = 0; d < dim; d++){
            const v1 = cs1.getOrdinate(i, d);
            const v2 = cs2.getOrdinate(i, d);
            if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) continue;
            if ((0, _doubleJsDefault.default).isNaN(v1) && (0, _doubleJsDefault.default).isNaN(v2)) continue;
            return false;
        }
        return true;
    }
    static minCoordinateIndex() {
        if (arguments.length === 1) {
            const seq = arguments[0];
            return CoordinateSequences.minCoordinateIndex(seq, 0, seq.size() - 1);
        } else if (arguments.length === 3) {
            const seq = arguments[0], from = arguments[1], to = arguments[2];
            let minCoordIndex = -1;
            let minCoord = null;
            for(let i = from; i <= to; i++){
                const testCoord = seq.getCoordinate(i);
                if (minCoord === null || minCoord.compareTo(testCoord) > 0) {
                    minCoord = testCoord;
                    minCoordIndex = i;
                }
            }
            return minCoordIndex;
        }
    }
    static extend(fact, seq, size) {
        const newseq = fact.create(size, seq.getDimension());
        const n = seq.size();
        CoordinateSequences.copy(seq, 0, newseq, 0, n);
        if (n > 0) for(let i = n; i < size; i++)CoordinateSequences.copy(seq, n - 1, newseq, i, 1);
        return newseq;
    }
    static reverse(seq) {
        const last = seq.size() - 1;
        const mid = Math.trunc(last / 2);
        for(let i = 0; i <= mid; i++)CoordinateSequences.swap(seq, i, last - i);
    }
    static ensureValidRing(fact, seq) {
        const n = seq.size();
        if (n === 0) return seq;
        if (n <= 3) return CoordinateSequences.createClosedRing(fact, seq, 4);
        const isClosed = seq.getOrdinate(0, (0, _coordinateSequenceJsDefault.default).X) === seq.getOrdinate(n - 1, (0, _coordinateSequenceJsDefault.default).X) && seq.getOrdinate(0, (0, _coordinateSequenceJsDefault.default).Y) === seq.getOrdinate(n - 1, (0, _coordinateSequenceJsDefault.default).Y);
        if (isClosed) return seq;
        return CoordinateSequences.createClosedRing(fact, seq, n + 1);
    }
    static minCoordinate(seq) {
        let minCoord = null;
        for(let i = 0; i < seq.size(); i++){
            const testCoord = seq.getCoordinate(i);
            if (minCoord === null || minCoord.compareTo(testCoord) > 0) minCoord = testCoord;
        }
        return minCoord;
    }
    static copyCoord(src, srcPos, dest, destPos) {
        const minDim = Math.min(src.getDimension(), dest.getDimension());
        for(let dim = 0; dim < minDim; dim++)dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));
    }
    static isRing(seq) {
        const n = seq.size();
        if (n === 0) return true;
        if (n <= 3) return false;
        return seq.getOrdinate(0, (0, _coordinateSequenceJsDefault.default).X) === seq.getOrdinate(n - 1, (0, _coordinateSequenceJsDefault.default).X) && seq.getOrdinate(0, (0, _coordinateSequenceJsDefault.default).Y) === seq.getOrdinate(n - 1, (0, _coordinateSequenceJsDefault.default).Y);
    }
    static swap(seq, i, j) {
        if (i === j) return null;
        for(let dim = 0; dim < seq.getDimension(); dim++){
            const tmp = seq.getOrdinate(i, dim);
            seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));
            seq.setOrdinate(j, dim, tmp);
        }
    }
    static copy(src, srcPos, dest, destPos, length) {
        for(let i = 0; i < length; i++)CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);
    }
    static indexOf(coordinate, seq) {
        for(let i = 0; i < seq.size(); i++)if (coordinate.x === seq.getOrdinate(i, (0, _coordinateSequenceJsDefault.default).X) && coordinate.y === seq.getOrdinate(i, (0, _coordinateSequenceJsDefault.default).Y)) return i;
        return -1;
    }
    static createClosedRing(fact, seq, size) {
        const newseq = fact.create(size, seq.getDimension());
        const n = seq.size();
        CoordinateSequences.copy(seq, 0, newseq, 0, n);
        for(let i = n; i < size; i++)CoordinateSequences.copy(seq, 0, newseq, i, 1);
        return newseq;
    }
}
exports.default = CoordinateSequences;

},{"../../../../hasInterface.js":"d8mIo","./Coordinate.js":"3REUb","../../../../java/lang/Double.js":"jCc26","./CoordinateSequence.js":"3GfKT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3GfKT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _cloneableJs = require("../../../../java/lang/Cloneable.js");
var _cloneableJsDefault = parcelHelpers.interopDefault(_cloneableJs);
class CoordinateSequence {
    getCoordinate() {
        if (arguments.length === 1) {
            const i = arguments[0];
        } else if (arguments.length === 2) {
            const index = arguments[0], coord = arguments[1];
        }
    }
    getCoordinateCopy(i) {}
    createCoordinate() {}
    getDimension() {}
    hasM() {
        return this.getMeasures() > 0;
    }
    getX(index) {}
    hasZ() {
        return this.getDimension() - this.getMeasures() > 2;
    }
    getMeasures() {
        return 0;
    }
    expandEnvelope(env) {}
    copy() {}
    getY(index) {}
    toCoordinateArray() {}
    getM(index) {
        if (this.hasM()) {
            const mIndex = this.getDimension() - this.getMeasures();
            return this.getOrdinate(index, mIndex);
        } else return (0, _doubleJsDefault.default).NaN;
    }
    setOrdinate(index, ordinateIndex, value) {}
    getZ(index) {
        if (this.hasZ()) return this.getOrdinate(index, 2);
        else return (0, _doubleJsDefault.default).NaN;
    }
    size() {}
    getOrdinate(index, ordinateIndex) {}
    get interfaces_() {
        return [
            (0, _cloneableJsDefault.default)
        ];
    }
}
exports.default = CoordinateSequence;
CoordinateSequence.X = 0;
CoordinateSequence.Y = 1;
CoordinateSequence.Z = 2;
CoordinateSequence.M = 3;

},{"../../../../java/lang/Double.js":"jCc26","../../../../java/lang/Cloneable.js":"bkkIE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"djHvd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class GeometryFilter {
    filter(geom) {}
}
exports.default = GeometryFilter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8HUHX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class CoordinateSequenceFilter {
    filter(seq, i) {}
    isGeometryChanged() {}
    isDone() {}
}
exports.default = CoordinateSequenceFilter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bKVoa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateSequenceFactoryJs = require("../CoordinateSequenceFactory.js");
var _coordinateSequenceFactoryJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFactoryJs);
var _coordinateSequenceJs = require("../CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateArraySequenceJs = require("./CoordinateArraySequence.js");
var _coordinateArraySequenceJsDefault = parcelHelpers.interopDefault(_coordinateArraySequenceJs);
class CoordinateArraySequenceFactory {
    static instance() {
        return CoordinateArraySequenceFactory.instanceObject;
    }
    readResolve() {
        return CoordinateArraySequenceFactory.instance();
    }
    create() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const coordinates = arguments[0];
                return new (0, _coordinateArraySequenceJsDefault.default)(coordinates);
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordSeq = arguments[0];
                return new (0, _coordinateArraySequenceJsDefault.default)(coordSeq);
            }
        } else if (arguments.length === 2) {
            let size = arguments[0], dimension = arguments[1];
            if (dimension > 3) dimension = 3;
            if (dimension < 2) dimension = 2;
            return new (0, _coordinateArraySequenceJsDefault.default)(size, dimension);
        } else if (arguments.length === 3) {
            let size = arguments[0], dimension = arguments[1], measures = arguments[2];
            let spatial = dimension - measures;
            if (measures > 1) measures = 1;
            if (spatial > 3) spatial = 3;
            if (spatial < 2) spatial = 2;
            return new (0, _coordinateArraySequenceJsDefault.default)(size, spatial + measures, measures);
        }
    }
    get interfaces_() {
        return [
            (0, _coordinateSequenceFactoryJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = CoordinateArraySequenceFactory;
CoordinateArraySequenceFactory.instanceObject = new CoordinateArraySequenceFactory();

},{"../CoordinateSequenceFactory.js":"hAZID","../CoordinateSequence.js":"3GfKT","../../../../../java/io/Serializable.js":"4emqV","../../../../../hasInterface.js":"d8mIo","./CoordinateArraySequence.js":"bdL5X","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hAZID":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateSequenceJs = require("./CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
class CoordinateSequenceFactory {
    create() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const coordinates = arguments[0];
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordSeq = arguments[0];
            }
        } else if (arguments.length === 2) {
            const size = arguments[0], dimension = arguments[1];
        } else if (arguments.length === 3) {
            const size = arguments[0], dimension = arguments[1], measures = arguments[2];
            return this.create(size, dimension);
        }
    }
}
exports.default = CoordinateSequenceFactory;

},{"../../../../hasInterface.js":"d8mIo","./CoordinateSequence.js":"3GfKT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bdL5X":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("../Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _coordinatesJs = require("../Coordinates.js");
var _coordinatesJsDefault = parcelHelpers.interopDefault(_coordinatesJs);
var _coordinateSequenceJs = require("../CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
var _coordinateArraysJs = require("../CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _stringBuilderJs = require("../../../../../java/lang/StringBuilder.js");
var _stringBuilderJsDefault = parcelHelpers.interopDefault(_stringBuilderJs);
class CoordinateArraySequence {
    constructor(){
        CoordinateArraySequence.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._dimension = 3;
        this._measures = 0;
        this._coordinates = null;
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const coordinates = arguments[0];
                CoordinateArraySequence.constructor_.call(this, coordinates, (0, _coordinateArraysJsDefault.default).dimension(coordinates), (0, _coordinateArraysJsDefault.default).measures(coordinates));
            } else if (Number.isInteger(arguments[0])) {
                const size = arguments[0];
                this._coordinates = new Array(size).fill(null);
                for(let i = 0; i < size; i++)this._coordinates[i] = new (0, _coordinateJsDefault.default)();
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
                const coordSeq = arguments[0];
                if (coordSeq === null) {
                    this._coordinates = new Array(0).fill(null);
                    return null;
                }
                this._dimension = coordSeq.getDimension();
                this._measures = coordSeq.getMeasures();
                this._coordinates = new Array(coordSeq.size()).fill(null);
                for(let i = 0; i < this._coordinates.length; i++)this._coordinates[i] = coordSeq.getCoordinateCopy(i);
            }
        } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                const coordinates = arguments[0], dimension = arguments[1];
                CoordinateArraySequence.constructor_.call(this, coordinates, dimension, (0, _coordinateArraysJsDefault.default).measures(coordinates));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                const size = arguments[0], dimension = arguments[1];
                this._coordinates = new Array(size).fill(null);
                this._dimension = dimension;
                for(let i = 0; i < size; i++)this._coordinates[i] = (0, _coordinatesJsDefault.default).create(dimension);
            }
        } else if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
                const coordinates = arguments[0], dimension = arguments[1], measures = arguments[2];
                this._dimension = dimension;
                this._measures = measures;
                if (coordinates === null) this._coordinates = new Array(0).fill(null);
                else this._coordinates = coordinates;
            } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
                const size = arguments[0], dimension = arguments[1], measures = arguments[2];
                this._coordinates = new Array(size).fill(null);
                this._dimension = dimension;
                this._measures = measures;
                for(let i = 0; i < size; i++)this._coordinates[i] = this.createCoordinate();
            }
        }
    }
    getCoordinate() {
        if (arguments.length === 1) {
            const i = arguments[0];
            return this._coordinates[i];
        } else if (arguments.length === 2) {
            const index = arguments[0], coord = arguments[1];
            coord.setCoordinate(this._coordinates[index]);
        }
    }
    getCoordinateCopy(i) {
        const copy = this.createCoordinate();
        copy.setCoordinate(this._coordinates[i]);
        return copy;
    }
    createCoordinate() {
        return (0, _coordinatesJsDefault.default).create(this.getDimension(), this.getMeasures());
    }
    getDimension() {
        return this._dimension;
    }
    getX(index) {
        return this._coordinates[index].x;
    }
    getMeasures() {
        return this._measures;
    }
    expandEnvelope(env) {
        for(let i = 0; i < this._coordinates.length; i++)env.expandToInclude(this._coordinates[i]);
        return env;
    }
    copy() {
        const cloneCoordinates = new Array(this.size()).fill(null);
        for(let i = 0; i < this._coordinates.length; i++){
            const duplicate = this.createCoordinate();
            duplicate.setCoordinate(this._coordinates[i]);
            cloneCoordinates[i] = duplicate;
        }
        return new CoordinateArraySequence(cloneCoordinates, this._dimension, this._measures);
    }
    toString() {
        if (this._coordinates.length > 0) {
            const strBuilder = new (0, _stringBuilderJsDefault.default)(17 * this._coordinates.length);
            strBuilder.append('(');
            strBuilder.append(this._coordinates[0]);
            for(let i = 1; i < this._coordinates.length; i++){
                strBuilder.append(', ');
                strBuilder.append(this._coordinates[i]);
            }
            strBuilder.append(')');
            return strBuilder.toString();
        } else return '()';
    }
    getY(index) {
        return this._coordinates[index].y;
    }
    toCoordinateArray() {
        return this._coordinates;
    }
    getM(index) {
        if (this.hasM()) return this._coordinates[index].getM();
        else return (0, _doubleJsDefault.default).NaN;
    }
    setOrdinate(index, ordinateIndex, value) {
        switch(ordinateIndex){
            case (0, _coordinateSequenceJsDefault.default).X:
                this._coordinates[index].x = value;
                break;
            case (0, _coordinateSequenceJsDefault.default).Y:
                this._coordinates[index].y = value;
                break;
            default:
                this._coordinates[index].setOrdinate(ordinateIndex, value);
        }
    }
    getZ(index) {
        if (this.hasZ()) return this._coordinates[index].getZ();
        else return (0, _doubleJsDefault.default).NaN;
    }
    size() {
        return this._coordinates.length;
    }
    getOrdinate(index, ordinateIndex) {
        switch(ordinateIndex){
            case (0, _coordinateSequenceJsDefault.default).X:
                return this._coordinates[index].x;
            case (0, _coordinateSequenceJsDefault.default).Y:
                return this._coordinates[index].y;
            default:
                return this._coordinates[index].getOrdinate(ordinateIndex);
        }
    }
    get interfaces_() {
        return [
            (0, _coordinateSequenceJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = CoordinateArraySequence;

},{"../../../../../hasInterface.js":"d8mIo","../Coordinate.js":"3REUb","../../../../../java/lang/Double.js":"jCc26","../Coordinates.js":"iNVOk","../CoordinateSequence.js":"3GfKT","../CoordinateArrays.js":"hwXsf","../../../../../java/io/Serializable.js":"4emqV","../../../../../java/lang/StringBuilder.js":"iGg1z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iGg1z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class StringBuilder {
    constructor(str){
        this.str = str;
    }
    append(e) {
        this.str += e;
    }
    setCharAt(i, c) {
        this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
    }
    toString() {
        return this.str;
    }
}
exports.default = StringBuilder;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"56YaT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _geometryCollectionJs = require("./GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _polygonalJs = require("./Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class MultiPolygon extends (0, _geometryCollectionJsDefault.default) {
    constructor(){
        super();
        MultiPolygon.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const polygons = arguments[0], factory = arguments[1];
        (0, _geometryCollectionJsDefault.default).constructor_.call(this, polygons, factory);
    }
    copyInternal() {
        const polygons = new Array(this._geometries.length).fill(null);
        for(let i = 0; i < polygons.length; i++)polygons[i] = this._geometries[i].copy();
        return new MultiPolygon(polygons, this._factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            return super.equalsExact.call(this, other, tolerance);
        } else return super.equalsExact.apply(this, arguments);
    }
    getBoundaryDimension() {
        return 1;
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_MULTIPOLYGON;
    }
    getDimension() {
        return 2;
    }
    getBoundary() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        const allRings = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < this._geometries.length; i++){
            const polygon = this._geometries[i];
            const rings = polygon.getBoundary();
            for(let j = 0; j < rings.getNumGeometries(); j++)allRings.add(rings.getGeometryN(j));
        }
        const allRingsArray = new Array(allRings.size()).fill(null);
        return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray));
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_MULTIPOLYGON;
    }
    get interfaces_() {
        return [
            (0, _polygonalJsDefault.default)
        ];
    }
}
exports.default = MultiPolygon;

},{"./Geometry.js":"d5V2e","./GeometryCollection.js":"9xeCT","./Polygonal.js":"gO2Qf","../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9xeCT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _treeSetJs = require("../../../../java/util/TreeSet.js");
var _treeSetJsDefault = parcelHelpers.interopDefault(_treeSetJs);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _geometryComponentFilterJs = require("./GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _arraysJs = require("../../../../java/util/Arrays.js");
var _arraysJsDefault = parcelHelpers.interopDefault(_arraysJs);
var _coordinateFilterJs = require("./CoordinateFilter.js");
var _coordinateFilterJsDefault = parcelHelpers.interopDefault(_coordinateFilterJs);
var _geometryFilterJs = require("./GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
var _coordinateSequenceFilterJs = require("./CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
var _envelopeJs = require("./Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class GeometryCollection extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        GeometryCollection.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geometries = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 2) {
            let geometries = arguments[0], factory = arguments[1];
            (0, _geometryJsDefault.default).constructor_.call(this, factory);
            if (geometries === null) geometries = [];
            if ((0, _geometryJsDefault.default).hasNullElements(geometries)) throw new (0, _illegalArgumentExceptionJsDefault.default)('geometries must not contain null elements');
            this._geometries = geometries;
        }
    }
    computeEnvelopeInternal() {
        const envelope = new (0, _envelopeJsDefault.default)();
        for(let i = 0; i < this._geometries.length; i++)envelope.expandToInclude(this._geometries[i].getEnvelopeInternal());
        return envelope;
    }
    getGeometryN(n) {
        return this._geometries[n];
    }
    getCoordinates() {
        const coordinates = new Array(this.getNumPoints()).fill(null);
        let k = -1;
        for(let i = 0; i < this._geometries.length; i++){
            const childCoordinates = this._geometries[i].getCoordinates();
            for(let j = 0; j < childCoordinates.length; j++){
                k++;
                coordinates[k] = childCoordinates[j];
            }
        }
        return coordinates;
    }
    getArea() {
        let area = 0.0;
        for(let i = 0; i < this._geometries.length; i++)area += this._geometries[i].getArea();
        return area;
    }
    copyInternal() {
        const geometries = new Array(this._geometries.length).fill(null);
        for(let i = 0; i < geometries.length; i++)geometries[i] = this._geometries[i].copy();
        return new GeometryCollection(geometries, this._factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            const otherCollection = other;
            if (this._geometries.length !== otherCollection._geometries.length) return false;
            for(let i = 0; i < this._geometries.length; i++)if (!this._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) return false;
            return true;
        } else return super.equalsExact.apply(this, arguments);
    }
    reverseInternal() {
        const numGeometries = this._geometries.length;
        const reversed = new (0, _arrayListJsDefault.default)(numGeometries);
        for(let i = 0; i < numGeometries; i++)reversed.add(this._geometries[i].reverse());
        return this.getFactory().buildGeometry(reversed);
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_GEOMETRYCOLLECTION;
    }
    getDimension() {
        let dimension = (0, _dimensionJsDefault.default).FALSE;
        for(let i = 0; i < this._geometries.length; i++)dimension = Math.max(dimension, this._geometries[i].getDimension());
        return dimension;
    }
    getNumGeometries() {
        return this._geometries.length;
    }
    getBoundary() {
        (0, _geometryJsDefault.default).checkNotGeometryCollection(this);
        (0, _assertJsDefault.default).shouldNeverReachHere();
        return null;
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_GEOMETRYCOLLECTION;
    }
    isEmpty() {
        for(let i = 0; i < this._geometries.length; i++)if (!this._geometries[i].isEmpty()) return false;
        return true;
    }
    normalize() {
        for(let i = 0; i < this._geometries.length; i++)this._geometries[i].normalize();
        (0, _arraysJsDefault.default).sort(this._geometries);
    }
    getCoordinate() {
        if (this.isEmpty()) return null;
        return this._geometries[0].getCoordinate();
    }
    getBoundaryDimension() {
        let dimension = (0, _dimensionJsDefault.default).FALSE;
        for(let i = 0; i < this._geometries.length; i++)dimension = Math.max(dimension, this._geometries[i].getBoundaryDimension());
        return dimension;
    }
    getLength() {
        let sum = 0.0;
        for(let i = 0; i < this._geometries.length; i++)sum += this._geometries[i].getLength();
        return sum;
    }
    getNumPoints() {
        let numPoints = 0;
        for(let i = 0; i < this._geometries.length; i++)numPoints += this._geometries[i].getNumPoints();
        return numPoints;
    }
    compareToSameClass() {
        if (arguments.length === 1) {
            const o = arguments[0];
            const theseElements = new (0, _treeSetJsDefault.default)((0, _arraysJsDefault.default).asList(this._geometries));
            const otherElements = new (0, _treeSetJsDefault.default)((0, _arraysJsDefault.default).asList(o._geometries));
            return this.compare(theseElements, otherElements);
        } else if (arguments.length === 2) {
            const o = arguments[0], comp = arguments[1];
            const gc = o;
            const n1 = this.getNumGeometries();
            const n2 = gc.getNumGeometries();
            let i = 0;
            while(i < n1 && i < n2){
                const thisGeom = this.getGeometryN(i);
                const otherGeom = gc.getGeometryN(i);
                const holeComp = thisGeom.compareToSameClass(otherGeom, comp);
                if (holeComp !== 0) return holeComp;
                i++;
            }
            if (i < n1) return 1;
            if (i < n2) return -1;
            return 0;
        }
    }
    apply() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateFilterJsDefault.default))) {
            const filter = arguments[0];
            for(let i = 0; i < this._geometries.length; i++)this._geometries[i].apply(filter);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceFilterJsDefault.default))) {
            const filter = arguments[0];
            if (this._geometries.length === 0) return null;
            for(let i = 0; i < this._geometries.length; i++){
                this._geometries[i].apply(filter);
                if (filter.isDone()) break;
            }
            if (filter.isGeometryChanged()) this.geometryChanged();
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
            for(let i = 0; i < this._geometries.length; i++)this._geometries[i].apply(filter);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryComponentFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
            for(let i = 0; i < this._geometries.length; i++)this._geometries[i].apply(filter);
        }
    }
}
exports.default = GeometryCollection;

},{"../../../../java/util/TreeSet.js":"iQa9l","../../../../hasInterface.js":"d8mIo","../../../../java/lang/IllegalArgumentException.js":"1VQhm","./GeometryComponentFilter.js":"8aMWe","./Dimension.js":"966Ye","../../../../java/util/ArrayList.js":"g8omH","./Geometry.js":"d5V2e","../../../../java/util/Arrays.js":"8vEqO","./CoordinateFilter.js":"9F02P","./GeometryFilter.js":"djHvd","./CoordinateSequenceFilter.js":"8HUHX","./Envelope.js":"ha5UZ","../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iQa9l":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _noSuchElementExceptionJs = require("./NoSuchElementException.js");
var _noSuchElementExceptionJsDefault = parcelHelpers.interopDefault(_noSuchElementExceptionJs);
var _unsupportedOperationExceptionJs = require("../lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
var _sortedSetJs = require("./SortedSet.js");
var _sortedSetJsDefault = parcelHelpers.interopDefault(_sortedSetJs);
class TreeSet extends (0, _sortedSetJsDefault.default) {
    constructor(o){
        super();
        this.array = [];
        if (o instanceof (0, _collectionJsDefault.default)) this.addAll(o);
    }
    contains(o) {
        for (const e of this.array)if (e.compareTo(o) === 0) return true;
        return false;
    }
    add(o) {
        if (this.contains(o)) return false;
        for(let i = 0, len = this.array.length; i < len; i++){
            const e = this.array[i];
            if (e.compareTo(o) === 1) return !!this.array.splice(i, 0, o);
        }
        this.array.push(o);
        return true;
    }
    addAll(c) {
        for (const e of c)this.add(e);
        return true;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
    size() {
        return this.array.length;
    }
    isEmpty() {
        return this.array.length === 0;
    }
    toArray() {
        return this.array.slice();
    }
    iterator() {
        return new Iterator(this.array);
    }
}
exports.default = TreeSet;
class Iterator {
    constructor(array){
        this.array = array;
        this.position = 0;
    }
    next() {
        if (this.position === this.array.length) throw new (0, _noSuchElementExceptionJsDefault.default)();
        return this.array[this.position++];
    }
    hasNext() {
        return this.position < this.array.length;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
}

},{"./Collection.js":"fbl5V","./NoSuchElementException.js":"1NxXp","../lang/UnsupportedOperationException.js":"fEx26","./SortedSet.js":"fqiEm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fqiEm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setJs = require("./Set.js");
var _setJsDefault = parcelHelpers.interopDefault(_setJs);
class SortedSet extends (0, _setJsDefault.default) {
}
exports.default = SortedSet;

},{"./Set.js":"6BSHf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6BSHf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
class Set extends (0, _collectionJsDefault.default) {
    /**
   * Returns true if this set contains the specified element. More formally,
   * returns true if and only if this set contains an element e such that (o==null ?
   * e==null : o.equals(e)).
   * @param {Object} e
   * @return {boolean}
   */ contains() {}
}
exports.default = Set;

},{"./Collection.js":"fbl5V","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8vEqO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("./ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class Arrays {
    static sort() {
        const a = arguments[0];
        if (arguments.length === 1) a.sort((a, b)=>a.compareTo(b));
        else if (arguments.length === 2) a.sort((a, b)=>arguments[1].compare(a, b));
        else if (arguments.length === 3) {
            const t = a.slice(arguments[1], arguments[2]);
            t.sort();
            const r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
            a.splice(0, a.length);
            for (const e of r)a.push(e);
        } else if (arguments.length === 4) {
            const t = a.slice(arguments[1], arguments[2]);
            t.sort((a, b)=>arguments[3].compare(a, b));
            const r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));
            a.splice(0, a.length);
            for (const e of r)a.push(e);
        }
    }
    /**
   * @param {Array} array
   * @return {ArrayList}
   */ static asList(array) {
        const arrayList = new (0, _arrayListJsDefault.default)();
        for (const e of array)arrayList.add(e);
        return arrayList;
    }
    static copyOf(original, newLength) {
        return original.slice(0, newLength);
    }
}
exports.default = Arrays;

},{"./ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gO2Qf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Polygonal {
}
exports.default = Polygonal;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9xUYw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashMapJs = require("../../../../java/util/HashMap.js");
var _hashMapJsDefault = parcelHelpers.interopDefault(_hashMapJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _integerJs = require("../../../../java/lang/Integer.js");
var _integerJsDefault = parcelHelpers.interopDefault(_integerJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
class PrecisionModel {
    constructor(){
        PrecisionModel.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._modelType = null;
        this._scale = null;
        if (arguments.length === 0) this._modelType = PrecisionModel.FLOATING;
        else if (arguments.length === 1) {
            if (arguments[0] instanceof Type) {
                const modelType = arguments[0];
                this._modelType = modelType;
                if (modelType === PrecisionModel.FIXED) this.setScale(1.0);
            } else if (typeof arguments[0] === 'number') {
                const scale = arguments[0];
                this._modelType = PrecisionModel.FIXED;
                this.setScale(scale);
            } else if (arguments[0] instanceof PrecisionModel) {
                const pm = arguments[0];
                this._modelType = pm._modelType;
                this._scale = pm._scale;
            }
        }
    }
    static mostPrecise(pm1, pm2) {
        if (pm1.compareTo(pm2) >= 0) return pm1;
        return pm2;
    }
    equals(other) {
        if (!(other instanceof PrecisionModel)) return false;
        const otherPrecisionModel = other;
        return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale;
    }
    compareTo(o) {
        const other = o;
        const sigDigits = this.getMaximumSignificantDigits();
        const otherSigDigits = other.getMaximumSignificantDigits();
        return (0, _integerJsDefault.default).compare(sigDigits, otherSigDigits);
    }
    getType() {
        return this._modelType;
    }
    toString() {
        let description = 'UNKNOWN';
        if (this._modelType === PrecisionModel.FLOATING) description = 'Floating';
        else if (this._modelType === PrecisionModel.FLOATING_SINGLE) description = 'Floating-Single';
        else if (this._modelType === PrecisionModel.FIXED) description = 'Fixed (Scale=' + this.getScale() + ')';
        return description;
    }
    makePrecise() {
        if (typeof arguments[0] === 'number') {
            const val = arguments[0];
            if ((0, _doubleJsDefault.default).isNaN(val)) return val;
            if (this._modelType === PrecisionModel.FLOATING_SINGLE) {
                const floatSingleVal = val;
                return floatSingleVal;
            }
            if (this._modelType === PrecisionModel.FIXED) return Math.round(val * this._scale) / this._scale;
            return val;
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const coord = arguments[0];
            if (this._modelType === PrecisionModel.FLOATING) return null;
            coord.x = this.makePrecise(coord.x);
            coord.y = this.makePrecise(coord.y);
        }
    }
    getMaximumSignificantDigits() {
        let maxSigDigits = 16;
        if (this._modelType === PrecisionModel.FLOATING) maxSigDigits = 16;
        else if (this._modelType === PrecisionModel.FLOATING_SINGLE) maxSigDigits = 6;
        else if (this._modelType === PrecisionModel.FIXED) maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));
        return maxSigDigits;
    }
    setScale(scale) {
        this._scale = Math.abs(scale);
    }
    getScale() {
        return this._scale;
    }
    isFloating() {
        return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE;
    }
    get interfaces_() {
        return [
            (0, _serializableJsDefault.default),
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = PrecisionModel;
class Type {
    constructor(){
        Type.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._name = null;
        const name = arguments[0];
        this._name = name;
        Type.nameToTypeMap.put(name, this);
    }
    readResolve() {
        return Type.nameToTypeMap.get(this._name);
    }
    toString() {
        return this._name;
    }
    get interfaces_() {
        return [
            (0, _serializableJsDefault.default)
        ];
    }
}
Type.nameToTypeMap = new (0, _hashMapJsDefault.default)();
PrecisionModel.Type = Type;
PrecisionModel.FIXED = new Type('FIXED');
PrecisionModel.FLOATING = new Type('FLOATING');
PrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');
PrecisionModel.maximumPreciseValue = 9007199254740992.0;

},{"../../../../java/util/HashMap.js":"gwL7P","./Coordinate.js":"3REUb","../../../../java/lang/Double.js":"jCc26","../../../../java/lang/Integer.js":"9MkbL","../../../../java/lang/Comparable.js":"6Adw4","../../../../java/io/Serializable.js":"4emqV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gwL7P":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("./ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _mapJs = require("./Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _hashSetJs = require("./HashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
class HashMap extends (0, _mapJsDefault.default) {
    constructor(){
        super();
        this.map = new Map();
    }
    get(key) {
        return this.map.get(key) || null;
    }
    put(key, value) {
        this.map.set(key, value);
        return value;
    }
    values() {
        const arrayList = new (0, _arrayListJsDefault.default)();
        const it = this.map.values();
        let o = it.next();
        while(!o.done){
            arrayList.add(o.value);
            o = it.next();
        }
        return arrayList;
    }
    entrySet() {
        const hashSet = new (0, _hashSetJsDefault.default)();
        this.map.entries().forEach((entry)=>hashSet.add(entry));
        return hashSet;
    }
    size() {
        return this.map.size();
    }
}
exports.default = HashMap;

},{"./ArrayList.js":"g8omH","./Map.js":"aMj1H","./HashSet.js":"cNQO2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aMj1H":[function(require,module,exports,__globalThis) {
/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Map {
    /**
     * Returns the value to which the specified key is mapped, or null if this map
     * contains no mapping for the key.
     * @param {Object} key
     * @return {Object}
     */ get() {}
    /**
     * Associates the specified value with the specified key in this map (optional
     * operation).
     * @param {Object} key
     * @param {Object} value
     * @return {Object}
     */ put() {}
    /**
     * Returns the number of key-value mappings in this map.
     * @return {number}
     */ size() {}
    /**
     * Returns a Collection view of the values contained in this map.
     * @return {javascript.util.Collection}
     */ values() {}
    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  If the map is modified
     * while an iteration over the set is in progress (except through
     * the iterator's own <tt>remove</tt> operation, or through the
     * <tt>setValue</tt> operation on a map entry returned by the
     * iterator) the results of the iteration are undefined.  The set
     * supports element removal, which removes the corresponding
     * mapping from the map, via the <tt>Iterator.remove</tt>,
     * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
     * <tt>clear</tt> operations.  It does not support the
     * <tt>add</tt> or <tt>addAll</tt> operations.
     *
     * @return {Set} a set view of the mappings contained in this map
     */ entrySet() {}
}
exports.default = Map;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cNQO2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _noSuchElementExceptionJs = require("./NoSuchElementException.js");
var _noSuchElementExceptionJsDefault = parcelHelpers.interopDefault(_noSuchElementExceptionJs);
var _unsupportedOperationExceptionJs = require("../lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
var _setJs = require("./Set.js");
var _setJsDefault = parcelHelpers.interopDefault(_setJs);
class HashSet extends (0, _setJsDefault.default) {
    constructor(o){
        super();
        this.map = new Map();
        if (o instanceof (0, _collectionJsDefault.default)) this.addAll(o);
    }
    contains(o) {
        const hashCode = o.hashCode ? o.hashCode() : o;
        if (this.map.has(hashCode)) return true;
        return false;
    }
    add(o) {
        const hashCode = o.hashCode ? o.hashCode() : o;
        if (this.map.has(hashCode)) return false;
        return !!this.map.set(hashCode, o);
    }
    addAll(c) {
        for (const e of c)this.add(e);
        return true;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
    size() {
        return this.map.size;
    }
    isEmpty() {
        return this.map.size === 0;
    }
    toArray() {
        return Array.from(this.map.values());
    }
    iterator() {
        return new Iterator(this.map);
    }
    [Symbol.iterator]() {
        return this.map;
    }
}
exports.default = HashSet;
class Iterator {
    constructor(map){
        this.iterator = map.values();
        const { done, value } = this.iterator.next();
        this.done = done;
        this.value = value;
    }
    next() {
        if (this.done) throw new (0, _noSuchElementExceptionJsDefault.default)();
        const current = this.value;
        const { done, value } = this.iterator.next();
        this.done = done;
        this.value = value;
        return current;
    }
    hasNext() {
        return !this.done;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
}

},{"./Collection.js":"fbl5V","./NoSuchElementException.js":"1NxXp","../lang/UnsupportedOperationException.js":"fEx26","./Set.js":"6BSHf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9MkbL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Integer {
    constructor(value){
        this.value = value;
    }
    intValue() {
        return this.value;
    }
    compareTo(o) {
        if (this.value < o) return -1;
        if (this.value > o) return 1;
        return 0;
    }
    static compare(x, y) {
        if (x < y) return -1;
        if (x > y) return 1;
        return 0;
    }
    static isNan(n) {
        return Number.isNaN(n);
    }
    static valueOf(value) {
        return new Integer(value);
    }
}
exports.default = Integer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fdpMS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _linealJs = require("./Lineal.js");
var _linealJsDefault = parcelHelpers.interopDefault(_linealJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _geometryCollectionJs = require("./GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _unsupportedOperationExceptionJs = require("../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
class MultiLineString extends (0, _geometryCollectionJsDefault.default) {
    constructor(){
        super();
        MultiLineString.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const lineStrings = arguments[0], factory = arguments[1];
        (0, _geometryCollectionJsDefault.default).constructor_.call(this, lineStrings, factory);
    }
    copyInternal() {
        const lineStrings = new Array(this._geometries.length).fill(null);
        for(let i = 0; i < lineStrings.length; i++)lineStrings[i] = this._geometries[i].copy();
        return new MultiLineString(lineStrings, this._factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            return super.equalsExact.call(this, other, tolerance);
        } else return super.equalsExact.apply(this, arguments);
    }
    getBoundaryDimension() {
        if (this.isClosed()) return (0, _dimensionJsDefault.default).FALSE;
        return 0;
    }
    isClosed() {
        if (this.isEmpty()) return false;
        for(let i = 0; i < this._geometries.length; i++)if (!this._geometries[i].isClosed()) return false;
        return true;
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_MULTILINESTRING;
    }
    getDimension() {
        return 1;
    }
    getBoundary() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)();
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_MULTILINESTRING;
    }
    get interfaces_() {
        return [
            (0, _linealJsDefault.default)
        ];
    }
}
exports.default = MultiLineString;

},{"./Geometry.js":"d5V2e","./Lineal.js":"fZhBn","./Dimension.js":"966Ye","./GeometryCollection.js":"9xeCT","../../../../java/lang/UnsupportedOperationException.js":"fEx26","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i9MoJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _geometryComponentFilterJs = require("./GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _puntalJs = require("./Puntal.js");
var _puntalJsDefault = parcelHelpers.interopDefault(_puntalJs);
var _illegalStateExceptionJs = require("../../../../java/lang/IllegalStateException.js");
var _illegalStateExceptionJsDefault = parcelHelpers.interopDefault(_illegalStateExceptionJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _coordinateFilterJs = require("./CoordinateFilter.js");
var _coordinateFilterJsDefault = parcelHelpers.interopDefault(_coordinateFilterJs);
var _geometryFilterJs = require("./GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
var _coordinateSequenceFilterJs = require("./CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
var _envelopeJs = require("./Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class Point extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        Point.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._coordinates = null;
        const coordinates = arguments[0], factory = arguments[1];
        (0, _geometryJsDefault.default).constructor_.call(this, factory);
        this.init(coordinates);
    }
    computeEnvelopeInternal() {
        if (this.isEmpty()) return new (0, _envelopeJsDefault.default)();
        const env = new (0, _envelopeJsDefault.default)();
        env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));
        return env;
    }
    getCoordinates() {
        return this.isEmpty() ? [] : [
            this.getCoordinate()
        ];
    }
    copyInternal() {
        return new Point(this._coordinates.copy(), this._factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            if (this.isEmpty() && other.isEmpty()) return true;
            if (this.isEmpty() !== other.isEmpty()) return false;
            return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance);
        } else return super.equalsExact.apply(this, arguments);
    }
    reverseInternal() {
        return this.getFactory().createPoint(this._coordinates.copy());
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_POINT;
    }
    getDimension() {
        return 0;
    }
    getNumPoints() {
        return this.isEmpty() ? 0 : 1;
    }
    getX() {
        if (this.getCoordinate() === null) throw new (0, _illegalStateExceptionJsDefault.default)('getX called on empty Point');
        return this.getCoordinate().x;
    }
    getBoundary() {
        return this.getFactory().createGeometryCollection();
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_POINT;
    }
    getCoordinateSequence() {
        return this._coordinates;
    }
    getY() {
        if (this.getCoordinate() === null) throw new (0, _illegalStateExceptionJsDefault.default)('getY called on empty Point');
        return this.getCoordinate().y;
    }
    isSimple() {
        return true;
    }
    normalize() {}
    getCoordinate() {
        return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
    }
    getBoundaryDimension() {
        return (0, _dimensionJsDefault.default).FALSE;
    }
    compareToSameClass() {
        if (arguments.length === 1) {
            const other = arguments[0];
            const point = other;
            return this.getCoordinate().compareTo(point.getCoordinate());
        } else if (arguments.length === 2) {
            const other = arguments[0], comp = arguments[1];
            const point = other;
            return comp.compare(this._coordinates, point._coordinates);
        }
    }
    apply() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateFilterJsDefault.default))) {
            const filter = arguments[0];
            if (this.isEmpty()) return null;
            filter.filter(this.getCoordinate());
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceFilterJsDefault.default))) {
            const filter = arguments[0];
            if (this.isEmpty()) return null;
            filter.filter(this._coordinates, 0);
            if (filter.isGeometryChanged()) this.geometryChanged();
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryComponentFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
        }
    }
    isEmpty() {
        return this._coordinates.size() === 0;
    }
    init(coordinates) {
        if (coordinates === null) coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);
        (0, _assertJsDefault.default).isTrue(coordinates.size() <= 1);
        this._coordinates = coordinates;
    }
    get interfaces_() {
        return [
            (0, _puntalJsDefault.default)
        ];
    }
}
exports.default = Point;

},{"../../../../hasInterface.js":"d8mIo","./GeometryComponentFilter.js":"8aMWe","./Dimension.js":"966Ye","./Puntal.js":"2RT7X","../../../../java/lang/IllegalStateException.js":"4MAFg","./Geometry.js":"d5V2e","./CoordinateFilter.js":"9F02P","./GeometryFilter.js":"djHvd","./CoordinateSequenceFilter.js":"8HUHX","./Envelope.js":"ha5UZ","../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2RT7X":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Puntal {
}
exports.default = Puntal;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4MAFg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("./Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class IllegalStateException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            IllegalStateException
        })[0];
    }
}
exports.default = IllegalStateException;

},{"./Exception.js":"gSmog","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jawWe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _areaJs = require("../algorithm/Area.js");
var _areaJsDefault = parcelHelpers.interopDefault(_areaJs);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _coordinateSequencesJs = require("./CoordinateSequences.js");
var _coordinateSequencesJsDefault = parcelHelpers.interopDefault(_coordinateSequencesJs);
var _geometryComponentFilterJs = require("./GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _polygonalJs = require("./Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _arraysJs = require("../../../../java/util/Arrays.js");
var _arraysJsDefault = parcelHelpers.interopDefault(_arraysJs);
var _coordinateFilterJs = require("./CoordinateFilter.js");
var _coordinateFilterJsDefault = parcelHelpers.interopDefault(_coordinateFilterJs);
var _geometryFilterJs = require("./GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
var _coordinateSequenceFilterJs = require("./CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
class Polygon extends (0, _geometryJsDefault.default) {
    constructor(){
        super();
        Polygon.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._shell = null;
        this._holes = null;
        let shell = arguments[0], holes = arguments[1], factory = arguments[2];
        (0, _geometryJsDefault.default).constructor_.call(this, factory);
        if (shell === null) shell = this.getFactory().createLinearRing();
        if (holes === null) holes = [];
        if ((0, _geometryJsDefault.default).hasNullElements(holes)) throw new (0, _illegalArgumentExceptionJsDefault.default)('holes must not contain null elements');
        if (shell.isEmpty() && (0, _geometryJsDefault.default).hasNonEmptyElements(holes)) throw new (0, _illegalArgumentExceptionJsDefault.default)('shell is empty but holes are not');
        this._shell = shell;
        this._holes = holes;
    }
    computeEnvelopeInternal() {
        return this._shell.getEnvelopeInternal();
    }
    getCoordinates() {
        if (this.isEmpty()) return [];
        const coordinates = new Array(this.getNumPoints()).fill(null);
        let k = -1;
        const shellCoordinates = this._shell.getCoordinates();
        for(let x = 0; x < shellCoordinates.length; x++){
            k++;
            coordinates[k] = shellCoordinates[x];
        }
        for(let i = 0; i < this._holes.length; i++){
            const childCoordinates = this._holes[i].getCoordinates();
            for(let j = 0; j < childCoordinates.length; j++){
                k++;
                coordinates[k] = childCoordinates[j];
            }
        }
        return coordinates;
    }
    getArea() {
        let area = 0.0;
        area += (0, _areaJsDefault.default).ofRing(this._shell.getCoordinateSequence());
        for(let i = 0; i < this._holes.length; i++)area -= (0, _areaJsDefault.default).ofRing(this._holes[i].getCoordinateSequence());
        return area;
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            const otherPolygon = other;
            const thisShell = this._shell;
            const otherPolygonShell = otherPolygon._shell;
            if (!thisShell.equalsExact(otherPolygonShell, tolerance)) return false;
            if (this._holes.length !== otherPolygon._holes.length) return false;
            for(let i = 0; i < this._holes.length; i++)if (!this._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) return false;
            return true;
        } else return super.equalsExact.apply(this, arguments);
    }
    reverseInternal() {
        const shell = this.getExteriorRing().reverse();
        const holes = new Array(this.getNumInteriorRing()).fill(null);
        for(let i = 0; i < holes.length; i++)holes[i] = this.getInteriorRingN(i).reverse();
        return this.getFactory().createPolygon(shell, holes);
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_POLYGON;
    }
    getDimension() {
        return 2;
    }
    getBoundary() {
        if (this.isEmpty()) return this.getFactory().createMultiLineString();
        const rings = new Array(this._holes.length + 1).fill(null);
        rings[0] = this._shell;
        for(let i = 0; i < this._holes.length; i++)rings[i + 1] = this._holes[i];
        if (rings.length <= 1) return this.getFactory().createLinearRing(rings[0].getCoordinateSequence());
        return this.getFactory().createMultiLineString(rings);
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_POLYGON;
    }
    getExteriorRing() {
        return this._shell;
    }
    copyInternal() {
        const shellCopy = this._shell.copy();
        const holeCopies = new Array(this._holes.length).fill(null);
        for(let i = 0; i < this._holes.length; i++)holeCopies[i] = this._holes[i].copy();
        return new Polygon(shellCopy, holeCopies, this._factory);
    }
    isRectangle() {
        if (this.getNumInteriorRing() !== 0) return false;
        if (this._shell === null) return false;
        if (this._shell.getNumPoints() !== 5) return false;
        const seq = this._shell.getCoordinateSequence();
        const env = this.getEnvelopeInternal();
        for(let i = 0; i < 5; i++){
            const x = seq.getX(i);
            if (!(x === env.getMinX() || x === env.getMaxX())) return false;
            const y = seq.getY(i);
            if (!(y === env.getMinY() || y === env.getMaxY())) return false;
        }
        let prevX = seq.getX(0);
        let prevY = seq.getY(0);
        for(let i = 1; i <= 4; i++){
            const x = seq.getX(i);
            const y = seq.getY(i);
            const xChanged = x !== prevX;
            const yChanged = y !== prevY;
            if (xChanged === yChanged) return false;
            prevX = x;
            prevY = y;
        }
        return true;
    }
    normalize() {
        if (arguments.length === 0) {
            this._shell = this.normalized(this._shell, true);
            for(let i = 0; i < this._holes.length; i++)this._holes[i] = this.normalized(this._holes[i], false);
            (0, _arraysJsDefault.default).sort(this._holes);
        } else if (arguments.length === 2) {
            const ring = arguments[0], clockwise = arguments[1];
            if (ring.isEmpty()) return null;
            const seq = ring.getCoordinateSequence();
            const minCoordinateIndex = (0, _coordinateSequencesJsDefault.default).minCoordinateIndex(seq, 0, seq.size() - 2);
            (0, _coordinateSequencesJsDefault.default).scroll(seq, minCoordinateIndex, true);
            if ((0, _orientationJsDefault.default).isCCW(seq) === clockwise) (0, _coordinateSequencesJsDefault.default).reverse(seq);
        }
    }
    getCoordinate() {
        return this._shell.getCoordinate();
    }
    getNumInteriorRing() {
        return this._holes.length;
    }
    getBoundaryDimension() {
        return 1;
    }
    getLength() {
        let len = 0.0;
        len += this._shell.getLength();
        for(let i = 0; i < this._holes.length; i++)len += this._holes[i].getLength();
        return len;
    }
    getNumPoints() {
        let numPoints = this._shell.getNumPoints();
        for(let i = 0; i < this._holes.length; i++)numPoints += this._holes[i].getNumPoints();
        return numPoints;
    }
    convexHull() {
        return this.getExteriorRing().convexHull();
    }
    normalized(ring, clockwise) {
        const res = ring.copy();
        this.normalize(res, clockwise);
        return res;
    }
    compareToSameClass() {
        if (arguments.length === 1) {
            const o = arguments[0];
            const thisShell = this._shell;
            const otherShell = o._shell;
            return thisShell.compareToSameClass(otherShell);
        } else if (arguments.length === 2) {
            const o = arguments[0], comp = arguments[1];
            const poly = o;
            const thisShell = this._shell;
            const otherShell = poly._shell;
            const shellComp = thisShell.compareToSameClass(otherShell, comp);
            if (shellComp !== 0) return shellComp;
            const nHole1 = this.getNumInteriorRing();
            const nHole2 = poly.getNumInteriorRing();
            let i = 0;
            while(i < nHole1 && i < nHole2){
                const thisHole = this.getInteriorRingN(i);
                const otherHole = poly.getInteriorRingN(i);
                const holeComp = thisHole.compareToSameClass(otherHole, comp);
                if (holeComp !== 0) return holeComp;
                i++;
            }
            if (i < nHole1) return 1;
            if (i < nHole2) return -1;
            return 0;
        }
    }
    apply() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateFilterJsDefault.default))) {
            const filter = arguments[0];
            this._shell.apply(filter);
            for(let i = 0; i < this._holes.length; i++)this._holes[i].apply(filter);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceFilterJsDefault.default))) {
            const filter = arguments[0];
            this._shell.apply(filter);
            if (!filter.isDone()) for(let i = 0; i < this._holes.length; i++){
                this._holes[i].apply(filter);
                if (filter.isDone()) break;
            }
            if (filter.isGeometryChanged()) this.geometryChanged();
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _geometryComponentFilterJsDefault.default))) {
            const filter = arguments[0];
            filter.filter(this);
            this._shell.apply(filter);
            for(let i = 0; i < this._holes.length; i++)this._holes[i].apply(filter);
        }
    }
    isEmpty() {
        return this._shell.isEmpty();
    }
    getInteriorRingN(n) {
        return this._holes[n];
    }
    get interfaces_() {
        return [
            (0, _polygonalJsDefault.default)
        ];
    }
}
exports.default = Polygon;

},{"../algorithm/Area.js":"lw4mS","../../../../hasInterface.js":"d8mIo","../../../../java/lang/IllegalArgumentException.js":"1VQhm","../algorithm/Orientation.js":"QDWSa","./CoordinateSequences.js":"fFRyy","./GeometryComponentFilter.js":"8aMWe","./Polygonal.js":"gO2Qf","./Geometry.js":"d5V2e","../../../../java/util/Arrays.js":"8vEqO","./CoordinateFilter.js":"9F02P","./GeometryFilter.js":"djHvd","./CoordinateSequenceFilter.js":"8HUHX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lw4mS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _coordinateSequenceJs = require("../geom/CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
class Area {
    static ofRingSigned() {
        if (arguments[0] instanceof Array) {
            const ring = arguments[0];
            if (ring.length < 3) return 0.0;
            let sum = 0.0;
            const x0 = ring[0].x;
            for(let i = 1; i < ring.length - 1; i++){
                const x = ring[i].x - x0;
                const y1 = ring[i + 1].y;
                const y2 = ring[i - 1].y;
                sum += x * (y2 - y1);
            }
            return sum / 2.0;
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
            const ring = arguments[0];
            const n = ring.size();
            if (n < 3) return 0.0;
            const p0 = new (0, _coordinateJsDefault.default)();
            const p1 = new (0, _coordinateJsDefault.default)();
            const p2 = new (0, _coordinateJsDefault.default)();
            ring.getCoordinate(0, p1);
            ring.getCoordinate(1, p2);
            const x0 = p1.x;
            p2.x -= x0;
            let sum = 0.0;
            for(let i = 1; i < n - 1; i++){
                p0.y = p1.y;
                p1.x = p2.x;
                p1.y = p2.y;
                ring.getCoordinate(i + 1, p2);
                p2.x -= x0;
                sum += p1.x * (p0.y - p2.y);
            }
            return sum / 2.0;
        }
    }
    static ofRing() {
        if (arguments[0] instanceof Array) {
            const ring = arguments[0];
            return Math.abs(Area.ofRingSigned(ring));
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
            const ring = arguments[0];
            return Math.abs(Area.ofRingSigned(ring));
        }
    }
}
exports.default = Area;

},{"../../../../hasInterface.js":"d8mIo","../geom/Coordinate.js":"3REUb","../geom/CoordinateSequence.js":"3GfKT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"QDWSa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _cgalgorithmsDDJs = require("./CGAlgorithmsDD.js");
var _cgalgorithmsDDJsDefault = parcelHelpers.interopDefault(_cgalgorithmsDDJs);
var _coordinateSequenceJs = require("../geom/CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
class Orientation {
    static isCCW() {
        if (arguments[0] instanceof Array) {
            const ring = arguments[0];
            const nPts = ring.length - 1;
            if (nPts < 3) throw new (0, _illegalArgumentExceptionJsDefault.default)('Ring has fewer than 4 points, so orientation cannot be determined');
            let hiPt = ring[0];
            let hiIndex = 0;
            for(let i = 1; i <= nPts; i++){
                const p = ring[i];
                if (p.y > hiPt.y) {
                    hiPt = p;
                    hiIndex = i;
                }
            }
            let iPrev = hiIndex;
            do {
                iPrev = iPrev - 1;
                if (iPrev < 0) iPrev = nPts;
            }while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex);
            let iNext = hiIndex;
            do iNext = (iNext + 1) % nPts;
            while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex);
            const prev = ring[iPrev];
            const next = ring[iNext];
            if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;
            const disc = Orientation.index(prev, hiPt, next);
            let isCCW = null;
            if (disc === 0) isCCW = prev.x > next.x;
            else isCCW = disc > 0;
            return isCCW;
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _coordinateSequenceJsDefault.default))) {
            const ring = arguments[0];
            const nPts = ring.size() - 1;
            if (nPts < 3) throw new (0, _illegalArgumentExceptionJsDefault.default)('Ring has fewer than 4 points, so orientation cannot be determined');
            let hiPt = ring.getCoordinate(0);
            let hiIndex = 0;
            for(let i = 1; i <= nPts; i++){
                const p = ring.getCoordinate(i);
                if (p.y > hiPt.y) {
                    hiPt = p;
                    hiIndex = i;
                }
            }
            let prev = null;
            let iPrev = hiIndex;
            do {
                iPrev = iPrev - 1;
                if (iPrev < 0) iPrev = nPts;
                prev = ring.getCoordinate(iPrev);
            }while (prev.equals2D(hiPt) && iPrev !== hiIndex);
            let next = null;
            let iNext = hiIndex;
            do {
                iNext = (iNext + 1) % nPts;
                next = ring.getCoordinate(iNext);
            }while (next.equals2D(hiPt) && iNext !== hiIndex);
            if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) return false;
            const disc = Orientation.index(prev, hiPt, next);
            let isCCW = null;
            if (disc === 0) isCCW = prev.x > next.x;
            else isCCW = disc > 0;
            return isCCW;
        }
    }
    static index(p1, p2, q) {
        return (0, _cgalgorithmsDDJsDefault.default).orientationIndex(p1, p2, q);
    }
}
exports.default = Orientation;
Orientation.CLOCKWISE = -1;
Orientation.RIGHT = Orientation.CLOCKWISE;
Orientation.COUNTERCLOCKWISE = 1;
Orientation.LEFT = Orientation.COUNTERCLOCKWISE;
Orientation.COLLINEAR = 0;
Orientation.STRAIGHT = Orientation.COLLINEAR;

},{"../../../../hasInterface.js":"d8mIo","../../../../java/lang/IllegalArgumentException.js":"1VQhm","./CGAlgorithmsDD.js":"3tMI9","../geom/CoordinateSequence.js":"3GfKT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3tMI9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _ddJs = require("../math/DD.js");
var _ddJsDefault = parcelHelpers.interopDefault(_ddJs);
class CGAlgorithmsDD {
    static orientationIndex(p1, p2, q) {
        const index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);
        if (index <= 1) return index;
        const dx1 = (0, _ddJsDefault.default).valueOf(p2.x).selfAdd(-p1.x);
        const dy1 = (0, _ddJsDefault.default).valueOf(p2.y).selfAdd(-p1.y);
        const dx2 = (0, _ddJsDefault.default).valueOf(q.x).selfAdd(-p2.x);
        const dy2 = (0, _ddJsDefault.default).valueOf(q.y).selfAdd(-p2.y);
        return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum();
    }
    static signOfDet2x2() {
        if (arguments[3] instanceof (0, _ddJsDefault.default) && arguments[2] instanceof (0, _ddJsDefault.default) && arguments[0] instanceof (0, _ddJsDefault.default) && arguments[1] instanceof (0, _ddJsDefault.default)) {
            const x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3];
            const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
            return det.signum();
        } else if (typeof arguments[3] === 'number' && typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            const dx1 = arguments[0], dy1 = arguments[1], dx2 = arguments[2], dy2 = arguments[3];
            const x1 = (0, _ddJsDefault.default).valueOf(dx1);
            const y1 = (0, _ddJsDefault.default).valueOf(dy1);
            const x2 = (0, _ddJsDefault.default).valueOf(dx2);
            const y2 = (0, _ddJsDefault.default).valueOf(dy2);
            const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
            return det.signum();
        }
    }
    static intersection(p1, p2, q1, q2) {
        const px = new (0, _ddJsDefault.default)(p1.y).selfSubtract(p2.y);
        const py = new (0, _ddJsDefault.default)(p2.x).selfSubtract(p1.x);
        const pw = new (0, _ddJsDefault.default)(p1.x).selfMultiply(p2.y).selfSubtract(new (0, _ddJsDefault.default)(p2.x).selfMultiply(p1.y));
        const qx = new (0, _ddJsDefault.default)(q1.y).selfSubtract(q2.y);
        const qy = new (0, _ddJsDefault.default)(q2.x).selfSubtract(q1.x);
        const qw = new (0, _ddJsDefault.default)(q1.x).selfMultiply(q2.y).selfSubtract(new (0, _ddJsDefault.default)(q2.x).selfMultiply(q1.y));
        const x = py.multiply(qw).selfSubtract(qy.multiply(pw));
        const y = qx.multiply(pw).selfSubtract(px.multiply(qw));
        const w = px.multiply(qy).selfSubtract(qx.multiply(py));
        const xInt = x.selfDivide(w).doubleValue();
        const yInt = y.selfDivide(w).doubleValue();
        if ((0, _doubleJsDefault.default).isNaN(xInt) || (0, _doubleJsDefault.default).isInfinite(xInt) || (0, _doubleJsDefault.default).isNaN(yInt) || (0, _doubleJsDefault.default).isInfinite(yInt)) return null;
        return new (0, _coordinateJsDefault.default)(xInt, yInt);
    }
    static orientationIndexFilter(pa, pb, pc) {
        let detsum = null;
        const detleft = (pa.x - pc.x) * (pb.y - pc.y);
        const detright = (pa.y - pc.y) * (pb.x - pc.x);
        const det = detleft - detright;
        if (detleft > 0.0) {
            if (detright <= 0.0) return CGAlgorithmsDD.signum(det);
            else detsum = detleft + detright;
        } else if (detleft < 0.0) {
            if (detright >= 0.0) return CGAlgorithmsDD.signum(det);
            else detsum = -detleft - detright;
        } else return CGAlgorithmsDD.signum(det);
        const errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;
        if (det >= errbound || -det >= errbound) return CGAlgorithmsDD.signum(det);
        return 2;
    }
    static signum(x) {
        if (x > 0) return 1;
        if (x < 0) return -1;
        return 0;
    }
}
exports.default = CGAlgorithmsDD;
CGAlgorithmsDD.DP_SAFE_EPSILON = 1e-15;

},{"../geom/Coordinate.js":"3REUb","../../../../java/lang/Double.js":"jCc26","../math/DD.js":"jc3gq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jc3gq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stringBufferJs = require("../../../../java/lang/StringBuffer.js");
var _stringBufferJsDefault = parcelHelpers.interopDefault(_stringBufferJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _integerJs = require("../../../../java/lang/Integer.js");
var _integerJsDefault = parcelHelpers.interopDefault(_integerJs);
var _characterJs = require("../../../../java/lang/Character.js");
var _characterJsDefault = parcelHelpers.interopDefault(_characterJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _cloneableJs = require("../../../../java/lang/Cloneable.js");
var _cloneableJsDefault = parcelHelpers.interopDefault(_cloneableJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _illegalStateExceptionJs = require("../../../../java/lang/IllegalStateException.js");
var _illegalStateExceptionJsDefault = parcelHelpers.interopDefault(_illegalStateExceptionJs);
class DD {
    constructor(){
        DD.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._hi = 0.0;
        this._lo = 0.0;
        if (arguments.length === 0) this.init(0.0);
        else if (arguments.length === 1) {
            if (typeof arguments[0] === 'number') {
                const x = arguments[0];
                this.init(x);
            } else if (arguments[0] instanceof DD) {
                const dd = arguments[0];
                this.init(dd);
            } else if (typeof arguments[0] === 'string') {
                const str = arguments[0];
                DD.constructor_.call(this, DD.parse(str));
            }
        } else if (arguments.length === 2) {
            const hi = arguments[0], lo = arguments[1];
            this.init(hi, lo);
        }
    }
    static determinant() {
        if (typeof arguments[3] === 'number' && typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            const x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3];
            return DD.determinant(DD.valueOf(x1), DD.valueOf(y1), DD.valueOf(x2), DD.valueOf(y2));
        } else if (arguments[3] instanceof DD && arguments[2] instanceof DD && arguments[0] instanceof DD && arguments[1] instanceof DD) {
            const x1 = arguments[0], y1 = arguments[1], x2 = arguments[2], y2 = arguments[3];
            const det = x1.multiply(y2).selfSubtract(y1.multiply(x2));
            return det;
        }
    }
    static sqr(x) {
        return DD.valueOf(x).selfMultiply(x);
    }
    static valueOf() {
        if (typeof arguments[0] === 'string') {
            const str = arguments[0];
            return DD.parse(str);
        } else if (typeof arguments[0] === 'number') {
            const x = arguments[0];
            return new DD(x);
        }
    }
    static sqrt(x) {
        return DD.valueOf(x).sqrt();
    }
    static parse(str) {
        let i = 0;
        const strlen = str.length;
        while((0, _characterJsDefault.default).isWhitespace(str.charAt(i)))i++;
        let isNegative = false;
        if (i < strlen) {
            const signCh = str.charAt(i);
            if (signCh === '-' || signCh === '+') {
                i++;
                if (signCh === '-') isNegative = true;
            }
        }
        const val = new DD();
        let numDigits = 0;
        let numBeforeDec = 0;
        let exp = 0;
        let hasDecimalChar = false;
        while(true){
            if (i >= strlen) break;
            const ch = str.charAt(i);
            i++;
            if ((0, _characterJsDefault.default).isDigit(ch)) {
                const d = ch - '0';
                val.selfMultiply(DD.TEN);
                val.selfAdd(d);
                numDigits++;
                continue;
            }
            if (ch === '.') {
                numBeforeDec = numDigits;
                hasDecimalChar = true;
                continue;
            }
            if (ch === 'e' || ch === 'E') {
                const expStr = str.substring(i);
                try {
                    exp = (0, _integerJsDefault.default).parseInt(expStr);
                } catch (ex) {
                    if (ex instanceof NumberFormatException) throw new NumberFormatException('Invalid exponent ' + expStr + ' in string ' + str);
                    else throw ex;
                } finally{}
                break;
            }
            throw new NumberFormatException('Unexpected character \'' + ch + '\' at position ' + i + ' in string ' + str);
        }
        let val2 = val;
        if (!hasDecimalChar) numBeforeDec = numDigits;
        const numDecPlaces = numDigits - numBeforeDec - exp;
        if (numDecPlaces === 0) val2 = val;
        else if (numDecPlaces > 0) {
            const scale = DD.TEN.pow(numDecPlaces);
            val2 = val.divide(scale);
        } else if (numDecPlaces < 0) {
            const scale = DD.TEN.pow(-numDecPlaces);
            val2 = val.multiply(scale);
        }
        if (isNegative) return val2.negate();
        return val2;
    }
    static createNaN() {
        return new DD((0, _doubleJsDefault.default).NaN, (0, _doubleJsDefault.default).NaN);
    }
    static copy(dd) {
        return new DD(dd);
    }
    static magnitude(x) {
        const xAbs = Math.abs(x);
        const xLog10 = Math.log(xAbs) / Math.log(10);
        let xMag = Math.trunc(Math.floor(xLog10));
        const xApprox = Math.pow(10, xMag);
        if (xApprox * 10 <= xAbs) xMag += 1;
        return xMag;
    }
    static stringOfChar(ch, len) {
        const buf = new (0, _stringBufferJsDefault.default)();
        for(let i = 0; i < len; i++)buf.append(ch);
        return buf.toString();
    }
    le(y) {
        return this._hi < y._hi || this._hi === y._hi && this._lo <= y._lo;
    }
    extractSignificantDigits(insertDecimalPoint, magnitude) {
        let y = this.abs();
        let mag = DD.magnitude(y._hi);
        const scale = DD.TEN.pow(mag);
        y = y.divide(scale);
        if (y.gt(DD.TEN)) {
            y = y.divide(DD.TEN);
            mag += 1;
        } else if (y.lt(DD.ONE)) {
            y = y.multiply(DD.TEN);
            mag -= 1;
        }
        const decimalPointPos = mag + 1;
        const buf = new (0, _stringBufferJsDefault.default)();
        const numDigits = DD.MAX_PRINT_DIGITS - 1;
        for(let i = 0; i <= numDigits; i++){
            if (insertDecimalPoint && i === decimalPointPos) buf.append('.');
            const digit = Math.trunc(y._hi);
            digit < 0 || digit;
            if (digit < 0) break;
            let rebiasBy10 = false;
            let digitChar = 0;
            if (digit > 9) {
                rebiasBy10 = true;
                digitChar = '9';
            } else digitChar = '0' + digit;
            buf.append(digitChar);
            y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);
            if (rebiasBy10) y.selfAdd(DD.TEN);
            let continueExtractingDigits = true;
            const remMag = DD.magnitude(y._hi);
            if (remMag < 0 && Math.abs(remMag) >= numDigits - i) continueExtractingDigits = false;
            if (!continueExtractingDigits) break;
        }
        magnitude[0] = mag;
        return buf.toString();
    }
    sqr() {
        return this.multiply(this);
    }
    getSpecialNumberString() {
        if (this.isZero()) return '0.0';
        if (this.isNaN()) return 'NaN ';
        return null;
    }
    setValue() {
        if (arguments[0] instanceof DD) {
            const value = arguments[0];
            this.init(value);
            return this;
        } else if (typeof arguments[0] === 'number') {
            const value = arguments[0];
            this.init(value);
            return this;
        }
    }
    multiply() {
        if (arguments[0] instanceof DD) {
            const y = arguments[0];
            if (y.isNaN()) return DD.createNaN();
            return DD.copy(this).selfMultiply(y);
        } else if (typeof arguments[0] === 'number') {
            const y = arguments[0];
            if ((0, _doubleJsDefault.default).isNaN(y)) return DD.createNaN();
            return DD.copy(this).selfMultiply(y, 0.0);
        }
    }
    isNaN() {
        return (0, _doubleJsDefault.default).isNaN(this._hi);
    }
    reciprocal() {
        let hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;
        C = 1.0 / this._hi;
        c = DD.SPLIT * C;
        hc = c - C;
        u = DD.SPLIT * this._hi;
        hc = c - hc;
        tc = C - hc;
        hy = u - this._hi;
        U = C * this._hi;
        hy = u - hy;
        ty = this._hi - hy;
        u = hc * hy - U + hc * ty + tc * hy + tc * ty;
        c = (1.0 - U - u - C * this._lo) / this._hi;
        const zhi = C + c;
        const zlo = C - zhi + c;
        return new DD(zhi, zlo);
    }
    doubleValue() {
        return this._hi + this._lo;
    }
    subtract() {
        if (arguments[0] instanceof DD) {
            const y = arguments[0];
            return this.add(y.negate());
        } else if (typeof arguments[0] === 'number') {
            const y = arguments[0];
            return this.add(-y);
        }
    }
    equals() {
        if (arguments.length === 1 && arguments[0] instanceof DD) {
            const y = arguments[0];
            return this._hi === y._hi && this._lo === y._lo;
        }
    }
    isZero() {
        return this._hi === 0.0 && this._lo === 0.0;
    }
    selfSubtract() {
        if (arguments[0] instanceof DD) {
            const y = arguments[0];
            if (this.isNaN()) return this;
            return this.selfAdd(-y._hi, -y._lo);
        } else if (typeof arguments[0] === 'number') {
            const y = arguments[0];
            if (this.isNaN()) return this;
            return this.selfAdd(-y, 0.0);
        }
    }
    min(x) {
        if (this.le(x)) return this;
        else return x;
    }
    selfDivide() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof DD) {
                const y = arguments[0];
                return this.selfDivide(y._hi, y._lo);
            } else if (typeof arguments[0] === 'number') {
                const y = arguments[0];
                return this.selfDivide(y, 0.0);
            }
        } else if (arguments.length === 2) {
            const yhi = arguments[0], ylo = arguments[1];
            let hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;
            C = this._hi / yhi;
            c = DD.SPLIT * C;
            hc = c - C;
            u = DD.SPLIT * yhi;
            hc = c - hc;
            tc = C - hc;
            hy = u - yhi;
            U = C * yhi;
            hy = u - hy;
            ty = yhi - hy;
            u = hc * hy - U + hc * ty + tc * hy + tc * ty;
            c = (this._hi - U - u + this._lo - C * ylo) / yhi;
            u = C + c;
            this._hi = u;
            this._lo = C - u + c;
            return this;
        }
    }
    dump() {
        return 'DD<' + this._hi + ', ' + this._lo + '>';
    }
    divide() {
        if (arguments[0] instanceof DD) {
            const y = arguments[0];
            let hc = null, tc = null, hy = null, ty = null, C = null, c = null, U = null, u = null;
            C = this._hi / y._hi;
            c = DD.SPLIT * C;
            hc = c - C;
            u = DD.SPLIT * y._hi;
            hc = c - hc;
            tc = C - hc;
            hy = u - y._hi;
            U = C * y._hi;
            hy = u - hy;
            ty = y._hi - hy;
            u = hc * hy - U + hc * ty + tc * hy + tc * ty;
            c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;
            u = C + c;
            const zhi = u;
            const zlo = C - u + c;
            return new DD(zhi, zlo);
        } else if (typeof arguments[0] === 'number') {
            const y = arguments[0];
            if ((0, _doubleJsDefault.default).isNaN(y)) return DD.createNaN();
            return DD.copy(this).selfDivide(y, 0.0);
        }
    }
    ge(y) {
        return this._hi > y._hi || this._hi === y._hi && this._lo >= y._lo;
    }
    pow(exp) {
        if (exp === 0.0) return DD.valueOf(1.0);
        let r = new DD(this);
        let s = DD.valueOf(1.0);
        let n = Math.abs(exp);
        if (n > 1) while(n > 0){
            if (n % 2 === 1) s.selfMultiply(r);
            n /= 2;
            if (n > 0) r = r.sqr();
        }
        else s = r;
        if (exp < 0) return s.reciprocal();
        return s;
    }
    ceil() {
        if (this.isNaN()) return DD.NaN;
        const fhi = Math.ceil(this._hi);
        let flo = 0.0;
        if (fhi === this._hi) flo = Math.ceil(this._lo);
        return new DD(fhi, flo);
    }
    compareTo(o) {
        const other = o;
        if (this._hi < other._hi) return -1;
        if (this._hi > other._hi) return 1;
        if (this._lo < other._lo) return -1;
        if (this._lo > other._lo) return 1;
        return 0;
    }
    rint() {
        if (this.isNaN()) return this;
        const plus5 = this.add(0.5);
        return plus5.floor();
    }
    max(x) {
        if (this.ge(x)) return this;
        else return x;
    }
    sqrt() {
        if (this.isZero()) return DD.valueOf(0.0);
        if (this.isNegative()) return DD.NaN;
        const x = 1.0 / Math.sqrt(this._hi);
        const ax = this._hi * x;
        const axdd = DD.valueOf(ax);
        const diffSq = this.subtract(axdd.sqr());
        const d2 = diffSq._hi * (x * 0.5);
        return axdd.add(d2);
    }
    selfAdd() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof DD) {
                const y = arguments[0];
                return this.selfAdd(y._hi, y._lo);
            } else if (typeof arguments[0] === 'number') {
                const y = arguments[0];
                let H = null, h = null, S = null, s = null, e = null, f = null;
                S = this._hi + y;
                e = S - this._hi;
                s = S - e;
                s = y - e + (this._hi - s);
                f = s + this._lo;
                H = S + f;
                h = f + (S - H);
                this._hi = H + h;
                this._lo = h + (H - this._hi);
                return this;
            }
        } else if (arguments.length === 2) {
            const yhi = arguments[0], ylo = arguments[1];
            let H = null, h = null, T = null, t = null, S = null, s = null, e = null, f = null;
            S = this._hi + yhi;
            T = this._lo + ylo;
            e = S - this._hi;
            f = T - this._lo;
            s = S - e;
            t = T - f;
            s = yhi - e + (this._hi - s);
            t = ylo - f + (this._lo - t);
            e = s + T;
            H = S + e;
            h = e + (S - H);
            e = t + h;
            const zhi = H + e;
            const zlo = e + (H - zhi);
            this._hi = zhi;
            this._lo = zlo;
            return this;
        }
    }
    selfMultiply() {
        if (arguments.length === 1) {
            if (arguments[0] instanceof DD) {
                const y = arguments[0];
                return this.selfMultiply(y._hi, y._lo);
            } else if (typeof arguments[0] === 'number') {
                const y = arguments[0];
                return this.selfMultiply(y, 0.0);
            }
        } else if (arguments.length === 2) {
            const yhi = arguments[0], ylo = arguments[1];
            let hx = null, tx = null, hy = null, ty = null, C = null, c = null;
            C = DD.SPLIT * this._hi;
            hx = C - this._hi;
            c = DD.SPLIT * yhi;
            hx = C - hx;
            tx = this._hi - hx;
            hy = c - yhi;
            C = this._hi * yhi;
            hy = c - hy;
            ty = yhi - hy;
            c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);
            const zhi = C + c;
            hx = C - zhi;
            const zlo = c + hx;
            this._hi = zhi;
            this._lo = zlo;
            return this;
        }
    }
    selfSqr() {
        return this.selfMultiply(this);
    }
    floor() {
        if (this.isNaN()) return DD.NaN;
        const fhi = Math.floor(this._hi);
        let flo = 0.0;
        if (fhi === this._hi) flo = Math.floor(this._lo);
        return new DD(fhi, flo);
    }
    negate() {
        if (this.isNaN()) return this;
        return new DD(-this._hi, -this._lo);
    }
    clone() {
        try {
            return null;
        } catch (ex) {
            if (ex instanceof CloneNotSupportedException) return null;
            else throw ex;
        } finally{}
    }
    intValue() {
        return Math.trunc(this._hi);
    }
    toString() {
        const mag = DD.magnitude(this._hi);
        if (mag >= -3 && mag <= 20) return this.toStandardNotation();
        return this.toSciNotation();
    }
    toStandardNotation() {
        const specialStr = this.getSpecialNumberString();
        if (specialStr !== null) return specialStr;
        const magnitude = new Array(1).fill(null);
        const sigDigits = this.extractSignificantDigits(true, magnitude);
        const decimalPointPos = magnitude[0] + 1;
        let num = sigDigits;
        if (sigDigits.charAt(0) === '.') num = '0' + sigDigits;
        else if (decimalPointPos < 0) num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;
        else if (sigDigits.indexOf('.') === -1) {
            const numZeroes = decimalPointPos - sigDigits.length;
            const zeroes = DD.stringOfChar('0', numZeroes);
            num = sigDigits + zeroes + '.0';
        }
        if (this.isNegative()) return '-' + num;
        return num;
    }
    toSciNotation() {
        if (this.isZero()) return DD.SCI_NOT_ZERO;
        const specialStr = this.getSpecialNumberString();
        if (specialStr !== null) return specialStr;
        const magnitude = new Array(1).fill(null);
        const digits = this.extractSignificantDigits(false, magnitude);
        const expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];
        if (digits.charAt(0) === '0') throw new (0, _illegalStateExceptionJsDefault.default)('Found leading zero: ' + digits);
        let trailingDigits = '';
        if (digits.length > 1) trailingDigits = digits.substring(1);
        const digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;
        if (this.isNegative()) return '-' + digitsWithDecimal + expStr;
        return digitsWithDecimal + expStr;
    }
    abs() {
        if (this.isNaN()) return DD.NaN;
        if (this.isNegative()) return this.negate();
        return new DD(this);
    }
    isPositive() {
        return this._hi > 0.0 || this._hi === 0.0 && this._lo > 0.0;
    }
    lt(y) {
        return this._hi < y._hi || this._hi === y._hi && this._lo < y._lo;
    }
    add() {
        if (arguments[0] instanceof DD) {
            const y = arguments[0];
            return DD.copy(this).selfAdd(y);
        } else if (typeof arguments[0] === 'number') {
            const y = arguments[0];
            return DD.copy(this).selfAdd(y);
        }
    }
    init() {
        if (arguments.length === 1) {
            if (typeof arguments[0] === 'number') {
                const x = arguments[0];
                this._hi = x;
                this._lo = 0.0;
            } else if (arguments[0] instanceof DD) {
                const dd = arguments[0];
                this._hi = dd._hi;
                this._lo = dd._lo;
            }
        } else if (arguments.length === 2) {
            const hi = arguments[0], lo = arguments[1];
            this._hi = hi;
            this._lo = lo;
        }
    }
    gt(y) {
        return this._hi > y._hi || this._hi === y._hi && this._lo > y._lo;
    }
    isNegative() {
        return this._hi < 0.0 || this._hi === 0.0 && this._lo < 0.0;
    }
    trunc() {
        if (this.isNaN()) return DD.NaN;
        if (this.isPositive()) return this.floor();
        else return this.ceil();
    }
    signum() {
        if (this._hi > 0) return 1;
        if (this._hi < 0) return -1;
        if (this._lo > 0) return 1;
        if (this._lo < 0) return -1;
        return 0;
    }
    get interfaces_() {
        return [
            (0, _serializableJsDefault.default),
            (0, _comparableJsDefault.default),
            (0, _cloneableJsDefault.default)
        ];
    }
}
exports.default = DD;
DD.PI = new DD(3.141592653589793116e+00, 1.224646799147353207e-16);
DD.TWO_PI = new DD(6.283185307179586232e+00, 2.449293598294706414e-16);
DD.PI_2 = new DD(1.570796326794896558e+00, 6.123233995736766036e-17);
DD.E = new DD(2.718281828459045091e+00, 1.445646891729250158e-16);
DD.NaN = new DD((0, _doubleJsDefault.default).NaN, (0, _doubleJsDefault.default).NaN);
DD.EPS = 1.23259516440783e-32;
DD.SPLIT = 134217729.0;
DD.MAX_PRINT_DIGITS = 32;
DD.TEN = DD.valueOf(10.0);
DD.ONE = DD.valueOf(1.0);
DD.SCI_NOT_EXPONENT_CHAR = 'E';
DD.SCI_NOT_ZERO = '0.0E0';

},{"../../../../java/lang/StringBuffer.js":"lJQsM","../../../../java/lang/Double.js":"jCc26","../../../../java/lang/Integer.js":"9MkbL","../../../../java/lang/Character.js":"kHj8q","../../../../java/lang/Comparable.js":"6Adw4","../../../../java/lang/Cloneable.js":"bkkIE","../../../../java/io/Serializable.js":"4emqV","../../../../java/lang/IllegalStateException.js":"4MAFg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lJQsM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class StringBuffer {
    constructor(str){
        this.str = str;
    }
    append(e) {
        this.str += e;
    }
    setCharAt(i, c) {
        this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);
    }
    toString() {
        return this.str;
    }
}
exports.default = StringBuffer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ikww2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _geometryCollectionJs = require("./GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _puntalJs = require("./Puntal.js");
var _puntalJsDefault = parcelHelpers.interopDefault(_puntalJs);
class MultiPoint extends (0, _geometryCollectionJsDefault.default) {
    constructor(){
        super();
        MultiPoint.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const points = arguments[0], factory = arguments[1];
        (0, _geometryCollectionJsDefault.default).constructor_.call(this, points, factory);
    }
    equalsExact() {
        if (arguments.length === 2 && typeof arguments[1] === 'number' && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const other = arguments[0], tolerance = arguments[1];
            if (!this.isEquivalentClass(other)) return false;
            return super.equalsExact.call(this, other, tolerance);
        } else return super.equalsExact.apply(this, arguments);
    }
    getTypeCode() {
        return (0, _geometryJsDefault.default).TYPECODE_MULTIPOINT;
    }
    getDimension() {
        return 0;
    }
    getBoundary() {
        return this.getFactory().createGeometryCollection();
    }
    getGeometryType() {
        return (0, _geometryJsDefault.default).TYPENAME_MULTIPOINT;
    }
    copyInternal() {
        const points = new Array(this._geometries.length).fill(null);
        for(let i = 0; i < points.length; i++)points[i] = this._geometries[i].copy();
        return new MultiPoint(points, this._factory);
    }
    isValid() {
        return true;
    }
    getCoordinate() {
        if (arguments.length === 1 && Number.isInteger(arguments[0])) {
            const n = arguments[0];
            return this._geometries[n].getCoordinate();
        } else return super.getCoordinate.apply(this, arguments);
    }
    getBoundaryDimension() {
        return (0, _dimensionJsDefault.default).FALSE;
    }
    get interfaces_() {
        return [
            (0, _puntalJsDefault.default)
        ];
    }
}
exports.default = MultiPoint;

},{"./Geometry.js":"d5V2e","./GeometryCollection.js":"9xeCT","./Dimension.js":"966Ye","./Puntal.js":"2RT7X","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8dTUp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("./Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _dimensionJs = require("./Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _cloneableJs = require("../../../../java/lang/Cloneable.js");
var _cloneableJsDefault = parcelHelpers.interopDefault(_cloneableJs);
var _stringBuilderJs = require("../../../../java/lang/StringBuilder.js");
var _stringBuilderJsDefault = parcelHelpers.interopDefault(_stringBuilderJs);
class IntersectionMatrix {
    constructor(){
        IntersectionMatrix.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._matrix = null;
        if (arguments.length === 0) {
            this._matrix = Array(3).fill().map(()=>Array(3));
            this.setAll((0, _dimensionJsDefault.default).FALSE);
        } else if (arguments.length === 1) {
            if (typeof arguments[0] === 'string') {
                const elements = arguments[0];
                IntersectionMatrix.constructor_.call(this);
                this.set(elements);
            } else if (arguments[0] instanceof IntersectionMatrix) {
                const other = arguments[0];
                IntersectionMatrix.constructor_.call(this);
                this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR] = other._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR];
                this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY] = other._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY];
                this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR] = other._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR];
                this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR] = other._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR];
                this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY] = other._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY];
                this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).EXTERIOR] = other._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).EXTERIOR];
                this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR] = other._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR];
                this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).BOUNDARY] = other._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).BOUNDARY];
                this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).EXTERIOR] = other._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).EXTERIOR];
            }
        }
    }
    static isTrue(actualDimensionValue) {
        if (actualDimensionValue >= 0 || actualDimensionValue === (0, _dimensionJsDefault.default).TRUE) return true;
        return false;
    }
    static matches() {
        if (Number.isInteger(arguments[0]) && typeof arguments[1] === 'string') {
            const actualDimensionValue = arguments[0], requiredDimensionSymbol = arguments[1];
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_DONTCARE) return true;
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_TRUE && (actualDimensionValue >= 0 || actualDimensionValue === (0, _dimensionJsDefault.default).TRUE)) return true;
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_FALSE && actualDimensionValue === (0, _dimensionJsDefault.default).FALSE) return true;
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_P && actualDimensionValue === (0, _dimensionJsDefault.default).P) return true;
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_L && actualDimensionValue === (0, _dimensionJsDefault.default).L) return true;
            if (requiredDimensionSymbol === (0, _dimensionJsDefault.default).SYM_A && actualDimensionValue === (0, _dimensionJsDefault.default).A) return true;
            return false;
        } else if (typeof arguments[0] === 'string' && typeof arguments[1] === 'string') {
            const actualDimensionSymbols = arguments[0], requiredDimensionSymbols = arguments[1];
            const m = new IntersectionMatrix(actualDimensionSymbols);
            return m.matches(requiredDimensionSymbols);
        }
    }
    isIntersects() {
        return !this.isDisjoint();
    }
    set() {
        if (arguments.length === 1) {
            const dimensionSymbols = arguments[0];
            for(let i = 0; i < dimensionSymbols.length; i++){
                const row = Math.trunc(i / 3);
                const col = i % 3;
                this._matrix[row][col] = (0, _dimensionJsDefault.default).toDimensionValue(dimensionSymbols.charAt(i));
            }
        } else if (arguments.length === 3) {
            const row = arguments[0], column = arguments[1], dimensionValue = arguments[2];
            this._matrix[row][column] = dimensionValue;
        }
    }
    isContains() {
        return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).BOUNDARY] === (0, _dimensionJsDefault.default).FALSE;
    }
    isWithin() {
        return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE;
    }
    isTouches(dimensionOfGeometryA, dimensionOfGeometryB) {
        if (dimensionOfGeometryA > dimensionOfGeometryB) return this.isTouches(dimensionOfGeometryB, dimensionOfGeometryA);
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).A && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A || dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L || dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A || dimensionOfGeometryA === (0, _dimensionJsDefault.default).P && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A || dimensionOfGeometryA === (0, _dimensionJsDefault.default).P && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L) return this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && (IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY]));
        return false;
    }
    isOverlaps(dimensionOfGeometryA, dimensionOfGeometryB) {
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).P && dimensionOfGeometryB === (0, _dimensionJsDefault.default).P || dimensionOfGeometryA === (0, _dimensionJsDefault.default).A && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A) return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR]);
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L) return this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR] === 1 && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR]) && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR]);
        return false;
    }
    isEquals(dimensionOfGeometryA, dimensionOfGeometryB) {
        if (dimensionOfGeometryA !== dimensionOfGeometryB) return false;
        return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).BOUNDARY] === (0, _dimensionJsDefault.default).FALSE;
    }
    matches(requiredDimensionSymbols) {
        if (requiredDimensionSymbols.length !== 9) throw new (0, _illegalArgumentExceptionJsDefault.default)('Should be length 9: ' + requiredDimensionSymbols);
        for(let ai = 0; ai < 3; ai++)for(let bi = 0; bi < 3; bi++)if (!IntersectionMatrix.matches(this._matrix[ai][bi], requiredDimensionSymbols.charAt(3 * ai + bi))) return false;
        return true;
    }
    add(im) {
        for(let i = 0; i < 3; i++)for(let j = 0; j < 3; j++)this.setAtLeast(i, j, im.get(i, j));
    }
    isDisjoint() {
        return this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY] === (0, _dimensionJsDefault.default).FALSE;
    }
    isCrosses(dimensionOfGeometryA, dimensionOfGeometryB) {
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).P && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L || dimensionOfGeometryA === (0, _dimensionJsDefault.default).P && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A || dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).A) return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR]);
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).P || dimensionOfGeometryA === (0, _dimensionJsDefault.default).A && dimensionOfGeometryB === (0, _dimensionJsDefault.default).P || dimensionOfGeometryA === (0, _dimensionJsDefault.default).A && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L) return IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) && IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR]);
        if (dimensionOfGeometryA === (0, _dimensionJsDefault.default).L && dimensionOfGeometryB === (0, _dimensionJsDefault.default).L) return this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR] === 0;
        return false;
    }
    isCovers() {
        const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY]);
        return hasPointInCommon && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).INTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).EXTERIOR][(0, _locationJsDefault.default).BOUNDARY] === (0, _dimensionJsDefault.default).FALSE;
    }
    isCoveredBy() {
        const hasPointInCommon = IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).BOUNDARY]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).INTERIOR]) || IntersectionMatrix.isTrue(this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).BOUNDARY]);
        return hasPointInCommon && this._matrix[(0, _locationJsDefault.default).INTERIOR][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE && this._matrix[(0, _locationJsDefault.default).BOUNDARY][(0, _locationJsDefault.default).EXTERIOR] === (0, _dimensionJsDefault.default).FALSE;
    }
    setAtLeast() {
        if (arguments.length === 1) {
            const minimumDimensionSymbols = arguments[0];
            for(let i = 0; i < minimumDimensionSymbols.length; i++){
                const row = Math.trunc(i / 3);
                const col = i % 3;
                this.setAtLeast(row, col, (0, _dimensionJsDefault.default).toDimensionValue(minimumDimensionSymbols.charAt(i)));
            }
        } else if (arguments.length === 3) {
            const row = arguments[0], column = arguments[1], minimumDimensionValue = arguments[2];
            if (this._matrix[row][column] < minimumDimensionValue) this._matrix[row][column] = minimumDimensionValue;
        }
    }
    setAtLeastIfValid(row, column, minimumDimensionValue) {
        if (row >= 0 && column >= 0) this.setAtLeast(row, column, minimumDimensionValue);
    }
    toString() {
        const builder = new (0, _stringBuilderJsDefault.default)('123456789');
        for(let ai = 0; ai < 3; ai++)for(let bi = 0; bi < 3; bi++)builder.setCharAt(3 * ai + bi, (0, _dimensionJsDefault.default).toDimensionSymbol(this._matrix[ai][bi]));
        return builder.toString();
    }
    setAll(dimensionValue) {
        for(let ai = 0; ai < 3; ai++)for(let bi = 0; bi < 3; bi++)this._matrix[ai][bi] = dimensionValue;
    }
    get(row, column) {
        return this._matrix[row][column];
    }
    transpose() {
        let temp = this._matrix[1][0];
        this._matrix[1][0] = this._matrix[0][1];
        this._matrix[0][1] = temp;
        temp = this._matrix[2][0];
        this._matrix[2][0] = this._matrix[0][2];
        this._matrix[0][2] = temp;
        temp = this._matrix[2][1];
        this._matrix[2][1] = this._matrix[1][2];
        this._matrix[1][2] = temp;
        return this;
    }
    get interfaces_() {
        return [
            (0, _cloneableJsDefault.default)
        ];
    }
}
exports.default = IntersectionMatrix;

},{"./Location.js":"71R1B","../../../../java/lang/IllegalArgumentException.js":"1VQhm","./Dimension.js":"966Ye","../../../../java/lang/Cloneable.js":"bkkIE","../../../../java/lang/StringBuilder.js":"iGg1z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"71R1B":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class Location {
    static toLocationSymbol(locationValue) {
        switch(locationValue){
            case Location.EXTERIOR:
                return 'e';
            case Location.BOUNDARY:
                return 'b';
            case Location.INTERIOR:
                return 'i';
            case Location.NONE:
                return '-';
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Unknown location value: ' + locationValue);
    }
}
exports.default = Location;
Location.INTERIOR = 0;
Location.BOUNDARY = 1;
Location.EXTERIOR = 2;
Location.NONE = -1;

},{"../../../../java/lang/IllegalArgumentException.js":"1VQhm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fJOZ9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _quadrantJs = require("./Quadrant.js");
var _quadrantJsDefault = parcelHelpers.interopDefault(_quadrantJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class EdgeEnd {
    constructor(){
        EdgeEnd.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._edge = null;
        this._label = null;
        this._node = null;
        this._p0 = null;
        this._p1 = null;
        this._dx = null;
        this._dy = null;
        this._quadrant = null;
        if (arguments.length === 1) {
            const edge = arguments[0];
            this._edge = edge;
        } else if (arguments.length === 3) {
            const edge = arguments[0], p0 = arguments[1], p1 = arguments[2];
            EdgeEnd.constructor_.call(this, edge, p0, p1, null);
        } else if (arguments.length === 4) {
            const edge = arguments[0], p0 = arguments[1], p1 = arguments[2], label = arguments[3];
            EdgeEnd.constructor_.call(this, edge);
            this.init(p0, p1);
            this._label = label;
        }
    }
    compareDirection(e) {
        if (this._dx === e._dx && this._dy === e._dy) return 0;
        if (this._quadrant > e._quadrant) return 1;
        if (this._quadrant < e._quadrant) return -1;
        return (0, _orientationJsDefault.default).index(e._p0, e._p1, this._p1);
    }
    getDy() {
        return this._dy;
    }
    print(out) {
        const angle = Math.atan2(this._dy, this._dx);
        const className = this.getClass().getName();
        const lastDotPos = className.lastIndexOf('.');
        const name = className.substring(lastDotPos + 1);
        out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);
    }
    getLabel() {
        return this._label;
    }
    getEdge() {
        return this._edge;
    }
    toString() {
        const angle = Math.atan2(this._dy, this._dx);
        const className = this.getClass().getName();
        const lastDotPos = className.lastIndexOf('.');
        const name = className.substring(lastDotPos + 1);
        return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label;
    }
    computeLabel(boundaryNodeRule) {}
    init(p0, p1) {
        this._p0 = p0;
        this._p1 = p1;
        this._dx = p1.x - p0.x;
        this._dy = p1.y - p0.y;
        this._quadrant = (0, _quadrantJsDefault.default).quadrant(this._dx, this._dy);
        (0, _assertJsDefault.default).isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');
    }
    getCoordinate() {
        return this._p0;
    }
    setNode(node) {
        this._node = node;
    }
    compareTo(obj) {
        const e = obj;
        return this.compareDirection(e);
    }
    getDirectedCoordinate() {
        return this._p1;
    }
    getDx() {
        return this._dx;
    }
    getQuadrant() {
        return this._quadrant;
    }
    getNode() {
        return this._node;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = EdgeEnd;

},{"../algorithm/Orientation.js":"QDWSa","../../../../java/lang/Comparable.js":"6Adw4","./Quadrant.js":"hwMrb","../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwMrb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class Quadrant {
    static isNorthern(quad) {
        return quad === Quadrant.NE || quad === Quadrant.NW;
    }
    static isOpposite(quad1, quad2) {
        if (quad1 === quad2) return false;
        const diff = (quad1 - quad2 + 4) % 4;
        if (diff === 2) return true;
        return false;
    }
    static commonHalfPlane(quad1, quad2) {
        if (quad1 === quad2) return quad1;
        const diff = (quad1 - quad2 + 4) % 4;
        if (diff === 2) return -1;
        const min = quad1 < quad2 ? quad1 : quad2;
        const max = quad1 > quad2 ? quad1 : quad2;
        if (min === 0 && max === 3) return 3;
        return min;
    }
    static isInHalfPlane(quad, halfPlane) {
        if (halfPlane === Quadrant.SE) return quad === Quadrant.SE || quad === Quadrant.SW;
        return quad === halfPlane || quad === halfPlane + 1;
    }
    static quadrant() {
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            const dx = arguments[0], dy = arguments[1];
            if (dx === 0.0 && dy === 0.0) throw new (0, _illegalArgumentExceptionJsDefault.default)('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )');
            if (dx >= 0.0) {
                if (dy >= 0.0) return Quadrant.NE;
                else return Quadrant.SE;
            } else if (dy >= 0.0) return Quadrant.NW;
            else return Quadrant.SW;
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
            const p0 = arguments[0], p1 = arguments[1];
            if (p1.x === p0.x && p1.y === p0.y) throw new (0, _illegalArgumentExceptionJsDefault.default)('Cannot compute the quadrant for two identical points ' + p0);
            if (p1.x >= p0.x) {
                if (p1.y >= p0.y) return Quadrant.NE;
                else return Quadrant.SE;
            } else if (p1.y >= p0.y) return Quadrant.NW;
            else return Quadrant.SW;
        }
    }
}
exports.default = Quadrant;
Quadrant.NE = 0;
Quadrant.NW = 1;
Quadrant.SW = 2;
Quadrant.SE = 3;

},{"../geom/Coordinate.js":"3REUb","../../../../java/lang/IllegalArgumentException.js":"1VQhm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2NrfJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stringBufferJs = require("../../../../java/lang/StringBuffer.js");
var _stringBufferJsDefault = parcelHelpers.interopDefault(_stringBufferJs);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _topologyLocationJs = require("./TopologyLocation.js");
var _topologyLocationJsDefault = parcelHelpers.interopDefault(_topologyLocationJs);
class Label {
    constructor(){
        Label.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.elt = new Array(2).fill(null);
        if (arguments.length === 1) {
            if (Number.isInteger(arguments[0])) {
                const onLoc = arguments[0];
                this.elt[0] = new (0, _topologyLocationJsDefault.default)(onLoc);
                this.elt[1] = new (0, _topologyLocationJsDefault.default)(onLoc);
            } else if (arguments[0] instanceof Label) {
                const lbl = arguments[0];
                this.elt[0] = new (0, _topologyLocationJsDefault.default)(lbl.elt[0]);
                this.elt[1] = new (0, _topologyLocationJsDefault.default)(lbl.elt[1]);
            }
        } else if (arguments.length === 2) {
            const geomIndex = arguments[0], onLoc = arguments[1];
            this.elt[0] = new (0, _topologyLocationJsDefault.default)((0, _locationJsDefault.default).NONE);
            this.elt[1] = new (0, _topologyLocationJsDefault.default)((0, _locationJsDefault.default).NONE);
            this.elt[geomIndex].setLocation(onLoc);
        } else if (arguments.length === 3) {
            const onLoc = arguments[0], leftLoc = arguments[1], rightLoc = arguments[2];
            this.elt[0] = new (0, _topologyLocationJsDefault.default)(onLoc, leftLoc, rightLoc);
            this.elt[1] = new (0, _topologyLocationJsDefault.default)(onLoc, leftLoc, rightLoc);
        } else if (arguments.length === 4) {
            const geomIndex = arguments[0], onLoc = arguments[1], leftLoc = arguments[2], rightLoc = arguments[3];
            this.elt[0] = new (0, _topologyLocationJsDefault.default)((0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE);
            this.elt[1] = new (0, _topologyLocationJsDefault.default)((0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE);
            this.elt[geomIndex].setLocations(onLoc, leftLoc, rightLoc);
        }
    }
    static toLineLabel(label) {
        const lineLabel = new Label((0, _locationJsDefault.default).NONE);
        for(let i = 0; i < 2; i++)lineLabel.setLocation(i, label.getLocation(i));
        return lineLabel;
    }
    getGeometryCount() {
        let count = 0;
        if (!this.elt[0].isNull()) count++;
        if (!this.elt[1].isNull()) count++;
        return count;
    }
    setAllLocations(geomIndex, location) {
        this.elt[geomIndex].setAllLocations(location);
    }
    isNull(geomIndex) {
        return this.elt[geomIndex].isNull();
    }
    setAllLocationsIfNull() {
        if (arguments.length === 1) {
            const location = arguments[0];
            this.setAllLocationsIfNull(0, location);
            this.setAllLocationsIfNull(1, location);
        } else if (arguments.length === 2) {
            const geomIndex = arguments[0], location = arguments[1];
            this.elt[geomIndex].setAllLocationsIfNull(location);
        }
    }
    isLine(geomIndex) {
        return this.elt[geomIndex].isLine();
    }
    merge(lbl) {
        for(let i = 0; i < 2; i++)if (this.elt[i] === null && lbl.elt[i] !== null) this.elt[i] = new (0, _topologyLocationJsDefault.default)(lbl.elt[i]);
        else this.elt[i].merge(lbl.elt[i]);
    }
    flip() {
        this.elt[0].flip();
        this.elt[1].flip();
    }
    getLocation() {
        if (arguments.length === 1) {
            const geomIndex = arguments[0];
            return this.elt[geomIndex].get((0, _positionJsDefault.default).ON);
        } else if (arguments.length === 2) {
            const geomIndex = arguments[0], posIndex = arguments[1];
            return this.elt[geomIndex].get(posIndex);
        }
    }
    toString() {
        const buf = new (0, _stringBufferJsDefault.default)();
        if (this.elt[0] !== null) {
            buf.append('A:');
            buf.append(this.elt[0].toString());
        }
        if (this.elt[1] !== null) {
            buf.append(' B:');
            buf.append(this.elt[1].toString());
        }
        return buf.toString();
    }
    setLocation() {
        if (arguments.length === 2) {
            const geomIndex = arguments[0], location = arguments[1];
            this.elt[geomIndex].setLocation((0, _positionJsDefault.default).ON, location);
        } else if (arguments.length === 3) {
            const geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];
            this.elt[geomIndex].setLocation(posIndex, location);
        }
    }
    isEqualOnSide(lbl, side) {
        return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side);
    }
    allPositionsEqual(geomIndex, loc) {
        return this.elt[geomIndex].allPositionsEqual(loc);
    }
    toLine(geomIndex) {
        if (this.elt[geomIndex].isArea()) this.elt[geomIndex] = new (0, _topologyLocationJsDefault.default)(this.elt[geomIndex].location[0]);
    }
    isArea() {
        if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea();
        else if (arguments.length === 1) {
            const geomIndex = arguments[0];
            return this.elt[geomIndex].isArea();
        }
    }
    isAnyNull(geomIndex) {
        return this.elt[geomIndex].isAnyNull();
    }
}
exports.default = Label;

},{"../../../../java/lang/StringBuffer.js":"lJQsM","../geom/Location.js":"71R1B","./Position.js":"929cL","./TopologyLocation.js":"dYcaO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"929cL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Position {
    static opposite(position) {
        if (position === Position.LEFT) return Position.RIGHT;
        if (position === Position.RIGHT) return Position.LEFT;
        return position;
    }
}
exports.default = Position;
Position.ON = 0;
Position.LEFT = 1;
Position.RIGHT = 2;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dYcaO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stringBufferJs = require("../../../../java/lang/StringBuffer.js");
var _stringBufferJsDefault = parcelHelpers.interopDefault(_stringBufferJs);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
class TopologyLocation {
    constructor(){
        TopologyLocation.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.location = null;
        if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
                const location = arguments[0];
                this.init(location.length);
            } else if (Number.isInteger(arguments[0])) {
                const on = arguments[0];
                this.init(1);
                this.location[(0, _positionJsDefault.default).ON] = on;
            } else if (arguments[0] instanceof TopologyLocation) {
                const gl = arguments[0];
                this.init(gl.location.length);
                if (gl !== null) for(let i = 0; i < this.location.length; i++)this.location[i] = gl.location[i];
            }
        } else if (arguments.length === 3) {
            const on = arguments[0], left = arguments[1], right = arguments[2];
            this.init(3);
            this.location[(0, _positionJsDefault.default).ON] = on;
            this.location[(0, _positionJsDefault.default).LEFT] = left;
            this.location[(0, _positionJsDefault.default).RIGHT] = right;
        }
    }
    setAllLocations(locValue) {
        for(let i = 0; i < this.location.length; i++)this.location[i] = locValue;
    }
    isNull() {
        for(let i = 0; i < this.location.length; i++)if (this.location[i] !== (0, _locationJsDefault.default).NONE) return false;
        return true;
    }
    setAllLocationsIfNull(locValue) {
        for(let i = 0; i < this.location.length; i++)if (this.location[i] === (0, _locationJsDefault.default).NONE) this.location[i] = locValue;
    }
    isLine() {
        return this.location.length === 1;
    }
    merge(gl) {
        if (gl.location.length > this.location.length) {
            const newLoc = new Array(3).fill(null);
            newLoc[(0, _positionJsDefault.default).ON] = this.location[(0, _positionJsDefault.default).ON];
            newLoc[(0, _positionJsDefault.default).LEFT] = (0, _locationJsDefault.default).NONE;
            newLoc[(0, _positionJsDefault.default).RIGHT] = (0, _locationJsDefault.default).NONE;
            this.location = newLoc;
        }
        for(let i = 0; i < this.location.length; i++)if (this.location[i] === (0, _locationJsDefault.default).NONE && i < gl.location.length) this.location[i] = gl.location[i];
    }
    getLocations() {
        return this.location;
    }
    flip() {
        if (this.location.length <= 1) return null;
        const temp = this.location[(0, _positionJsDefault.default).LEFT];
        this.location[(0, _positionJsDefault.default).LEFT] = this.location[(0, _positionJsDefault.default).RIGHT];
        this.location[(0, _positionJsDefault.default).RIGHT] = temp;
    }
    get(posIndex) {
        if (posIndex < this.location.length) return this.location[posIndex];
        return (0, _locationJsDefault.default).NONE;
    }
    isEqualOnSide(le, locIndex) {
        return this.location[locIndex] === le.location[locIndex];
    }
    allPositionsEqual(loc) {
        for(let i = 0; i < this.location.length; i++)if (this.location[i] !== loc) return false;
        return true;
    }
    toString() {
        const buf = new (0, _stringBufferJsDefault.default)();
        if (this.location.length > 1) buf.append((0, _locationJsDefault.default).toLocationSymbol(this.location[(0, _positionJsDefault.default).LEFT]));
        buf.append((0, _locationJsDefault.default).toLocationSymbol(this.location[(0, _positionJsDefault.default).ON]));
        if (this.location.length > 1) buf.append((0, _locationJsDefault.default).toLocationSymbol(this.location[(0, _positionJsDefault.default).RIGHT]));
        return buf.toString();
    }
    setLocations(on, left, right) {
        this.location[(0, _positionJsDefault.default).ON] = on;
        this.location[(0, _positionJsDefault.default).LEFT] = left;
        this.location[(0, _positionJsDefault.default).RIGHT] = right;
    }
    isArea() {
        return this.location.length > 1;
    }
    isAnyNull() {
        for(let i = 0; i < this.location.length; i++)if (this.location[i] === (0, _locationJsDefault.default).NONE) return true;
        return false;
    }
    setLocation() {
        if (arguments.length === 1) {
            const locValue = arguments[0];
            this.setLocation((0, _positionJsDefault.default).ON, locValue);
        } else if (arguments.length === 2) {
            const locIndex = arguments[0], locValue = arguments[1];
            this.location[locIndex] = locValue;
        }
    }
    init(size) {
        this.location = new Array(size).fill(null);
        this.setAllLocations((0, _locationJsDefault.default).NONE);
    }
}
exports.default = TopologyLocation;

},{"../../../../java/lang/StringBuffer.js":"lJQsM","../geom/Location.js":"71R1B","./Position.js":"929cL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i6KqO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _nodeJs = require("./Node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _treeMapJs = require("../../../../java/util/TreeMap.js");
var _treeMapJsDefault = parcelHelpers.interopDefault(_treeMapJs);
class NodeMap {
    constructor(){
        NodeMap.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.nodeMap = new (0, _treeMapJsDefault.default)();
        this.nodeFact = null;
        const nodeFact = arguments[0];
        this.nodeFact = nodeFact;
    }
    print(out) {
        for(let it = this.iterator(); it.hasNext();){
            const n = it.next();
            n.print(out);
        }
    }
    iterator() {
        return this.nodeMap.values().iterator();
    }
    values() {
        return this.nodeMap.values();
    }
    getBoundaryNodes(geomIndex) {
        const bdyNodes = new (0, _arrayListJsDefault.default)();
        for(let i = this.iterator(); i.hasNext();){
            const node = i.next();
            if (node.getLabel().getLocation(geomIndex) === (0, _locationJsDefault.default).BOUNDARY) bdyNodes.add(node);
        }
        return bdyNodes;
    }
    add(e) {
        const p = e.getCoordinate();
        const n = this.addNode(p);
        n.add(e);
    }
    find(coord) {
        return this.nodeMap.get(coord);
    }
    addNode() {
        if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const coord = arguments[0];
            let node = this.nodeMap.get(coord);
            if (node === null) {
                node = this.nodeFact.createNode(coord);
                this.nodeMap.put(coord, node);
            }
            return node;
        } else if (arguments[0] instanceof (0, _nodeJsDefault.default)) {
            const n = arguments[0];
            const node = this.nodeMap.get(n.getCoordinate());
            if (node === null) {
                this.nodeMap.put(n.getCoordinate(), n);
                return n;
            }
            node.mergeLabel(n);
            return node;
        }
    }
}
exports.default = NodeMap;

},{"../geom/Location.js":"71R1B","../geom/Coordinate.js":"3REUb","./Node.js":"fKSwC","../../../../java/util/ArrayList.js":"g8omH","../../../../java/util/TreeMap.js":"3VPI6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fKSwC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _graphComponentJs = require("./GraphComponent.js");
var _graphComponentJsDefault = parcelHelpers.interopDefault(_graphComponentJs);
class Node extends (0, _graphComponentJsDefault.default) {
    constructor(){
        super();
        Node.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._coord = null;
        this._edges = null;
        const coord = arguments[0], edges = arguments[1];
        this._coord = coord;
        this._edges = edges;
        this._label = new (0, _labelJsDefault.default)(0, (0, _locationJsDefault.default).NONE);
    }
    isIncidentEdgeInResult() {
        for(let it = this.getEdges().getEdges().iterator(); it.hasNext();){
            const de = it.next();
            if (de.getEdge().isInResult()) return true;
        }
        return false;
    }
    isIsolated() {
        return this._label.getGeometryCount() === 1;
    }
    getCoordinate() {
        return this._coord;
    }
    computeMergedLocation(label2, eltIndex) {
        let loc = (0, _locationJsDefault.default).NONE;
        loc = this._label.getLocation(eltIndex);
        if (!label2.isNull(eltIndex)) {
            const nLoc = label2.getLocation(eltIndex);
            if (loc !== (0, _locationJsDefault.default).BOUNDARY) loc = nLoc;
        }
        return loc;
    }
    setLabel() {
        if (arguments.length === 2 && Number.isInteger(arguments[1]) && Number.isInteger(arguments[0])) {
            const argIndex = arguments[0], onLocation = arguments[1];
            if (this._label === null) this._label = new (0, _labelJsDefault.default)(argIndex, onLocation);
            else this._label.setLocation(argIndex, onLocation);
        } else return super.setLabel.apply(this, arguments);
    }
    getEdges() {
        return this._edges;
    }
    mergeLabel() {
        if (arguments[0] instanceof Node) {
            const n = arguments[0];
            this.mergeLabel(n._label);
        } else if (arguments[0] instanceof (0, _labelJsDefault.default)) {
            const label2 = arguments[0];
            for(let i = 0; i < 2; i++){
                const loc = this.computeMergedLocation(label2, i);
                const thisLoc = this._label.getLocation(i);
                if (thisLoc === (0, _locationJsDefault.default).NONE) this._label.setLocation(i, loc);
            }
        }
    }
    add(e) {
        this._edges.insert(e);
        e.setNode(this);
    }
    setLabelBoundary(argIndex) {
        if (this._label === null) return null;
        let loc = (0, _locationJsDefault.default).NONE;
        if (this._label !== null) loc = this._label.getLocation(argIndex);
        let newLoc = null;
        switch(loc){
            case (0, _locationJsDefault.default).BOUNDARY:
                newLoc = (0, _locationJsDefault.default).INTERIOR;
                break;
            case (0, _locationJsDefault.default).INTERIOR:
                newLoc = (0, _locationJsDefault.default).BOUNDARY;
                break;
            default:
                newLoc = (0, _locationJsDefault.default).BOUNDARY;
                break;
        }
        this._label.setLocation(argIndex, newLoc);
    }
    print(out) {
        out.println('node ' + this._coord + ' lbl: ' + this._label);
    }
    computeIM(im) {}
}
exports.default = Node;

},{"../geom/Location.js":"71R1B","./Label.js":"2NrfJ","./GraphComponent.js":"cY8Ur","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cY8Ur":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class GraphComponent {
    constructor(){
        GraphComponent.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._label = null;
        this._isInResult = false;
        this._isCovered = false;
        this._isCoveredSet = false;
        this._isVisited = false;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const label = arguments[0];
            this._label = label;
        }
    }
    setVisited(isVisited) {
        this._isVisited = isVisited;
    }
    setInResult(isInResult) {
        this._isInResult = isInResult;
    }
    setLabel(label) {
        this._label = label;
    }
    getLabel() {
        return this._label;
    }
    setCovered(isCovered) {
        this._isCovered = isCovered;
        this._isCoveredSet = true;
    }
    updateIM(im) {
        (0, _assertJsDefault.default).isTrue(this._label.getGeometryCount() >= 2, 'found partial label');
        this.computeIM(im);
    }
    isCovered() {
        return this._isCovered;
    }
    isCoveredSet() {
        return this._isCoveredSet;
    }
    isInResult() {
        return this._isInResult;
    }
    isVisited() {
        return this._isVisited;
    }
}
exports.default = GraphComponent;

},{"../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3VPI6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("./ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _sortedMapJs = require("./SortedMap.js");
var _sortedMapJsDefault = parcelHelpers.interopDefault(_sortedMapJs);
var _hashSetJs = require("./HashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
const BLACK = 0;
const RED = 1;
function colorOf(p) {
    return p == null ? BLACK : p.color;
}
function parentOf(p) {
    return p == null ? null : p.parent;
}
function setColor(p, c) {
    if (p !== null) p.color = c;
}
function leftOf(p) {
    return p == null ? null : p.left;
}
function rightOf(p) {
    return p == null ? null : p.right;
}
class TreeMap extends (0, _sortedMapJsDefault.default) {
    constructor(){
        super();
        this.root_ = null;
        this.size_ = 0;
    }
    get(key) {
        let p = this.root_;
        while(p !== null){
            const cmp = key.compareTo(p.key);
            if (cmp < 0) p = p.left;
            else if (cmp > 0) p = p.right;
            else return p.value;
        }
        return null;
    }
    put(key, value) {
        if (this.root_ === null) {
            this.root_ = {
                key: key,
                value: value,
                left: null,
                right: null,
                parent: null,
                color: BLACK,
                getValue () {
                    return this.value;
                },
                getKey () {
                    return this.key;
                }
            };
            this.size_ = 1;
            return null;
        }
        let t = this.root_;
        let parent;
        let cmp;
        do {
            parent = t;
            cmp = key.compareTo(t.key);
            if (cmp < 0) t = t.left;
            else if (cmp > 0) t = t.right;
            else {
                const oldValue = t.value;
                t.value = value;
                return oldValue;
            }
        }while (t !== null);
        const e = {
            key: key,
            left: null,
            right: null,
            value: value,
            parent: parent,
            color: BLACK,
            getValue () {
                return this.value;
            },
            getKey () {
                return this.key;
            }
        };
        if (cmp < 0) parent.left = e;
        else parent.right = e;
        this.fixAfterInsertion(e);
        this.size_++;
        return null;
    }
    /**
   * @param {Object} x
   */ fixAfterInsertion(x) {
        let y;
        x.color = RED;
        while(x != null && x !== this.root_ && x.parent.color === RED)if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {
            y = rightOf(parentOf(parentOf(x)));
            if (colorOf(y) === RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x === rightOf(parentOf(x))) {
                    x = parentOf(x);
                    this.rotateLeft(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                this.rotateRight(parentOf(parentOf(x)));
            }
        } else {
            y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) === RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x === leftOf(parentOf(x))) {
                    x = parentOf(x);
                    this.rotateRight(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                this.rotateLeft(parentOf(parentOf(x)));
            }
        }
        this.root_.color = BLACK;
    }
    values() {
        const arrayList = new (0, _arrayListJsDefault.default)();
        let p = this.getFirstEntry();
        if (p !== null) {
            arrayList.add(p.value);
            while((p = TreeMap.successor(p)) !== null)arrayList.add(p.value);
        }
        return arrayList;
    }
    entrySet() {
        const hashSet = new (0, _hashSetJsDefault.default)();
        let p = this.getFirstEntry();
        if (p !== null) {
            hashSet.add(p);
            while((p = TreeMap.successor(p)) !== null)hashSet.add(p);
        }
        return hashSet;
    }
    /**
   * @param {Object} p
   */ rotateLeft(p) {
        if (p != null) {
            const r = p.right;
            p.right = r.left;
            if (r.left != null) r.left.parent = p;
            r.parent = p.parent;
            if (p.parent == null) this.root_ = r;
            else if (p.parent.left === p) p.parent.left = r;
            else p.parent.right = r;
            r.left = p;
            p.parent = r;
        }
    }
    /**
   * @param {Object} p
   */ rotateRight(p) {
        if (p != null) {
            const l = p.left;
            p.left = l.right;
            if (l.right != null) l.right.parent = p;
            l.parent = p.parent;
            if (p.parent == null) this.root_ = l;
            else if (p.parent.right === p) p.parent.right = l;
            else p.parent.left = l;
            l.right = p;
            p.parent = l;
        }
    }
    /**
   * @return {Object}
   */ getFirstEntry() {
        let p = this.root_;
        if (p != null) while(p.left != null)p = p.left;
        return p;
    }
    /**
   * @param {Object} t
   * @return {Object}
   * @private
   */ static successor(t) {
        let p;
        if (t === null) return null;
        else if (t.right !== null) {
            p = t.right;
            while(p.left !== null)p = p.left;
            return p;
        } else {
            p = t.parent;
            let ch = t;
            while(p !== null && ch === p.right){
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }
    size() {
        return this.size_;
    }
    containsKey(key) {
        let p = this.root_;
        while(p !== null){
            const cmp = key.compareTo(p.key);
            if (cmp < 0) p = p.left;
            else if (cmp > 0) p = p.right;
            else return true;
        }
        return false;
    }
}
exports.default = TreeMap;

},{"./ArrayList.js":"g8omH","./SortedMap.js":"hljOk","./HashSet.js":"cNQO2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hljOk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapJs = require("./Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
class SortedMap extends (0, _mapJsDefault.default) {
}
exports.default = SortedMap;

},{"./Map.js":"aMj1H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4v1Qe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _stringBufferJs = require("../../../../java/lang/StringBuffer.js");
var _stringBufferJsDefault = parcelHelpers.interopDefault(_stringBufferJs);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _topologyExceptionJs = require("../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _simplePointInAreaLocatorJs = require("../algorithm/locate/SimplePointInAreaLocator.js");
var _simplePointInAreaLocatorJsDefault = parcelHelpers.interopDefault(_simplePointInAreaLocatorJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _treeMapJs = require("../../../../java/util/TreeMap.js");
var _treeMapJsDefault = parcelHelpers.interopDefault(_treeMapJs);
class EdgeEndStar {
    constructor(){
        EdgeEndStar.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._edgeMap = new (0, _treeMapJsDefault.default)();
        this._edgeList = null;
        this._ptInAreaLocation = [
            (0, _locationJsDefault.default).NONE,
            (0, _locationJsDefault.default).NONE
        ];
    }
    getNextCW(ee) {
        this.getEdges();
        const i = this._edgeList.indexOf(ee);
        let iNextCW = i - 1;
        if (i === 0) iNextCW = this._edgeList.size() - 1;
        return this._edgeList.get(iNextCW);
    }
    propagateSideLabels(geomIndex) {
        let startLoc = (0, _locationJsDefault.default).NONE;
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            if (label.isArea(geomIndex) && label.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT) !== (0, _locationJsDefault.default).NONE) startLoc = label.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT);
        }
        if (startLoc === (0, _locationJsDefault.default).NONE) return null;
        let currLoc = startLoc;
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            if (label.getLocation(geomIndex, (0, _positionJsDefault.default).ON) === (0, _locationJsDefault.default).NONE) label.setLocation(geomIndex, (0, _positionJsDefault.default).ON, currLoc);
            if (label.isArea(geomIndex)) {
                const leftLoc = label.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT);
                const rightLoc = label.getLocation(geomIndex, (0, _positionJsDefault.default).RIGHT);
                if (rightLoc !== (0, _locationJsDefault.default).NONE) {
                    if (rightLoc !== currLoc) throw new (0, _topologyExceptionJsDefault.default)('side location conflict', e.getCoordinate());
                    if (leftLoc === (0, _locationJsDefault.default).NONE) (0, _assertJsDefault.default).shouldNeverReachHere('found single null side (at ' + e.getCoordinate() + ')');
                    currLoc = leftLoc;
                } else {
                    (0, _assertJsDefault.default).isTrue(label.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT) === (0, _locationJsDefault.default).NONE, 'found single null side');
                    label.setLocation(geomIndex, (0, _positionJsDefault.default).RIGHT, currLoc);
                    label.setLocation(geomIndex, (0, _positionJsDefault.default).LEFT, currLoc);
                }
            }
        }
    }
    getCoordinate() {
        const it = this.iterator();
        if (!it.hasNext()) return null;
        const e = it.next();
        return e.getCoordinate();
    }
    checkAreaLabelsConsistent(geomIndex) {
        const edges = this.getEdges();
        if (edges.size() <= 0) return true;
        const lastEdgeIndex = edges.size() - 1;
        const startLabel = edges.get(lastEdgeIndex).getLabel();
        const startLoc = startLabel.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT);
        (0, _assertJsDefault.default).isTrue(startLoc !== (0, _locationJsDefault.default).NONE, 'Found unlabelled area edge');
        let currLoc = startLoc;
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            (0, _assertJsDefault.default).isTrue(label.isArea(geomIndex), 'Found non-area edge');
            const leftLoc = label.getLocation(geomIndex, (0, _positionJsDefault.default).LEFT);
            const rightLoc = label.getLocation(geomIndex, (0, _positionJsDefault.default).RIGHT);
            if (leftLoc === rightLoc) return false;
            if (rightLoc !== currLoc) return false;
            currLoc = leftLoc;
        }
        return true;
    }
    findIndex(eSearch) {
        this.iterator();
        for(let i = 0; i < this._edgeList.size(); i++){
            const e = this._edgeList.get(i);
            if (e === eSearch) return i;
        }
        return -1;
    }
    iterator() {
        return this.getEdges().iterator();
    }
    getEdges() {
        if (this._edgeList === null) this._edgeList = new (0, _arrayListJsDefault.default)(this._edgeMap.values());
        return this._edgeList;
    }
    getLocation(geomIndex, p, geom) {
        if (this._ptInAreaLocation[geomIndex] === (0, _locationJsDefault.default).NONE) this._ptInAreaLocation[geomIndex] = (0, _simplePointInAreaLocatorJsDefault.default).locate(p, geom[geomIndex].getGeometry());
        return this._ptInAreaLocation[geomIndex];
    }
    toString() {
        const buf = new (0, _stringBufferJsDefault.default)();
        buf.append('EdgeEndStar:   ' + this.getCoordinate());
        buf.append('\n');
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            buf.append(e);
            buf.append('\n');
        }
        return buf.toString();
    }
    computeEdgeEndLabels(boundaryNodeRule) {
        for(let it = this.iterator(); it.hasNext();){
            const ee = it.next();
            ee.computeLabel(boundaryNodeRule);
        }
    }
    computeLabelling(geomGraph) {
        this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());
        this.propagateSideLabels(0);
        this.propagateSideLabels(1);
        const hasDimensionalCollapseEdge = [
            false,
            false
        ];
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            for(let geomi = 0; geomi < 2; geomi++)if (label.isLine(geomi) && label.getLocation(geomi) === (0, _locationJsDefault.default).BOUNDARY) hasDimensionalCollapseEdge[geomi] = true;
        }
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            for(let geomi = 0; geomi < 2; geomi++)if (label.isAnyNull(geomi)) {
                let loc = (0, _locationJsDefault.default).NONE;
                if (hasDimensionalCollapseEdge[geomi]) loc = (0, _locationJsDefault.default).EXTERIOR;
                else {
                    const p = e.getCoordinate();
                    loc = this.getLocation(geomi, p, geomGraph);
                }
                label.setAllLocationsIfNull(geomi, loc);
            }
        }
    }
    getDegree() {
        return this._edgeMap.size();
    }
    insertEdgeEnd(e, obj) {
        this._edgeMap.put(e, obj);
        this._edgeList = null;
    }
    print(out) {
        (0, _systemJsDefault.default).out.println('EdgeEndStar:   ' + this.getCoordinate());
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            e.print(out);
        }
    }
    isAreaLabelsConsistent(geomGraph) {
        this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());
        return this.checkAreaLabelsConsistent(0);
    }
}
exports.default = EdgeEndStar;

},{"../../../../java/lang/StringBuffer.js":"lJQsM","../geom/Location.js":"71R1B","./Position.js":"929cL","../geom/TopologyException.js":"cGr97","../../../../java/lang/System.js":"11VqP","../algorithm/locate/SimplePointInAreaLocator.js":"cLho6","../../../../java/util/ArrayList.js":"g8omH","../util/Assert.js":"ePbcB","../../../../java/util/TreeMap.js":"3VPI6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cGr97":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _runtimeExceptionJs = require("../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
class TopologyException extends (0, _runtimeExceptionJsDefault.default) {
    constructor(msg, pt){
        super(pt ? msg + ' [ ' + pt + ' ]' : msg);
        this.pt = pt ? new (0, _coordinateJsDefault.default)(pt) : undefined;
        this.name = Object.keys({
            TopologyException
        })[0];
    }
    getCoordinate() {
        return this.pt;
    }
}
exports.default = TopologyException;

},{"./Coordinate.js":"3REUb","../../../../java/lang/RuntimeException.js":"1sBnT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cLho6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _polygonJs = require("../../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _pointLocationJs = require("../PointLocation.js");
var _pointLocationJsDefault = parcelHelpers.interopDefault(_pointLocationJs);
var _pointOnGeometryLocatorJs = require("./PointOnGeometryLocator.js");
var _pointOnGeometryLocatorJsDefault = parcelHelpers.interopDefault(_pointOnGeometryLocatorJs);
var _geometryCollectionIteratorJs = require("../../geom/GeometryCollectionIterator.js");
var _geometryCollectionIteratorJsDefault = parcelHelpers.interopDefault(_geometryCollectionIteratorJs);
var _geometryCollectionJs = require("../../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
class SimplePointInAreaLocator {
    constructor(){
        SimplePointInAreaLocator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geom = null;
        const geom = arguments[0];
        this._geom = geom;
    }
    static locatePointInPolygon(p, poly) {
        if (poly.isEmpty()) return (0, _locationJsDefault.default).EXTERIOR;
        const shell = poly.getExteriorRing();
        const shellLoc = SimplePointInAreaLocator.locatePointInRing(p, shell);
        if (shellLoc !== (0, _locationJsDefault.default).INTERIOR) return shellLoc;
        for(let i = 0; i < poly.getNumInteriorRing(); i++){
            const hole = poly.getInteriorRingN(i);
            const holeLoc = SimplePointInAreaLocator.locatePointInRing(p, hole);
            if (holeLoc === (0, _locationJsDefault.default).BOUNDARY) return (0, _locationJsDefault.default).BOUNDARY;
            if (holeLoc === (0, _locationJsDefault.default).INTERIOR) return (0, _locationJsDefault.default).EXTERIOR;
        }
        return (0, _locationJsDefault.default).INTERIOR;
    }
    static locatePointInRing(p, ring) {
        if (!ring.getEnvelopeInternal().intersects(p)) return (0, _locationJsDefault.default).EXTERIOR;
        return (0, _pointLocationJsDefault.default).locateInRing(p, ring.getCoordinates());
    }
    static isContained(p, geom) {
        return (0, _locationJsDefault.default).EXTERIOR !== SimplePointInAreaLocator.locate(p, geom);
    }
    static locate(p, geom) {
        if (geom.isEmpty()) return (0, _locationJsDefault.default).EXTERIOR;
        if (!geom.getEnvelopeInternal().intersects(p)) return (0, _locationJsDefault.default).EXTERIOR;
        return SimplePointInAreaLocator.locateInGeometry(p, geom);
    }
    static containsPointInPolygon(p, poly) {
        return (0, _locationJsDefault.default).EXTERIOR !== SimplePointInAreaLocator.locatePointInPolygon(p, poly);
    }
    static locateInGeometry(p, geom) {
        if (geom instanceof (0, _polygonJsDefault.default)) return SimplePointInAreaLocator.locatePointInPolygon(p, geom);
        if (geom instanceof (0, _geometryCollectionJsDefault.default)) {
            const geomi = new (0, _geometryCollectionIteratorJsDefault.default)(geom);
            while(geomi.hasNext()){
                const g2 = geomi.next();
                if (g2 !== geom) {
                    const loc = SimplePointInAreaLocator.locateInGeometry(p, g2);
                    if (loc !== (0, _locationJsDefault.default).EXTERIOR) return loc;
                }
            }
        }
        return (0, _locationJsDefault.default).EXTERIOR;
    }
    locate(p) {
        return SimplePointInAreaLocator.locate(p, this._geom);
    }
    get interfaces_() {
        return [
            (0, _pointOnGeometryLocatorJsDefault.default)
        ];
    }
}
exports.default = SimplePointInAreaLocator;

},{"../../geom/Location.js":"71R1B","../../geom/Polygon.js":"jawWe","../PointLocation.js":"3XiEk","./PointOnGeometryLocator.js":"fAKcZ","../../geom/GeometryCollectionIterator.js":"303Gx","../../geom/GeometryCollection.js":"9xeCT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3XiEk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _coordinateSequenceJs = require("../geom/CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
var _robustLineIntersectorJs = require("./RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _rayCrossingCounterJs = require("./RayCrossingCounter.js");
var _rayCrossingCounterJsDefault = parcelHelpers.interopDefault(_rayCrossingCounterJs);
class PointLocation {
    static isInRing(p, ring) {
        return PointLocation.locateInRing(p, ring) !== (0, _locationJsDefault.default).EXTERIOR;
    }
    static locateInRing(p, ring) {
        return (0, _rayCrossingCounterJsDefault.default).locatePointInRing(p, ring);
    }
    static isOnLine() {
        if (arguments[0] instanceof (0, _coordinateJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _coordinateSequenceJsDefault.default))) {
            const p = arguments[0], line = arguments[1];
            const lineIntersector = new (0, _robustLineIntersectorJsDefault.default)();
            const p0 = new (0, _coordinateJsDefault.default)();
            const p1 = new (0, _coordinateJsDefault.default)();
            const n = line.size();
            for(let i = 1; i < n; i++){
                line.getCoordinate(i - 1, p0);
                line.getCoordinate(i, p1);
                lineIntersector.computeIntersection(p, p0, p1);
                if (lineIntersector.hasIntersection()) return true;
            }
            return false;
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof Array) {
            const p = arguments[0], line = arguments[1];
            const lineIntersector = new (0, _robustLineIntersectorJsDefault.default)();
            for(let i = 1; i < line.length; i++){
                const p0 = line[i - 1];
                const p1 = line[i];
                lineIntersector.computeIntersection(p, p0, p1);
                if (lineIntersector.hasIntersection()) return true;
            }
            return false;
        }
    }
}
exports.default = PointLocation;

},{"../geom/Location.js":"71R1B","../../../../hasInterface.js":"d8mIo","../geom/Coordinate.js":"3REUb","../geom/CoordinateSequence.js":"3GfKT","./RobustLineIntersector.js":"fBBRl","./RayCrossingCounter.js":"hPHJC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fBBRl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _envelopeJs = require("../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _orientationJs = require("./Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _intersectionJs = require("./Intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
var _cgalgorithmsDDJs = require("./CGAlgorithmsDD.js");
var _cgalgorithmsDDJsDefault = parcelHelpers.interopDefault(_cgalgorithmsDDJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _distanceJs = require("./Distance.js");
var _distanceJsDefault = parcelHelpers.interopDefault(_distanceJs);
var _lineIntersectorJs = require("./LineIntersector.js");
var _lineIntersectorJsDefault = parcelHelpers.interopDefault(_lineIntersectorJs);
class RobustLineIntersector extends (0, _lineIntersectorJsDefault.default) {
    constructor(){
        super();
    }
    static nearestEndpoint(p1, p2, q1, q2) {
        let nearestPt = p1;
        let minDist = (0, _distanceJsDefault.default).pointToSegment(p1, q1, q2);
        let dist = (0, _distanceJsDefault.default).pointToSegment(p2, q1, q2);
        if (dist < minDist) {
            minDist = dist;
            nearestPt = p2;
        }
        dist = (0, _distanceJsDefault.default).pointToSegment(q1, p1, p2);
        if (dist < minDist) {
            minDist = dist;
            nearestPt = q1;
        }
        dist = (0, _distanceJsDefault.default).pointToSegment(q2, p1, p2);
        if (dist < minDist) {
            minDist = dist;
            nearestPt = q2;
        }
        return nearestPt;
    }
    isInSegmentEnvelopes(intPt) {
        const env0 = new (0, _envelopeJsDefault.default)(this._inputLines[0][0], this._inputLines[0][1]);
        const env1 = new (0, _envelopeJsDefault.default)(this._inputLines[1][0], this._inputLines[1][1]);
        return env0.contains(intPt) && env1.contains(intPt);
    }
    computeIntersection() {
        if (arguments.length === 3) {
            const p = arguments[0], p1 = arguments[1], p2 = arguments[2];
            this._isProper = false;
            if ((0, _envelopeJsDefault.default).intersects(p1, p2, p)) {
                if ((0, _orientationJsDefault.default).index(p1, p2, p) === 0 && (0, _orientationJsDefault.default).index(p2, p1, p) === 0) {
                    this._isProper = true;
                    if (p.equals(p1) || p.equals(p2)) this._isProper = false;
                    this._result = (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION;
                    return null;
                }
            }
            this._result = (0, _lineIntersectorJsDefault.default).NO_INTERSECTION;
        } else return super.computeIntersection.apply(this, arguments);
    }
    intersection(p1, p2, q1, q2) {
        let intPt = this.intersectionSafe(p1, p2, q1, q2);
        if (!this.isInSegmentEnvelopes(intPt)) intPt = new (0, _coordinateJsDefault.default)(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));
        if (this._precisionModel !== null) this._precisionModel.makePrecise(intPt);
        return intPt;
    }
    checkDD(p1, p2, q1, q2, intPt) {
        const intPtDD = (0, _cgalgorithmsDDJsDefault.default).intersection(p1, p2, q1, q2);
        const isIn = this.isInSegmentEnvelopes(intPtDD);
        (0, _systemJsDefault.default).out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);
        if (intPt.distance(intPtDD) > 0.0001) (0, _systemJsDefault.default).out.println('Distance = ' + intPt.distance(intPtDD));
    }
    intersectionSafe(p1, p2, q1, q2) {
        let intPt = (0, _intersectionJsDefault.default).intersection(p1, p2, q1, q2);
        if (intPt === null) intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);
        return intPt;
    }
    computeCollinearIntersection(p1, p2, q1, q2) {
        const p1q1p2 = (0, _envelopeJsDefault.default).intersects(p1, p2, q1);
        const p1q2p2 = (0, _envelopeJsDefault.default).intersects(p1, p2, q2);
        const q1p1q2 = (0, _envelopeJsDefault.default).intersects(q1, q2, p1);
        const q1p2q2 = (0, _envelopeJsDefault.default).intersects(q1, q2, p2);
        if (p1q1p2 && p1q2p2) {
            this._intPt[0] = q1;
            this._intPt[1] = q2;
            return (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        if (q1p1q2 && q1p2q2) {
            this._intPt[0] = p1;
            this._intPt[1] = p2;
            return (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        if (p1q1p2 && q1p1q2) {
            this._intPt[0] = q1;
            this._intPt[1] = p1;
            return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION : (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        if (p1q1p2 && q1p2q2) {
            this._intPt[0] = q1;
            this._intPt[1] = p2;
            return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION : (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        if (p1q2p2 && q1p1q2) {
            this._intPt[0] = q2;
            this._intPt[1] = p1;
            return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION : (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        if (p1q2p2 && q1p2q2) {
            this._intPt[0] = q2;
            this._intPt[1] = p2;
            return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION : (0, _lineIntersectorJsDefault.default).COLLINEAR_INTERSECTION;
        }
        return (0, _lineIntersectorJsDefault.default).NO_INTERSECTION;
    }
    computeIntersect(p1, p2, q1, q2) {
        this._isProper = false;
        if (!(0, _envelopeJsDefault.default).intersects(p1, p2, q1, q2)) return (0, _lineIntersectorJsDefault.default).NO_INTERSECTION;
        const Pq1 = (0, _orientationJsDefault.default).index(p1, p2, q1);
        const Pq2 = (0, _orientationJsDefault.default).index(p1, p2, q2);
        if (Pq1 > 0 && Pq2 > 0 || Pq1 < 0 && Pq2 < 0) return (0, _lineIntersectorJsDefault.default).NO_INTERSECTION;
        const Qp1 = (0, _orientationJsDefault.default).index(q1, q2, p1);
        const Qp2 = (0, _orientationJsDefault.default).index(q1, q2, p2);
        if (Qp1 > 0 && Qp2 > 0 || Qp1 < 0 && Qp2 < 0) return (0, _lineIntersectorJsDefault.default).NO_INTERSECTION;
        const collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;
        if (collinear) return this.computeCollinearIntersection(p1, p2, q1, q2);
        if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {
            this._isProper = false;
            if (p1.equals2D(q1) || p1.equals2D(q2)) this._intPt[0] = p1;
            else if (p2.equals2D(q1) || p2.equals2D(q2)) this._intPt[0] = p2;
            else if (Pq1 === 0) this._intPt[0] = new (0, _coordinateJsDefault.default)(q1);
            else if (Pq2 === 0) this._intPt[0] = new (0, _coordinateJsDefault.default)(q2);
            else if (Qp1 === 0) this._intPt[0] = new (0, _coordinateJsDefault.default)(p1);
            else if (Qp2 === 0) this._intPt[0] = new (0, _coordinateJsDefault.default)(p2);
        } else {
            this._isProper = true;
            this._intPt[0] = this.intersection(p1, p2, q1, q2);
        }
        return (0, _lineIntersectorJsDefault.default).POINT_INTERSECTION;
    }
}
exports.default = RobustLineIntersector;

},{"../geom/Coordinate.js":"3REUb","../geom/Envelope.js":"ha5UZ","./Orientation.js":"QDWSa","./Intersection.js":"46jkJ","./CGAlgorithmsDD.js":"3tMI9","../../../../java/lang/System.js":"11VqP","./Distance.js":"gNNl0","./LineIntersector.js":"hxqwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"46jkJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
class Intersection {
    static intersection(p1, p2, q1, q2) {
        const minX0 = p1.x < p2.x ? p1.x : p2.x;
        const minY0 = p1.y < p2.y ? p1.y : p2.y;
        const maxX0 = p1.x > p2.x ? p1.x : p2.x;
        const maxY0 = p1.y > p2.y ? p1.y : p2.y;
        const minX1 = q1.x < q2.x ? q1.x : q2.x;
        const minY1 = q1.y < q2.y ? q1.y : q2.y;
        const maxX1 = q1.x > q2.x ? q1.x : q2.x;
        const maxY1 = q1.y > q2.y ? q1.y : q2.y;
        const intMinX = minX0 > minX1 ? minX0 : minX1;
        const intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;
        const intMinY = minY0 > minY1 ? minY0 : minY1;
        const intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;
        const midx = (intMinX + intMaxX) / 2.0;
        const midy = (intMinY + intMaxY) / 2.0;
        const p1x = p1.x - midx;
        const p1y = p1.y - midy;
        const p2x = p2.x - midx;
        const p2y = p2.y - midy;
        const q1x = q1.x - midx;
        const q1y = q1.y - midy;
        const q2x = q2.x - midx;
        const q2y = q2.y - midy;
        const px = p1y - p2y;
        const py = p2x - p1x;
        const pw = p1x * p2y - p2x * p1y;
        const qx = q1y - q2y;
        const qy = q2x - q1x;
        const qw = q1x * q2y - q2x * q1y;
        const x = py * qw - qy * pw;
        const y = qx * pw - px * qw;
        const w = px * qy - qx * py;
        const xInt = x / w;
        const yInt = y / w;
        if ((0, _doubleJsDefault.default).isNaN(xInt) || (0, _doubleJsDefault.default).isInfinite(xInt) || (0, _doubleJsDefault.default).isNaN(yInt) || (0, _doubleJsDefault.default).isInfinite(yInt)) return null;
        return new (0, _coordinateJsDefault.default)(xInt + midx, yInt + midy);
    }
}
exports.default = Intersection;

},{"../geom/Coordinate.js":"3REUb","../../../../java/lang/Double.js":"jCc26","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gNNl0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _mathUtilJs = require("../math/MathUtil.js");
var _mathUtilJsDefault = parcelHelpers.interopDefault(_mathUtilJs);
var _envelopeJs = require("../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class Distance {
    static pointToSegmentString(p, line) {
        if (line.length === 0) throw new (0, _illegalArgumentExceptionJsDefault.default)('Line array must contain at least one vertex');
        let minDistance = p.distance(line[0]);
        for(let i = 0; i < line.length - 1; i++){
            const dist = Distance.pointToSegment(p, line[i], line[i + 1]);
            if (dist < minDistance) minDistance = dist;
        }
        return minDistance;
    }
    static segmentToSegment(A, B, C, D) {
        if (A.equals(B)) return Distance.pointToSegment(A, C, D);
        if (C.equals(D)) return Distance.pointToSegment(D, A, B);
        let noIntersection = false;
        if (!(0, _envelopeJsDefault.default).intersects(A, B, C, D)) noIntersection = true;
        else {
            const denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
            if (denom === 0) noIntersection = true;
            else {
                const r_num = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);
                const s_num = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);
                const s = s_num / denom;
                const r = r_num / denom;
                if (r < 0 || r > 1 || s < 0 || s > 1) noIntersection = true;
            }
        }
        if (noIntersection) return (0, _mathUtilJsDefault.default).min(Distance.pointToSegment(A, C, D), Distance.pointToSegment(B, C, D), Distance.pointToSegment(C, A, B), Distance.pointToSegment(D, A, B));
        return 0.0;
    }
    static pointToLinePerpendicular(p, A, B) {
        const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
        const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
        return Math.abs(s) * Math.sqrt(len2);
    }
    static pointToSegment(p, A, B) {
        if (A.x === B.x && A.y === B.y) return p.distance(A);
        const len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);
        const r = ((p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y)) / len2;
        if (r <= 0.0) return p.distance(A);
        if (r >= 1.0) return p.distance(B);
        const s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;
        return Math.abs(s) * Math.sqrt(len2);
    }
}
exports.default = Distance;

},{"../../../../java/lang/IllegalArgumentException.js":"1VQhm","../math/MathUtil.js":"hTgav","../geom/Envelope.js":"ha5UZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hxqwC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktwriterJs = require("../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _stringBuilderJs = require("../../../../java/lang/StringBuilder.js");
var _stringBuilderJsDefault = parcelHelpers.interopDefault(_stringBuilderJs);
class LineIntersector {
    constructor(){
        LineIntersector.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._result = null;
        this._inputLines = Array(2).fill().map(()=>Array(2));
        this._intPt = new Array(2).fill(null);
        this._intLineIndex = null;
        this._isProper = null;
        this._pa = null;
        this._pb = null;
        this._precisionModel = null;
        this._intPt[0] = new (0, _coordinateJsDefault.default)();
        this._intPt[1] = new (0, _coordinateJsDefault.default)();
        this._pa = this._intPt[0];
        this._pb = this._intPt[1];
        this._result = 0;
    }
    static nonRobustComputeEdgeDistance(p, p1, p2) {
        const dx = p.x - p1.x;
        const dy = p.y - p1.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        (0, _assertJsDefault.default).isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');
        return dist;
    }
    static computeEdgeDistance(p, p0, p1) {
        const dx = Math.abs(p1.x - p0.x);
        const dy = Math.abs(p1.y - p0.y);
        let dist = -1;
        if (p.equals(p0)) dist = 0.0;
        else if (p.equals(p1)) {
            if (dx > dy) dist = dx;
            else dist = dy;
        } else {
            const pdx = Math.abs(p.x - p0.x);
            const pdy = Math.abs(p.y - p0.y);
            if (dx > dy) dist = pdx;
            else dist = pdy;
            if (dist === 0.0 && !p.equals(p0)) dist = Math.max(pdx, pdy);
        }
        (0, _assertJsDefault.default).isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');
        return dist;
    }
    computeIntersection(p1, p2, p3, p4) {
        this._inputLines[0][0] = p1;
        this._inputLines[0][1] = p2;
        this._inputLines[1][0] = p3;
        this._inputLines[1][1] = p4;
        this._result = this.computeIntersect(p1, p2, p3, p4);
    }
    getIntersectionNum() {
        return this._result;
    }
    computeIntLineIndex() {
        if (arguments.length === 0) {
            if (this._intLineIndex === null) {
                this._intLineIndex = Array(2).fill().map(()=>Array(2));
                this.computeIntLineIndex(0);
                this.computeIntLineIndex(1);
            }
        } else if (arguments.length === 1) {
            const segmentIndex = arguments[0];
            const dist0 = this.getEdgeDistance(segmentIndex, 0);
            const dist1 = this.getEdgeDistance(segmentIndex, 1);
            if (dist0 > dist1) {
                this._intLineIndex[segmentIndex][0] = 0;
                this._intLineIndex[segmentIndex][1] = 1;
            } else {
                this._intLineIndex[segmentIndex][0] = 1;
                this._intLineIndex[segmentIndex][1] = 0;
            }
        }
    }
    isInteriorIntersection() {
        if (arguments.length === 0) {
            if (this.isInteriorIntersection(0)) return true;
            if (this.isInteriorIntersection(1)) return true;
            return false;
        } else if (arguments.length === 1) {
            const inputLineIndex = arguments[0];
            for(let i = 0; i < this._result; i++)if (!(this._intPt[i].equals2D(this._inputLines[inputLineIndex][0]) || this._intPt[i].equals2D(this._inputLines[inputLineIndex][1]))) return true;
            return false;
        }
    }
    getIntersection(intIndex) {
        return this._intPt[intIndex];
    }
    getEdgeDistance(segmentIndex, intIndex) {
        const dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);
        return dist;
    }
    isCollinear() {
        return this._result === LineIntersector.COLLINEAR_INTERSECTION;
    }
    toString() {
        return (0, _wktwriterJsDefault.default).toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + (0, _wktwriterJsDefault.default).toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
    }
    getEndpoint(segmentIndex, ptIndex) {
        return this._inputLines[segmentIndex][ptIndex];
    }
    getIndexAlongSegment(segmentIndex, intIndex) {
        this.computeIntLineIndex();
        return this._intLineIndex[segmentIndex][intIndex];
    }
    getTopologySummary() {
        const catBuilder = new (0, _stringBuilderJsDefault.default)();
        if (this.isEndPoint()) catBuilder.append(' endpoint');
        if (this._isProper) catBuilder.append(' proper');
        if (this.isCollinear()) catBuilder.append(' collinear');
        return catBuilder.toString();
    }
    isProper() {
        return this.hasIntersection() && this._isProper;
    }
    setPrecisionModel(precisionModel) {
        this._precisionModel = precisionModel;
    }
    isEndPoint() {
        return this.hasIntersection() && !this._isProper;
    }
    hasIntersection() {
        return this._result !== LineIntersector.NO_INTERSECTION;
    }
    isIntersection(pt) {
        for(let i = 0; i < this._result; i++)if (this._intPt[i].equals2D(pt)) return true;
        return false;
    }
    getIntersectionAlongSegment(segmentIndex, intIndex) {
        this.computeIntLineIndex();
        return this._intPt[this._intLineIndex[segmentIndex][intIndex]];
    }
}
exports.default = LineIntersector;
LineIntersector.DONT_INTERSECT = 0;
LineIntersector.DO_INTERSECT = 1;
LineIntersector.COLLINEAR = 2;
LineIntersector.NO_INTERSECTION = 0;
LineIntersector.POINT_INTERSECTION = 1;
LineIntersector.COLLINEAR_INTERSECTION = 2;

},{"../io/WKTWriter.js":"gvRTy","../geom/Coordinate.js":"3REUb","../util/Assert.js":"ePbcB","../../../../java/lang/StringBuilder.js":"iGg1z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gvRTy":[function(require,module,exports,__globalThis) {
/**
 * @module org/locationtech/jts/io/WKTWriter
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktparserJs = require("./WKTParser.js");
var _wktparserJsDefault = parcelHelpers.interopDefault(_wktparserJs);
class WKTWriter {
    /**
   * @param {GeometryFactory} geometryFactory
   */ constructor(geometryFactory){
        this.parser = new (0, _wktparserJsDefault.default)(geometryFactory);
    }
    /**
   * Converts a <code>Geometry</code> to its Well-known Text representation.
   *
   * @param {Geometry} geometry a <code>Geometry</code> to process.
   * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple
   *         Features Specification).
   * @memberof module:org/locationtech/jts/io/WKTWriter#
   */ write(geometry) {
        return this.parser.write(geometry);
    }
    /**
   * Generates the WKT for a <tt>LINESTRING</tt> specified by two
   * {@link Coordinate}s.
   *
   * @param p0 the first coordinate.
   * @param p1 the second coordinate.
   *
   * @return the WKT.
   * @private
   */ static toLineString(p0, p1) {
        if (arguments.length !== 2) throw new Error('Not implemented');
        return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )';
    }
}
exports.default = WKTWriter;

},{"./WKTParser.js":"aE0c2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aE0c2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _geometryFactoryJs = require("../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */ const GeometryLayout = {
    XY: 'XY',
    XYZ: 'XYZ',
    XYM: 'XYM',
    XYZM: 'XYZM'
};
/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */ const GeometryType = {
    POINT: 'Point',
    LINE_STRING: 'LineString',
    LINEAR_RING: 'LinearRing',
    POLYGON: 'Polygon',
    MULTI_POINT: 'MultiPoint',
    MULTI_LINE_STRING: 'MultiLineString',
    MULTI_POLYGON: 'MultiPolygon',
    GEOMETRY_COLLECTION: 'GeometryCollection',
    CIRCLE: 'Circle'
};
/**
 * @typedef {Object} Options
 * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into
 * multiple features on reading.
 */ /**
 * @typedef {Object} Token
 * @property {number} type
 * @property {number|string} [value]
 * @property {number} position
 */ /**
 * @const
 * @type {string}
 */ const EMPTY = 'EMPTY';
/**
 * @const
 * @type {string}
 */ const Z = 'Z';
/**
 * @const
 * @type {string}
 */ const M = 'M';
/**
 * @const
 * @type {string}
 */ const ZM = 'ZM';
/**
 * @const
 * @enum {number}
 */ const TokenType = {
    TEXT: 1,
    LEFT_PAREN: 2,
    RIGHT_PAREN: 3,
    NUMBER: 4,
    COMMA: 5,
    EOF: 6
};
/**
 * @const
 * @type {Object<string, string>}
 */ const WKTGeometryType = {};
for(const type in GeometryType)WKTGeometryType[type] = GeometryType[type].toUpperCase();
/**
 * Class to tokenize a WKT string.
 */ class Lexer {
    /**
   * @param {string} wkt WKT string.
   */ constructor(wkt){
        /**
     * @type {string}
     */ this.wkt = wkt;
        /**
     * @type {number}
     * @private
     */ this.index_ = -1;
    }
    /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is alphabetic.
   * @private
   */ isAlpha_(c) {
        return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
    }
    /**
   * @param {string} c Character.
   * @param {boolean=} opt_decimal Whether the string number
   *     contains a dot, i.e. is a decimal number.
   * @return {boolean} Whether the character is numeric.
   * @private
   */ isNumeric_(c, opt_decimal) {
        const decimal = opt_decimal !== undefined ? opt_decimal : false;
        return c >= '0' && c <= '9' || c == '.' && !decimal;
    }
    /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is whitespace.
   * @private
   */ isWhiteSpace_(c) {
        return c == ' ' || c == '\t' || c == '\r' || c == '\n';
    }
    /**
   * @return {string} Next string character.
   * @private
   */ nextChar_() {
        return this.wkt.charAt(++this.index_);
    }
    /**
   * Fetch and return the next token.
   * @return {!Token} Next string token.
   */ nextToken() {
        const c = this.nextChar_();
        const position = this.index_;
        /** @type {number|string} */ let value = c;
        let type;
        if (c == '(') type = TokenType.LEFT_PAREN;
        else if (c == ',') type = TokenType.COMMA;
        else if (c == ')') type = TokenType.RIGHT_PAREN;
        else if (this.isNumeric_(c) || c == '-') {
            type = TokenType.NUMBER;
            value = this.readNumber_();
        } else if (this.isAlpha_(c)) {
            type = TokenType.TEXT;
            value = this.readText_();
        } else if (this.isWhiteSpace_(c)) return this.nextToken();
        else if (c === '') type = TokenType.EOF;
        else throw new Error('Unexpected character: ' + c);
        return {
            position: position,
            value: value,
            type: type
        };
    }
    /**
   * @return {number} Numeric token value.
   * @private
   */ readNumber_() {
        let c;
        const index = this.index_;
        let decimal = false;
        let scientificNotation = false;
        do {
            if (c == '.') decimal = true;
            else if (c == 'e' || c == 'E') scientificNotation = true;
            c = this.nextChar_();
        }while (this.isNumeric_(c, decimal) || // if we haven't detected a scientific number before, 'e' or 'E'
        // hint that we should continue to read
        !scientificNotation && (c == 'e' || c == 'E') || // once we know that we have a scientific number, both '-' and '+'
        // are allowed
        scientificNotation && (c == '-' || c == '+'));
        return parseFloat(this.wkt.substring(index, this.index_--));
    }
    /**
   * @return {string} String token value.
   * @private
   */ readText_() {
        let c;
        const index = this.index_;
        do c = this.nextChar_();
        while (this.isAlpha_(c));
        return this.wkt.substring(index, this.index_--).toUpperCase();
    }
}
/**
 * Class to parse the tokens from the WKT string.
 */ class Parser {
    /**
   * @param {Lexer} lexer The lexer.
   */ constructor(lexer, factory){
        /**
     * @type {Lexer}
     * @private
     */ this.lexer_ = lexer;
        /**
     * @type {Token}
     * @private
     */ this.token_;
        /**
     * @type {import("../geom/GeometryLayout.js").default}
     * @private
     */ this.layout_ = GeometryLayout.XY;
        this.factory = factory;
    }
    /**
   * Fetch the next token form the lexer and replace the active token.
   * @private
   */ consume_() {
        this.token_ = this.lexer_.nextToken();
    }
    /**
   * Tests if the given type matches the type of the current token.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */ isTokenType(type) {
        const isMatch = this.token_.type == type;
        return isMatch;
    }
    /**
   * If the given type matches the current token, consume it.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */ match(type) {
        const isMatch = this.isTokenType(type);
        if (isMatch) this.consume_();
        return isMatch;
    }
    /**
   * Try to parse the tokens provided by the lexer.
   * @return {import("../geom/Geometry.js").default} The geometry.
   */ parse() {
        this.consume_();
        const geometry = this.parseGeometry_();
        return geometry;
    }
    /**
   * Try to parse the dimensional info.
   * @return {import("../geom/GeometryLayout.js").default} The layout.
   * @private
   */ parseGeometryLayout_() {
        let layout = GeometryLayout.XY;
        const dimToken = this.token_;
        if (this.isTokenType(TokenType.TEXT)) {
            const dimInfo = dimToken.value;
            if (dimInfo === Z) layout = GeometryLayout.XYZ;
            else if (dimInfo === M) layout = GeometryLayout.XYM;
            else if (dimInfo === ZM) layout = GeometryLayout.XYZM;
            if (layout !== GeometryLayout.XY) this.consume_();
        }
        return layout;
    }
    /**
   * @return {!Array<import("../geom/Geometry.js").default>} A collection of geometries.
   * @private
   */ parseGeometryCollectionText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const geometries = [];
            do geometries.push(this.parseGeometry_());
            while (this.match(TokenType.COMMA));
            if (this.match(TokenType.RIGHT_PAREN)) return geometries;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {Array<number>} All values in a point.
   * @private
   */ parsePointText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const coordinates = this.parsePoint_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return null;
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<number>>} All points in a linestring.
   * @private
   */ parseLineStringText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const coordinates = this.parsePointList_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<!Array<number>>>} All points in a polygon.
   * @private
   */ parsePolygonText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const coordinates = this.parseLineStringTextList_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<number>>} All points in a multipoint.
   * @private
   */ parseMultiPointText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            let coordinates;
            if (this.token_.type == TokenType.LEFT_PAREN) coordinates = this.parsePointTextList_();
            else coordinates = this.parsePointList_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<!Array<number>>>} All linestring points
   *                                          in a multilinestring.
   * @private
   */ parseMultiLineStringText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const coordinates = this.parseLineStringTextList_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<!Array<!Array<number>>>>} All polygon points in a multipolygon.
   * @private
   */ parseMultiPolygonText_() {
        if (this.match(TokenType.LEFT_PAREN)) {
            const coordinates = this.parsePolygonTextList_();
            if (this.match(TokenType.RIGHT_PAREN)) return coordinates;
        } else if (this.isEmptyGeometry_()) return [];
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<number>} A point.
   * @private
   */ parsePoint_() {
        const coordinates = [];
        const dimensions = this.layout_.length;
        for(let i = 0; i < dimensions; ++i){
            const token = this.token_;
            if (this.match(TokenType.NUMBER)) coordinates.push(/** @type {number} */ token.value);
            else break;
        }
        if (coordinates.length == dimensions) return coordinates;
        throw new Error(this.formatErrorMessage_());
    }
    /**
   * @return {!Array<!Array<number>>} An array of points.
   * @private
   */ parsePointList_() {
        const coordinates = [
            this.parsePoint_()
        ];
        while(this.match(TokenType.COMMA))coordinates.push(this.parsePoint_());
        return coordinates;
    }
    /**
   * @return {!Array<!Array<number>>} An array of points.
   * @private
   */ parsePointTextList_() {
        const coordinates = [
            this.parsePointText_()
        ];
        while(this.match(TokenType.COMMA))coordinates.push(this.parsePointText_());
        return coordinates;
    }
    /**
   * @return {!Array<!Array<!Array<number>>>} An array of points.
   * @private
   */ parseLineStringTextList_() {
        const coordinates = [
            this.parseLineStringText_()
        ];
        while(this.match(TokenType.COMMA))coordinates.push(this.parseLineStringText_());
        return coordinates;
    }
    /**
   * @return {!Array<!Array<!Array<!Array<number>>>>} An array of points.
   * @private
   */ parsePolygonTextList_() {
        const coordinates = [
            this.parsePolygonText_()
        ];
        while(this.match(TokenType.COMMA))coordinates.push(this.parsePolygonText_());
        return coordinates;
    }
    /**
   * @return {boolean} Whether the token implies an empty geometry.
   * @private
   */ isEmptyGeometry_() {
        const isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;
        if (isEmpty) this.consume_();
        return isEmpty;
    }
    /**
   * Create an error message for an unexpected token error.
   * @return {string} Error message.
   * @private
   */ formatErrorMessage_() {
        return 'Unexpected `' + this.token_.value + '` at position ' + this.token_.position + ' in `' + this.lexer_.wkt + '`';
    }
    /**
   * @return {!import("../geom/Geometry.js").default} The geometry.
   * @private
   */ parseGeometry_() {
        const factory = this.factory;
        const o2c = (ordinates)=>ordinates ? new (0, _coordinateJsDefault.default)(...ordinates) : new (0, _coordinateJsDefault.default)();
        const ca2p = (coordinates)=>{
            const rings = coordinates.map((a)=>factory.createLinearRing(a.map(o2c)));
            if (rings.length > 1) return factory.createPolygon(rings[0], rings.slice(1));
            else if (rings.length === 1) return factory.createPolygon(rings[0]);
            else return factory.createPolygon();
        };
        const token = this.token_;
        if (this.match(TokenType.TEXT)) {
            const geomType = token.value;
            this.layout_ = this.parseGeometryLayout_();
            if (geomType == 'GEOMETRYCOLLECTION') {
                const geometries = this.parseGeometryCollectionText_();
                return factory.createGeometryCollection(geometries);
            } else switch(geomType){
                case 'POINT':
                    {
                        const ordinates = this.parsePointText_();
                        if (!ordinates) return factory.createPoint();
                        return factory.createPoint(new (0, _coordinateJsDefault.default)(...ordinates));
                    }
                case 'LINESTRING':
                    {
                        const coordinates = this.parseLineStringText_();
                        const components = coordinates.map(o2c);
                        return factory.createLineString(components);
                    }
                case 'LINEARRING':
                    {
                        const coordinates = this.parseLineStringText_();
                        const components = coordinates.map(o2c);
                        return factory.createLinearRing(components);
                    }
                case 'POLYGON':
                    {
                        const coordinates = this.parsePolygonText_();
                        if (!coordinates || coordinates.length === 0) return factory.createPolygon();
                        return ca2p(coordinates);
                    }
                case 'MULTIPOINT':
                    {
                        const coordinates = this.parseMultiPointText_();
                        if (!coordinates || coordinates.length === 0) return factory.createMultiPoint();
                        const components = coordinates.map(o2c).map((c)=>factory.createPoint(c));
                        return factory.createMultiPoint(components);
                    }
                case 'MULTILINESTRING':
                    {
                        const coordinates = this.parseMultiLineStringText_();
                        const components = coordinates.map((a)=>factory.createLineString(a.map(o2c)));
                        return factory.createMultiLineString(components);
                    }
                case 'MULTIPOLYGON':
                    {
                        const coordinates = this.parseMultiPolygonText_();
                        if (!coordinates || coordinates.length === 0) return factory.createMultiPolygon();
                        const polygons = coordinates.map(ca2p);
                        return factory.createMultiPolygon(polygons);
                    }
                default:
                    throw new Error('Invalid geometry type: ' + geomType);
            }
        }
        throw new Error(this.formatErrorMessage_());
    }
}
/**
 * @param {Point} geom Point geometry.
 * @return {string} Coordinates part of Point as WKT.
 */ function encodePointGeometry(geom) {
    if (geom.isEmpty()) return '';
    const c = geom.getCoordinate();
    const cs = [
        c.x,
        c.y
    ];
    if (c.z !== undefined && !Number.isNaN(c.z)) cs.push(c.z);
    if (c.m !== undefined && !Number.isNaN(c.m)) cs.push(c.m);
    return cs.join(' ');
}
/**
 * @param {MultiPoint} geom MultiPoint geometry.
 * @return {string} Coordinates part of MultiPoint as WKT.
 */ function encodeMultiPointGeometry(geom) {
    const array = [];
    for(let i = 0, ii = geom.getNumGeometries(); i < ii; ++i)array.push('(' + encodePointGeometry(geom.getGeometryN(i)) + ')');
    return array.join(', ');
}
/**
 * @param {GeometryCollection} geom GeometryCollection geometry.
 * @return {string} Coordinates part of GeometryCollection as WKT.
 */ function encodeGeometryCollectionGeometry(geom) {
    const array = [];
    for(let i = 0, ii = geom.getNumGeometries(); i < ii; ++i)array.push(encode(geom.getGeometryN(i)));
    return array.join(', ');
}
/**
 * @param {LineString|import("../geom/LinearRing.js").default} geom LineString geometry.
 * @return {string} Coordinates part of LineString as WKT.
 */ function encodeLineStringGeometry(geom) {
    const coordinates = geom.getCoordinates().map((c)=>{
        const a = [
            c.x,
            c.y
        ];
        if (c.z !== undefined && !Number.isNaN(c.z)) a.push(c.z);
        if (c.m !== undefined && !Number.isNaN(c.m)) a.push(c.m);
        return a;
    });
    const array = [];
    for(let i = 0, ii = coordinates.length; i < ii; ++i)array.push(coordinates[i].join(' '));
    return array.join(', ');
}
/**
 * @param {MultiLineString} geom MultiLineString geometry.
 * @return {string} Coordinates part of MultiLineString as WKT.
 */ function encodeMultiLineStringGeometry(geom) {
    const array = [];
    for(let i = 0, ii = geom.getNumGeometries(); i < ii; ++i)array.push('(' + encodeLineStringGeometry(geom.getGeometryN(i)) + ')');
    return array.join(', ');
}
/**
 * @param {Polygon} geom Polygon geometry.
 * @return {string} Coordinates part of Polygon as WKT.
 */ function encodePolygonGeometry(geom) {
    const array = [];
    array.push('(' + encodeLineStringGeometry(geom.getExteriorRing()) + ')');
    for(let i = 0, ii = geom.getNumInteriorRing(); i < ii; ++i)array.push('(' + encodeLineStringGeometry(geom.getInteriorRingN(i)) + ')');
    return array.join(', ');
}
/**
 * @param {MultiPolygon} geom MultiPolygon geometry.
 * @return {string} Coordinates part of MultiPolygon as WKT.
 */ function encodeMultiPolygonGeometry(geom) {
    const array = [];
    for(let i = 0, ii = geom.getNumGeometries(); i < ii; ++i)array.push('(' + encodePolygonGeometry(geom.getGeometryN(i)) + ')');
    return array.join(', ');
}
/**
 * @param {Geometry} geom Geometry geometry.
 * @return {string} Potential dimensional information for WKT type.
 */ function encodeGeometryLayout(geom) {
    let dimInfo = '';
    if (geom.isEmpty()) return dimInfo;
    const c = geom.getCoordinate();
    if (c.z !== undefined && !Number.isNaN(c.z)) dimInfo += Z;
    if (c.m !== undefined && !Number.isNaN(c.m)) dimInfo += M;
    return dimInfo;
}
/**
 * @const
 * @type {Object<string, function(import("../geom/Geometry.js").default): string>}
 */ const GeometryEncoder = {
    'Point': encodePointGeometry,
    'LineString': encodeLineStringGeometry,
    'LinearRing': encodeLineStringGeometry,
    'Polygon': encodePolygonGeometry,
    'MultiPoint': encodeMultiPointGeometry,
    'MultiLineString': encodeMultiLineStringGeometry,
    'MultiPolygon': encodeMultiPolygonGeometry,
    'GeometryCollection': encodeGeometryCollectionGeometry
};
/**
 * Encode a geometry as WKT.
 * @param {!import("../geom/Geometry.js").default} geom The geometry to encode.
 * @return {string} WKT string for the geometry.
 */ function encode(geom) {
    let type = geom.getGeometryType();
    const geometryEncoder = GeometryEncoder[type];
    type = type.toUpperCase();
    const dimInfo = encodeGeometryLayout(geom);
    if (dimInfo.length > 0) type += ' ' + dimInfo;
    if (geom.isEmpty()) return type + ' ' + EMPTY;
    const enc = geometryEncoder(geom);
    return type + ' (' + enc + ')';
}
class WKTParser {
    /** Create a new parser for WKT
   *
   * @param {GeometryFactory} geometryFactory
   * @return An instance of WKTParser.
   * @private
   */ constructor(geometryFactory){
        this.geometryFactory = geometryFactory || new (0, _geometryFactoryJsDefault.default)();
        this.precisionModel = this.geometryFactory.getPrecisionModel();
    }
    /**
   * Deserialize a WKT string and return a geometry. Supports WKT for POINT,
   * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,
   * and GEOMETRYCOLLECTION.
   *
   * @param {String} wkt A WKT string.
   * @return {Geometry} A geometry instance.
   * @private
   */ read(wkt) {
        const lexer = new Lexer(wkt);
        const parser = new Parser(lexer, this.geometryFactory);
        const geometry = parser.parse();
        return geometry;
    }
    /**
   * Serialize a geometry into a WKT string.
   *
   * @param {Geometry} geometry A feature or array of features.
   * @return {String} The WKT string representation of the input geometries.
   * @private
   */ write(geometry) {
        return encode(geometry);
    }
}
exports.default = WKTParser;

},{"../geom/Coordinate.js":"3REUb","../geom/GeometryFactory.js":"6Ct9y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hPHJC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _orientationJs = require("./Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _coordinateSequenceJs = require("../geom/CoordinateSequence.js");
var _coordinateSequenceJsDefault = parcelHelpers.interopDefault(_coordinateSequenceJs);
class RayCrossingCounter {
    constructor(){
        RayCrossingCounter.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._p = null;
        this._crossingCount = 0;
        this._isPointOnSegment = false;
        const p = arguments[0];
        this._p = p;
    }
    static locatePointInRing() {
        if (arguments[0] instanceof (0, _coordinateJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _coordinateSequenceJsDefault.default))) {
            const p = arguments[0], ring = arguments[1];
            const counter = new RayCrossingCounter(p);
            const p1 = new (0, _coordinateJsDefault.default)();
            const p2 = new (0, _coordinateJsDefault.default)();
            for(let i = 1; i < ring.size(); i++){
                ring.getCoordinate(i, p1);
                ring.getCoordinate(i - 1, p2);
                counter.countSegment(p1, p2);
                if (counter.isOnSegment()) return counter.getLocation();
            }
            return counter.getLocation();
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof Array) {
            const p = arguments[0], ring = arguments[1];
            const counter = new RayCrossingCounter(p);
            for(let i = 1; i < ring.length; i++){
                const p1 = ring[i];
                const p2 = ring[i - 1];
                counter.countSegment(p1, p2);
                if (counter.isOnSegment()) return counter.getLocation();
            }
            return counter.getLocation();
        }
    }
    getLocation() {
        if (this._isPointOnSegment) return (0, _locationJsDefault.default).BOUNDARY;
        if (this._crossingCount % 2 === 1) return (0, _locationJsDefault.default).INTERIOR;
        return (0, _locationJsDefault.default).EXTERIOR;
    }
    isPointInPolygon() {
        return this.getLocation() !== (0, _locationJsDefault.default).EXTERIOR;
    }
    isOnSegment() {
        return this._isPointOnSegment;
    }
    countSegment(p1, p2) {
        if (p1.x < this._p.x && p2.x < this._p.x) return null;
        if (this._p.x === p2.x && this._p.y === p2.y) {
            this._isPointOnSegment = true;
            return null;
        }
        if (p1.y === this._p.y && p2.y === this._p.y) {
            let minx = p1.x;
            let maxx = p2.x;
            if (minx > maxx) {
                minx = p2.x;
                maxx = p1.x;
            }
            if (this._p.x >= minx && this._p.x <= maxx) this._isPointOnSegment = true;
            return null;
        }
        if (p1.y > this._p.y && p2.y <= this._p.y || p2.y > this._p.y && p1.y <= this._p.y) {
            let orient = (0, _orientationJsDefault.default).index(p1, p2, this._p);
            if (orient === (0, _orientationJsDefault.default).COLLINEAR) {
                this._isPointOnSegment = true;
                return null;
            }
            if (p2.y < p1.y) orient = -orient;
            if (orient === (0, _orientationJsDefault.default).LEFT) this._crossingCount++;
        }
    }
}
exports.default = RayCrossingCounter;

},{"../geom/Location.js":"71R1B","../../../../hasInterface.js":"d8mIo","../geom/Coordinate.js":"3REUb","./Orientation.js":"QDWSa","../geom/CoordinateSequence.js":"3GfKT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fAKcZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class PointOnGeometryLocator {
    locate(p) {}
}
exports.default = PointOnGeometryLocator;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"303Gx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _iteratorJs = require("../../../../java/util/Iterator.js");
var _iteratorJsDefault = parcelHelpers.interopDefault(_iteratorJs);
var _noSuchElementExceptionJs = require("../../../../java/util/NoSuchElementException.js");
var _noSuchElementExceptionJsDefault = parcelHelpers.interopDefault(_noSuchElementExceptionJs);
var _geometryCollectionJs = require("./GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _unsupportedOperationExceptionJs = require("../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
class GeometryCollectionIterator {
    constructor(){
        GeometryCollectionIterator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._parent = null;
        this._atStart = null;
        this._max = null;
        this._index = null;
        this._subcollectionIterator = null;
        const parent = arguments[0];
        this._parent = parent;
        this._atStart = true;
        this._index = 0;
        this._max = parent.getNumGeometries();
    }
    static isAtomic(geom) {
        return !(geom instanceof (0, _geometryCollectionJsDefault.default));
    }
    next() {
        if (this._atStart) {
            this._atStart = false;
            if (GeometryCollectionIterator.isAtomic(this._parent)) this._index++;
            return this._parent;
        }
        if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
            else this._subcollectionIterator = null;
        }
        if (this._index >= this._max) throw new (0, _noSuchElementExceptionJsDefault.default)();
        const obj = this._parent.getGeometryN(this._index++);
        if (obj instanceof (0, _geometryCollectionJsDefault.default)) {
            this._subcollectionIterator = new GeometryCollectionIterator(obj);
            return this._subcollectionIterator.next();
        }
        return obj;
    }
    hasNext() {
        if (this._atStart) return true;
        if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return true;
            this._subcollectionIterator = null;
        }
        if (this._index >= this._max) return false;
        return true;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)(this.getClass().getName());
    }
    get interfaces_() {
        return [
            (0, _iteratorJsDefault.default)
        ];
    }
}
exports.default = GeometryCollectionIterator;

},{"../../../../java/util/Iterator.js":"d9RWN","../../../../java/util/NoSuchElementException.js":"1NxXp","./GeometryCollection.js":"9xeCT","../../../../java/lang/UnsupportedOperationException.js":"fEx26","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d9RWN":[function(require,module,exports,__globalThis) {
/**
 * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html
 * @constructor
 * @private
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Iterator {
    /**
     * Returns true if the iteration has more elements.
     * @return {boolean}
     */ hasNext() {}
    /**
     * Returns the next element in the iteration.
     * @return {Object}
     */ next() {}
    /**
     * Removes from the underlying collection the last element returned by the
     * iterator (optional operation).
     */ remove() {}
}
exports.default = Iterator;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3WOZk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _hashMapJs = require("../../../../java/util/HashMap.js");
var _hashMapJsDefault = parcelHelpers.interopDefault(_hashMapJs);
var _geometryJs = require("../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _simpleMCSweepLineIntersectorJs = require("./index/SimpleMCSweepLineIntersector.js");
var _simpleMCSweepLineIntersectorJsDefault = parcelHelpers.interopDefault(_simpleMCSweepLineIntersectorJs);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _coordinateArraysJs = require("../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _polygonalJs = require("../geom/Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _planarGraphJs = require("./PlanarGraph.js");
var _planarGraphJsDefault = parcelHelpers.interopDefault(_planarGraphJs);
var _pointLocatorJs = require("../algorithm/PointLocator.js");
var _pointLocatorJsDefault = parcelHelpers.interopDefault(_pointLocatorJs);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _multiPointJs = require("../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _linearRingJs = require("../geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _boundaryNodeRuleJs = require("../algorithm/BoundaryNodeRule.js");
var _boundaryNodeRuleJsDefault = parcelHelpers.interopDefault(_boundaryNodeRuleJs);
var _segmentIntersectorJs = require("./index/SegmentIntersector.js");
var _segmentIntersectorJsDefault = parcelHelpers.interopDefault(_segmentIntersectorJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _geometryCollectionJs = require("../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _unsupportedOperationExceptionJs = require("../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
var _indexedPointInAreaLocatorJs = require("../algorithm/locate/IndexedPointInAreaLocator.js");
var _indexedPointInAreaLocatorJsDefault = parcelHelpers.interopDefault(_indexedPointInAreaLocatorJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _edgeJs = require("./Edge.js");
var _edgeJsDefault = parcelHelpers.interopDefault(_edgeJs);
class GeometryGraph extends (0, _planarGraphJsDefault.default) {
    constructor(){
        super();
        GeometryGraph.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._parentGeom = null;
        this._lineEdgeMap = new (0, _hashMapJsDefault.default)();
        this._boundaryNodeRule = null;
        this._useBoundaryDeterminationRule = true;
        this._argIndex = null;
        this._boundaryNodes = null;
        this._hasTooFewPoints = false;
        this._invalidPoint = null;
        this._areaPtLocator = null;
        this._ptLocator = new (0, _pointLocatorJsDefault.default)();
        if (arguments.length === 2) {
            const argIndex = arguments[0], parentGeom = arguments[1];
            GeometryGraph.constructor_.call(this, argIndex, parentGeom, (0, _boundaryNodeRuleJsDefault.default).OGC_SFS_BOUNDARY_RULE);
        } else if (arguments.length === 3) {
            const argIndex = arguments[0], parentGeom = arguments[1], boundaryNodeRule = arguments[2];
            this._argIndex = argIndex;
            this._parentGeom = parentGeom;
            this._boundaryNodeRule = boundaryNodeRule;
            if (parentGeom !== null) this.add(parentGeom);
        }
    }
    static determineBoundary(boundaryNodeRule, boundaryCount) {
        return boundaryNodeRule.isInBoundary(boundaryCount) ? (0, _locationJsDefault.default).BOUNDARY : (0, _locationJsDefault.default).INTERIOR;
    }
    insertBoundaryPoint(argIndex, coord) {
        const n = this._nodes.addNode(coord);
        const lbl = n.getLabel();
        let boundaryCount = 1;
        let loc = (0, _locationJsDefault.default).NONE;
        loc = lbl.getLocation(argIndex, (0, _positionJsDefault.default).ON);
        if (loc === (0, _locationJsDefault.default).BOUNDARY) boundaryCount++;
        const newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);
        lbl.setLocation(argIndex, newLoc);
    }
    computeSelfNodes() {
        if (arguments.length === 2) {
            const li = arguments[0], computeRingSelfNodes = arguments[1];
            return this.computeSelfNodes(li, computeRingSelfNodes, false);
        } else if (arguments.length === 3) {
            const li = arguments[0], computeRingSelfNodes = arguments[1], isDoneIfProperInt = arguments[2];
            const si = new (0, _segmentIntersectorJsDefault.default)(li, true, false);
            si.setIsDoneIfProperInt(isDoneIfProperInt);
            const esi = this.createEdgeSetIntersector();
            const isRings = this._parentGeom instanceof (0, _linearRingJsDefault.default) || this._parentGeom instanceof (0, _polygonJsDefault.default) || this._parentGeom instanceof (0, _multiPolygonJsDefault.default);
            const computeAllSegments = computeRingSelfNodes || !isRings;
            esi.computeIntersections(this._edges, si, computeAllSegments);
            this.addSelfIntersectionNodes(this._argIndex);
            return si;
        }
    }
    addPolygon(p) {
        this.addPolygonRing(p.getExteriorRing(), (0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR);
        for(let i = 0; i < p.getNumInteriorRing(); i++){
            const hole = p.getInteriorRingN(i);
            this.addPolygonRing(hole, (0, _locationJsDefault.default).INTERIOR, (0, _locationJsDefault.default).EXTERIOR);
        }
    }
    addEdge(e) {
        this.insertEdge(e);
        const coord = e.getCoordinates();
        this.insertPoint(this._argIndex, coord[0], (0, _locationJsDefault.default).BOUNDARY);
        this.insertPoint(this._argIndex, coord[coord.length - 1], (0, _locationJsDefault.default).BOUNDARY);
    }
    addLineString(line) {
        const coord = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(line.getCoordinates());
        if (coord.length < 2) {
            this._hasTooFewPoints = true;
            this._invalidPoint = coord[0];
            return null;
        }
        const e = new (0, _edgeJsDefault.default)(coord, new (0, _labelJsDefault.default)(this._argIndex, (0, _locationJsDefault.default).INTERIOR));
        this._lineEdgeMap.put(line, e);
        this.insertEdge(e);
        (0, _assertJsDefault.default).isTrue(coord.length >= 2, 'found LineString with single point');
        this.insertBoundaryPoint(this._argIndex, coord[0]);
        this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);
    }
    getInvalidPoint() {
        return this._invalidPoint;
    }
    getBoundaryPoints() {
        const coll = this.getBoundaryNodes();
        const pts = new Array(coll.size()).fill(null);
        let i = 0;
        for(let it = coll.iterator(); it.hasNext();){
            const node = it.next();
            pts[i++] = node.getCoordinate().copy();
        }
        return pts;
    }
    addSelfIntersectionNodes(argIndex) {
        for(let i = this._edges.iterator(); i.hasNext();){
            const e = i.next();
            const eLoc = e.getLabel().getLocation(argIndex);
            for(let eiIt = e.eiList.iterator(); eiIt.hasNext();){
                const ei = eiIt.next();
                this.addSelfIntersectionNode(argIndex, ei.coord, eLoc);
            }
        }
    }
    add() {
        if (arguments.length === 1 && arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const g = arguments[0];
            if (g.isEmpty()) return null;
            if (g instanceof (0, _multiPolygonJsDefault.default)) this._useBoundaryDeterminationRule = false;
            if (g instanceof (0, _polygonJsDefault.default)) this.addPolygon(g);
            else if (g instanceof (0, _lineStringJsDefault.default)) this.addLineString(g);
            else if (g instanceof (0, _pointJsDefault.default)) this.addPoint(g);
            else if (g instanceof (0, _multiPointJsDefault.default)) this.addCollection(g);
            else if (g instanceof (0, _multiLineStringJsDefault.default)) this.addCollection(g);
            else if (g instanceof (0, _multiPolygonJsDefault.default)) this.addCollection(g);
            else if (g instanceof (0, _geometryCollectionJsDefault.default)) this.addCollection(g);
            else throw new (0, _unsupportedOperationExceptionJsDefault.default)(g.getGeometryType());
        } else return super.add.apply(this, arguments);
    }
    addCollection(gc) {
        for(let i = 0; i < gc.getNumGeometries(); i++){
            const g = gc.getGeometryN(i);
            this.add(g);
        }
    }
    locate(pt) {
        if ((0, _hasInterfaceJsDefault.default)(this._parentGeom, (0, _polygonalJsDefault.default)) && this._parentGeom.getNumGeometries() > 50) {
            if (this._areaPtLocator === null) this._areaPtLocator = new (0, _indexedPointInAreaLocatorJsDefault.default)(this._parentGeom);
            return this._areaPtLocator.locate(pt);
        }
        return this._ptLocator.locate(pt, this._parentGeom);
    }
    findEdge() {
        if (arguments.length === 1 && arguments[0] instanceof (0, _lineStringJsDefault.default)) {
            const line = arguments[0];
            return this._lineEdgeMap.get(line);
        } else return super.findEdge.apply(this, arguments);
    }
    computeSplitEdges(edgelist) {
        for(let i = this._edges.iterator(); i.hasNext();){
            const e = i.next();
            e.eiList.addSplitEdges(edgelist);
        }
    }
    computeEdgeIntersections(g, li, includeProper) {
        const si = new (0, _segmentIntersectorJsDefault.default)(li, includeProper, true);
        si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());
        const esi = this.createEdgeSetIntersector();
        esi.computeIntersections(this._edges, g._edges, si);
        return si;
    }
    getGeometry() {
        return this._parentGeom;
    }
    getBoundaryNodeRule() {
        return this._boundaryNodeRule;
    }
    hasTooFewPoints() {
        return this._hasTooFewPoints;
    }
    addPoint() {
        if (arguments[0] instanceof (0, _pointJsDefault.default)) {
            const p = arguments[0];
            const coord = p.getCoordinate();
            this.insertPoint(this._argIndex, coord, (0, _locationJsDefault.default).INTERIOR);
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const pt = arguments[0];
            this.insertPoint(this._argIndex, pt, (0, _locationJsDefault.default).INTERIOR);
        }
    }
    getBoundaryNodes() {
        if (this._boundaryNodes === null) this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex);
        return this._boundaryNodes;
    }
    addSelfIntersectionNode(argIndex, coord, loc) {
        if (this.isBoundaryNode(argIndex, coord)) return null;
        if (loc === (0, _locationJsDefault.default).BOUNDARY && this._useBoundaryDeterminationRule) this.insertBoundaryPoint(argIndex, coord);
        else this.insertPoint(argIndex, coord, loc);
    }
    addPolygonRing(lr, cwLeft, cwRight) {
        if (lr.isEmpty()) return null;
        const coord = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(lr.getCoordinates());
        if (coord.length < 4) {
            this._hasTooFewPoints = true;
            this._invalidPoint = coord[0];
            return null;
        }
        let left = cwLeft;
        let right = cwRight;
        if ((0, _orientationJsDefault.default).isCCW(coord)) {
            left = cwRight;
            right = cwLeft;
        }
        const e = new (0, _edgeJsDefault.default)(coord, new (0, _labelJsDefault.default)(this._argIndex, (0, _locationJsDefault.default).BOUNDARY, left, right));
        this._lineEdgeMap.put(lr, e);
        this.insertEdge(e);
        this.insertPoint(this._argIndex, coord[0], (0, _locationJsDefault.default).BOUNDARY);
    }
    insertPoint(argIndex, coord, onLocation) {
        const n = this._nodes.addNode(coord);
        const lbl = n.getLabel();
        if (lbl === null) n._label = new (0, _labelJsDefault.default)(argIndex, onLocation);
        else lbl.setLocation(argIndex, onLocation);
    }
    createEdgeSetIntersector() {
        return new (0, _simpleMCSweepLineIntersectorJsDefault.default)();
    }
}
exports.default = GeometryGraph;

},{"../geom/LineString.js":"1Hc8p","../../../../java/util/HashMap.js":"gwL7P","../geom/Geometry.js":"d5V2e","../../../../hasInterface.js":"d8mIo","./Position.js":"929cL","./index/SimpleMCSweepLineIntersector.js":"2s2Ur","../algorithm/Orientation.js":"QDWSa","./Label.js":"2NrfJ","../geom/CoordinateArrays.js":"hwXsf","../geom/Polygonal.js":"gO2Qf","../geom/MultiLineString.js":"fdpMS","./PlanarGraph.js":"42N6d","../algorithm/PointLocator.js":"5OxlZ","../geom/Location.js":"71R1B","../geom/Coordinate.js":"3REUb","../geom/Point.js":"i9MoJ","../geom/Polygon.js":"jawWe","../geom/MultiPoint.js":"ikww2","../geom/LinearRing.js":"iks2I","../algorithm/BoundaryNodeRule.js":"5geJz","./index/SegmentIntersector.js":"4AKZt","../geom/MultiPolygon.js":"56YaT","../geom/GeometryCollection.js":"9xeCT","../../../../java/lang/UnsupportedOperationException.js":"fEx26","../algorithm/locate/IndexedPointInAreaLocator.js":"isCVo","../util/Assert.js":"ePbcB","./Edge.js":"5KXFs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2s2Ur":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _edgeSetIntersectorJs = require("./EdgeSetIntersector.js");
var _edgeSetIntersectorJsDefault = parcelHelpers.interopDefault(_edgeSetIntersectorJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
var _segmentIntersectorJs = require("./SegmentIntersector.js");
var _segmentIntersectorJsDefault = parcelHelpers.interopDefault(_segmentIntersectorJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _listJs = require("../../../../../java/util/List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
var _monotoneChainJs = require("./MonotoneChain.js");
var _monotoneChainJsDefault = parcelHelpers.interopDefault(_monotoneChainJs);
var _sweepLineEventJs = require("./SweepLineEvent.js");
var _sweepLineEventJsDefault = parcelHelpers.interopDefault(_sweepLineEventJs);
class SimpleMCSweepLineIntersector extends (0, _edgeSetIntersectorJsDefault.default) {
    constructor(){
        super();
        SimpleMCSweepLineIntersector.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.events = new (0, _arrayListJsDefault.default)();
        this.nOverlaps = null;
    }
    prepareEvents() {
        (0, _collectionsJsDefault.default).sort(this.events);
        for(let i = 0; i < this.events.size(); i++){
            const ev = this.events.get(i);
            if (ev.isDelete()) ev.getInsertEvent().setDeleteEventIndex(i);
        }
    }
    computeIntersections() {
        if (arguments.length === 1) {
            const si = arguments[0];
            this.nOverlaps = 0;
            this.prepareEvents();
            for(let i = 0; i < this.events.size(); i++){
                const ev = this.events.get(i);
                if (ev.isInsert()) this.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);
                if (si.isDone()) break;
            }
        } else if (arguments.length === 3) {
            if (arguments[2] instanceof (0, _segmentIntersectorJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[0], (0, _listJsDefault.default)) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _listJsDefault.default))) {
                const edges0 = arguments[0], edges1 = arguments[1], si = arguments[2];
                this.addEdges(edges0, edges0);
                this.addEdges(edges1, edges1);
                this.computeIntersections(si);
            } else if (typeof arguments[2] === 'boolean' && (0, _hasInterfaceJsDefault.default)(arguments[0], (0, _listJsDefault.default)) && arguments[1] instanceof (0, _segmentIntersectorJsDefault.default)) {
                const edges = arguments[0], si = arguments[1], testAllSegments = arguments[2];
                if (testAllSegments) this.addEdges(edges, null);
                else this.addEdges(edges);
                this.computeIntersections(si);
            }
        }
    }
    addEdge(edge, edgeSet) {
        const mce = edge.getMonotoneChainEdge();
        const startIndex = mce.getStartIndexes();
        for(let i = 0; i < startIndex.length - 1; i++){
            const mc = new (0, _monotoneChainJsDefault.default)(mce, i);
            const insertEvent = new (0, _sweepLineEventJsDefault.default)(edgeSet, mce.getMinX(i), mc);
            this.events.add(insertEvent);
            this.events.add(new (0, _sweepLineEventJsDefault.default)(mce.getMaxX(i), insertEvent));
        }
    }
    processOverlaps(start, end, ev0, si) {
        const mc0 = ev0.getObject();
        for(let i = start; i < end; i++){
            const ev1 = this.events.get(i);
            if (ev1.isInsert()) {
                const mc1 = ev1.getObject();
                if (!ev0.isSameLabel(ev1)) {
                    mc0.computeIntersections(mc1, si);
                    this.nOverlaps++;
                }
            }
        }
    }
    addEdges() {
        if (arguments.length === 1) {
            const edges = arguments[0];
            for(let i = edges.iterator(); i.hasNext();){
                const edge = i.next();
                this.addEdge(edge, edge);
            }
        } else if (arguments.length === 2) {
            const edges = arguments[0], edgeSet = arguments[1];
            for(let i = edges.iterator(); i.hasNext();){
                const edge = i.next();
                this.addEdge(edge, edgeSet);
            }
        }
    }
}
exports.default = SimpleMCSweepLineIntersector;

},{"../../../../../hasInterface.js":"d8mIo","./EdgeSetIntersector.js":"d01td","../../../../../java/util/Collections.js":"hUg9B","./SegmentIntersector.js":"4AKZt","../../../../../java/util/ArrayList.js":"g8omH","../../../../../java/util/List.js":"5xM2g","./MonotoneChain.js":"3iBPJ","./SweepLineEvent.js":"E2dhl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d01td":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class EdgeSetIntersector {
}
exports.default = EdgeSetIntersector;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hUg9B":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arraysJs = require("./Arrays.js");
var _arraysJsDefault = parcelHelpers.interopDefault(_arraysJs);
var _arrayListJs = require("./ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
const Collections = {
    reverseOrder: function() {
        return {
            compare (a, b) {
                return b.compareTo(a);
            }
        };
    },
    min: function(l) {
        Collections.sort(l);
        return l.get(0);
    },
    sort: function(l, c) {
        const a = l.toArray();
        if (c) (0, _arraysJsDefault.default).sort(a, c);
        else (0, _arraysJsDefault.default).sort(a);
        const i = l.iterator();
        for(let pos = 0, alen = a.length; pos < alen; pos++){
            i.next();
            i.set(a[pos]);
        }
    },
    singletonList: function(o) {
        const arrayList = new (0, _arrayListJsDefault.default)();
        arrayList.add(o);
        return arrayList;
    }
};
exports.default = Collections;

},{"./Arrays.js":"8vEqO","./ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4AKZt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class SegmentIntersector {
    constructor(){
        SegmentIntersector.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._hasIntersection = false;
        this._hasProper = false;
        this._hasProperInterior = false;
        this._properIntersectionPoint = null;
        this._li = null;
        this._includeProper = null;
        this._recordIsolated = null;
        this._isSelfIntersection = null;
        this._numIntersections = 0;
        this.numTests = 0;
        this._bdyNodes = null;
        this._isDone = false;
        this._isDoneWhenProperInt = false;
        const li = arguments[0], includeProper = arguments[1], recordIsolated = arguments[2];
        this._li = li;
        this._includeProper = includeProper;
        this._recordIsolated = recordIsolated;
    }
    static isAdjacentSegments(i1, i2) {
        return Math.abs(i1 - i2) === 1;
    }
    isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
        if (e0 === e1) {
            if (this._li.getIntersectionNum() === 1) {
                if (SegmentIntersector.isAdjacentSegments(segIndex0, segIndex1)) return true;
                if (e0.isClosed()) {
                    const maxSegIndex = e0.getNumPoints() - 1;
                    if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) return true;
                }
            }
        }
        return false;
    }
    hasProperInteriorIntersection() {
        return this._hasProperInterior;
    }
    isBoundaryPointInternal(li, bdyNodes) {
        for(let i = bdyNodes.iterator(); i.hasNext();){
            const node = i.next();
            const pt = node.getCoordinate();
            if (li.isIntersection(pt)) return true;
        }
        return false;
    }
    hasProperIntersection() {
        return this._hasProper;
    }
    hasIntersection() {
        return this._hasIntersection;
    }
    isDone() {
        return this._isDone;
    }
    isBoundaryPoint(li, bdyNodes) {
        if (bdyNodes === null) return false;
        if (this.isBoundaryPointInternal(li, bdyNodes[0])) return true;
        if (this.isBoundaryPointInternal(li, bdyNodes[1])) return true;
        return false;
    }
    setBoundaryNodes(bdyNodes0, bdyNodes1) {
        this._bdyNodes = new Array(2).fill(null);
        this._bdyNodes[0] = bdyNodes0;
        this._bdyNodes[1] = bdyNodes1;
    }
    addIntersections(e0, segIndex0, e1, segIndex1) {
        if (e0 === e1 && segIndex0 === segIndex1) return null;
        this.numTests++;
        const p00 = e0.getCoordinates()[segIndex0];
        const p01 = e0.getCoordinates()[segIndex0 + 1];
        const p10 = e1.getCoordinates()[segIndex1];
        const p11 = e1.getCoordinates()[segIndex1 + 1];
        this._li.computeIntersection(p00, p01, p10, p11);
        if (this._li.hasIntersection()) {
            if (this._recordIsolated) {
                e0.setIsolated(false);
                e1.setIsolated(false);
            }
            this._numIntersections++;
            if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
                this._hasIntersection = true;
                if (this._includeProper || !this._li.isProper()) {
                    e0.addIntersections(this._li, segIndex0, 0);
                    e1.addIntersections(this._li, segIndex1, 1);
                }
                if (this._li.isProper()) {
                    this._properIntersectionPoint = this._li.getIntersection(0).copy();
                    this._hasProper = true;
                    if (this._isDoneWhenProperInt) this._isDone = true;
                    if (!this.isBoundaryPoint(this._li, this._bdyNodes)) this._hasProperInterior = true;
                }
            }
        }
    }
    getProperIntersectionPoint() {
        return this._properIntersectionPoint;
    }
    setIsDoneIfProperInt(isDoneWhenProperInt) {
        this._isDoneWhenProperInt = isDoneWhenProperInt;
    }
}
exports.default = SegmentIntersector;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3iBPJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class MonotoneChain {
    constructor(){
        MonotoneChain.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.mce = null;
        this.chainIndex = null;
        const mce = arguments[0], chainIndex = arguments[1];
        this.mce = mce;
        this.chainIndex = chainIndex;
    }
    computeIntersections(mc, si) {
        this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);
    }
}
exports.default = MonotoneChain;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"E2dhl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparableJs = require("../../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
class SweepLineEvent {
    constructor(){
        SweepLineEvent.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._label = null;
        this._xValue = null;
        this._eventType = null;
        this._insertEvent = null;
        this._deleteEventIndex = null;
        this._obj = null;
        if (arguments.length === 2) {
            const x = arguments[0], insertEvent = arguments[1];
            this._eventType = SweepLineEvent.DELETE;
            this._xValue = x;
            this._insertEvent = insertEvent;
        } else if (arguments.length === 3) {
            const label = arguments[0], x = arguments[1], obj = arguments[2];
            this._eventType = SweepLineEvent.INSERT;
            this._label = label;
            this._xValue = x;
            this._obj = obj;
        }
    }
    getObject() {
        return this._obj;
    }
    getDeleteEventIndex() {
        return this._deleteEventIndex;
    }
    isDelete() {
        return this._eventType === SweepLineEvent.DELETE;
    }
    setDeleteEventIndex(deleteEventIndex) {
        this._deleteEventIndex = deleteEventIndex;
    }
    compareTo(o) {
        const pe = o;
        if (this._xValue < pe._xValue) return -1;
        if (this._xValue > pe._xValue) return 1;
        if (this._eventType < pe._eventType) return -1;
        if (this._eventType > pe._eventType) return 1;
        return 0;
    }
    getInsertEvent() {
        return this._insertEvent;
    }
    isInsert() {
        return this._eventType === SweepLineEvent.INSERT;
    }
    isSameLabel(ev) {
        if (this._label === null) return false;
        return this._label === ev._label;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = SweepLineEvent;
SweepLineEvent.INSERT = 1;
SweepLineEvent.DELETE = 2;

},{"../../../../../java/lang/Comparable.js":"6Adw4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"42N6d":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _nodeJs = require("./Node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
var _nodeMapJs = require("./NodeMap.js");
var _nodeMapJsDefault = parcelHelpers.interopDefault(_nodeMapJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _quadrantJs = require("./Quadrant.js");
var _quadrantJsDefault = parcelHelpers.interopDefault(_quadrantJs);
var _nodeFactoryJs = require("./NodeFactory.js");
var _nodeFactoryJsDefault = parcelHelpers.interopDefault(_nodeFactoryJs);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _directedEdgeJs = require("./DirectedEdge.js");
var _directedEdgeJsDefault = parcelHelpers.interopDefault(_directedEdgeJs);
class PlanarGraph {
    constructor(){
        PlanarGraph.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._edges = new (0, _arrayListJsDefault.default)();
        this._nodes = null;
        this._edgeEndList = new (0, _arrayListJsDefault.default)();
        if (arguments.length === 0) this._nodes = new (0, _nodeMapJsDefault.default)(new (0, _nodeFactoryJsDefault.default)());
        else if (arguments.length === 1) {
            const nodeFact = arguments[0];
            this._nodes = new (0, _nodeMapJsDefault.default)(nodeFact);
        }
    }
    static linkResultDirectedEdges(nodes) {
        for(let nodeit = nodes.iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().linkResultDirectedEdges();
        }
    }
    printEdges(out) {
        out.println('Edges:');
        for(let i = 0; i < this._edges.size(); i++){
            out.println('edge ' + i + ':');
            const e = this._edges.get(i);
            e.print(out);
            e.eiList.print(out);
        }
    }
    debugPrintln(o) {
        (0, _systemJsDefault.default).out.println(o);
    }
    isBoundaryNode(geomIndex, coord) {
        const node = this._nodes.find(coord);
        if (node === null) return false;
        const label = node.getLabel();
        if (label !== null && label.getLocation(geomIndex) === (0, _locationJsDefault.default).BOUNDARY) return true;
        return false;
    }
    linkAllDirectedEdges() {
        for(let nodeit = this._nodes.iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().linkAllDirectedEdges();
        }
    }
    debugPrint(o) {
        (0, _systemJsDefault.default).out.print(o);
    }
    findEdgeEnd(e) {
        for(let i = this.getEdgeEnds().iterator(); i.hasNext();){
            const ee = i.next();
            if (ee.getEdge() === e) return ee;
        }
        return null;
    }
    getNodes() {
        return this._nodes.values();
    }
    findEdge(p0, p1) {
        for(let i = 0; i < this._edges.size(); i++){
            const e = this._edges.get(i);
            const eCoord = e.getCoordinates();
            if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) return e;
        }
        return null;
    }
    find(coord) {
        return this._nodes.find(coord);
    }
    addNode() {
        if (arguments[0] instanceof (0, _nodeJsDefault.default)) {
            const node = arguments[0];
            return this._nodes.addNode(node);
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const coord = arguments[0];
            return this._nodes.addNode(coord);
        }
    }
    getNodeIterator() {
        return this._nodes.iterator();
    }
    linkResultDirectedEdges() {
        for(let nodeit = this._nodes.iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().linkResultDirectedEdges();
        }
    }
    matchInSameDirection(p0, p1, ep0, ep1) {
        if (!p0.equals(ep0)) return false;
        if ((0, _orientationJsDefault.default).index(p0, p1, ep1) === (0, _orientationJsDefault.default).COLLINEAR && (0, _quadrantJsDefault.default).quadrant(p0, p1) === (0, _quadrantJsDefault.default).quadrant(ep0, ep1)) return true;
        return false;
    }
    getEdgeEnds() {
        return this._edgeEndList;
    }
    getEdgeIterator() {
        return this._edges.iterator();
    }
    findEdgeInSameDirection(p0, p1) {
        for(let i = 0; i < this._edges.size(); i++){
            const e = this._edges.get(i);
            const eCoord = e.getCoordinates();
            if (this.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) return e;
            if (this.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) return e;
        }
        return null;
    }
    insertEdge(e) {
        this._edges.add(e);
    }
    addEdges(edgesToAdd) {
        for(let it = edgesToAdd.iterator(); it.hasNext();){
            const e = it.next();
            this._edges.add(e);
            const de1 = new (0, _directedEdgeJsDefault.default)(e, true);
            const de2 = new (0, _directedEdgeJsDefault.default)(e, false);
            de1.setSym(de2);
            de2.setSym(de1);
            this.add(de1);
            this.add(de2);
        }
    }
    add(e) {
        this._nodes.add(e);
        this._edgeEndList.add(e);
    }
}
exports.default = PlanarGraph;

},{"../geom/Location.js":"71R1B","../geom/Coordinate.js":"3REUb","./Node.js":"fKSwC","./NodeMap.js":"i6KqO","../../../../java/lang/System.js":"11VqP","../../../../java/util/ArrayList.js":"g8omH","./Quadrant.js":"hwMrb","./NodeFactory.js":"ig4eg","../algorithm/Orientation.js":"QDWSa","./DirectedEdge.js":"4EruM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ig4eg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nodeJs = require("./Node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
class NodeFactory {
    createNode(coord) {
        return new (0, _nodeJsDefault.default)(coord, null);
    }
}
exports.default = NodeFactory;

},{"./Node.js":"fKSwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4EruM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _edgeEndJs = require("./EdgeEnd.js");
var _edgeEndJsDefault = parcelHelpers.interopDefault(_edgeEndJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _topologyExceptionJs = require("../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
class DirectedEdge extends (0, _edgeEndJsDefault.default) {
    constructor(){
        super();
        DirectedEdge.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._isForward = null;
        this._isInResult = false;
        this._isVisited = false;
        this._sym = null;
        this._next = null;
        this._nextMin = null;
        this._edgeRing = null;
        this._minEdgeRing = null;
        this._depth = [
            0,
            -999,
            -999
        ];
        const edge = arguments[0], isForward = arguments[1];
        (0, _edgeEndJsDefault.default).constructor_.call(this, edge);
        this._isForward = isForward;
        if (isForward) this.init(edge.getCoordinate(0), edge.getCoordinate(1));
        else {
            const n = edge.getNumPoints() - 1;
            this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));
        }
        this.computeDirectedLabel();
    }
    static depthFactor(currLocation, nextLocation) {
        if (currLocation === (0, _locationJsDefault.default).EXTERIOR && nextLocation === (0, _locationJsDefault.default).INTERIOR) return 1;
        else if (currLocation === (0, _locationJsDefault.default).INTERIOR && nextLocation === (0, _locationJsDefault.default).EXTERIOR) return -1;
        return 0;
    }
    setVisited(isVisited) {
        this._isVisited = isVisited;
    }
    setDepth(position, depthVal) {
        if (this._depth[position] !== -999) {
            if (this._depth[position] !== depthVal) throw new (0, _topologyExceptionJsDefault.default)('assigned depths do not match', this.getCoordinate());
        }
        this._depth[position] = depthVal;
    }
    isInteriorAreaEdge() {
        let isInteriorAreaEdge = true;
        for(let i = 0; i < 2; i++)if (!(this._label.isArea(i) && this._label.getLocation(i, (0, _positionJsDefault.default).LEFT) === (0, _locationJsDefault.default).INTERIOR && this._label.getLocation(i, (0, _positionJsDefault.default).RIGHT) === (0, _locationJsDefault.default).INTERIOR)) isInteriorAreaEdge = false;
        return isInteriorAreaEdge;
    }
    setNextMin(nextMin) {
        this._nextMin = nextMin;
    }
    print(out) {
        super.print.call(this, out);
        out.print(' ' + this._depth[(0, _positionJsDefault.default).LEFT] + '/' + this._depth[(0, _positionJsDefault.default).RIGHT]);
        out.print(' (' + this.getDepthDelta() + ')');
        if (this._isInResult) out.print(' inResult');
    }
    setMinEdgeRing(minEdgeRing) {
        this._minEdgeRing = minEdgeRing;
    }
    getSym() {
        return this._sym;
    }
    isForward() {
        return this._isForward;
    }
    setSym(de) {
        this._sym = de;
    }
    setVisitedEdge(isVisited) {
        this.setVisited(isVisited);
        this._sym.setVisited(isVisited);
    }
    getNextMin() {
        return this._nextMin;
    }
    getDepth(position) {
        return this._depth[position];
    }
    computeDirectedLabel() {
        this._label = new (0, _labelJsDefault.default)(this._edge.getLabel());
        if (!this._isForward) this._label.flip();
    }
    getNext() {
        return this._next;
    }
    isLineEdge() {
        const isLine = this._label.isLine(0) || this._label.isLine(1);
        const isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, (0, _locationJsDefault.default).EXTERIOR);
        const isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, (0, _locationJsDefault.default).EXTERIOR);
        return isLine && isExteriorIfArea0 && isExteriorIfArea1;
    }
    setEdgeRing(edgeRing) {
        this._edgeRing = edgeRing;
    }
    getMinEdgeRing() {
        return this._minEdgeRing;
    }
    getDepthDelta() {
        let depthDelta = this._edge.getDepthDelta();
        if (!this._isForward) depthDelta = -depthDelta;
        return depthDelta;
    }
    setInResult(isInResult) {
        this._isInResult = isInResult;
    }
    getEdge() {
        return this._edge;
    }
    printEdge(out) {
        this.print(out);
        out.print(' ');
        if (this._isForward) this._edge.print(out);
        else this._edge.printReverse(out);
    }
    setEdgeDepths(position, depth) {
        let depthDelta = this.getEdge().getDepthDelta();
        if (!this._isForward) depthDelta = -depthDelta;
        let directionFactor = 1;
        if (position === (0, _positionJsDefault.default).LEFT) directionFactor = -1;
        const oppositePos = (0, _positionJsDefault.default).opposite(position);
        const delta = depthDelta * directionFactor;
        const oppositeDepth = depth + delta;
        this.setDepth(position, depth);
        this.setDepth(oppositePos, oppositeDepth);
    }
    getEdgeRing() {
        return this._edgeRing;
    }
    isInResult() {
        return this._isInResult;
    }
    setNext(next) {
        this._next = next;
    }
    isVisited() {
        return this._isVisited;
    }
}
exports.default = DirectedEdge;

},{"../geom/Location.js":"71R1B","./EdgeEnd.js":"fJOZ9","./Position.js":"929cL","../geom/TopologyException.js":"cGr97","./Label.js":"2NrfJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5OxlZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _pointLocationJs = require("./PointLocation.js");
var _pointLocationJsDefault = parcelHelpers.interopDefault(_pointLocationJs);
var _boundaryNodeRuleJs = require("./BoundaryNodeRule.js");
var _boundaryNodeRuleJsDefault = parcelHelpers.interopDefault(_boundaryNodeRuleJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _geometryCollectionIteratorJs = require("../geom/GeometryCollectionIterator.js");
var _geometryCollectionIteratorJsDefault = parcelHelpers.interopDefault(_geometryCollectionIteratorJs);
var _geometryCollectionJs = require("../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
class PointLocator {
    constructor(){
        PointLocator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._boundaryRule = (0, _boundaryNodeRuleJsDefault.default).OGC_SFS_BOUNDARY_RULE;
        this._isIn = null;
        this._numBoundaries = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const boundaryRule = arguments[0];
            if (boundaryRule === null) throw new (0, _illegalArgumentExceptionJsDefault.default)('Rule must be non-null');
            this._boundaryRule = boundaryRule;
        }
    }
    locateInPolygonRing(p, ring) {
        if (!ring.getEnvelopeInternal().intersects(p)) return (0, _locationJsDefault.default).EXTERIOR;
        return (0, _pointLocationJsDefault.default).locateInRing(p, ring.getCoordinates());
    }
    intersects(p, geom) {
        return this.locate(p, geom) !== (0, _locationJsDefault.default).EXTERIOR;
    }
    updateLocationInfo(loc) {
        if (loc === (0, _locationJsDefault.default).INTERIOR) this._isIn = true;
        if (loc === (0, _locationJsDefault.default).BOUNDARY) this._numBoundaries++;
    }
    computeLocation(p, geom) {
        if (geom instanceof (0, _pointJsDefault.default)) this.updateLocationInfo(this.locateOnPoint(p, geom));
        if (geom instanceof (0, _lineStringJsDefault.default)) this.updateLocationInfo(this.locateOnLineString(p, geom));
        else if (geom instanceof (0, _polygonJsDefault.default)) this.updateLocationInfo(this.locateInPolygon(p, geom));
        else if (geom instanceof (0, _multiLineStringJsDefault.default)) {
            const ml = geom;
            for(let i = 0; i < ml.getNumGeometries(); i++){
                const l = ml.getGeometryN(i);
                this.updateLocationInfo(this.locateOnLineString(p, l));
            }
        } else if (geom instanceof (0, _multiPolygonJsDefault.default)) {
            const mpoly = geom;
            for(let i = 0; i < mpoly.getNumGeometries(); i++){
                const poly = mpoly.getGeometryN(i);
                this.updateLocationInfo(this.locateInPolygon(p, poly));
            }
        } else if (geom instanceof (0, _geometryCollectionJsDefault.default)) {
            const geomi = new (0, _geometryCollectionIteratorJsDefault.default)(geom);
            while(geomi.hasNext()){
                const g2 = geomi.next();
                if (g2 !== geom) this.computeLocation(p, g2);
            }
        }
    }
    locateOnPoint(p, pt) {
        const ptCoord = pt.getCoordinate();
        if (ptCoord.equals2D(p)) return (0, _locationJsDefault.default).INTERIOR;
        return (0, _locationJsDefault.default).EXTERIOR;
    }
    locateOnLineString(p, l) {
        if (!l.getEnvelopeInternal().intersects(p)) return (0, _locationJsDefault.default).EXTERIOR;
        const seq = l.getCoordinateSequence();
        if (!l.isClosed()) {
            if (p.equals(seq.getCoordinate(0)) || p.equals(seq.getCoordinate(seq.size() - 1))) return (0, _locationJsDefault.default).BOUNDARY;
        }
        if ((0, _pointLocationJsDefault.default).isOnLine(p, seq)) return (0, _locationJsDefault.default).INTERIOR;
        return (0, _locationJsDefault.default).EXTERIOR;
    }
    locateInPolygon(p, poly) {
        if (poly.isEmpty()) return (0, _locationJsDefault.default).EXTERIOR;
        const shell = poly.getExteriorRing();
        const shellLoc = this.locateInPolygonRing(p, shell);
        if (shellLoc === (0, _locationJsDefault.default).EXTERIOR) return (0, _locationJsDefault.default).EXTERIOR;
        if (shellLoc === (0, _locationJsDefault.default).BOUNDARY) return (0, _locationJsDefault.default).BOUNDARY;
        for(let i = 0; i < poly.getNumInteriorRing(); i++){
            const hole = poly.getInteriorRingN(i);
            const holeLoc = this.locateInPolygonRing(p, hole);
            if (holeLoc === (0, _locationJsDefault.default).INTERIOR) return (0, _locationJsDefault.default).EXTERIOR;
            if (holeLoc === (0, _locationJsDefault.default).BOUNDARY) return (0, _locationJsDefault.default).BOUNDARY;
        }
        return (0, _locationJsDefault.default).INTERIOR;
    }
    locate(p, geom) {
        if (geom.isEmpty()) return (0, _locationJsDefault.default).EXTERIOR;
        if (geom instanceof (0, _lineStringJsDefault.default)) return this.locateOnLineString(p, geom);
        else if (geom instanceof (0, _polygonJsDefault.default)) return this.locateInPolygon(p, geom);
        this._isIn = false;
        this._numBoundaries = 0;
        this.computeLocation(p, geom);
        if (this._boundaryRule.isInBoundary(this._numBoundaries)) return (0, _locationJsDefault.default).BOUNDARY;
        if (this._numBoundaries > 0 || this._isIn) return (0, _locationJsDefault.default).INTERIOR;
        return (0, _locationJsDefault.default).EXTERIOR;
    }
}
exports.default = PointLocator;

},{"../geom/Location.js":"71R1B","../geom/LineString.js":"1Hc8p","../geom/Polygon.js":"jawWe","./PointLocation.js":"3XiEk","./BoundaryNodeRule.js":"5geJz","../geom/MultiPolygon.js":"56YaT","../geom/GeometryCollectionIterator.js":"303Gx","../geom/GeometryCollection.js":"9xeCT","../geom/MultiLineString.js":"fdpMS","../../../../java/lang/IllegalArgumentException.js":"1VQhm","../geom/Point.js":"i9MoJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5geJz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class BoundaryNodeRule {
    isInBoundary(boundaryCount) {}
}
exports.default = BoundaryNodeRule;
class Mod2BoundaryNodeRule {
    isInBoundary(boundaryCount) {
        return boundaryCount % 2 === 1;
    }
    get interfaces_() {
        return [
            BoundaryNodeRule
        ];
    }
}
class EndPointBoundaryNodeRule {
    isInBoundary(boundaryCount) {
        return boundaryCount > 0;
    }
    get interfaces_() {
        return [
            BoundaryNodeRule
        ];
    }
}
class MultiValentEndPointBoundaryNodeRule {
    isInBoundary(boundaryCount) {
        return boundaryCount > 1;
    }
    get interfaces_() {
        return [
            BoundaryNodeRule
        ];
    }
}
class MonoValentEndPointBoundaryNodeRule {
    isInBoundary(boundaryCount) {
        return boundaryCount === 1;
    }
    get interfaces_() {
        return [
            BoundaryNodeRule
        ];
    }
}
BoundaryNodeRule.Mod2BoundaryNodeRule = Mod2BoundaryNodeRule;
BoundaryNodeRule.EndPointBoundaryNodeRule = EndPointBoundaryNodeRule;
BoundaryNodeRule.MultiValentEndPointBoundaryNodeRule = MultiValentEndPointBoundaryNodeRule;
BoundaryNodeRule.MonoValentEndPointBoundaryNodeRule = MonoValentEndPointBoundaryNodeRule;
BoundaryNodeRule.MOD2_BOUNDARY_RULE = new Mod2BoundaryNodeRule();
BoundaryNodeRule.ENDPOINT_BOUNDARY_RULE = new EndPointBoundaryNodeRule();
BoundaryNodeRule.MULTIVALENT_ENDPOINT_BOUNDARY_RULE = new MultiValentEndPointBoundaryNodeRule();
BoundaryNodeRule.MONOVALENT_ENDPOINT_BOUNDARY_RULE = new MonoValentEndPointBoundaryNodeRule();
BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE = BoundaryNodeRule.MOD2_BOUNDARY_RULE;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"isCVo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _illegalArgumentExceptionJs = require("../../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _itemVisitorJs = require("../../index/ItemVisitor.js");
var _itemVisitorJsDefault = parcelHelpers.interopDefault(_itemVisitorJs);
var _pointOnGeometryLocatorJs = require("./PointOnGeometryLocator.js");
var _pointOnGeometryLocatorJsDefault = parcelHelpers.interopDefault(_pointOnGeometryLocatorJs);
var _linearRingJs = require("../../geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _sortedPackedIntervalRTreeJs = require("../../index/intervalrtree/SortedPackedIntervalRTree.js");
var _sortedPackedIntervalRTreeJsDefault = parcelHelpers.interopDefault(_sortedPackedIntervalRTreeJs);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
var _linearComponentExtracterJs = require("../../geom/util/LinearComponentExtracter.js");
var _linearComponentExtracterJsDefault = parcelHelpers.interopDefault(_linearComponentExtracterJs);
var _arrayListVisitorJs = require("../../index/ArrayListVisitor.js");
var _arrayListVisitorJsDefault = parcelHelpers.interopDefault(_arrayListVisitorJs);
var _rayCrossingCounterJs = require("../RayCrossingCounter.js");
var _rayCrossingCounterJsDefault = parcelHelpers.interopDefault(_rayCrossingCounterJs);
var _polygonalJs = require("../../geom/Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class IndexedPointInAreaLocator {
    constructor(){
        IndexedPointInAreaLocator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geom = null;
        this._index = null;
        const g = arguments[0];
        if (!((0, _hasInterfaceJsDefault.default)(g, (0, _polygonalJsDefault.default)) || g instanceof (0, _linearRingJsDefault.default))) throw new (0, _illegalArgumentExceptionJsDefault.default)('Argument must be Polygonal or LinearRing');
        this._geom = g;
    }
    locate(p) {
        if (this._index === null) {
            this._index = new IntervalIndexedGeometry(this._geom);
            this._geom = null;
        }
        const rcc = new (0, _rayCrossingCounterJsDefault.default)(p);
        const visitor = new SegmentVisitor(rcc);
        this._index.query(p.y, p.y, visitor);
        return rcc.getLocation();
    }
    get interfaces_() {
        return [
            (0, _pointOnGeometryLocatorJsDefault.default)
        ];
    }
}
exports.default = IndexedPointInAreaLocator;
class SegmentVisitor {
    constructor(){
        SegmentVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._counter = null;
        const counter = arguments[0];
        this._counter = counter;
    }
    visitItem(item) {
        const seg = item;
        this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));
    }
    get interfaces_() {
        return [
            (0, _itemVisitorJsDefault.default)
        ];
    }
}
class IntervalIndexedGeometry {
    constructor(){
        IntervalIndexedGeometry.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._isEmpty = false;
        this._index = new (0, _sortedPackedIntervalRTreeJsDefault.default)();
        const geom = arguments[0];
        if (geom.isEmpty()) this._isEmpty = true;
        else this.init(geom);
    }
    init(geom) {
        const lines = (0, _linearComponentExtracterJsDefault.default).getLines(geom);
        for(let i = lines.iterator(); i.hasNext();){
            const line = i.next();
            const pts = line.getCoordinates();
            this.addLine(pts);
        }
    }
    addLine(pts) {
        for(let i = 1; i < pts.length; i++){
            const seg = new (0, _lineSegmentJsDefault.default)(pts[i - 1], pts[i]);
            const min = Math.min(seg.p0.y, seg.p1.y);
            const max = Math.max(seg.p0.y, seg.p1.y);
            this._index.insert(min, max, seg);
        }
    }
    query() {
        if (arguments.length === 2) {
            const min = arguments[0], max = arguments[1];
            if (this._isEmpty) return new (0, _arrayListJsDefault.default)();
            const visitor = new (0, _arrayListVisitorJsDefault.default)();
            this._index.query(min, max, visitor);
            return visitor.getItems();
        } else if (arguments.length === 3) {
            const min = arguments[0], max = arguments[1], visitor = arguments[2];
            if (this._isEmpty) return null;
            this._index.query(min, max, visitor);
        }
    }
}
IndexedPointInAreaLocator.SegmentVisitor = SegmentVisitor;
IndexedPointInAreaLocator.IntervalIndexedGeometry = IntervalIndexedGeometry;

},{"../../../../../hasInterface.js":"d8mIo","../../../../../java/lang/IllegalArgumentException.js":"1VQhm","../../index/ItemVisitor.js":"8Rynh","./PointOnGeometryLocator.js":"fAKcZ","../../geom/LinearRing.js":"iks2I","../../index/intervalrtree/SortedPackedIntervalRTree.js":"7UVzp","../../geom/LineSegment.js":"4V3G8","../../geom/util/LinearComponentExtracter.js":"3pr36","../../index/ArrayListVisitor.js":"fiG9F","../RayCrossingCounter.js":"hPHJC","../../geom/Polygonal.js":"gO2Qf","../../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Rynh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class ItemVisitor {
    visitItem(item) {}
}
exports.default = ItemVisitor;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7UVzp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktwriterJs = require("../../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _intervalRTreeLeafNodeJs = require("./IntervalRTreeLeafNode.js");
var _intervalRTreeLeafNodeJsDefault = parcelHelpers.interopDefault(_intervalRTreeLeafNodeJs);
var _intervalRTreeNodeJs = require("./IntervalRTreeNode.js");
var _intervalRTreeNodeJsDefault = parcelHelpers.interopDefault(_intervalRTreeNodeJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
var _systemJs = require("../../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _illegalStateExceptionJs = require("../../../../../java/lang/IllegalStateException.js");
var _illegalStateExceptionJsDefault = parcelHelpers.interopDefault(_illegalStateExceptionJs);
var _intervalRTreeBranchNodeJs = require("./IntervalRTreeBranchNode.js");
var _intervalRTreeBranchNodeJsDefault = parcelHelpers.interopDefault(_intervalRTreeBranchNodeJs);
class SortedPackedIntervalRTree {
    constructor(){
        SortedPackedIntervalRTree.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._leaves = new (0, _arrayListJsDefault.default)();
        this._root = null;
        this._level = 0;
    }
    buildTree() {
        (0, _collectionsJsDefault.default).sort(this._leaves, new (0, _intervalRTreeNodeJsDefault.default).NodeComparator());
        let src = this._leaves;
        let temp = null;
        let dest = new (0, _arrayListJsDefault.default)();
        while(true){
            this.buildLevel(src, dest);
            if (dest.size() === 1) return dest.get(0);
            temp = src;
            src = dest;
            dest = temp;
        }
    }
    insert(min, max, item) {
        if (this._root !== null) throw new (0, _illegalStateExceptionJsDefault.default)('Index cannot be added to once it has been queried');
        this._leaves.add(new (0, _intervalRTreeLeafNodeJsDefault.default)(min, max, item));
    }
    query(min, max, visitor) {
        this.init();
        if (this._root === null) return null;
        this._root.query(min, max, visitor);
    }
    buildRoot() {
        if (this._root !== null) return null;
        this._root = this.buildTree();
    }
    printNode(node) {
        (0, _systemJsDefault.default).out.println((0, _wktwriterJsDefault.default).toLineString(new (0, _coordinateJsDefault.default)(node._min, this._level), new (0, _coordinateJsDefault.default)(node._max, this._level)));
    }
    init() {
        if (this._root !== null) return null;
        if (this._leaves.size() === 0) return null;
        this.buildRoot();
    }
    buildLevel(src, dest) {
        this._level++;
        dest.clear();
        for(let i = 0; i < src.size(); i += 2){
            const n1 = src.get(i);
            const n2 = i + 1 < src.size() ? src.get(i) : null;
            if (n2 === null) dest.add(n1);
            else {
                const node = new (0, _intervalRTreeBranchNodeJsDefault.default)(src.get(i), src.get(i + 1));
                dest.add(node);
            }
        }
    }
}
exports.default = SortedPackedIntervalRTree;

},{"../../io/WKTWriter.js":"gvRTy","../../geom/Coordinate.js":"3REUb","./IntervalRTreeLeafNode.js":"3jAcU","./IntervalRTreeNode.js":"bPvAG","../../../../../java/util/Collections.js":"hUg9B","../../../../../java/lang/System.js":"11VqP","../../../../../java/util/ArrayList.js":"g8omH","../../../../../java/lang/IllegalStateException.js":"4MAFg","./IntervalRTreeBranchNode.js":"klYIC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3jAcU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _intervalRTreeNodeJs = require("./IntervalRTreeNode.js");
var _intervalRTreeNodeJsDefault = parcelHelpers.interopDefault(_intervalRTreeNodeJs);
class IntervalRTreeLeafNode extends (0, _intervalRTreeNodeJsDefault.default) {
    constructor(){
        super();
        IntervalRTreeLeafNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._item = null;
        const min = arguments[0], max = arguments[1], item = arguments[2];
        this._min = min;
        this._max = max;
        this._item = item;
    }
    query(queryMin, queryMax, visitor) {
        if (!this.intersects(queryMin, queryMax)) return null;
        visitor.visitItem(this._item);
    }
}
exports.default = IntervalRTreeLeafNode;

},{"./IntervalRTreeNode.js":"bPvAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bPvAG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktwriterJs = require("../../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _comparatorJs = require("../../../../../java/util/Comparator.js");
var _comparatorJsDefault = parcelHelpers.interopDefault(_comparatorJs);
class IntervalRTreeNode {
    constructor(){
        IntervalRTreeNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._min = (0, _doubleJsDefault.default).POSITIVE_INFINITY;
        this._max = (0, _doubleJsDefault.default).NEGATIVE_INFINITY;
    }
    getMin() {
        return this._min;
    }
    intersects(queryMin, queryMax) {
        if (this._min > queryMax || this._max < queryMin) return false;
        return true;
    }
    getMax() {
        return this._max;
    }
    toString() {
        return (0, _wktwriterJsDefault.default).toLineString(new (0, _coordinateJsDefault.default)(this._min, 0), new (0, _coordinateJsDefault.default)(this._max, 0));
    }
}
exports.default = IntervalRTreeNode;
class NodeComparator {
    compare(o1, o2) {
        const n1 = o1;
        const n2 = o2;
        const mid1 = (n1._min + n1._max) / 2;
        const mid2 = (n2._min + n2._max) / 2;
        if (mid1 < mid2) return -1;
        if (mid1 > mid2) return 1;
        return 0;
    }
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
}
IntervalRTreeNode.NodeComparator = NodeComparator;

},{"../../io/WKTWriter.js":"gvRTy","../../geom/Coordinate.js":"3REUb","../../../../../java/lang/Double.js":"jCc26","../../../../../java/util/Comparator.js":"6CEtH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klYIC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _intervalRTreeNodeJs = require("./IntervalRTreeNode.js");
var _intervalRTreeNodeJsDefault = parcelHelpers.interopDefault(_intervalRTreeNodeJs);
class IntervalRTreeBranchNode extends (0, _intervalRTreeNodeJsDefault.default) {
    constructor(){
        super();
        IntervalRTreeBranchNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._node1 = null;
        this._node2 = null;
        const n1 = arguments[0], n2 = arguments[1];
        this._node1 = n1;
        this._node2 = n2;
        this.buildExtent(this._node1, this._node2);
    }
    buildExtent(n1, n2) {
        this._min = Math.min(n1._min, n2._min);
        this._max = Math.max(n1._max, n2._max);
    }
    query(queryMin, queryMax, visitor) {
        if (!this.intersects(queryMin, queryMax)) return null;
        if (this._node1 !== null) this._node1.query(queryMin, queryMax, visitor);
        if (this._node2 !== null) this._node2.query(queryMin, queryMax, visitor);
    }
}
exports.default = IntervalRTreeBranchNode;

},{"./IntervalRTreeNode.js":"bPvAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4V3G8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _robustLineIntersectorJs = require("../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _serializableJs = require("../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _illegalStateExceptionJs = require("../../../../java/lang/IllegalStateException.js");
var _illegalStateExceptionJsDefault = parcelHelpers.interopDefault(_illegalStateExceptionJs);
var _distanceJs = require("../algorithm/Distance.js");
var _distanceJsDefault = parcelHelpers.interopDefault(_distanceJs);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _intersectionJs = require("../algorithm/Intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
class LineSegment {
    constructor(){
        LineSegment.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.p0 = null;
        this.p1 = null;
        if (arguments.length === 0) LineSegment.constructor_.call(this, new (0, _coordinateJsDefault.default)(), new (0, _coordinateJsDefault.default)());
        else if (arguments.length === 1) {
            const ls = arguments[0];
            LineSegment.constructor_.call(this, ls.p0, ls.p1);
        } else if (arguments.length === 2) {
            const p0 = arguments[0], p1 = arguments[1];
            this.p0 = p0;
            this.p1 = p1;
        } else if (arguments.length === 4) {
            const x0 = arguments[0], y0 = arguments[1], x1 = arguments[2], y1 = arguments[3];
            LineSegment.constructor_.call(this, new (0, _coordinateJsDefault.default)(x0, y0), new (0, _coordinateJsDefault.default)(x1, y1));
        }
    }
    static midPoint(p0, p1) {
        return new (0, _coordinateJsDefault.default)((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);
    }
    minX() {
        return Math.min(this.p0.x, this.p1.x);
    }
    orientationIndex() {
        if (arguments[0] instanceof LineSegment) {
            const seg = arguments[0];
            const orient0 = (0, _orientationJsDefault.default).index(this.p0, this.p1, seg.p0);
            const orient1 = (0, _orientationJsDefault.default).index(this.p0, this.p1, seg.p1);
            if (orient0 >= 0 && orient1 >= 0) return Math.max(orient0, orient1);
            if (orient0 <= 0 && orient1 <= 0) return Math.max(orient0, orient1);
            return 0;
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const p = arguments[0];
            return (0, _orientationJsDefault.default).index(this.p0, this.p1, p);
        }
    }
    toGeometry(geomFactory) {
        return geomFactory.createLineString([
            this.p0,
            this.p1
        ]);
    }
    isVertical() {
        return this.p0.x === this.p1.x;
    }
    minY() {
        return Math.min(this.p0.y, this.p1.y);
    }
    midPoint() {
        return LineSegment.midPoint(this.p0, this.p1);
    }
    maxY() {
        return Math.max(this.p0.y, this.p1.y);
    }
    pointAlongOffset(segmentLengthFraction, offsetDistance) {
        const segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
        const segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
        const dx = this.p1.x - this.p0.x;
        const dy = this.p1.y - this.p0.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        let ux = 0.0;
        let uy = 0.0;
        if (offsetDistance !== 0.0) {
            if (len <= 0.0) throw new (0, _illegalStateExceptionJsDefault.default)('Cannot compute offset from zero-length line segment');
            ux = offsetDistance * dx / len;
            uy = offsetDistance * dy / len;
        }
        const offsetx = segx - uy;
        const offsety = segy + ux;
        const coord = new (0, _coordinateJsDefault.default)(offsetx, offsety);
        return coord;
    }
    setCoordinates() {
        if (arguments.length === 1) {
            const ls = arguments[0];
            this.setCoordinates(ls.p0, ls.p1);
        } else if (arguments.length === 2) {
            const p0 = arguments[0], p1 = arguments[1];
            this.p0.x = p0.x;
            this.p0.y = p0.y;
            this.p1.x = p1.x;
            this.p1.y = p1.y;
        }
    }
    segmentFraction(inputPt) {
        let segFrac = this.projectionFactor(inputPt);
        if (segFrac < 0.0) segFrac = 0.0;
        else if (segFrac > 1.0 || (0, _doubleJsDefault.default).isNaN(segFrac)) segFrac = 1.0;
        return segFrac;
    }
    toString() {
        return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')';
    }
    distance() {
        if (arguments[0] instanceof LineSegment) {
            const ls = arguments[0];
            return (0, _distanceJsDefault.default).segmentToSegment(this.p0, this.p1, ls.p0, ls.p1);
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const p = arguments[0];
            return (0, _distanceJsDefault.default).pointToSegment(p, this.p0, this.p1);
        }
    }
    equals(o) {
        if (!(o instanceof LineSegment)) return false;
        const other = o;
        return this.p0.equals(other.p0) && this.p1.equals(other.p1);
    }
    intersection(line) {
        const li = new (0, _robustLineIntersectorJsDefault.default)();
        li.computeIntersection(this.p0, this.p1, line.p0, line.p1);
        if (li.hasIntersection()) return li.getIntersection(0);
        return null;
    }
    project() {
        if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const p = arguments[0];
            if (p.equals(this.p0) || p.equals(this.p1)) return new (0, _coordinateJsDefault.default)(p);
            const r = this.projectionFactor(p);
            const coord = new (0, _coordinateJsDefault.default)();
            coord.x = this.p0.x + r * (this.p1.x - this.p0.x);
            coord.y = this.p0.y + r * (this.p1.y - this.p0.y);
            return coord;
        } else if (arguments[0] instanceof LineSegment) {
            const seg = arguments[0];
            const pf0 = this.projectionFactor(seg.p0);
            const pf1 = this.projectionFactor(seg.p1);
            if (pf0 >= 1.0 && pf1 >= 1.0) return null;
            if (pf0 <= 0.0 && pf1 <= 0.0) return null;
            let newp0 = this.project(seg.p0);
            if (pf0 < 0.0) newp0 = this.p0;
            if (pf0 > 1.0) newp0 = this.p1;
            let newp1 = this.project(seg.p1);
            if (pf1 < 0.0) newp1 = this.p0;
            if (pf1 > 1.0) newp1 = this.p1;
            return new LineSegment(newp0, newp1);
        }
    }
    normalize() {
        if (this.p1.compareTo(this.p0) < 0) this.reverse();
    }
    angle() {
        return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
    }
    getCoordinate(i) {
        if (i === 0) return this.p0;
        return this.p1;
    }
    distancePerpendicular(p) {
        return (0, _distanceJsDefault.default).pointToLinePerpendicular(p, this.p0, this.p1);
    }
    closestPoint(p) {
        const factor = this.projectionFactor(p);
        if (factor > 0 && factor < 1) return this.project(p);
        const dist0 = this.p0.distance(p);
        const dist1 = this.p1.distance(p);
        if (dist0 < dist1) return this.p0;
        return this.p1;
    }
    projectionFactor(p) {
        if (p.equals(this.p0)) return 0.0;
        if (p.equals(this.p1)) return 1.0;
        const dx = this.p1.x - this.p0.x;
        const dy = this.p1.y - this.p0.y;
        const len = dx * dx + dy * dy;
        if (len <= 0.0) return (0, _doubleJsDefault.default).NaN;
        const r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;
        return r;
    }
    closestPoints(line) {
        const intPt = this.intersection(line);
        if (intPt !== null) return [
            intPt,
            intPt
        ];
        const closestPt = new Array(2).fill(null);
        let minDistance = (0, _doubleJsDefault.default).MAX_VALUE;
        let dist = null;
        const close00 = this.closestPoint(line.p0);
        minDistance = close00.distance(line.p0);
        closestPt[0] = close00;
        closestPt[1] = line.p0;
        const close01 = this.closestPoint(line.p1);
        dist = close01.distance(line.p1);
        if (dist < minDistance) {
            minDistance = dist;
            closestPt[0] = close01;
            closestPt[1] = line.p1;
        }
        const close10 = line.closestPoint(this.p0);
        dist = close10.distance(this.p0);
        if (dist < minDistance) {
            minDistance = dist;
            closestPt[0] = this.p0;
            closestPt[1] = close10;
        }
        const close11 = line.closestPoint(this.p1);
        dist = close11.distance(this.p1);
        if (dist < minDistance) {
            minDistance = dist;
            closestPt[0] = this.p1;
            closestPt[1] = close11;
        }
        return closestPt;
    }
    maxX() {
        return Math.max(this.p0.x, this.p1.x);
    }
    getLength() {
        return this.p0.distance(this.p1);
    }
    compareTo(o) {
        const other = o;
        const comp0 = this.p0.compareTo(other.p0);
        if (comp0 !== 0) return comp0;
        return this.p1.compareTo(other.p1);
    }
    reverse() {
        const temp = this.p0;
        this.p0 = this.p1;
        this.p1 = temp;
    }
    equalsTopo(other) {
        return this.p0.equals(other.p0) && this.p1.equals(other.p1) || this.p0.equals(other.p1) && this.p1.equals(other.p0);
    }
    lineIntersection(line) {
        const intPt = (0, _intersectionJsDefault.default).intersection(this.p0, this.p1, line.p0, line.p1);
        return intPt;
    }
    isHorizontal() {
        return this.p0.y === this.p1.y;
    }
    reflect(p) {
        const A = this.p1.getY() - this.p0.getY();
        const B = this.p0.getX() - this.p1.getX();
        const C = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY());
        const A2plusB2 = A * A + B * B;
        const A2subB2 = A * A - B * B;
        const x = p.getX();
        const y = p.getY();
        const rx = (-A2subB2 * x - 2 * A * B * y - 2 * A * C) / A2plusB2;
        const ry = (A2subB2 * y - 2 * A * B * x - 2 * B * C) / A2plusB2;
        return new (0, _coordinateJsDefault.default)(rx, ry);
    }
    pointAlong(segmentLengthFraction) {
        const coord = new (0, _coordinateJsDefault.default)();
        coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);
        coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);
        return coord;
    }
    hashCode() {
        let bits0 = (0, _doubleJsDefault.default).doubleToLongBits(this.p0.x);
        bits0 ^= (0, _doubleJsDefault.default).doubleToLongBits(this.p0.y) * 31;
        const hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);
        let bits1 = (0, _doubleJsDefault.default).doubleToLongBits(this.p1.x);
        bits1 ^= (0, _doubleJsDefault.default).doubleToLongBits(this.p1.y) * 31;
        const hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);
        return hash0 ^ hash1;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = LineSegment;

},{"./Coordinate.js":"3REUb","../../../../java/lang/Double.js":"jCc26","../../../../java/lang/Comparable.js":"6Adw4","../algorithm/RobustLineIntersector.js":"fBBRl","../../../../java/io/Serializable.js":"4emqV","../../../../java/lang/IllegalStateException.js":"4MAFg","../algorithm/Distance.js":"gNNl0","../algorithm/Orientation.js":"QDWSa","../algorithm/Intersection.js":"46jkJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3pr36":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _geometryJs = require("../Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _collectionJs = require("../../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _linearRingJs = require("../LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _geometryComponentFilterJs = require("../GeometryComponentFilter.js");
var _geometryComponentFilterJsDefault = parcelHelpers.interopDefault(_geometryComponentFilterJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class LinearComponentExtracter {
    constructor(){
        LinearComponentExtracter.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._lines = null;
        this._isForcedToLineString = false;
        if (arguments.length === 1) {
            const lines = arguments[0];
            this._lines = lines;
        } else if (arguments.length === 2) {
            const lines = arguments[0], isForcedToLineString = arguments[1];
            this._lines = lines;
            this._isForcedToLineString = isForcedToLineString;
        }
    }
    static getLines() {
        if (arguments.length === 1) {
            const geom = arguments[0];
            return LinearComponentExtracter.getLines(geom, false);
        } else if (arguments.length === 2) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default)) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _collectionJsDefault.default))) {
                const geoms = arguments[0], lines = arguments[1];
                for(let i = geoms.iterator(); i.hasNext();){
                    const g = i.next();
                    LinearComponentExtracter.getLines(g, lines);
                }
                return lines;
            } else if (arguments[0] instanceof (0, _geometryJsDefault.default) && typeof arguments[1] === 'boolean') {
                const geom = arguments[0], forceToLineString = arguments[1];
                const lines = new (0, _arrayListJsDefault.default)();
                geom.apply(new LinearComponentExtracter(lines, forceToLineString));
                return lines;
            } else if (arguments[0] instanceof (0, _geometryJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _collectionJsDefault.default))) {
                const geom = arguments[0], lines = arguments[1];
                if (geom instanceof (0, _lineStringJsDefault.default)) lines.add(geom);
                else geom.apply(new LinearComponentExtracter(lines));
                return lines;
            }
        } else if (arguments.length === 3) {
            if (typeof arguments[2] === 'boolean' && (0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default)) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _collectionJsDefault.default))) {
                const geoms = arguments[0], lines = arguments[1], forceToLineString = arguments[2];
                for(let i = geoms.iterator(); i.hasNext();){
                    const g = i.next();
                    LinearComponentExtracter.getLines(g, lines, forceToLineString);
                }
                return lines;
            } else if (typeof arguments[2] === 'boolean' && arguments[0] instanceof (0, _geometryJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _collectionJsDefault.default))) {
                const geom = arguments[0], lines = arguments[1], forceToLineString = arguments[2];
                geom.apply(new LinearComponentExtracter(lines, forceToLineString));
                return lines;
            }
        }
    }
    static getGeometry() {
        if (arguments.length === 1) {
            const geom = arguments[0];
            return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom));
        } else if (arguments.length === 2) {
            const geom = arguments[0], forceToLineString = arguments[1];
            return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom, forceToLineString));
        }
    }
    filter(geom) {
        if (this._isForcedToLineString && geom instanceof (0, _linearRingJsDefault.default)) {
            const line = geom.getFactory().createLineString(geom.getCoordinateSequence());
            this._lines.add(line);
            return null;
        }
        if (geom instanceof (0, _lineStringJsDefault.default)) this._lines.add(geom);
    }
    setForceToLineString(isForcedToLineString) {
        this._isForcedToLineString = isForcedToLineString;
    }
    get interfaces_() {
        return [
            (0, _geometryComponentFilterJsDefault.default)
        ];
    }
}
exports.default = LinearComponentExtracter;

},{"../LineString.js":"1Hc8p","../Geometry.js":"d5V2e","../../../../../hasInterface.js":"d8mIo","../../../../../java/util/Collection.js":"fbl5V","../LinearRing.js":"iks2I","../GeometryComponentFilter.js":"8aMWe","../../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fiG9F":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itemVisitorJs = require("./ItemVisitor.js");
var _itemVisitorJsDefault = parcelHelpers.interopDefault(_itemVisitorJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class ArrayListVisitor {
    constructor(){
        ArrayListVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._items = new (0, _arrayListJsDefault.default)();
    }
    getItems() {
        return this._items;
    }
    visitItem(item) {
        this._items.add(item);
    }
    get interfaces_() {
        return [
            (0, _itemVisitorJsDefault.default)
        ];
    }
}
exports.default = ArrayListVisitor;

},{"./ItemVisitor.js":"8Rynh","../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5KXFs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeIntersectionListJs = require("./EdgeIntersectionList.js");
var _edgeIntersectionListJsDefault = parcelHelpers.interopDefault(_edgeIntersectionListJs);
var _intersectionMatrixJs = require("../geom/IntersectionMatrix.js");
var _intersectionMatrixJsDefault = parcelHelpers.interopDefault(_intersectionMatrixJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _envelopeJs = require("../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _stringBuilderJs = require("../../../../java/lang/StringBuilder.js");
var _stringBuilderJsDefault = parcelHelpers.interopDefault(_stringBuilderJs);
var _depthJs = require("./Depth.js");
var _depthJsDefault = parcelHelpers.interopDefault(_depthJs);
var _graphComponentJs = require("./GraphComponent.js");
var _graphComponentJsDefault = parcelHelpers.interopDefault(_graphComponentJs);
var _monotoneChainEdgeJs = require("./index/MonotoneChainEdge.js");
var _monotoneChainEdgeJsDefault = parcelHelpers.interopDefault(_monotoneChainEdgeJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
class Edge extends (0, _graphComponentJsDefault.default) {
    constructor(){
        super();
        Edge.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.pts = null;
        this._env = null;
        this.eiList = new (0, _edgeIntersectionListJsDefault.default)(this);
        this._name = null;
        this._mce = null;
        this._isIsolated = true;
        this._depth = new (0, _depthJsDefault.default)();
        this._depthDelta = 0;
        if (arguments.length === 1) {
            const pts = arguments[0];
            Edge.constructor_.call(this, pts, null);
        } else if (arguments.length === 2) {
            const pts = arguments[0], label = arguments[1];
            this.pts = pts;
            this._label = label;
        }
    }
    static updateIM() {
        if (arguments.length === 2 && arguments[1] instanceof (0, _intersectionMatrixJsDefault.default) && arguments[0] instanceof (0, _labelJsDefault.default)) {
            const label = arguments[0], im = arguments[1];
            im.setAtLeastIfValid(label.getLocation(0, (0, _positionJsDefault.default).ON), label.getLocation(1, (0, _positionJsDefault.default).ON), 1);
            if (label.isArea()) {
                im.setAtLeastIfValid(label.getLocation(0, (0, _positionJsDefault.default).LEFT), label.getLocation(1, (0, _positionJsDefault.default).LEFT), 2);
                im.setAtLeastIfValid(label.getLocation(0, (0, _positionJsDefault.default).RIGHT), label.getLocation(1, (0, _positionJsDefault.default).RIGHT), 2);
            }
        } else return super.updateIM.apply(this, arguments);
    }
    getDepth() {
        return this._depth;
    }
    getCollapsedEdge() {
        const newPts = new Array(2).fill(null);
        newPts[0] = this.pts[0];
        newPts[1] = this.pts[1];
        const newe = new Edge(newPts, (0, _labelJsDefault.default).toLineLabel(this._label));
        return newe;
    }
    setIsolated(isIsolated) {
        this._isIsolated = isIsolated;
    }
    setName(name) {
        this._name = name;
    }
    equals(o) {
        if (!(o instanceof Edge)) return false;
        const e = o;
        if (this.pts.length !== e.pts.length) return false;
        let isEqualForward = true;
        let isEqualReverse = true;
        let iRev = this.pts.length;
        for(let i = 0; i < this.pts.length; i++){
            if (!this.pts[i].equals2D(e.pts[i])) isEqualForward = false;
            if (!this.pts[i].equals2D(e.pts[--iRev])) isEqualReverse = false;
            if (!isEqualForward && !isEqualReverse) return false;
        }
        return true;
    }
    getCoordinate() {
        if (arguments.length === 0) {
            if (this.pts.length > 0) return this.pts[0];
            return null;
        } else if (arguments.length === 1) {
            const i = arguments[0];
            return this.pts[i];
        }
    }
    isClosed() {
        return this.pts[0].equals(this.pts[this.pts.length - 1]);
    }
    getMaximumSegmentIndex() {
        return this.pts.length - 1;
    }
    setDepthDelta(depthDelta) {
        this._depthDelta = depthDelta;
    }
    getEdgeIntersectionList() {
        return this.eiList;
    }
    addIntersections(li, segmentIndex, geomIndex) {
        for(let i = 0; i < li.getIntersectionNum(); i++)this.addIntersection(li, segmentIndex, geomIndex, i);
    }
    isIsolated() {
        return this._isIsolated;
    }
    getCoordinates() {
        return this.pts;
    }
    print(out) {
        out.print('edge ' + this._name + ': ');
        out.print('LINESTRING (');
        for(let i = 0; i < this.pts.length; i++){
            if (i > 0) out.print(',');
            out.print(this.pts[i].x + ' ' + this.pts[i].y);
        }
        out.print(')  ' + this._label + ' ' + this._depthDelta);
    }
    computeIM(im) {
        Edge.updateIM(this._label, im);
    }
    isCollapsed() {
        if (!this._label.isArea()) return false;
        if (this.pts.length !== 3) return false;
        if (this.pts[0].equals(this.pts[2])) return true;
        return false;
    }
    getDepthDelta() {
        return this._depthDelta;
    }
    getNumPoints() {
        return this.pts.length;
    }
    printReverse(out) {
        out.print('edge ' + this._name + ': ');
        for(let i = this.pts.length - 1; i >= 0; i--)out.print(this.pts[i] + ' ');
        out.println('');
    }
    getMonotoneChainEdge() {
        if (this._mce === null) this._mce = new (0, _monotoneChainEdgeJsDefault.default)(this);
        return this._mce;
    }
    getEnvelope() {
        if (this._env === null) {
            this._env = new (0, _envelopeJsDefault.default)();
            for(let i = 0; i < this.pts.length; i++)this._env.expandToInclude(this.pts[i]);
        }
        return this._env;
    }
    addIntersection(li, segmentIndex, geomIndex, intIndex) {
        const intPt = new (0, _coordinateJsDefault.default)(li.getIntersection(intIndex));
        let normalizedSegmentIndex = segmentIndex;
        let dist = li.getEdgeDistance(geomIndex, intIndex);
        const nextSegIndex = normalizedSegmentIndex + 1;
        if (nextSegIndex < this.pts.length) {
            const nextPt = this.pts[nextSegIndex];
            if (intPt.equals2D(nextPt)) {
                normalizedSegmentIndex = nextSegIndex;
                dist = 0.0;
            }
        }
        const ei = this.eiList.add(intPt, normalizedSegmentIndex, dist);
    }
    toString() {
        const builder = new (0, _stringBuilderJsDefault.default)();
        builder.append('edge ' + this._name + ': ');
        builder.append('LINESTRING (');
        for(let i = 0; i < this.pts.length; i++){
            if (i > 0) builder.append(',');
            builder.append(this.pts[i].x + ' ' + this.pts[i].y);
        }
        builder.append(')  ' + this._label + ' ' + this._depthDelta);
        return builder.toString();
    }
    isPointwiseEqual(e) {
        if (this.pts.length !== e.pts.length) return false;
        for(let i = 0; i < this.pts.length; i++)if (!this.pts[i].equals2D(e.pts[i])) return false;
        return true;
    }
}
exports.default = Edge;

},{"./EdgeIntersectionList.js":"6maFw","../geom/IntersectionMatrix.js":"8dTUp","../geom/Coordinate.js":"3REUb","./Label.js":"2NrfJ","../geom/Envelope.js":"ha5UZ","../../../../java/lang/StringBuilder.js":"iGg1z","./Depth.js":"giN22","./GraphComponent.js":"cY8Ur","./index/MonotoneChainEdge.js":"4AI1O","./Position.js":"929cL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6maFw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeIntersectionJs = require("./EdgeIntersection.js");
var _edgeIntersectionJsDefault = parcelHelpers.interopDefault(_edgeIntersectionJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _edgeJs = require("./Edge.js");
var _edgeJsDefault = parcelHelpers.interopDefault(_edgeJs);
var _treeMapJs = require("../../../../java/util/TreeMap.js");
var _treeMapJsDefault = parcelHelpers.interopDefault(_treeMapJs);
class EdgeIntersectionList {
    constructor(){
        EdgeIntersectionList.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._nodeMap = new (0, _treeMapJsDefault.default)();
        this.edge = null;
        const edge = arguments[0];
        this.edge = edge;
    }
    print(out) {
        out.println('Intersections:');
        for(let it = this.iterator(); it.hasNext();){
            const ei = it.next();
            ei.print(out);
        }
    }
    addEndpoints() {
        const maxSegIndex = this.edge.pts.length - 1;
        this.add(this.edge.pts[0], 0, 0.0);
        this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);
    }
    createSplitEdge(ei0, ei1) {
        let npts = ei1.segmentIndex - ei0.segmentIndex + 2;
        const lastSegStartPt = this.edge.pts[ei1.segmentIndex];
        const useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);
        if (!useIntPt1) npts--;
        const pts = new Array(npts).fill(null);
        let ipt = 0;
        pts[ipt++] = new (0, _coordinateJsDefault.default)(ei0.coord);
        for(let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++)pts[ipt++] = this.edge.pts[i];
        if (useIntPt1) pts[ipt] = ei1.coord;
        return new (0, _edgeJsDefault.default)(pts, new (0, _labelJsDefault.default)(this.edge._label));
    }
    add(intPt, segmentIndex, dist) {
        const eiNew = new (0, _edgeIntersectionJsDefault.default)(intPt, segmentIndex, dist);
        const ei = this._nodeMap.get(eiNew);
        if (ei !== null) return ei;
        this._nodeMap.put(eiNew, eiNew);
        return eiNew;
    }
    isIntersection(pt) {
        for(let it = this.iterator(); it.hasNext();){
            const ei = it.next();
            if (ei.coord.equals(pt)) return true;
        }
        return false;
    }
    iterator() {
        return this._nodeMap.values().iterator();
    }
    addSplitEdges(edgeList) {
        this.addEndpoints();
        const it = this.iterator();
        let eiPrev = it.next();
        while(it.hasNext()){
            const ei = it.next();
            const newEdge = this.createSplitEdge(eiPrev, ei);
            edgeList.add(newEdge);
            eiPrev = ei;
        }
    }
}
exports.default = EdgeIntersectionList;

},{"./EdgeIntersection.js":"aY6Sr","../geom/Coordinate.js":"3REUb","./Label.js":"2NrfJ","./Edge.js":"5KXFs","../../../../java/util/TreeMap.js":"3VPI6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aY6Sr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
class EdgeIntersection {
    constructor(){
        EdgeIntersection.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.coord = null;
        this.segmentIndex = null;
        this.dist = null;
        const coord = arguments[0], segmentIndex = arguments[1], dist = arguments[2];
        this.coord = new (0, _coordinateJsDefault.default)(coord);
        this.segmentIndex = segmentIndex;
        this.dist = dist;
    }
    getSegmentIndex() {
        return this.segmentIndex;
    }
    getCoordinate() {
        return this.coord;
    }
    print(out) {
        out.print(this.coord);
        out.print(' seg # = ' + this.segmentIndex);
        out.println(' dist = ' + this.dist);
    }
    compareTo(obj) {
        const other = obj;
        return this.compare(other.segmentIndex, other.dist);
    }
    isEndPoint(maxSegmentIndex) {
        if (this.segmentIndex === 0 && this.dist === 0.0) return true;
        if (this.segmentIndex === maxSegmentIndex) return true;
        return false;
    }
    toString() {
        return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist;
    }
    getDistance() {
        return this.dist;
    }
    compare(segmentIndex, dist) {
        if (this.segmentIndex < segmentIndex) return -1;
        if (this.segmentIndex > segmentIndex) return 1;
        if (this.dist < dist) return -1;
        if (this.dist > dist) return 1;
        return 0;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = EdgeIntersection;

},{"../geom/Coordinate.js":"3REUb","../../../../java/lang/Comparable.js":"6Adw4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"giN22":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
class Depth {
    constructor(){
        Depth.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._depth = Array(2).fill().map(()=>Array(3));
        for(let i = 0; i < 2; i++)for(let j = 0; j < 3; j++)this._depth[i][j] = Depth.NULL_VALUE;
    }
    static depthAtLocation(location) {
        if (location === (0, _locationJsDefault.default).EXTERIOR) return 0;
        if (location === (0, _locationJsDefault.default).INTERIOR) return 1;
        return Depth.NULL_VALUE;
    }
    getDepth(geomIndex, posIndex) {
        return this._depth[geomIndex][posIndex];
    }
    setDepth(geomIndex, posIndex, depthValue) {
        this._depth[geomIndex][posIndex] = depthValue;
    }
    isNull() {
        if (arguments.length === 0) {
            for(let i = 0; i < 2; i++)for(let j = 0; j < 3; j++)if (this._depth[i][j] !== Depth.NULL_VALUE) return false;
            return true;
        } else if (arguments.length === 1) {
            const geomIndex = arguments[0];
            return this._depth[geomIndex][1] === Depth.NULL_VALUE;
        } else if (arguments.length === 2) {
            const geomIndex = arguments[0], posIndex = arguments[1];
            return this._depth[geomIndex][posIndex] === Depth.NULL_VALUE;
        }
    }
    normalize() {
        for(let i = 0; i < 2; i++)if (!this.isNull(i)) {
            let minDepth = this._depth[i][1];
            if (this._depth[i][2] < minDepth) minDepth = this._depth[i][2];
            if (minDepth < 0) minDepth = 0;
            for(let j = 1; j < 3; j++){
                let newValue = 0;
                if (this._depth[i][j] > minDepth) newValue = 1;
                this._depth[i][j] = newValue;
            }
        }
    }
    getDelta(geomIndex) {
        return this._depth[geomIndex][(0, _positionJsDefault.default).RIGHT] - this._depth[geomIndex][(0, _positionJsDefault.default).LEFT];
    }
    getLocation(geomIndex, posIndex) {
        if (this._depth[geomIndex][posIndex] <= 0) return (0, _locationJsDefault.default).EXTERIOR;
        return (0, _locationJsDefault.default).INTERIOR;
    }
    toString() {
        return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2];
    }
    add() {
        if (arguments.length === 1) {
            const lbl = arguments[0];
            for(let i = 0; i < 2; i++)for(let j = 1; j < 3; j++){
                const loc = lbl.getLocation(i, j);
                if (loc === (0, _locationJsDefault.default).EXTERIOR || loc === (0, _locationJsDefault.default).INTERIOR) {
                    if (this.isNull(i, j)) this._depth[i][j] = Depth.depthAtLocation(loc);
                    else this._depth[i][j] += Depth.depthAtLocation(loc);
                }
            }
        } else if (arguments.length === 3) {
            const geomIndex = arguments[0], posIndex = arguments[1], location = arguments[2];
            if (location === (0, _locationJsDefault.default).INTERIOR) this._depth[geomIndex][posIndex]++;
        }
    }
}
exports.default = Depth;
Depth.NULL_VALUE = -1;

},{"../geom/Location.js":"71R1B","./Position.js":"929cL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4AI1O":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _monotoneChainIndexerJs = require("./MonotoneChainIndexer.js");
var _monotoneChainIndexerJsDefault = parcelHelpers.interopDefault(_monotoneChainIndexerJs);
var _envelopeJs = require("../../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class MonotoneChainEdge {
    constructor(){
        MonotoneChainEdge.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.e = null;
        this.pts = null;
        this.startIndex = null;
        const e = arguments[0];
        this.e = e;
        this.pts = e.getCoordinates();
        const mcb = new (0, _monotoneChainIndexerJsDefault.default)();
        this.startIndex = mcb.getChainStartIndices(this.pts);
    }
    getCoordinates() {
        return this.pts;
    }
    getMaxX(chainIndex) {
        const x1 = this.pts[this.startIndex[chainIndex]].x;
        const x2 = this.pts[this.startIndex[chainIndex + 1]].x;
        return x1 > x2 ? x1 : x2;
    }
    getMinX(chainIndex) {
        const x1 = this.pts[this.startIndex[chainIndex]].x;
        const x2 = this.pts[this.startIndex[chainIndex + 1]].x;
        return x1 < x2 ? x1 : x2;
    }
    computeIntersectsForChain() {
        if (arguments.length === 4) {
            const chainIndex0 = arguments[0], mce = arguments[1], chainIndex1 = arguments[2], si = arguments[3];
            this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);
        } else if (arguments.length === 6) {
            const start0 = arguments[0], end0 = arguments[1], mce = arguments[2], start1 = arguments[3], end1 = arguments[4], ei = arguments[5];
            if (end0 - start0 === 1 && end1 - start1 === 1) {
                ei.addIntersections(this.e, start0, mce.e, start1);
                return null;
            }
            if (!this.overlaps(start0, end0, mce, start1, end1)) return null;
            const mid0 = Math.trunc((start0 + end0) / 2);
            const mid1 = Math.trunc((start1 + end1) / 2);
            if (start0 < mid0) {
                if (start1 < mid1) this.computeIntersectsForChain(start0, mid0, mce, start1, mid1, ei);
                if (mid1 < end1) this.computeIntersectsForChain(start0, mid0, mce, mid1, end1, ei);
            }
            if (mid0 < end0) {
                if (start1 < mid1) this.computeIntersectsForChain(mid0, end0, mce, start1, mid1, ei);
                if (mid1 < end1) this.computeIntersectsForChain(mid0, end0, mce, mid1, end1, ei);
            }
        }
    }
    overlaps(start0, end0, mce, start1, end1) {
        return (0, _envelopeJsDefault.default).intersects(this.pts[start0], this.pts[end0], mce.pts[start1], mce.pts[end1]);
    }
    getStartIndexes() {
        return this.startIndex;
    }
    computeIntersects(mce, si) {
        for(let i = 0; i < this.startIndex.length - 1; i++)for(let j = 0; j < mce.startIndex.length - 1; j++)this.computeIntersectsForChain(i, mce, j, si);
    }
}
exports.default = MonotoneChainEdge;

},{"./MonotoneChainIndexer.js":"1SRyx","../../geom/Envelope.js":"ha5UZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1SRyx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _intArrayListJs = require("../../util/IntArrayList.js");
var _intArrayListJsDefault = parcelHelpers.interopDefault(_intArrayListJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _quadrantJs = require("../Quadrant.js");
var _quadrantJsDefault = parcelHelpers.interopDefault(_quadrantJs);
class MonotoneChainIndexer {
    static toIntArray(list) {
        const array = new Array(list.size()).fill(null);
        for(let i = 0; i < array.length; i++)array[i] = list.get(i).intValue();
        return array;
    }
    findChainEnd(pts, start) {
        const chainQuad = (0, _quadrantJsDefault.default).quadrant(pts[start], pts[start + 1]);
        let last = start + 1;
        while(last < pts.length){
            const quad = (0, _quadrantJsDefault.default).quadrant(pts[last - 1], pts[last]);
            if (quad !== chainQuad) break;
            last++;
        }
        return last - 1;
    }
    OLDgetChainStartIndices(pts) {
        let start = 0;
        const startIndexList = new (0, _arrayListJsDefault.default)();
        startIndexList.add(start);
        do {
            const last = this.findChainEnd(pts, start);
            startIndexList.add(last);
            start = last;
        }while (start < pts.length - 1);
        const startIndex = MonotoneChainIndexer.toIntArray(startIndexList);
        return startIndex;
    }
    getChainStartIndices(pts) {
        let start = 0;
        const startIndexList = new (0, _intArrayListJsDefault.default)(Math.trunc(pts.length / 2));
        startIndexList.add(start);
        do {
            const last = this.findChainEnd(pts, start);
            startIndexList.add(last);
            start = last;
        }while (start < pts.length - 1);
        return startIndexList.toArray();
    }
}
exports.default = MonotoneChainIndexer;

},{"../../util/IntArrayList.js":"dK9YJ","../../../../../java/util/ArrayList.js":"g8omH","../Quadrant.js":"hwMrb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dK9YJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arraysJs = require("../../../../java/util/Arrays.js");
var _arraysJsDefault = parcelHelpers.interopDefault(_arraysJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
class IntArrayList {
    constructor(){
        IntArrayList.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._data = null;
        this._size = 0;
        if (arguments.length === 0) IntArrayList.constructor_.call(this, 10);
        else if (arguments.length === 1) {
            const initialCapacity = arguments[0];
            this._data = new Array(initialCapacity).fill(null);
        }
    }
    size() {
        return this._size;
    }
    addAll(values) {
        if (values === null) return null;
        if (values.length === 0) return null;
        this.ensureCapacity(this._size + values.length);
        (0, _systemJsDefault.default).arraycopy(values, 0, this._data, this._size, values.length);
        this._size += values.length;
    }
    ensureCapacity(capacity) {
        if (capacity <= this._data.length) return null;
        const newLength = Math.max(capacity, this._data.length * 2);
        this._data = (0, _arraysJsDefault.default).copyOf(this._data, newLength);
    }
    toArray() {
        const array = new Array(this._size).fill(null);
        (0, _systemJsDefault.default).arraycopy(this._data, 0, array, 0, this._size);
        return array;
    }
    add(value) {
        this.ensureCapacity(this._size + 1);
        this._data[this._size] = value;
        ++this._size;
    }
}
exports.default = IntArrayList;

},{"../../../../java/util/Arrays.js":"8vEqO","../../../../java/lang/System.js":"11VqP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6c8UI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _boundaryNodeRuleJs = require("../algorithm/BoundaryNodeRule.js");
var _boundaryNodeRuleJsDefault = parcelHelpers.interopDefault(_boundaryNodeRuleJs);
var _geometryGraphJs = require("../geomgraph/GeometryGraph.js");
var _geometryGraphJsDefault = parcelHelpers.interopDefault(_geometryGraphJs);
var _robustLineIntersectorJs = require("../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
class GeometryGraphOperation {
    constructor(){
        GeometryGraphOperation.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._resultPrecisionModel = null;
        this._arg = null;
        if (arguments.length === 1) {
            const g0 = arguments[0];
            this.setComputationPrecision(g0.getPrecisionModel());
            this._arg = new Array(1).fill(null);
            this._arg[0] = new (0, _geometryGraphJsDefault.default)(0, g0);
        } else if (arguments.length === 2) {
            const g0 = arguments[0], g1 = arguments[1];
            GeometryGraphOperation.constructor_.call(this, g0, g1, (0, _boundaryNodeRuleJsDefault.default).OGC_SFS_BOUNDARY_RULE);
        } else if (arguments.length === 3) {
            const g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];
            if (g0.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) this.setComputationPrecision(g0.getPrecisionModel());
            else this.setComputationPrecision(g1.getPrecisionModel());
            this._arg = new Array(2).fill(null);
            this._arg[0] = new (0, _geometryGraphJsDefault.default)(0, g0, boundaryNodeRule);
            this._arg[1] = new (0, _geometryGraphJsDefault.default)(1, g1, boundaryNodeRule);
        }
    }
    setComputationPrecision(pm) {
        this._resultPrecisionModel = pm;
        this._li.setPrecisionModel(this._resultPrecisionModel);
    }
    getArgGeometry(i) {
        return this._arg[i].getGeometry();
    }
}
exports.default = GeometryGraphOperation;

},{"../algorithm/BoundaryNodeRule.js":"5geJz","../geomgraph/GeometryGraph.js":"3WOZk","../algorithm/RobustLineIntersector.js":"fBBRl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kMEug":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnaryUnionOp", ()=>(0, _unaryUnionOpJsDefault.default));
var _unaryUnionOpJs = require("./union/UnaryUnionOp.js");
var _unaryUnionOpJsDefault = parcelHelpers.interopDefault(_unaryUnionOpJs);

},{"./union/UnaryUnionOp.js":"alMZx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"alMZx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _collectionJs = require("../../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _snapIfNeededOverlayOpJs = require("../overlay/snap/SnapIfNeededOverlayOp.js");
var _snapIfNeededOverlayOpJsDefault = parcelHelpers.interopDefault(_snapIfNeededOverlayOpJs);
var _inputExtracterJs = require("./InputExtracter.js");
var _inputExtracterJsDefault = parcelHelpers.interopDefault(_inputExtracterJs);
var _geometryJs = require("../../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _pointGeometryUnionJs = require("./PointGeometryUnion.js");
var _pointGeometryUnionJsDefault = parcelHelpers.interopDefault(_pointGeometryUnionJs);
var _overlayOpJs = require("../overlay/OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
var _cascadedPolygonUnionJs = require("./CascadedPolygonUnion.js");
var _cascadedPolygonUnionJsDefault = parcelHelpers.interopDefault(_cascadedPolygonUnionJs);
class UnaryUnionOp {
    constructor(){
        UnaryUnionOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geomFact = null;
        this._extracter = null;
        if (arguments.length === 1) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
                const geoms = arguments[0];
                this.extract(geoms);
            } else if (arguments[0] instanceof (0, _geometryJsDefault.default)) {
                const geom = arguments[0];
                this.extract(geom);
            }
        } else if (arguments.length === 2) {
            const geoms = arguments[0], geomFact = arguments[1];
            this._geomFact = geomFact;
            this.extract(geoms);
        }
    }
    static union() {
        if (arguments.length === 1) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
                const geoms = arguments[0];
                const op = new UnaryUnionOp(geoms);
                return op.union();
            } else if (arguments[0] instanceof (0, _geometryJsDefault.default)) {
                const geom = arguments[0];
                const op = new UnaryUnionOp(geom);
                return op.union();
            }
        } else if (arguments.length === 2) {
            const geoms = arguments[0], geomFact = arguments[1];
            const op = new UnaryUnionOp(geoms, geomFact);
            return op.union();
        }
    }
    extract() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const geoms = arguments[0];
            this._extracter = (0, _inputExtracterJsDefault.default).extract(geoms);
        } else if (arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const geom = arguments[0];
            this._extracter = (0, _inputExtracterJsDefault.default).extract(geom);
        }
    }
    unionWithNull(g0, g1) {
        if (g0 === null && g1 === null) return null;
        if (g1 === null) return g0;
        if (g0 === null) return g1;
        return (0, _overlayOpJsDefault.default).union(g0, g1);
    }
    unionNoOpt(g0) {
        const empty = this._geomFact.createPoint();
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(g0, empty, (0, _overlayOpJsDefault.default).UNION);
    }
    union() {
        if (this._geomFact === null) this._geomFact = this._extracter.getFactory();
        if (this._geomFact === null) return null;
        if (this._extracter.isEmpty()) return this._geomFact.createEmpty(this._extracter.getDimension());
        const points = this._extracter.getExtract(0);
        const lines = this._extracter.getExtract(1);
        const polygons = this._extracter.getExtract(2);
        let unionPoints = null;
        if (points.size() > 0) {
            const ptGeom = this._geomFact.buildGeometry(points);
            unionPoints = this.unionNoOpt(ptGeom);
        }
        let unionLines = null;
        if (lines.size() > 0) {
            const lineGeom = this._geomFact.buildGeometry(lines);
            unionLines = this.unionNoOpt(lineGeom);
        }
        let unionPolygons = null;
        if (polygons.size() > 0) unionPolygons = (0, _cascadedPolygonUnionJsDefault.default).union(polygons);
        const unionLA = this.unionWithNull(unionLines, unionPolygons);
        let union = null;
        if (unionPoints === null) union = unionLA;
        else if (unionLA === null) union = unionPoints;
        else union = (0, _pointGeometryUnionJsDefault.default).union(unionPoints, unionLA);
        if (union === null) return this._geomFact.createGeometryCollection();
        return union;
    }
}
exports.default = UnaryUnionOp;

},{"../../../../../hasInterface.js":"d8mIo","../../../../../java/util/Collection.js":"fbl5V","../overlay/snap/SnapIfNeededOverlayOp.js":"3ISyI","./InputExtracter.js":"f3jox","../../geom/Geometry.js":"d5V2e","./PointGeometryUnion.js":"9OJ3y","../overlay/OverlayOp.js":"eclqj","./CascadedPolygonUnion.js":"3cZut","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ISyI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _snapOverlayOpJs = require("./SnapOverlayOp.js");
var _snapOverlayOpJsDefault = parcelHelpers.interopDefault(_snapOverlayOpJs);
var _runtimeExceptionJs = require("../../../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
var _overlayOpJs = require("../OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
class SnapIfNeededOverlayOp {
    constructor(){
        SnapIfNeededOverlayOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geom = new Array(2).fill(null);
        const g1 = arguments[0], g2 = arguments[1];
        this._geom[0] = g1;
        this._geom[1] = g2;
    }
    static overlayOp(g0, g1, opCode) {
        const op = new SnapIfNeededOverlayOp(g0, g1);
        return op.getResultGeometry(opCode);
    }
    static union(g0, g1) {
        return SnapIfNeededOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).UNION);
    }
    static intersection(g0, g1) {
        return SnapIfNeededOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).INTERSECTION);
    }
    static symDifference(g0, g1) {
        return SnapIfNeededOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).SYMDIFFERENCE);
    }
    static difference(g0, g1) {
        return SnapIfNeededOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).DIFFERENCE);
    }
    getResultGeometry(opCode) {
        let result = null;
        let isSuccess = false;
        let savedException = null;
        try {
            result = (0, _overlayOpJsDefault.default).overlayOp(this._geom[0], this._geom[1], opCode);
            const isValid = true;
            if (isValid) isSuccess = true;
        } catch (ex) {
            if (ex instanceof (0, _runtimeExceptionJsDefault.default)) savedException = ex;
            else throw ex;
        } finally{}
        if (!isSuccess) try {
            result = (0, _snapOverlayOpJsDefault.default).overlayOp(this._geom[0], this._geom[1], opCode);
        } catch (ex) {
            if (ex instanceof (0, _runtimeExceptionJsDefault.default)) throw savedException;
            else throw ex;
        } finally{}
        return result;
    }
}
exports.default = SnapIfNeededOverlayOp;

},{"./SnapOverlayOp.js":"37ROd","../../../../../../java/lang/RuntimeException.js":"1sBnT","../OverlayOp.js":"eclqj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"37ROd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometrySnapperJs = require("./GeometrySnapper.js");
var _geometrySnapperJsDefault = parcelHelpers.interopDefault(_geometrySnapperJs);
var _systemJs = require("../../../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _commonBitsRemoverJs = require("../../../precision/CommonBitsRemover.js");
var _commonBitsRemoverJsDefault = parcelHelpers.interopDefault(_commonBitsRemoverJs);
var _overlayOpJs = require("../OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
class SnapOverlayOp {
    constructor(){
        SnapOverlayOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geom = new Array(2).fill(null);
        this._snapTolerance = null;
        this._cbr = null;
        const g1 = arguments[0], g2 = arguments[1];
        this._geom[0] = g1;
        this._geom[1] = g2;
        this.computeSnapTolerance();
    }
    static overlayOp(g0, g1, opCode) {
        const op = new SnapOverlayOp(g0, g1);
        return op.getResultGeometry(opCode);
    }
    static union(g0, g1) {
        return SnapOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).UNION);
    }
    static intersection(g0, g1) {
        return SnapOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).INTERSECTION);
    }
    static symDifference(g0, g1) {
        return SnapOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).SYMDIFFERENCE);
    }
    static difference(g0, g1) {
        return SnapOverlayOp.overlayOp(g0, g1, (0, _overlayOpJsDefault.default).DIFFERENCE);
    }
    selfSnap(geom) {
        const snapper0 = new (0, _geometrySnapperJsDefault.default)(geom);
        const snapGeom = snapper0.snapTo(geom, this._snapTolerance);
        return snapGeom;
    }
    removeCommonBits(geom) {
        this._cbr = new (0, _commonBitsRemoverJsDefault.default)();
        this._cbr.add(geom[0]);
        this._cbr.add(geom[1]);
        const remGeom = new Array(2).fill(null);
        remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());
        remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());
        return remGeom;
    }
    prepareResult(geom) {
        this._cbr.addCommonBits(geom);
        return geom;
    }
    getResultGeometry(opCode) {
        const prepGeom = this.snap(this._geom);
        const result = (0, _overlayOpJsDefault.default).overlayOp(prepGeom[0], prepGeom[1], opCode);
        return this.prepareResult(result);
    }
    checkValid(g) {
        if (!g.isValid()) (0, _systemJsDefault.default).out.println('Snapped geometry is invalid');
    }
    computeSnapTolerance() {
        this._snapTolerance = (0, _geometrySnapperJsDefault.default).computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
    }
    snap(geom) {
        const remGeom = this.removeCommonBits(geom);
        const snapGeom = (0, _geometrySnapperJsDefault.default).snap(remGeom[0], remGeom[1], this._snapTolerance);
        return snapGeom;
    }
}
exports.default = SnapOverlayOp;

},{"./GeometrySnapper.js":"dWF2i","../../../../../../java/lang/System.js":"11VqP","../../../precision/CommonBitsRemover.js":"duHyp","../OverlayOp.js":"eclqj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dWF2i":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _treeSetJs = require("../../../../../../java/util/TreeSet.js");
var _treeSetJsDefault = parcelHelpers.interopDefault(_treeSetJs);
var _doubleJs = require("../../../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _bufferOpJs = require("../../buffer/BufferOp.js");
var _bufferOpJsDefault = parcelHelpers.interopDefault(_bufferOpJs);
var _lineStringSnapperJs = require("./LineStringSnapper.js");
var _lineStringSnapperJsDefault = parcelHelpers.interopDefault(_lineStringSnapperJs);
var _precisionModelJs = require("../../../geom/PrecisionModel.js");
var _precisionModelJsDefault = parcelHelpers.interopDefault(_precisionModelJs);
var _polygonalJs = require("../../../geom/Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _geometryTransformerJs = require("../../../geom/util/GeometryTransformer.js");
var _geometryTransformerJsDefault = parcelHelpers.interopDefault(_geometryTransformerJs);
var _hasInterfaceJs = require("../../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
class GeometrySnapper {
    constructor(){
        GeometrySnapper.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._srcGeom = null;
        const srcGeom = arguments[0];
        this._srcGeom = srcGeom;
    }
    static computeSizeBasedSnapTolerance(g) {
        const env = g.getEnvelopeInternal();
        const minDimension = Math.min(env.getHeight(), env.getWidth());
        const snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;
        return snapTol;
    }
    static computeOverlaySnapTolerance() {
        if (arguments.length === 1) {
            const g = arguments[0];
            let snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);
            const pm = g.getPrecisionModel();
            if (pm.getType() === (0, _precisionModelJsDefault.default).FIXED) {
                const fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;
                if (fixedSnapTol > snapTolerance) snapTolerance = fixedSnapTol;
            }
            return snapTolerance;
        } else if (arguments.length === 2) {
            const g0 = arguments[0], g1 = arguments[1];
            return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1));
        }
    }
    static snapToSelf(geom, snapTolerance, cleanResult) {
        const snapper0 = new GeometrySnapper(geom);
        return snapper0.snapToSelf(snapTolerance, cleanResult);
    }
    static snap(g0, g1, snapTolerance) {
        const snapGeom = new Array(2).fill(null);
        const snapper0 = new GeometrySnapper(g0);
        snapGeom[0] = snapper0.snapTo(g1, snapTolerance);
        const snapper1 = new GeometrySnapper(g1);
        snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);
        return snapGeom;
    }
    computeSnapTolerance(ringPts) {
        const minSegLen = this.computeMinimumSegmentLength(ringPts);
        const snapTol = minSegLen / 10;
        return snapTol;
    }
    snapTo(snapGeom, snapTolerance) {
        const snapPts = this.extractTargetCoordinates(snapGeom);
        const snapTrans = new SnapTransformer(snapTolerance, snapPts);
        return snapTrans.transform(this._srcGeom);
    }
    snapToSelf(snapTolerance, cleanResult) {
        const snapPts = this.extractTargetCoordinates(this._srcGeom);
        const snapTrans = new SnapTransformer(snapTolerance, snapPts, true);
        const snappedGeom = snapTrans.transform(this._srcGeom);
        let result = snappedGeom;
        if (cleanResult && (0, _hasInterfaceJsDefault.default)(result, (0, _polygonalJsDefault.default))) result = (0, _bufferOpJsDefault.default).bufferOp(snappedGeom, 0);
        return result;
    }
    extractTargetCoordinates(g) {
        const ptSet = new (0, _treeSetJsDefault.default)();
        const pts = g.getCoordinates();
        for(let i = 0; i < pts.length; i++)ptSet.add(pts[i]);
        return ptSet.toArray(new Array(0).fill(null));
    }
    computeMinimumSegmentLength(pts) {
        let minSegLen = (0, _doubleJsDefault.default).MAX_VALUE;
        for(let i = 0; i < pts.length - 1; i++){
            const segLen = pts[i].distance(pts[i + 1]);
            if (segLen < minSegLen) minSegLen = segLen;
        }
        return minSegLen;
    }
}
exports.default = GeometrySnapper;
GeometrySnapper.SNAP_PRECISION_FACTOR = 1e-9;
class SnapTransformer extends (0, _geometryTransformerJsDefault.default) {
    constructor(){
        super();
        SnapTransformer.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._snapTolerance = null;
        this._snapPts = null;
        this._isSelfSnap = false;
        if (arguments.length === 2) {
            const snapTolerance = arguments[0], snapPts = arguments[1];
            this._snapTolerance = snapTolerance;
            this._snapPts = snapPts;
        } else if (arguments.length === 3) {
            const snapTolerance = arguments[0], snapPts = arguments[1], isSelfSnap = arguments[2];
            this._snapTolerance = snapTolerance;
            this._snapPts = snapPts;
            this._isSelfSnap = isSelfSnap;
        }
    }
    transformCoordinates(coords, parent) {
        const srcPts = coords.toCoordinateArray();
        const newPts = this.snapLine(srcPts, this._snapPts);
        return this._factory.getCoordinateSequenceFactory().create(newPts);
    }
    snapLine(srcPts, snapPts) {
        const snapper = new (0, _lineStringSnapperJsDefault.default)(srcPts, this._snapTolerance);
        snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);
        return snapper.snapTo(snapPts);
    }
}

},{"../../../../../../java/util/TreeSet.js":"iQa9l","../../../../../../java/lang/Double.js":"jCc26","../../buffer/BufferOp.js":"a028O","./LineStringSnapper.js":"krn45","../../../geom/PrecisionModel.js":"9xUYw","../../../geom/Polygonal.js":"gO2Qf","../../../geom/util/GeometryTransformer.js":"6Tw5K","../../../../../../hasInterface.js":"d8mIo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a028O":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bufferParametersJs = require("./BufferParameters.js");
var _bufferParametersJsDefault = parcelHelpers.interopDefault(_bufferParametersJs);
var _scaledNoderJs = require("../../noding/ScaledNoder.js");
var _scaledNoderJsDefault = parcelHelpers.interopDefault(_scaledNoderJs);
var _topologyExceptionJs = require("../../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _mathUtilJs = require("../../math/MathUtil.js");
var _mathUtilJsDefault = parcelHelpers.interopDefault(_mathUtilJs);
var _precisionModelJs = require("../../geom/PrecisionModel.js");
var _precisionModelJsDefault = parcelHelpers.interopDefault(_precisionModelJs);
var _runtimeExceptionJs = require("../../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
var _mcindexSnapRounderJs = require("../../noding/snapround/MCIndexSnapRounder.js");
var _mcindexSnapRounderJsDefault = parcelHelpers.interopDefault(_mcindexSnapRounderJs);
var _geometryJs = require("../../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _bufferBuilderJs = require("./BufferBuilder.js");
var _bufferBuilderJsDefault = parcelHelpers.interopDefault(_bufferBuilderJs);
class BufferOp {
    constructor(){
        BufferOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._argGeom = null;
        this._distance = null;
        this._bufParams = new (0, _bufferParametersJsDefault.default)();
        this._resultGeometry = null;
        this._saveException = null;
        if (arguments.length === 1) {
            const g = arguments[0];
            this._argGeom = g;
        } else if (arguments.length === 2) {
            const g = arguments[0], bufParams = arguments[1];
            this._argGeom = g;
            this._bufParams = bufParams;
        }
    }
    static bufferOp() {
        if (arguments.length === 2) {
            const g = arguments[0], distance = arguments[1];
            const gBuf = new BufferOp(g);
            const geomBuf = gBuf.getResultGeometry(distance);
            return geomBuf;
        } else if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof (0, _geometryJsDefault.default) && typeof arguments[1] === 'number') {
                const g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2];
                const bufOp = new BufferOp(g);
                bufOp.setQuadrantSegments(quadrantSegments);
                const geomBuf = bufOp.getResultGeometry(distance);
                return geomBuf;
            } else if (arguments[2] instanceof (0, _bufferParametersJsDefault.default) && arguments[0] instanceof (0, _geometryJsDefault.default) && typeof arguments[1] === 'number') {
                const g = arguments[0], distance = arguments[1], params = arguments[2];
                const bufOp = new BufferOp(g, params);
                const geomBuf = bufOp.getResultGeometry(distance);
                return geomBuf;
            }
        } else if (arguments.length === 4) {
            const g = arguments[0], distance = arguments[1], quadrantSegments = arguments[2], endCapStyle = arguments[3];
            const bufOp = new BufferOp(g);
            bufOp.setQuadrantSegments(quadrantSegments);
            bufOp.setEndCapStyle(endCapStyle);
            const geomBuf = bufOp.getResultGeometry(distance);
            return geomBuf;
        }
    }
    static precisionScaleFactor(g, distance, maxPrecisionDigits) {
        const env = g.getEnvelopeInternal();
        const envMax = (0, _mathUtilJsDefault.default).max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));
        const expandByDistance = distance > 0.0 ? distance : 0.0;
        const bufEnvMax = envMax + 2 * expandByDistance;
        const bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);
        const minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;
        const scaleFactor = Math.pow(10.0, minUnitLog10);
        return scaleFactor;
    }
    bufferFixedPrecision(fixedPM) {
        const noder = new (0, _scaledNoderJsDefault.default)(new (0, _mcindexSnapRounderJsDefault.default)(new (0, _precisionModelJsDefault.default)(1.0)), fixedPM.getScale());
        const bufBuilder = new (0, _bufferBuilderJsDefault.default)(this._bufParams);
        bufBuilder.setWorkingPrecisionModel(fixedPM);
        bufBuilder.setNoder(noder);
        this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
    }
    bufferReducedPrecision() {
        if (arguments.length === 0) {
            for(let precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--){
                try {
                    this.bufferReducedPrecision(precDigits);
                } catch (ex) {
                    if (ex instanceof (0, _topologyExceptionJsDefault.default)) this._saveException = ex;
                    else throw ex;
                } finally{}
                if (this._resultGeometry !== null) return null;
            }
            throw this._saveException;
        } else if (arguments.length === 1) {
            const precisionDigits = arguments[0];
            const sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);
            const fixedPM = new (0, _precisionModelJsDefault.default)(sizeBasedScaleFactor);
            this.bufferFixedPrecision(fixedPM);
        }
    }
    bufferOriginalPrecision() {
        try {
            const bufBuilder = new (0, _bufferBuilderJsDefault.default)(this._bufParams);
            this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);
        } catch (ex) {
            if (ex instanceof (0, _runtimeExceptionJsDefault.default)) this._saveException = ex;
            else throw ex;
        } finally{}
    }
    getResultGeometry(distance) {
        this._distance = distance;
        this.computeGeometry();
        return this._resultGeometry;
    }
    setEndCapStyle(endCapStyle) {
        this._bufParams.setEndCapStyle(endCapStyle);
    }
    computeGeometry() {
        this.bufferOriginalPrecision();
        if (this._resultGeometry !== null) return null;
        const argPM = this._argGeom.getFactory().getPrecisionModel();
        if (argPM.getType() === (0, _precisionModelJsDefault.default).FIXED) this.bufferFixedPrecision(argPM);
        else this.bufferReducedPrecision();
    }
    setQuadrantSegments(quadrantSegments) {
        this._bufParams.setQuadrantSegments(quadrantSegments);
    }
}
exports.default = BufferOp;
BufferOp.CAP_ROUND = (0, _bufferParametersJsDefault.default).CAP_ROUND;
BufferOp.CAP_BUTT = (0, _bufferParametersJsDefault.default).CAP_FLAT;
BufferOp.CAP_FLAT = (0, _bufferParametersJsDefault.default).CAP_FLAT;
BufferOp.CAP_SQUARE = (0, _bufferParametersJsDefault.default).CAP_SQUARE;
BufferOp.MAX_PRECISION_DIGITS = 12;

},{"./BufferParameters.js":"frCaq","../../noding/ScaledNoder.js":"f4MhO","../../geom/TopologyException.js":"cGr97","../../math/MathUtil.js":"hTgav","../../geom/PrecisionModel.js":"9xUYw","../../../../../java/lang/RuntimeException.js":"1sBnT","../../noding/snapround/MCIndexSnapRounder.js":"ixmUI","../../geom/Geometry.js":"d5V2e","./BufferBuilder.js":"9lFpX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"frCaq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class BufferParameters {
    constructor(){
        BufferParameters.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
        this._endCapStyle = BufferParameters.CAP_ROUND;
        this._joinStyle = BufferParameters.JOIN_ROUND;
        this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;
        this._isSingleSided = false;
        this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const quadrantSegments = arguments[0];
            this.setQuadrantSegments(quadrantSegments);
        } else if (arguments.length === 2) {
            const quadrantSegments = arguments[0], endCapStyle = arguments[1];
            this.setQuadrantSegments(quadrantSegments);
            this.setEndCapStyle(endCapStyle);
        } else if (arguments.length === 4) {
            const quadrantSegments = arguments[0], endCapStyle = arguments[1], joinStyle = arguments[2], mitreLimit = arguments[3];
            this.setQuadrantSegments(quadrantSegments);
            this.setEndCapStyle(endCapStyle);
            this.setJoinStyle(joinStyle);
            this.setMitreLimit(mitreLimit);
        }
    }
    static bufferDistanceError(quadSegs) {
        const alpha = Math.PI / 2.0 / quadSegs;
        return 1 - Math.cos(alpha / 2.0);
    }
    getEndCapStyle() {
        return this._endCapStyle;
    }
    isSingleSided() {
        return this._isSingleSided;
    }
    setQuadrantSegments(quadSegs) {
        this._quadrantSegments = quadSegs;
        if (this._quadrantSegments === 0) this._joinStyle = BufferParameters.JOIN_BEVEL;
        if (this._quadrantSegments < 0) {
            this._joinStyle = BufferParameters.JOIN_MITRE;
            this._mitreLimit = Math.abs(this._quadrantSegments);
        }
        if (quadSegs <= 0) this._quadrantSegments = 1;
        if (this._joinStyle !== BufferParameters.JOIN_ROUND) this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;
    }
    getJoinStyle() {
        return this._joinStyle;
    }
    setJoinStyle(joinStyle) {
        this._joinStyle = joinStyle;
    }
    setSimplifyFactor(simplifyFactor) {
        this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;
    }
    getSimplifyFactor() {
        return this._simplifyFactor;
    }
    getQuadrantSegments() {
        return this._quadrantSegments;
    }
    setEndCapStyle(endCapStyle) {
        this._endCapStyle = endCapStyle;
    }
    getMitreLimit() {
        return this._mitreLimit;
    }
    setMitreLimit(mitreLimit) {
        this._mitreLimit = mitreLimit;
    }
    setSingleSided(isSingleSided) {
        this._isSingleSided = isSingleSided;
    }
}
exports.default = BufferParameters;
BufferParameters.CAP_ROUND = 1;
BufferParameters.CAP_FLAT = 2;
BufferParameters.CAP_SQUARE = 3;
BufferParameters.JOIN_ROUND = 1;
BufferParameters.JOIN_MITRE = 2;
BufferParameters.JOIN_BEVEL = 3;
BufferParameters.DEFAULT_QUADRANT_SEGMENTS = 8;
BufferParameters.DEFAULT_MITRE_LIMIT = 5.0;
BufferParameters.DEFAULT_SIMPLIFY_FACTOR = 0.01;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f4MhO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _nodedSegmentStringJs = require("./NodedSegmentString.js");
var _nodedSegmentStringJsDefault = parcelHelpers.interopDefault(_nodedSegmentStringJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _coordinateArraysJs = require("../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _collectionJs = require("../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _noderJs = require("./Noder.js");
var _noderJsDefault = parcelHelpers.interopDefault(_noderJs);
class ScaledNoder {
    constructor(){
        ScaledNoder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._noder = null;
        this._scaleFactor = null;
        this._offsetX = null;
        this._offsetY = null;
        this._isScaled = false;
        if (arguments.length === 2) {
            const noder = arguments[0], scaleFactor = arguments[1];
            ScaledNoder.constructor_.call(this, noder, scaleFactor, 0, 0);
        } else if (arguments.length === 4) {
            const noder = arguments[0], scaleFactor = arguments[1], offsetX = arguments[2], offsetY = arguments[3];
            this._noder = noder;
            this._scaleFactor = scaleFactor;
            this._isScaled = !this.isIntegerPrecision();
        }
    }
    rescale() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const segStrings = arguments[0];
            for(let i = segStrings.iterator(); i.hasNext();){
                const ss = i.next();
                this.rescale(ss.getCoordinates());
            }
        } else if (arguments[0] instanceof Array) {
            const pts = arguments[0];
            for(let i = 0; i < pts.length; i++){
                pts[i].x = pts[i].x / this._scaleFactor + this._offsetX;
                pts[i].y = pts[i].y / this._scaleFactor + this._offsetY;
            }
            if (pts.length === 2 && pts[0].equals2D(pts[1])) (0, _systemJsDefault.default).out.println(pts);
        }
    }
    scale() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const segStrings = arguments[0];
            const nodedSegmentStrings = new (0, _arrayListJsDefault.default)(segStrings.size());
            for(let i = segStrings.iterator(); i.hasNext();){
                const ss = i.next();
                nodedSegmentStrings.add(new (0, _nodedSegmentStringJsDefault.default)(this.scale(ss.getCoordinates()), ss.getData()));
            }
            return nodedSegmentStrings;
        } else if (arguments[0] instanceof Array) {
            const pts = arguments[0];
            const roundPts = new Array(pts.length).fill(null);
            for(let i = 0; i < pts.length; i++)roundPts[i] = new (0, _coordinateJsDefault.default)(Math.round((pts[i].x - this._offsetX) * this._scaleFactor), Math.round((pts[i].y - this._offsetY) * this._scaleFactor), pts[i].getZ());
            const roundPtsNoDup = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(roundPts);
            return roundPtsNoDup;
        }
    }
    isIntegerPrecision() {
        return this._scaleFactor === 1.0;
    }
    getNodedSubstrings() {
        const splitSS = this._noder.getNodedSubstrings();
        if (this._isScaled) this.rescale(splitSS);
        return splitSS;
    }
    computeNodes(inputSegStrings) {
        let intSegStrings = inputSegStrings;
        if (this._isScaled) intSegStrings = this.scale(inputSegStrings);
        this._noder.computeNodes(intSegStrings);
    }
    get interfaces_() {
        return [
            (0, _noderJsDefault.default)
        ];
    }
}
exports.default = ScaledNoder;

},{"../../../../hasInterface.js":"d8mIo","../geom/Coordinate.js":"3REUb","./NodedSegmentString.js":"lhvbm","../../../../java/lang/System.js":"11VqP","../geom/CoordinateArrays.js":"hwXsf","../../../../java/util/ArrayList.js":"g8omH","../../../../java/util/Collection.js":"fbl5V","./Noder.js":"ct7GF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lhvbm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _segmentNodeListJs = require("./SegmentNodeList.js");
var _segmentNodeListJsDefault = parcelHelpers.interopDefault(_segmentNodeListJs);
var _wktwriterJs = require("../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _coordinateArraySequenceJs = require("../geom/impl/CoordinateArraySequence.js");
var _coordinateArraySequenceJsDefault = parcelHelpers.interopDefault(_coordinateArraySequenceJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _octantJs = require("./Octant.js");
var _octantJsDefault = parcelHelpers.interopDefault(_octantJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _nodableSegmentStringJs = require("./NodableSegmentString.js");
var _nodableSegmentStringJsDefault = parcelHelpers.interopDefault(_nodableSegmentStringJs);
class NodedSegmentString {
    constructor(){
        NodedSegmentString.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._nodeList = new (0, _segmentNodeListJsDefault.default)(this);
        this._pts = null;
        this._data = null;
        const pts = arguments[0], data = arguments[1];
        this._pts = pts;
        this._data = data;
    }
    static getNodedSubstrings() {
        if (arguments.length === 1) {
            const segStrings = arguments[0];
            const resultEdgelist = new (0, _arrayListJsDefault.default)();
            NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);
            return resultEdgelist;
        } else if (arguments.length === 2) {
            const segStrings = arguments[0], resultEdgelist = arguments[1];
            for(let i = segStrings.iterator(); i.hasNext();){
                const ss = i.next();
                ss.getNodeList().addSplitEdges(resultEdgelist);
            }
        }
    }
    getCoordinates() {
        return this._pts;
    }
    size() {
        return this._pts.length;
    }
    getCoordinate(i) {
        return this._pts[i];
    }
    isClosed() {
        return this._pts[0].equals(this._pts[this._pts.length - 1]);
    }
    getSegmentOctant(index) {
        if (index === this._pts.length - 1) return -1;
        return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1));
    }
    toString() {
        return (0, _wktwriterJsDefault.default).toLineString(new (0, _coordinateArraySequenceJsDefault.default)(this._pts));
    }
    getNodeList() {
        return this._nodeList;
    }
    addIntersectionNode(intPt, segmentIndex) {
        let normalizedSegmentIndex = segmentIndex;
        const nextSegIndex = normalizedSegmentIndex + 1;
        if (nextSegIndex < this._pts.length) {
            const nextPt = this._pts[nextSegIndex];
            if (intPt.equals2D(nextPt)) normalizedSegmentIndex = nextSegIndex;
        }
        const ei = this._nodeList.add(intPt, normalizedSegmentIndex);
        return ei;
    }
    addIntersections(li, segmentIndex, geomIndex) {
        for(let i = 0; i < li.getIntersectionNum(); i++)this.addIntersection(li, segmentIndex, geomIndex, i);
    }
    setData(data) {
        this._data = data;
    }
    safeOctant(p0, p1) {
        if (p0.equals2D(p1)) return 0;
        return (0, _octantJsDefault.default).octant(p0, p1);
    }
    getData() {
        return this._data;
    }
    addIntersection() {
        if (arguments.length === 2) {
            const intPt = arguments[0], segmentIndex = arguments[1];
            this.addIntersectionNode(intPt, segmentIndex);
        } else if (arguments.length === 4) {
            const li = arguments[0], segmentIndex = arguments[1], geomIndex = arguments[2], intIndex = arguments[3];
            const intPt = new (0, _coordinateJsDefault.default)(li.getIntersection(intIndex));
            this.addIntersection(intPt, segmentIndex);
        }
    }
    get interfaces_() {
        return [
            (0, _nodableSegmentStringJsDefault.default)
        ];
    }
}
exports.default = NodedSegmentString;

},{"./SegmentNodeList.js":"lATFa","../io/WKTWriter.js":"gvRTy","../geom/impl/CoordinateArraySequence.js":"bdL5X","../geom/Coordinate.js":"3REUb","./Octant.js":"cMygk","../../../../java/util/ArrayList.js":"g8omH","./NodableSegmentString.js":"lU3kT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lATFa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateListJs = require("../geom/CoordinateList.js");
var _coordinateListJsDefault = parcelHelpers.interopDefault(_coordinateListJs);
var _segmentNodeJs = require("./SegmentNode.js");
var _segmentNodeJsDefault = parcelHelpers.interopDefault(_segmentNodeJs);
var _iteratorJs = require("../../../../java/util/Iterator.js");
var _iteratorJsDefault = parcelHelpers.interopDefault(_iteratorJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _nodedSegmentStringJs = require("./NodedSegmentString.js");
var _nodedSegmentStringJsDefault = parcelHelpers.interopDefault(_nodedSegmentStringJs);
var _integerJs = require("../../../../java/lang/Integer.js");
var _integerJsDefault = parcelHelpers.interopDefault(_integerJs);
var _unsupportedOperationExceptionJs = require("../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _treeMapJs = require("../../../../java/util/TreeMap.js");
var _treeMapJsDefault = parcelHelpers.interopDefault(_treeMapJs);
var _runtimeExceptionJs = require("../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class SegmentNodeList {
    constructor(){
        SegmentNodeList.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._nodeMap = new (0, _treeMapJsDefault.default)();
        this._edge = null;
        const edge = arguments[0];
        this._edge = edge;
    }
    getSplitCoordinates() {
        const coordList = new (0, _coordinateListJsDefault.default)();
        this.addEndpoints();
        const it = this.iterator();
        let eiPrev = it.next();
        while(it.hasNext()){
            const ei = it.next();
            this.addEdgeCoordinates(eiPrev, ei, coordList);
            eiPrev = ei;
        }
        return coordList.toCoordinateArray();
    }
    print(out) {
        out.println('Intersections:');
        for(let it = this.iterator(); it.hasNext();){
            const ei = it.next();
            ei.print(out);
        }
    }
    findCollapsesFromExistingVertices(collapsedVertexIndexes) {
        for(let i = 0; i < this._edge.size() - 2; i++){
            const p0 = this._edge.getCoordinate(i);
            const p1 = this._edge.getCoordinate(i + 1);
            const p2 = this._edge.getCoordinate(i + 2);
            if (p0.equals2D(p2)) collapsedVertexIndexes.add((0, _integerJsDefault.default).valueOf(i + 1));
        }
    }
    addEdgeCoordinates(ei0, ei1, coordList) {
        const pts = this.createSplitEdgePts(ei0, ei1);
        coordList.add(pts, false);
    }
    findCollapseIndex(ei0, ei1, collapsedVertexIndex) {
        if (!ei0.coord.equals2D(ei1.coord)) return false;
        let numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;
        if (!ei1.isInterior()) numVerticesBetween--;
        if (numVerticesBetween === 1) {
            collapsedVertexIndex[0] = ei0.segmentIndex + 1;
            return true;
        }
        return false;
    }
    findCollapsesFromInsertedNodes(collapsedVertexIndexes) {
        const collapsedVertexIndex = new Array(1).fill(null);
        const it = this.iterator();
        let eiPrev = it.next();
        while(it.hasNext()){
            const ei = it.next();
            const isCollapsed = this.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);
            if (isCollapsed) collapsedVertexIndexes.add((0, _integerJsDefault.default).valueOf(collapsedVertexIndex[0]));
            eiPrev = ei;
        }
    }
    getEdge() {
        return this._edge;
    }
    addEndpoints() {
        const maxSegIndex = this._edge.size() - 1;
        this.add(this._edge.getCoordinate(0), 0);
        this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);
    }
    createSplitEdge(ei0, ei1) {
        const pts = this.createSplitEdgePts(ei0, ei1);
        return new (0, _nodedSegmentStringJsDefault.default)(pts, this._edge.getData());
    }
    add(intPt, segmentIndex) {
        const eiNew = new (0, _segmentNodeJsDefault.default)(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));
        const ei = this._nodeMap.get(eiNew);
        if (ei !== null) {
            (0, _assertJsDefault.default).isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');
            return ei;
        }
        this._nodeMap.put(eiNew, eiNew);
        return eiNew;
    }
    checkSplitEdgesCorrectness(splitEdges) {
        const edgePts = this._edge.getCoordinates();
        const split0 = splitEdges.get(0);
        const pt0 = split0.getCoordinate(0);
        if (!pt0.equals2D(edgePts[0])) throw new (0, _runtimeExceptionJsDefault.default)('bad split edge start point at ' + pt0);
        const splitn = splitEdges.get(splitEdges.size() - 1);
        const splitnPts = splitn.getCoordinates();
        const ptn = splitnPts[splitnPts.length - 1];
        if (!ptn.equals2D(edgePts[edgePts.length - 1])) throw new (0, _runtimeExceptionJsDefault.default)('bad split edge end point at ' + ptn);
    }
    addCollapsedNodes() {
        const collapsedVertexIndexes = new (0, _arrayListJsDefault.default)();
        this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);
        this.findCollapsesFromExistingVertices(collapsedVertexIndexes);
        for(let it = collapsedVertexIndexes.iterator(); it.hasNext();){
            const vertexIndex = it.next().intValue();
            this.add(this._edge.getCoordinate(vertexIndex), vertexIndex);
        }
    }
    createSplitEdgePts(ei0, ei1) {
        let npts = ei1.segmentIndex - ei0.segmentIndex + 2;
        if (npts === 2) return [
            new (0, _coordinateJsDefault.default)(ei0.coord),
            new (0, _coordinateJsDefault.default)(ei1.coord)
        ];
        const lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);
        const useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);
        if (!useIntPt1) npts--;
        const pts = new Array(npts).fill(null);
        let ipt = 0;
        pts[ipt++] = new (0, _coordinateJsDefault.default)(ei0.coord);
        for(let i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++)pts[ipt++] = this._edge.getCoordinate(i);
        if (useIntPt1) pts[ipt] = new (0, _coordinateJsDefault.default)(ei1.coord);
        return pts;
    }
    iterator() {
        return this._nodeMap.values().iterator();
    }
    addSplitEdges(edgeList) {
        this.addEndpoints();
        this.addCollapsedNodes();
        const it = this.iterator();
        let eiPrev = it.next();
        while(it.hasNext()){
            const ei = it.next();
            const newEdge = this.createSplitEdge(eiPrev, ei);
            edgeList.add(newEdge);
            eiPrev = ei;
        }
    }
}
exports.default = SegmentNodeList;
class NodeVertexIterator {
    constructor(){
        NodeVertexIterator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._nodeList = null;
        this._edge = null;
        this._nodeIt = null;
        this._currNode = null;
        this._nextNode = null;
        this._currSegIndex = 0;
        const nodeList = arguments[0];
        this._nodeList = nodeList;
        this._edge = nodeList.getEdge();
        this._nodeIt = nodeList.iterator();
        this.readNextNode();
    }
    next() {
        if (this._currNode === null) {
            this._currNode = this._nextNode;
            this._currSegIndex = this._currNode.segmentIndex;
            this.readNextNode();
            return this._currNode;
        }
        if (this._nextNode === null) return null;
        if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {
            this._currNode = this._nextNode;
            this._currSegIndex = this._currNode.segmentIndex;
            this.readNextNode();
            return this._currNode;
        }
        this._nextNode.segmentIndex, this._currNode.segmentIndex;
        return null;
    }
    readNextNode() {
        if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next();
        else this._nextNode = null;
    }
    hasNext() {
        if (this._nextNode === null) return false;
        return true;
    }
    remove() {
        throw new (0, _unsupportedOperationExceptionJsDefault.default)(this.getClass().getName());
    }
    get interfaces_() {
        return [
            (0, _iteratorJsDefault.default)
        ];
    }
}

},{"../geom/CoordinateList.js":"39sXT","./SegmentNode.js":"cLbBG","../../../../java/util/Iterator.js":"d9RWN","../geom/Coordinate.js":"3REUb","./NodedSegmentString.js":"lhvbm","../../../../java/lang/Integer.js":"9MkbL","../../../../java/lang/UnsupportedOperationException.js":"fEx26","../../../../java/util/ArrayList.js":"g8omH","../../../../java/util/TreeMap.js":"3VPI6","../../../../java/lang/RuntimeException.js":"1sBnT","../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cLbBG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _segmentPointComparatorJs = require("./SegmentPointComparator.js");
var _segmentPointComparatorJsDefault = parcelHelpers.interopDefault(_segmentPointComparatorJs);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
class SegmentNode {
    constructor(){
        SegmentNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._segString = null;
        this.coord = null;
        this.segmentIndex = null;
        this._segmentOctant = null;
        this._isInterior = null;
        const segString = arguments[0], coord = arguments[1], segmentIndex = arguments[2], segmentOctant = arguments[3];
        this._segString = segString;
        this.coord = new (0, _coordinateJsDefault.default)(coord);
        this.segmentIndex = segmentIndex;
        this._segmentOctant = segmentOctant;
        this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));
    }
    getCoordinate() {
        return this.coord;
    }
    print(out) {
        out.print(this.coord);
        out.print(' seg # = ' + this.segmentIndex);
    }
    compareTo(obj) {
        const other = obj;
        if (this.segmentIndex < other.segmentIndex) return -1;
        if (this.segmentIndex > other.segmentIndex) return 1;
        if (this.coord.equals2D(other.coord)) return 0;
        if (!this._isInterior) return -1;
        if (!other._isInterior) return 1;
        return (0, _segmentPointComparatorJsDefault.default).compare(this._segmentOctant, this.coord, other.coord);
    }
    isEndPoint(maxSegmentIndex) {
        if (this.segmentIndex === 0 && !this._isInterior) return true;
        if (this.segmentIndex === maxSegmentIndex) return true;
        return false;
    }
    toString() {
        return this.segmentIndex + ':' + this.coord.toString();
    }
    isInterior() {
        return this._isInterior;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = SegmentNode;

},{"../geom/Coordinate.js":"3REUb","./SegmentPointComparator.js":"iJVqE","../../../../java/lang/Comparable.js":"6Adw4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iJVqE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class SegmentPointComparator {
    static relativeSign(x0, x1) {
        if (x0 < x1) return -1;
        if (x0 > x1) return 1;
        return 0;
    }
    static compareValue(compareSign0, compareSign1) {
        if (compareSign0 < 0) return -1;
        if (compareSign0 > 0) return 1;
        if (compareSign1 < 0) return -1;
        if (compareSign1 > 0) return 1;
        return 0;
    }
    static compare(octant, p0, p1) {
        if (p0.equals2D(p1)) return 0;
        const xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);
        const ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);
        switch(octant){
            case 0:
                return SegmentPointComparator.compareValue(xSign, ySign);
            case 1:
                return SegmentPointComparator.compareValue(ySign, xSign);
            case 2:
                return SegmentPointComparator.compareValue(ySign, -xSign);
            case 3:
                return SegmentPointComparator.compareValue(-xSign, ySign);
            case 4:
                return SegmentPointComparator.compareValue(-xSign, -ySign);
            case 5:
                return SegmentPointComparator.compareValue(-ySign, -xSign);
            case 6:
                return SegmentPointComparator.compareValue(-ySign, xSign);
            case 7:
                return SegmentPointComparator.compareValue(xSign, -ySign);
        }
        (0, _assertJsDefault.default).shouldNeverReachHere('invalid octant value');
        return 0;
    }
}
exports.default = SegmentPointComparator;

},{"../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cMygk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class Octant {
    static octant() {
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            const dx = arguments[0], dy = arguments[1];
            if (dx === 0.0 && dy === 0.0) throw new (0, _illegalArgumentExceptionJsDefault.default)('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )');
            const adx = Math.abs(dx);
            const ady = Math.abs(dy);
            if (dx >= 0) {
                if (dy >= 0) {
                    if (adx >= ady) return 0;
                    else return 1;
                } else if (adx >= ady) return 7;
                else return 6;
            } else if (dy >= 0) {
                if (adx >= ady) return 3;
                else return 2;
            } else if (adx >= ady) return 4;
            else return 5;
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
            const p0 = arguments[0], p1 = arguments[1];
            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;
            if (dx === 0.0 && dy === 0.0) throw new (0, _illegalArgumentExceptionJsDefault.default)('Cannot compute the octant for two identical points ' + p0);
            return Octant.octant(dx, dy);
        }
    }
}
exports.default = Octant;

},{"../geom/Coordinate.js":"3REUb","../../../../java/lang/IllegalArgumentException.js":"1VQhm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lU3kT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _segmentStringJs = require("./SegmentString.js");
var _segmentStringJsDefault = parcelHelpers.interopDefault(_segmentStringJs);
class NodableSegmentString {
    addIntersection(intPt, segmentIndex) {}
    get interfaces_() {
        return [
            (0, _segmentStringJsDefault.default)
        ];
    }
}
exports.default = NodableSegmentString;

},{"./SegmentString.js":"dLqAE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dLqAE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class SegmentString {
    getCoordinates() {}
    size() {}
    getCoordinate(i) {}
    isClosed() {}
    setData(data) {}
    getData() {}
}
exports.default = SegmentString;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ct7GF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Noder {
    getNodedSubstrings() {}
    computeNodes(segStrings) {}
}
exports.default = Noder;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ixmUI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nodingValidatorJs = require("../NodingValidator.js");
var _nodingValidatorJsDefault = parcelHelpers.interopDefault(_nodingValidatorJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _mcindexNoderJs = require("../MCIndexNoder.js");
var _mcindexNoderJsDefault = parcelHelpers.interopDefault(_mcindexNoderJs);
var _nodedSegmentStringJs = require("../NodedSegmentString.js");
var _nodedSegmentStringJsDefault = parcelHelpers.interopDefault(_nodedSegmentStringJs);
var _hotPixelJs = require("./HotPixel.js");
var _hotPixelJsDefault = parcelHelpers.interopDefault(_hotPixelJs);
var _exceptionJs = require("../../../../../java/lang/Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
var _mcindexPointSnapperJs = require("./MCIndexPointSnapper.js");
var _mcindexPointSnapperJsDefault = parcelHelpers.interopDefault(_mcindexPointSnapperJs);
var _robustLineIntersectorJs = require("../../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _interiorIntersectionFinderAdderJs = require("../InteriorIntersectionFinderAdder.js");
var _interiorIntersectionFinderAdderJsDefault = parcelHelpers.interopDefault(_interiorIntersectionFinderAdderJs);
var _collectionJs = require("../../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _noderJs = require("../Noder.js");
var _noderJsDefault = parcelHelpers.interopDefault(_noderJs);
class MCIndexSnapRounder {
    constructor(){
        MCIndexSnapRounder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._pm = null;
        this._li = null;
        this._scaleFactor = null;
        this._noder = null;
        this._pointSnapper = null;
        this._nodedSegStrings = null;
        const pm = arguments[0];
        this._pm = pm;
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._li.setPrecisionModel(pm);
        this._scaleFactor = pm.getScale();
    }
    checkCorrectness(inputSegmentStrings) {
        const resultSegStrings = (0, _nodedSegmentStringJsDefault.default).getNodedSubstrings(inputSegmentStrings);
        const nv = new (0, _nodingValidatorJsDefault.default)(resultSegStrings);
        try {
            nv.checkValid();
        } catch (ex) {
            if (ex instanceof (0, _exceptionJsDefault.default)) ex.printStackTrace();
            else throw ex;
        } finally{}
    }
    getNodedSubstrings() {
        return (0, _nodedSegmentStringJsDefault.default).getNodedSubstrings(this._nodedSegStrings);
    }
    snapRound(segStrings, li) {
        const intersections = this.findInteriorIntersections(segStrings, li);
        this.computeIntersectionSnaps(intersections);
        this.computeVertexSnaps(segStrings);
    }
    findInteriorIntersections(segStrings, li) {
        const intFinderAdder = new (0, _interiorIntersectionFinderAdderJsDefault.default)(li);
        this._noder.setSegmentIntersector(intFinderAdder);
        this._noder.computeNodes(segStrings);
        return intFinderAdder.getInteriorIntersections();
    }
    computeVertexSnaps() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const edges = arguments[0];
            for(let i0 = edges.iterator(); i0.hasNext();){
                const edge0 = i0.next();
                this.computeVertexSnaps(edge0);
            }
        } else if (arguments[0] instanceof (0, _nodedSegmentStringJsDefault.default)) {
            const e = arguments[0];
            const pts0 = e.getCoordinates();
            for(let i = 0; i < pts0.length; i++){
                const hotPixel = new (0, _hotPixelJsDefault.default)(pts0[i], this._scaleFactor, this._li);
                const isNodeAdded = this._pointSnapper.snap(hotPixel, e, i);
                if (isNodeAdded) e.addIntersection(pts0[i], i);
            }
        }
    }
    computeNodes(inputSegmentStrings) {
        this._nodedSegStrings = inputSegmentStrings;
        this._noder = new (0, _mcindexNoderJsDefault.default)();
        this._pointSnapper = new (0, _mcindexPointSnapperJsDefault.default)(this._noder.getIndex());
        this.snapRound(inputSegmentStrings, this._li);
    }
    computeIntersectionSnaps(snapPts) {
        for(let it = snapPts.iterator(); it.hasNext();){
            const snapPt = it.next();
            const hotPixel = new (0, _hotPixelJsDefault.default)(snapPt, this._scaleFactor, this._li);
            this._pointSnapper.snap(hotPixel);
        }
    }
    get interfaces_() {
        return [
            (0, _noderJsDefault.default)
        ];
    }
}
exports.default = MCIndexSnapRounder;

},{"../NodingValidator.js":"k69tZ","../../../../../hasInterface.js":"d8mIo","../MCIndexNoder.js":"9G0qr","../NodedSegmentString.js":"lhvbm","./HotPixel.js":"2qJxX","../../../../../java/lang/Exception.js":"gSmog","./MCIndexPointSnapper.js":"630Xn","../../algorithm/RobustLineIntersector.js":"fBBRl","../InteriorIntersectionFinderAdder.js":"aa40V","../../../../../java/util/Collection.js":"fbl5V","../Noder.js":"ct7GF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k69tZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryFactoryJs = require("../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _robustLineIntersectorJs = require("../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _runtimeExceptionJs = require("../../../../java/lang/RuntimeException.js");
var _runtimeExceptionJsDefault = parcelHelpers.interopDefault(_runtimeExceptionJs);
class NodingValidator {
    constructor(){
        NodingValidator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._segStrings = null;
        const segStrings = arguments[0];
        this._segStrings = segStrings;
    }
    checkEndPtVertexIntersections() {
        if (arguments.length === 0) for(let i = this._segStrings.iterator(); i.hasNext();){
            const ss = i.next();
            const pts = ss.getCoordinates();
            this.checkEndPtVertexIntersections(pts[0], this._segStrings);
            this.checkEndPtVertexIntersections(pts[pts.length - 1], this._segStrings);
        }
        else if (arguments.length === 2) {
            const testPt = arguments[0], segStrings = arguments[1];
            for(let i = segStrings.iterator(); i.hasNext();){
                const ss = i.next();
                const pts = ss.getCoordinates();
                for(let j = 1; j < pts.length - 1; j++)if (pts[j].equals(testPt)) throw new (0, _runtimeExceptionJsDefault.default)('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt);
            }
        }
    }
    checkInteriorIntersections() {
        if (arguments.length === 0) for(let i = this._segStrings.iterator(); i.hasNext();){
            const ss0 = i.next();
            for(let j = this._segStrings.iterator(); j.hasNext();){
                const ss1 = j.next();
                this.checkInteriorIntersections(ss0, ss1);
            }
        }
        else if (arguments.length === 2) {
            const ss0 = arguments[0], ss1 = arguments[1];
            const pts0 = ss0.getCoordinates();
            const pts1 = ss1.getCoordinates();
            for(let i0 = 0; i0 < pts0.length - 1; i0++)for(let i1 = 0; i1 < pts1.length - 1; i1++)this.checkInteriorIntersections(ss0, i0, ss1, i1);
        } else if (arguments.length === 4) {
            const e0 = arguments[0], segIndex0 = arguments[1], e1 = arguments[2], segIndex1 = arguments[3];
            if (e0 === e1 && segIndex0 === segIndex1) return null;
            const p00 = e0.getCoordinates()[segIndex0];
            const p01 = e0.getCoordinates()[segIndex0 + 1];
            const p10 = e1.getCoordinates()[segIndex1];
            const p11 = e1.getCoordinates()[segIndex1 + 1];
            this._li.computeIntersection(p00, p01, p10, p11);
            if (this._li.hasIntersection()) {
                if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) throw new (0, _runtimeExceptionJsDefault.default)('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11);
            }
        }
    }
    checkValid() {
        this.checkEndPtVertexIntersections();
        this.checkInteriorIntersections();
        this.checkCollapses();
    }
    checkCollapses() {
        if (arguments.length === 0) for(let i = this._segStrings.iterator(); i.hasNext();){
            const ss = i.next();
            this.checkCollapses(ss);
        }
        else if (arguments.length === 1) {
            const ss = arguments[0];
            const pts = ss.getCoordinates();
            for(let i = 0; i < pts.length - 2; i++)this.checkCollapse(pts[i], pts[i + 1], pts[i + 2]);
        }
    }
    hasInteriorIntersection(li, p0, p1) {
        for(let i = 0; i < li.getIntersectionNum(); i++){
            const intPt = li.getIntersection(i);
            if (!(intPt.equals(p0) || intPt.equals(p1))) return true;
        }
        return false;
    }
    checkCollapse(p0, p1, p2) {
        if (p0.equals(p2)) throw new (0, _runtimeExceptionJsDefault.default)('found non-noded collapse at ' + NodingValidator.fact.createLineString([
            p0,
            p1,
            p2
        ]));
    }
}
exports.default = NodingValidator;
NodingValidator.fact = new (0, _geometryFactoryJsDefault.default)();

},{"../geom/GeometryFactory.js":"6Ct9y","../algorithm/RobustLineIntersector.js":"fBBRl","../../../../java/lang/RuntimeException.js":"1sBnT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9G0qr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _strtreeJs = require("../index/strtree/STRtree.js");
var _strtreeJsDefault = parcelHelpers.interopDefault(_strtreeJs);
var _nodedSegmentStringJs = require("./NodedSegmentString.js");
var _nodedSegmentStringJsDefault = parcelHelpers.interopDefault(_nodedSegmentStringJs);
var _monotoneChainOverlapActionJs = require("../index/chain/MonotoneChainOverlapAction.js");
var _monotoneChainOverlapActionJsDefault = parcelHelpers.interopDefault(_monotoneChainOverlapActionJs);
var _monotoneChainBuilderJs = require("../index/chain/MonotoneChainBuilder.js");
var _monotoneChainBuilderJsDefault = parcelHelpers.interopDefault(_monotoneChainBuilderJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _singlePassNoderJs = require("./SinglePassNoder.js");
var _singlePassNoderJsDefault = parcelHelpers.interopDefault(_singlePassNoderJs);
class MCIndexNoder extends (0, _singlePassNoderJsDefault.default) {
    constructor(){
        super();
        MCIndexNoder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._monoChains = new (0, _arrayListJsDefault.default)();
        this._index = new (0, _strtreeJsDefault.default)();
        this._idCounter = 0;
        this._nodedSegStrings = null;
        this._nOverlaps = 0;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const si = arguments[0];
            (0, _singlePassNoderJsDefault.default).constructor_.call(this, si);
        }
    }
    getMonotoneChains() {
        return this._monoChains;
    }
    getNodedSubstrings() {
        return (0, _nodedSegmentStringJsDefault.default).getNodedSubstrings(this._nodedSegStrings);
    }
    getIndex() {
        return this._index;
    }
    add(segStr) {
        const segChains = (0, _monotoneChainBuilderJsDefault.default).getChains(segStr.getCoordinates(), segStr);
        for(let i = segChains.iterator(); i.hasNext();){
            const mc = i.next();
            mc.setId(this._idCounter++);
            this._index.insert(mc.getEnvelope(), mc);
            this._monoChains.add(mc);
        }
    }
    computeNodes(inputSegStrings) {
        this._nodedSegStrings = inputSegStrings;
        for(let i = inputSegStrings.iterator(); i.hasNext();)this.add(i.next());
        this.intersectChains();
    }
    intersectChains() {
        const overlapAction = new SegmentOverlapAction(this._segInt);
        for(let i = this._monoChains.iterator(); i.hasNext();){
            const queryChain = i.next();
            const overlapChains = this._index.query(queryChain.getEnvelope());
            for(let j = overlapChains.iterator(); j.hasNext();){
                const testChain = j.next();
                if (testChain.getId() > queryChain.getId()) {
                    queryChain.computeOverlaps(testChain, overlapAction);
                    this._nOverlaps++;
                }
                if (this._segInt.isDone()) return null;
            }
        }
    }
}
exports.default = MCIndexNoder;
class SegmentOverlapAction extends (0, _monotoneChainOverlapActionJsDefault.default) {
    constructor(){
        super();
        SegmentOverlapAction.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._si = null;
        const si = arguments[0];
        this._si = si;
    }
    overlap() {
        if (arguments.length === 4) {
            const mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3];
            const ss1 = mc1.getContext();
            const ss2 = mc2.getContext();
            this._si.processIntersections(ss1, start1, ss2, start2);
        } else return super.overlap.apply(this, arguments);
    }
}
MCIndexNoder.SegmentOverlapAction = SegmentOverlapAction;

},{"../index/strtree/STRtree.js":"55J20","./NodedSegmentString.js":"lhvbm","../index/chain/MonotoneChainOverlapAction.js":"4mFQi","../index/chain/MonotoneChainBuilder.js":"jEEzN","../../../../java/util/ArrayList.js":"g8omH","./SinglePassNoder.js":"8ZqYQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"55J20":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itemBoundableJs = require("./ItemBoundable.js");
var _itemBoundableJsDefault = parcelHelpers.interopDefault(_itemBoundableJs);
var _priorityQueueJs = require("../../../../../java/util/PriorityQueue.js");
var _priorityQueueJsDefault = parcelHelpers.interopDefault(_priorityQueueJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _doubleJs = require("../../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _spatialIndexJs = require("../SpatialIndex.js");
var _spatialIndexJsDefault = parcelHelpers.interopDefault(_spatialIndexJs);
var _abstractNodeJs = require("./AbstractNode.js");
var _abstractNodeJsDefault = parcelHelpers.interopDefault(_abstractNodeJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
var _boundablePairJs = require("./BoundablePair.js");
var _boundablePairJsDefault = parcelHelpers.interopDefault(_boundablePairJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _comparatorJs = require("../../../../../java/util/Comparator.js");
var _comparatorJsDefault = parcelHelpers.interopDefault(_comparatorJs);
var _envelopeJs = require("../../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _abstractSTRtreeJs = require("./AbstractSTRtree.js");
var _abstractSTRtreeJsDefault = parcelHelpers.interopDefault(_abstractSTRtreeJs);
var _itemDistanceJs = require("./ItemDistance.js");
var _itemDistanceJsDefault = parcelHelpers.interopDefault(_itemDistanceJs);
class STRtree extends (0, _abstractSTRtreeJsDefault.default) {
    constructor(){
        super();
        STRtree.constructor_.apply(this, arguments);
    }
    static constructor_() {
        if (arguments.length === 0) STRtree.constructor_.call(this, STRtree.DEFAULT_NODE_CAPACITY);
        else if (arguments.length === 1) {
            const nodeCapacity = arguments[0];
            (0, _abstractSTRtreeJsDefault.default).constructor_.call(this, nodeCapacity);
        }
    }
    static getItems(kNearestNeighbors) {
        const items = new Array(kNearestNeighbors.size()).fill(null);
        let count = 0;
        while(!kNearestNeighbors.isEmpty()){
            const bp = kNearestNeighbors.poll();
            items[count] = bp.getBoundable(0).getItem();
            count++;
        }
        return items;
    }
    static avg(a, b) {
        return (a + b) / 2;
    }
    static centreY(e) {
        return STRtree.avg(e.getMinY(), e.getMaxY());
    }
    static centreX(e) {
        return STRtree.avg(e.getMinX(), e.getMaxX());
    }
    size() {
        if (arguments.length === 0) return super.size.call(this);
        else return super.size.apply(this, arguments);
    }
    insert() {
        if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof (0, _envelopeJsDefault.default)) {
            const itemEnv = arguments[0], item = arguments[1];
            if (itemEnv.isNull()) return null;
            super.insert.call(this, itemEnv, item);
        } else return super.insert.apply(this, arguments);
    }
    getIntersectsOp() {
        return STRtree.intersectsOp;
    }
    verticalSlices(childBoundables, sliceCount) {
        const sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));
        const slices = new Array(sliceCount).fill(null);
        const i = childBoundables.iterator();
        for(let j = 0; j < sliceCount; j++){
            slices[j] = new (0, _arrayListJsDefault.default)();
            let boundablesAddedToSlice = 0;
            while(i.hasNext() && boundablesAddedToSlice < sliceCapacity){
                const childBoundable = i.next();
                slices[j].add(childBoundable);
                boundablesAddedToSlice++;
            }
        }
        return slices;
    }
    query() {
        if (arguments.length === 1) {
            const searchEnv = arguments[0];
            return super.query.call(this, searchEnv);
        } else if (arguments.length === 2) {
            const searchEnv = arguments[0], visitor = arguments[1];
            super.query.call(this, searchEnv, visitor);
        }
    }
    getComparator() {
        return STRtree.yComparator;
    }
    createParentBoundablesFromVerticalSlice(childBoundables, newLevel) {
        return super.createParentBoundables.call(this, childBoundables, newLevel);
    }
    remove() {
        if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof (0, _envelopeJsDefault.default)) {
            const itemEnv = arguments[0], item = arguments[1];
            return super.remove.call(this, itemEnv, item);
        } else return super.remove.apply(this, arguments);
    }
    depth() {
        if (arguments.length === 0) return super.depth.call(this);
        else return super.depth.apply(this, arguments);
    }
    createParentBoundables(childBoundables, newLevel) {
        (0, _assertJsDefault.default).isTrue(!childBoundables.isEmpty());
        const minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));
        const sortedChildBoundables = new (0, _arrayListJsDefault.default)(childBoundables);
        (0, _collectionsJsDefault.default).sort(sortedChildBoundables, STRtree.xComparator);
        const verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));
        return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel);
    }
    nearestNeighbour() {
        if (arguments.length === 1) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _itemDistanceJsDefault.default))) {
                const itemDist = arguments[0];
                if (this.isEmpty()) return null;
                const bp = new (0, _boundablePairJsDefault.default)(this.getRoot(), this.getRoot(), itemDist);
                return this.nearestNeighbour(bp);
            } else if (arguments[0] instanceof (0, _boundablePairJsDefault.default)) {
                const initBndPair = arguments[0];
                let distanceLowerBound = (0, _doubleJsDefault.default).POSITIVE_INFINITY;
                let minPair = null;
                const priQ = new (0, _priorityQueueJsDefault.default)();
                priQ.add(initBndPair);
                while(!priQ.isEmpty() && distanceLowerBound > 0.0){
                    const bndPair = priQ.poll();
                    const pairDistance = bndPair.getDistance();
                    if (pairDistance >= distanceLowerBound) break;
                    if (bndPair.isLeaves()) {
                        distanceLowerBound = pairDistance;
                        minPair = bndPair;
                    } else bndPair.expandToQueue(priQ, distanceLowerBound);
                }
                if (minPair === null) return null;
                return [
                    minPair.getBoundable(0).getItem(),
                    minPair.getBoundable(1).getItem()
                ];
            }
        } else if (arguments.length === 2) {
            const tree = arguments[0], itemDist = arguments[1];
            if (this.isEmpty() || tree.isEmpty()) return null;
            const bp = new (0, _boundablePairJsDefault.default)(this.getRoot(), tree.getRoot(), itemDist);
            return this.nearestNeighbour(bp);
        } else if (arguments.length === 3) {
            const env = arguments[0], item = arguments[1], itemDist = arguments[2];
            const bnd = new (0, _itemBoundableJsDefault.default)(env, item);
            const bp = new (0, _boundablePairJsDefault.default)(this.getRoot(), bnd, itemDist);
            return this.nearestNeighbour(bp)[0];
        } else if (arguments.length === 4) {
            const env = arguments[0], item = arguments[1], itemDist = arguments[2], k = arguments[3];
            const bnd = new (0, _itemBoundableJsDefault.default)(env, item);
            const bp = new (0, _boundablePairJsDefault.default)(this.getRoot(), bnd, itemDist);
            return this.nearestNeighbourK(bp, k);
        }
    }
    isWithinDistance() {
        if (arguments.length === 2) {
            const initBndPair = arguments[0], maxDistance = arguments[1];
            let distanceUpperBound = (0, _doubleJsDefault.default).POSITIVE_INFINITY;
            const priQ = new (0, _priorityQueueJsDefault.default)();
            priQ.add(initBndPair);
            while(!priQ.isEmpty()){
                const bndPair = priQ.poll();
                const pairDistance = bndPair.getDistance();
                if (pairDistance > maxDistance) return false;
                if (bndPair.maximumDistance() <= maxDistance) return true;
                if (bndPair.isLeaves()) {
                    distanceUpperBound = pairDistance;
                    if (distanceUpperBound <= maxDistance) return true;
                } else bndPair.expandToQueue(priQ, distanceUpperBound);
            }
            return false;
        } else if (arguments.length === 3) {
            const tree = arguments[0], itemDist = arguments[1], maxDistance = arguments[2];
            const bp = new (0, _boundablePairJsDefault.default)(this.getRoot(), tree.getRoot(), itemDist);
            return this.isWithinDistance(bp, maxDistance);
        }
    }
    createParentBoundablesFromVerticalSlices(verticalSlices, newLevel) {
        (0, _assertJsDefault.default).isTrue(verticalSlices.length > 0);
        const parentBoundables = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < verticalSlices.length; i++)parentBoundables.addAll(this.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));
        return parentBoundables;
    }
    nearestNeighbourK() {
        if (arguments.length === 2) {
            const initBndPair = arguments[0], k = arguments[1];
            return this.nearestNeighbourK(initBndPair, (0, _doubleJsDefault.default).POSITIVE_INFINITY, k);
        } else if (arguments.length === 3) {
            const initBndPair = arguments[0], maxDistance = arguments[1], k = arguments[2];
            let distanceLowerBound = maxDistance;
            const priQ = new (0, _priorityQueueJsDefault.default)();
            priQ.add(initBndPair);
            const kNearestNeighbors = new (0, _priorityQueueJsDefault.default)();
            while(!priQ.isEmpty() && distanceLowerBound >= 0.0){
                const bndPair = priQ.poll();
                const pairDistance = bndPair.getDistance();
                if (pairDistance >= distanceLowerBound) break;
                if (bndPair.isLeaves()) {
                    if (kNearestNeighbors.size() < k) kNearestNeighbors.add(bndPair);
                    else {
                        const bp1 = kNearestNeighbors.peek();
                        if (bp1.getDistance() > pairDistance) {
                            kNearestNeighbors.poll();
                            kNearestNeighbors.add(bndPair);
                        }
                        const bp2 = kNearestNeighbors.peek();
                        distanceLowerBound = bp2.getDistance();
                    }
                } else bndPair.expandToQueue(priQ, distanceLowerBound);
            }
            return STRtree.getItems(kNearestNeighbors);
        }
    }
    createNode(level) {
        return new STRtreeNode(level);
    }
    get interfaces_() {
        return [
            (0, _spatialIndexJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = STRtree;
class STRtreeNode extends (0, _abstractNodeJsDefault.default) {
    constructor(){
        super();
        STRtreeNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const level = arguments[0];
        (0, _abstractNodeJsDefault.default).constructor_.call(this, level);
    }
    computeBounds() {
        let bounds = null;
        for(let i = this.getChildBoundables().iterator(); i.hasNext();){
            const childBoundable = i.next();
            if (bounds === null) bounds = new (0, _envelopeJsDefault.default)(childBoundable.getBounds());
            else bounds.expandToInclude(childBoundable.getBounds());
        }
        return bounds;
    }
}
STRtree.STRtreeNode = STRtreeNode;
STRtree.xComparator = new class {
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
    compare(o1, o2) {
        return (0, _abstractSTRtreeJsDefault.default).compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()));
    }
}();
STRtree.yComparator = new class {
    get interfaces_() {
        return [
            (0, _comparatorJsDefault.default)
        ];
    }
    compare(o1, o2) {
        return (0, _abstractSTRtreeJsDefault.default).compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()));
    }
}();
STRtree.intersectsOp = new class {
    get interfaces_() {
        return [
            IntersectsOp
        ];
    }
    intersects(aBounds, bBounds) {
        return aBounds.intersects(bBounds);
    }
}();
STRtree.DEFAULT_NODE_CAPACITY = 10;

},{"./ItemBoundable.js":"k9yKX","../../../../../java/util/PriorityQueue.js":"kQ9lk","../../../../../hasInterface.js":"d8mIo","../../../../../java/lang/Double.js":"jCc26","../../../../../java/io/Serializable.js":"4emqV","../SpatialIndex.js":"8FXwD","./AbstractNode.js":"azb4P","../../../../../java/util/Collections.js":"hUg9B","./BoundablePair.js":"cBBct","../../../../../java/util/ArrayList.js":"g8omH","../../../../../java/util/Comparator.js":"6CEtH","../../geom/Envelope.js":"ha5UZ","../../util/Assert.js":"ePbcB","./AbstractSTRtree.js":"3Drhz","./ItemDistance.js":"4helj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k9yKX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _boundableJs = require("./Boundable.js");
var _boundableJsDefault = parcelHelpers.interopDefault(_boundableJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
class ItemBoundable {
    constructor(){
        ItemBoundable.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._bounds = null;
        this._item = null;
        const bounds = arguments[0], item = arguments[1];
        this._bounds = bounds;
        this._item = item;
    }
    getItem() {
        return this._item;
    }
    getBounds() {
        return this._bounds;
    }
    get interfaces_() {
        return [
            (0, _boundableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = ItemBoundable;

},{"./Boundable.js":"8PIcP","../../../../../java/io/Serializable.js":"4emqV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8PIcP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Boundable {
    getBounds() {}
}
exports.default = Boundable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kQ9lk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastpriorityqueue = require("fastpriorityqueue");
var _fastpriorityqueueDefault = parcelHelpers.interopDefault(_fastpriorityqueue);
class PriorityQueue {
    constructor(){
        this._fpQueue = new (0, _fastpriorityqueueDefault.default)((a, b)=>a.compareTo(b) < 0);
    }
    poll() {
        return this._fpQueue.poll();
    }
    size() {
        return this._fpQueue.size;
    }
    clear() {
        this._fpQueue = new (0, _fastpriorityqueueDefault.default)();
    }
    peek() {
        return this._fpQueue.peek();
    }
    remove() {
        return this._fpQueue.poll();
    }
    isEmpty() {
        return this._fpQueue.isEmpty();
    }
    add(x) {
        this._fpQueue.add(x);
    }
}
exports.default = PriorityQueue;

},{"fastpriorityqueue":"8CJHA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8CJHA":[function(require,module,exports,__globalThis) {
/**
 * FastPriorityQueue.js : a fast heap-based priority queue  in JavaScript.
 * (c) the authors
 * Licensed under the Apache License, Version 2.0.
 *
 * Speed-optimized heap-based priority queue for modern browsers and JavaScript engines.
 *
 * Usage :
         Installation (in shell, if you use node):
         $ npm install fastpriorityqueue

         Running test program (in JavaScript):

         // var FastPriorityQueue = require("fastpriorityqueue");// in node
         var x = new FastPriorityQueue();
         x.add(1);
         x.add(0);
         x.add(5);
         x.add(4);
         x.add(3);
         x.peek(); // should return 0, leaves x unchanged
         x.size; // should return 5, leaves x unchanged
         while(!x.isEmpty()) {
           console.log(x.poll());
         } // will print 0 1 3 4 5
         x.trim(); // (optional) optimizes memory usage
 */ 'use strict';
var defaultcomparator = function(a, b) {
    return a < b;
};
// construct a new priority queue
// the provided comparator function should take a, b and return *true* when a < b
function FastPriorityQueue(comparator) {
    if (!(this instanceof FastPriorityQueue)) return new FastPriorityQueue(comparator);
    this.array = [];
    this.size = 0;
    this.compare = comparator || defaultcomparator;
}
// copy the priority queue into another, and return it. Queue items are shallow-copied.
// Runs in `O(n)` time.
FastPriorityQueue.prototype.clone = function() {
    var fpq = new FastPriorityQueue(this.compare);
    fpq.size = this.size;
    fpq.array = this.array.slice(0, this.size);
    return fpq;
};
// add an element into the queue
// runs in `O(log n)` time
FastPriorityQueue.prototype.add = function(myval) {
    var i = this.size;
    this.array[this.size] = myval;
    this.size += 1;
    var p;
    var ap;
    while(i > 0){
        p = i - 1 >> 1;
        ap = this.array[p];
        if (!this.compare(myval, ap)) break;
        this.array[i] = ap;
        i = p;
    }
    this.array[i] = myval;
};
// replace the content of the heap by provided array and "heapify it"
FastPriorityQueue.prototype.heapify = function(arr) {
    this.array = arr;
    this.size = arr.length;
    var i;
    for(i = this.size >> 1; i >= 0; i--)this._percolateDown(i);
};
// for internal use
FastPriorityQueue.prototype._percolateUp = function(i, force) {
    var myval = this.array[i];
    var p;
    var ap;
    while(i > 0){
        p = i - 1 >> 1;
        ap = this.array[p];
        // force will skip the compare
        if (!force && !this.compare(myval, ap)) break;
        this.array[i] = ap;
        i = p;
    }
    this.array[i] = myval;
};
// for internal use
FastPriorityQueue.prototype._percolateDown = function(i) {
    var size = this.size;
    var hsize = this.size >>> 1;
    var ai = this.array[i];
    var l;
    var r;
    var bestc;
    while(i < hsize){
        l = (i << 1) + 1;
        r = l + 1;
        bestc = this.array[l];
        if (r < size) {
            if (this.compare(this.array[r], bestc)) {
                l = r;
                bestc = this.array[r];
            }
        }
        if (!this.compare(bestc, ai)) break;
        this.array[i] = bestc;
        i = l;
    }
    this.array[i] = ai;
};
// internal
// _removeAt(index) will remove the item at the given index from the queue,
// retaining balance. returns the removed item, or undefined if nothing is removed.
FastPriorityQueue.prototype._removeAt = function(index) {
    if (index > this.size - 1 || index < 0) return undefined;
    // impl1:
    //this.array.splice(index, 1);
    //this.heapify(this.array);
    // impl2:
    this._percolateUp(index, true);
    return this.poll();
};
// remove(myval) will remove an item matching the provided value from the
// queue, checked for equality by using the queue's comparator.
// return true if removed, false otherwise.
FastPriorityQueue.prototype.remove = function(myval) {
    for(var i = 0; i < this.size; i++)if (!this.compare(this.array[i], myval) && !this.compare(myval, this.array[i])) {
        // items match, comparator returns false both ways, remove item
        this._removeAt(i);
        return true;
    }
    return false;
};
// removeOne(callback) will execute the callback function for each item of the queue
// and will remove the first item for which the callback will return true.
// return the removed item, or undefined if nothing is removed.
FastPriorityQueue.prototype.removeOne = function(callback) {
    if (typeof callback !== "function") return undefined;
    for(var i = 0; i < this.size; i++){
        if (callback(this.array[i])) return this._removeAt(i);
    }
};
// remove(callback[, limit]) will execute the callback function for each item of
// the queue and will remove each item for which the callback returns true, up to
// a max limit of removed items if specified or no limit if unspecified.
// return an array containing the removed items.
// The callback function should be a pure function.
FastPriorityQueue.prototype.removeMany = function(callback, limit) {
    // Skip unnecessary processing for edge cases
    if (typeof callback !== "function" || this.size < 1) return [];
    limit = limit ? Math.min(limit, this.size) : this.size;
    // Prepare the results container to hold up to the results limit
    var resultSize = 0;
    var result = new Array(limit);
    // Prepare a temporary array to hold items we'll traverse through and need to keep
    var tmpSize = 0;
    var tmp = new Array(this.size);
    while(resultSize < limit && !this.isEmpty()){
        // Dequeue items into either the results or our temporary array
        var item = this.poll();
        if (callback(item)) result[resultSize++] = item;
        else tmp[tmpSize++] = item;
    }
    // Update the result array with the exact number of results
    result.length = resultSize;
    // Re-add all the items we can keep
    var i = 0;
    while(i < tmpSize)this.add(tmp[i++]);
    return result;
};
// Look at the top of the queue (one of the smallest elements) without removing it
// executes in constant time
//
// Calling peek on an empty priority queue returns
// the "undefined" value.
// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined
//
FastPriorityQueue.prototype.peek = function() {
    if (this.size == 0) return undefined;
    return this.array[0];
};
// remove the element on top of the heap (one of the smallest elements)
// runs in logarithmic time
//
// If the priority queue is empty, the function returns the
// "undefined" value.
// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined
//
// For long-running and large priority queues, or priority queues
// storing large objects, you may  want to call the trim function
// at strategic times to recover allocated memory.
FastPriorityQueue.prototype.poll = function() {
    if (this.size == 0) return undefined;
    var ans = this.array[0];
    if (this.size > 1) {
        this.array[0] = this.array[--this.size];
        this._percolateDown(0);
    } else this.size -= 1;
    return ans;
};
// This function adds the provided value to the heap, while removing
// and returning one of the smallest elements (like poll). The size of the queue
// thus remains unchanged.
FastPriorityQueue.prototype.replaceTop = function(myval) {
    if (this.size == 0) return undefined;
    var ans = this.array[0];
    this.array[0] = myval;
    this._percolateDown(0);
    return ans;
};
// recover unused memory (for long-running priority queues)
FastPriorityQueue.prototype.trim = function() {
    this.array = this.array.slice(0, this.size);
};
// Check whether the heap is empty
FastPriorityQueue.prototype.isEmpty = function() {
    return this.size === 0;
};
// iterate over the items in order, pass a callback that receives (item, index) as args.
// TODO once we transpile, uncomment
// if (Symbol && Symbol.iterator) {
//   FastPriorityQueue.prototype[Symbol.iterator] = function*() {
//     if (this.isEmpty()) return;
//     var fpq = this.clone();
//     while (!fpq.isEmpty()) {
//       yield fpq.poll();
//     }
//   };
// }
FastPriorityQueue.prototype.forEach = function(callback) {
    if (this.isEmpty() || typeof callback != 'function') return;
    var i = 0;
    var fpq = this.clone();
    while(!fpq.isEmpty())callback(fpq.poll(), i++);
};
// return the k 'smallest' elements of the queue as an array,
// runs in O(k log k) time, the elements are not removed
// from the priority queue.
FastPriorityQueue.prototype.kSmallest = function(k) {
    if (this.size == 0 || k <= 0) return [];
    k = Math.min(this.size, k);
    const newSize = Math.min(this.size, 2 ** (k - 1) + 1);
    if (newSize < 2) return [
        this.peek()
    ];
    const fpq = new FastPriorityQueue(this.compare);
    fpq.size = newSize;
    fpq.array = this.array.slice(0, newSize);
    const smallest = new Array(k);
    for(let i = 0; i < k; i++)smallest[i] = fpq.poll();
    return smallest;
};
module.exports = FastPriorityQueue;

},{}],"8FXwD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class SpatialIndex {
    query() {
        if (arguments.length === 1) {
            const searchEnv = arguments[0];
        } else if (arguments.length === 2) {
            const searchEnv = arguments[0], visitor = arguments[1];
        }
    }
    insert(itemEnv, item) {}
    remove(itemEnv, item) {}
}
exports.default = SpatialIndex;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"azb4P":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _boundableJs = require("./Boundable.js");
var _boundableJsDefault = parcelHelpers.interopDefault(_boundableJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class AbstractNode {
    constructor(){
        AbstractNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._childBoundables = new (0, _arrayListJsDefault.default)();
        this._bounds = null;
        this._level = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const level = arguments[0];
            this._level = level;
        }
    }
    getLevel() {
        return this._level;
    }
    addChildBoundable(childBoundable) {
        (0, _assertJsDefault.default).isTrue(this._bounds === null);
        this._childBoundables.add(childBoundable);
    }
    isEmpty() {
        return this._childBoundables.isEmpty();
    }
    getBounds() {
        if (this._bounds === null) this._bounds = this.computeBounds();
        return this._bounds;
    }
    size() {
        return this._childBoundables.size();
    }
    getChildBoundables() {
        return this._childBoundables;
    }
    get interfaces_() {
        return [
            (0, _boundableJsDefault.default),
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = AbstractNode;

},{"./Boundable.js":"8PIcP","../../../../../java/util/ArrayList.js":"g8omH","../../../../../java/io/Serializable.js":"4emqV","../../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cBBct":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _illegalArgumentExceptionJs = require("../../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _abstractNodeJs = require("./AbstractNode.js");
var _abstractNodeJsDefault = parcelHelpers.interopDefault(_abstractNodeJs);
var _envelopeDistanceJs = require("./EnvelopeDistance.js");
var _envelopeDistanceJsDefault = parcelHelpers.interopDefault(_envelopeDistanceJs);
var _comparableJs = require("../../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
class BoundablePair {
    constructor(){
        BoundablePair.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._boundable1 = null;
        this._boundable2 = null;
        this._distance = null;
        this._itemDistance = null;
        const boundable1 = arguments[0], boundable2 = arguments[1], itemDistance = arguments[2];
        this._boundable1 = boundable1;
        this._boundable2 = boundable2;
        this._itemDistance = itemDistance;
        this._distance = this.distance();
    }
    static area(b) {
        return b.getBounds().getArea();
    }
    static isComposite(item) {
        return item instanceof (0, _abstractNodeJsDefault.default);
    }
    maximumDistance() {
        return (0, _envelopeDistanceJsDefault.default).maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
    }
    expandToQueue(priQ, minDistance) {
        const isComp1 = BoundablePair.isComposite(this._boundable1);
        const isComp2 = BoundablePair.isComposite(this._boundable2);
        if (isComp1 && isComp2) {
            if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {
                this.expand(this._boundable1, this._boundable2, false, priQ, minDistance);
                return null;
            } else {
                this.expand(this._boundable2, this._boundable1, true, priQ, minDistance);
                return null;
            }
        } else if (isComp1) {
            this.expand(this._boundable1, this._boundable2, false, priQ, minDistance);
            return null;
        } else if (isComp2) {
            this.expand(this._boundable2, this._boundable1, true, priQ, minDistance);
            return null;
        }
        throw new (0, _illegalArgumentExceptionJsDefault.default)('neither boundable is composite');
    }
    isLeaves() {
        return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2));
    }
    getBoundable(i) {
        if (i === 0) return this._boundable1;
        return this._boundable2;
    }
    getDistance() {
        return this._distance;
    }
    distance() {
        if (this.isLeaves()) return this._itemDistance.distance(this._boundable1, this._boundable2);
        return this._boundable1.getBounds().distance(this._boundable2.getBounds());
    }
    compareTo(o) {
        const nd = o;
        if (this._distance < nd._distance) return -1;
        if (this._distance > nd._distance) return 1;
        return 0;
    }
    expand(bndComposite, bndOther, isFlipped, priQ, minDistance) {
        const children = bndComposite.getChildBoundables();
        for(let i = children.iterator(); i.hasNext();){
            const child = i.next();
            let bp = null;
            if (isFlipped) bp = new BoundablePair(bndOther, child, this._itemDistance);
            else bp = new BoundablePair(child, bndOther, this._itemDistance);
            if (bp.getDistance() < minDistance) priQ.add(bp);
        }
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = BoundablePair;

},{"../../../../../java/lang/IllegalArgumentException.js":"1VQhm","./AbstractNode.js":"azb4P","./EnvelopeDistance.js":"67GsS","../../../../../java/lang/Comparable.js":"6Adw4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"67GsS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class EnvelopeDistance {
    static distance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }
    static maximumDistance(env1, env2) {
        const minx = Math.min(env1.getMinX(), env2.getMinX());
        const miny = Math.min(env1.getMinY(), env2.getMinY());
        const maxx = Math.max(env1.getMaxX(), env2.getMaxX());
        const maxy = Math.max(env1.getMaxY(), env2.getMaxY());
        return EnvelopeDistance.distance(minx, miny, maxx, maxy);
    }
    static minMaxDistance(a, b) {
        const aminx = a.getMinX();
        const aminy = a.getMinY();
        const amaxx = a.getMaxX();
        const amaxy = a.getMaxY();
        const bminx = b.getMinX();
        const bminy = b.getMinY();
        const bmaxx = b.getMaxX();
        const bmaxy = b.getMaxY();
        let dist = EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bminx, bminy, bminx, bmaxy);
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bminx, bminy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bmaxx, bmaxy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, aminx, amaxy, bmaxx, bmaxy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bminx, bminy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bminx, bminy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bmaxx, bmaxy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(aminx, aminy, amaxx, aminy, bmaxx, bmaxy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bminx, bminy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bminx, bminy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bmaxx, bmaxy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, aminx, amaxy, bmaxx, bmaxy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bminx, bminy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bminx, bminy, bmaxx, bminy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bmaxx, bmaxy, bminx, bmaxy));
        dist = Math.min(dist, EnvelopeDistance.maxDistance(amaxx, amaxy, amaxx, aminy, bmaxx, bmaxy, bmaxx, bminy));
        return dist;
    }
    static maxDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
        let dist = EnvelopeDistance.distance(ax1, ay1, bx1, by1);
        dist = Math.max(dist, EnvelopeDistance.distance(ax1, ay1, bx2, by2));
        dist = Math.max(dist, EnvelopeDistance.distance(ax2, ay2, bx1, by1));
        dist = Math.max(dist, EnvelopeDistance.distance(ax2, ay2, bx2, by2));
        return dist;
    }
}
exports.default = EnvelopeDistance;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Drhz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _itemBoundableJs = require("./ItemBoundable.js");
var _itemBoundableJsDefault = parcelHelpers.interopDefault(_itemBoundableJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _itemVisitorJs = require("../ItemVisitor.js");
var _itemVisitorJsDefault = parcelHelpers.interopDefault(_itemVisitorJs);
var _abstractNodeJs = require("./AbstractNode.js");
var _abstractNodeJsDefault = parcelHelpers.interopDefault(_abstractNodeJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _serializableJs = require("../../../../../java/io/Serializable.js");
var _serializableJsDefault = parcelHelpers.interopDefault(_serializableJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _listJs = require("../../../../../java/util/List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
class AbstractSTRtree {
    constructor(){
        AbstractSTRtree.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._root = null;
        this._built = false;
        this._itemBoundables = new (0, _arrayListJsDefault.default)();
        this._nodeCapacity = null;
        if (arguments.length === 0) AbstractSTRtree.constructor_.call(this, AbstractSTRtree.DEFAULT_NODE_CAPACITY);
        else if (arguments.length === 1) {
            const nodeCapacity = arguments[0];
            (0, _assertJsDefault.default).isTrue(nodeCapacity > 1, 'Node capacity must be greater than 1');
            this._nodeCapacity = nodeCapacity;
        }
    }
    static compareDoubles(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
    }
    queryInternal() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[2], (0, _itemVisitorJsDefault.default)) && arguments[0] instanceof Object && arguments[1] instanceof (0, _abstractNodeJsDefault.default)) {
            const searchBounds = arguments[0], node = arguments[1], visitor = arguments[2];
            const childBoundables = node.getChildBoundables();
            for(let i = 0; i < childBoundables.size(); i++){
                const childBoundable = childBoundables.get(i);
                if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) continue;
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) this.queryInternal(searchBounds, childBoundable, visitor);
                else if (childBoundable instanceof (0, _itemBoundableJsDefault.default)) visitor.visitItem(childBoundable.getItem());
                else (0, _assertJsDefault.default).shouldNeverReachHere();
            }
        } else if ((0, _hasInterfaceJsDefault.default)(arguments[2], (0, _listJsDefault.default)) && arguments[0] instanceof Object && arguments[1] instanceof (0, _abstractNodeJsDefault.default)) {
            const searchBounds = arguments[0], node = arguments[1], matches = arguments[2];
            const childBoundables = node.getChildBoundables();
            for(let i = 0; i < childBoundables.size(); i++){
                const childBoundable = childBoundables.get(i);
                if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) continue;
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) this.queryInternal(searchBounds, childBoundable, matches);
                else if (childBoundable instanceof (0, _itemBoundableJsDefault.default)) matches.add(childBoundable.getItem());
                else (0, _assertJsDefault.default).shouldNeverReachHere();
            }
        }
    }
    insert(bounds, item) {
        (0, _assertJsDefault.default).isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');
        this._itemBoundables.add(new (0, _itemBoundableJsDefault.default)(bounds, item));
    }
    boundablesAtLevel() {
        if (arguments.length === 1) {
            const level = arguments[0];
            const boundables = new (0, _arrayListJsDefault.default)();
            this.boundablesAtLevel(level, this._root, boundables);
            return boundables;
        } else if (arguments.length === 3) {
            const level = arguments[0], top = arguments[1], boundables = arguments[2];
            (0, _assertJsDefault.default).isTrue(level > -2);
            if (top.getLevel() === level) {
                boundables.add(top);
                return null;
            }
            for(let i = top.getChildBoundables().iterator(); i.hasNext();){
                const boundable = i.next();
                if (boundable instanceof (0, _abstractNodeJsDefault.default)) this.boundablesAtLevel(level, boundable, boundables);
                else {
                    (0, _assertJsDefault.default).isTrue(boundable instanceof (0, _itemBoundableJsDefault.default));
                    if (level === -1) boundables.add(boundable);
                }
            }
            return null;
        }
    }
    getRoot() {
        this.build();
        return this._root;
    }
    remove() {
        if (arguments.length === 2) {
            const searchBounds = arguments[0], item = arguments[1];
            this.build();
            if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) return this.remove(searchBounds, this._root, item);
            return false;
        } else if (arguments.length === 3) {
            const searchBounds = arguments[0], node = arguments[1], item = arguments[2];
            let found = this.removeItem(node, item);
            if (found) return true;
            let childToPrune = null;
            for(let i = node.getChildBoundables().iterator(); i.hasNext();){
                const childBoundable = i.next();
                if (!this.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds)) continue;
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) {
                    found = this.remove(searchBounds, childBoundable, item);
                    if (found) {
                        childToPrune = childBoundable;
                        break;
                    }
                }
            }
            if (childToPrune !== null) {
                if (childToPrune.getChildBoundables().isEmpty()) node.getChildBoundables().remove(childToPrune);
            }
            return found;
        }
    }
    createHigherLevels(boundablesOfALevel, level) {
        (0, _assertJsDefault.default).isTrue(!boundablesOfALevel.isEmpty());
        const parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);
        if (parentBoundables.size() === 1) return parentBoundables.get(0);
        return this.createHigherLevels(parentBoundables, level + 1);
    }
    depth() {
        if (arguments.length === 0) {
            if (this.isEmpty()) return 0;
            this.build();
            return this.depth(this._root);
        } else if (arguments.length === 1) {
            const node = arguments[0];
            let maxChildDepth = 0;
            for(let i = node.getChildBoundables().iterator(); i.hasNext();){
                const childBoundable = i.next();
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) {
                    const childDepth = this.depth(childBoundable);
                    if (childDepth > maxChildDepth) maxChildDepth = childDepth;
                }
            }
            return maxChildDepth + 1;
        }
    }
    createParentBoundables(childBoundables, newLevel) {
        (0, _assertJsDefault.default).isTrue(!childBoundables.isEmpty());
        const parentBoundables = new (0, _arrayListJsDefault.default)();
        parentBoundables.add(this.createNode(newLevel));
        const sortedChildBoundables = new (0, _arrayListJsDefault.default)(childBoundables);
        (0, _collectionsJsDefault.default).sort(sortedChildBoundables, this.getComparator());
        for(let i = sortedChildBoundables.iterator(); i.hasNext();){
            const childBoundable = i.next();
            if (this.lastNode(parentBoundables).getChildBoundables().size() === this.getNodeCapacity()) parentBoundables.add(this.createNode(newLevel));
            this.lastNode(parentBoundables).addChildBoundable(childBoundable);
        }
        return parentBoundables;
    }
    isEmpty() {
        if (!this._built) return this._itemBoundables.isEmpty();
        return this._root.isEmpty();
    }
    getNodeCapacity() {
        return this._nodeCapacity;
    }
    lastNode(nodes) {
        return nodes.get(nodes.size() - 1);
    }
    size() {
        if (arguments.length === 0) {
            if (this.isEmpty()) return 0;
            this.build();
            return this.size(this._root);
        } else if (arguments.length === 1) {
            const node = arguments[0];
            let size = 0;
            for(let i = node.getChildBoundables().iterator(); i.hasNext();){
                const childBoundable = i.next();
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) size += this.size(childBoundable);
                else if (childBoundable instanceof (0, _itemBoundableJsDefault.default)) size += 1;
            }
            return size;
        }
    }
    removeItem(node, item) {
        let childToRemove = null;
        for(let i = node.getChildBoundables().iterator(); i.hasNext();){
            const childBoundable = i.next();
            if (childBoundable instanceof (0, _itemBoundableJsDefault.default)) {
                if (childBoundable.getItem() === item) childToRemove = childBoundable;
            }
        }
        if (childToRemove !== null) {
            node.getChildBoundables().remove(childToRemove);
            return true;
        }
        return false;
    }
    itemsTree() {
        if (arguments.length === 0) {
            this.build();
            const valuesTree = this.itemsTree(this._root);
            if (valuesTree === null) return new (0, _arrayListJsDefault.default)();
            return valuesTree;
        } else if (arguments.length === 1) {
            const node = arguments[0];
            const valuesTreeForNode = new (0, _arrayListJsDefault.default)();
            for(let i = node.getChildBoundables().iterator(); i.hasNext();){
                const childBoundable = i.next();
                if (childBoundable instanceof (0, _abstractNodeJsDefault.default)) {
                    const valuesTreeForChild = this.itemsTree(childBoundable);
                    if (valuesTreeForChild !== null) valuesTreeForNode.add(valuesTreeForChild);
                } else if (childBoundable instanceof (0, _itemBoundableJsDefault.default)) valuesTreeForNode.add(childBoundable.getItem());
                else (0, _assertJsDefault.default).shouldNeverReachHere();
            }
            if (valuesTreeForNode.size() <= 0) return null;
            return valuesTreeForNode;
        }
    }
    query() {
        if (arguments.length === 1) {
            const searchBounds = arguments[0];
            this.build();
            const matches = new (0, _arrayListJsDefault.default)();
            if (this.isEmpty()) return matches;
            if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) this.queryInternal(searchBounds, this._root, matches);
            return matches;
        } else if (arguments.length === 2) {
            const searchBounds = arguments[0], visitor = arguments[1];
            this.build();
            if (this.isEmpty()) return null;
            if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) this.queryInternal(searchBounds, this._root, visitor);
        }
    }
    build() {
        if (this._built) return null;
        this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);
        this._itemBoundables = null;
        this._built = true;
    }
    get interfaces_() {
        return [
            (0, _serializableJsDefault.default)
        ];
    }
}
exports.default = AbstractSTRtree;
function IntersectsOp() {}
AbstractSTRtree.IntersectsOp = IntersectsOp;
AbstractSTRtree.DEFAULT_NODE_CAPACITY = 10;

},{"./ItemBoundable.js":"k9yKX","../../../../../hasInterface.js":"d8mIo","../ItemVisitor.js":"8Rynh","./AbstractNode.js":"azb4P","../../../../../java/util/Collections.js":"hUg9B","../../../../../java/util/ArrayList.js":"g8omH","../../../../../java/io/Serializable.js":"4emqV","../../util/Assert.js":"ePbcB","../../../../../java/util/List.js":"5xM2g","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4helj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class ItemDistance {
    distance(item1, item2) {}
}
exports.default = ItemDistance;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4mFQi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
class MonotoneChainOverlapAction {
    constructor(){
        MonotoneChainOverlapAction.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._overlapSeg1 = new (0, _lineSegmentJsDefault.default)();
        this._overlapSeg2 = new (0, _lineSegmentJsDefault.default)();
    }
    overlap() {
        if (arguments.length === 2) {
            const seg1 = arguments[0], seg2 = arguments[1];
        } else if (arguments.length === 4) {
            const mc1 = arguments[0], start1 = arguments[1], mc2 = arguments[2], start2 = arguments[3];
            mc1.getLineSegment(start1, this._overlapSeg1);
            mc2.getLineSegment(start2, this._overlapSeg2);
            this.overlap(this._overlapSeg1, this._overlapSeg2);
        }
    }
}
exports.default = MonotoneChainOverlapAction;

},{"../../geom/LineSegment.js":"4V3G8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jEEzN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _monotoneChainJs = require("./MonotoneChain.js");
var _monotoneChainJsDefault = parcelHelpers.interopDefault(_monotoneChainJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _quadrantJs = require("../../geomgraph/Quadrant.js");
var _quadrantJsDefault = parcelHelpers.interopDefault(_quadrantJs);
class MonotoneChainBuilder {
    static findChainEnd(pts, start) {
        let safeStart = start;
        while(safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1]))safeStart++;
        if (safeStart >= pts.length - 1) return pts.length - 1;
        const chainQuad = (0, _quadrantJsDefault.default).quadrant(pts[safeStart], pts[safeStart + 1]);
        let last = start + 1;
        while(last < pts.length){
            if (!pts[last - 1].equals2D(pts[last])) {
                const quad = (0, _quadrantJsDefault.default).quadrant(pts[last - 1], pts[last]);
                if (quad !== chainQuad) break;
            }
            last++;
        }
        return last - 1;
    }
    static getChains() {
        if (arguments.length === 1) {
            const pts = arguments[0];
            return MonotoneChainBuilder.getChains(pts, null);
        } else if (arguments.length === 2) {
            const pts = arguments[0], context = arguments[1];
            const mcList = new (0, _arrayListJsDefault.default)();
            let chainStart = 0;
            do {
                const chainEnd = MonotoneChainBuilder.findChainEnd(pts, chainStart);
                const mc = new (0, _monotoneChainJsDefault.default)(pts, chainStart, chainEnd, context);
                mcList.add(mc);
                chainStart = chainEnd;
            }while (chainStart < pts.length - 1);
            return mcList;
        }
    }
}
exports.default = MonotoneChainBuilder;

},{"./MonotoneChain.js":"fr1qD","../../../../../java/util/ArrayList.js":"g8omH","../../geomgraph/Quadrant.js":"hwMrb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fr1qD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _envelopeJs = require("../../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class MonotoneChain {
    constructor(){
        MonotoneChain.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._pts = null;
        this._start = null;
        this._end = null;
        this._env = null;
        this._context = null;
        this._id = null;
        const pts = arguments[0], start = arguments[1], end = arguments[2], context = arguments[3];
        this._pts = pts;
        this._start = start;
        this._end = end;
        this._context = context;
    }
    computeOverlaps() {
        if (arguments.length === 2) {
            const mc = arguments[0], mco = arguments[1];
            this.computeOverlaps(this._start, this._end, mc, mc._start, mc._end, mco);
        } else if (arguments.length === 6) {
            const start0 = arguments[0], end0 = arguments[1], mc = arguments[2], start1 = arguments[3], end1 = arguments[4], mco = arguments[5];
            if (end0 - start0 === 1 && end1 - start1 === 1) {
                mco.overlap(this, start0, mc, start1);
                return null;
            }
            if (!this.overlaps(start0, end0, mc, start1, end1)) return null;
            const mid0 = Math.trunc((start0 + end0) / 2);
            const mid1 = Math.trunc((start1 + end1) / 2);
            if (start0 < mid0) {
                if (start1 < mid1) this.computeOverlaps(start0, mid0, mc, start1, mid1, mco);
                if (mid1 < end1) this.computeOverlaps(start0, mid0, mc, mid1, end1, mco);
            }
            if (mid0 < end0) {
                if (start1 < mid1) this.computeOverlaps(mid0, end0, mc, start1, mid1, mco);
                if (mid1 < end1) this.computeOverlaps(mid0, end0, mc, mid1, end1, mco);
            }
        }
    }
    setId(id) {
        this._id = id;
    }
    select(searchEnv, mcs) {
        this.computeSelect(searchEnv, this._start, this._end, mcs);
    }
    getEnvelope() {
        if (this._env === null) {
            const p0 = this._pts[this._start];
            const p1 = this._pts[this._end];
            this._env = new (0, _envelopeJsDefault.default)(p0, p1);
        }
        return this._env;
    }
    overlaps(start0, end0, mc, start1, end1) {
        return (0, _envelopeJsDefault.default).intersects(this._pts[start0], this._pts[end0], mc._pts[start1], mc._pts[end1]);
    }
    getEndIndex() {
        return this._end;
    }
    getStartIndex() {
        return this._start;
    }
    getContext() {
        return this._context;
    }
    getId() {
        return this._id;
    }
    getLineSegment(index, ls) {
        ls.p0 = this._pts[index];
        ls.p1 = this._pts[index + 1];
    }
    computeSelect(searchEnv, start0, end0, mcs) {
        const p0 = this._pts[start0];
        const p1 = this._pts[end0];
        if (end0 - start0 === 1) {
            mcs.select(this, start0);
            return null;
        }
        if (!searchEnv.intersects(p0, p1)) return null;
        const mid = Math.trunc((start0 + end0) / 2);
        if (start0 < mid) this.computeSelect(searchEnv, start0, mid, mcs);
        if (mid < end0) this.computeSelect(searchEnv, mid, end0, mcs);
    }
    getCoordinates() {
        const coord = new Array(this._end - this._start + 1).fill(null);
        let index = 0;
        for(let i = this._start; i <= this._end; i++)coord[index++] = this._pts[i];
        return coord;
    }
}
exports.default = MonotoneChain;

},{"../../geom/Envelope.js":"ha5UZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8ZqYQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _noderJs = require("./Noder.js");
var _noderJsDefault = parcelHelpers.interopDefault(_noderJs);
class SinglePassNoder {
    constructor(){
        SinglePassNoder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._segInt = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 1) {
            const segInt = arguments[0];
            this.setSegmentIntersector(segInt);
        }
    }
    setSegmentIntersector(segInt) {
        this._segInt = segInt;
    }
    get interfaces_() {
        return [
            (0, _noderJsDefault.default)
        ];
    }
}
exports.default = SinglePassNoder;

},{"./Noder.js":"ct7GF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2qJxX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _envelopeJs = require("../../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class HotPixel {
    constructor(){
        HotPixel.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = null;
        this._pt = null;
        this._originalPt = null;
        this._ptScaled = null;
        this._p0Scaled = null;
        this._p1Scaled = null;
        this._scaleFactor = null;
        this._minx = null;
        this._maxx = null;
        this._miny = null;
        this._maxy = null;
        this._corner = new Array(4).fill(null);
        this._safeEnv = null;
        const pt = arguments[0], scaleFactor = arguments[1], li = arguments[2];
        this._originalPt = pt;
        this._pt = pt;
        this._scaleFactor = scaleFactor;
        this._li = li;
        if (scaleFactor <= 0) throw new (0, _illegalArgumentExceptionJsDefault.default)('Scale factor must be non-zero');
        if (scaleFactor !== 1.0) {
            this._pt = new (0, _coordinateJsDefault.default)(this.scale(pt.x), this.scale(pt.y));
            this._p0Scaled = new (0, _coordinateJsDefault.default)();
            this._p1Scaled = new (0, _coordinateJsDefault.default)();
        }
        this.initCorners(this._pt);
    }
    intersectsScaled(p0, p1) {
        const segMinx = Math.min(p0.x, p1.x);
        const segMaxx = Math.max(p0.x, p1.x);
        const segMiny = Math.min(p0.y, p1.y);
        const segMaxy = Math.max(p0.y, p1.y);
        const isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;
        if (isOutsidePixelEnv) return false;
        const intersects = this.intersectsToleranceSquare(p0, p1);
        (0, _assertJsDefault.default).isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');
        return intersects;
    }
    copyScaled(p, pScaled) {
        pScaled.x = this.scale(p.x);
        pScaled.y = this.scale(p.y);
    }
    getSafeEnvelope() {
        if (this._safeEnv === null) {
            const safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new (0, _envelopeJsDefault.default)(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);
        }
        return this._safeEnv;
    }
    intersectsPixelClosure(p0, p1) {
        this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
        if (this._li.hasIntersection()) return true;
        this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
        if (this._li.hasIntersection()) return true;
        this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
        if (this._li.hasIntersection()) return true;
        this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
        if (this._li.hasIntersection()) return true;
        return false;
    }
    intersectsToleranceSquare(p0, p1) {
        let intersectsLeft = false;
        let intersectsBottom = false;
        this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);
        if (this._li.isProper()) return true;
        this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);
        if (this._li.isProper()) return true;
        if (this._li.hasIntersection()) intersectsLeft = true;
        this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);
        if (this._li.isProper()) return true;
        if (this._li.hasIntersection()) intersectsBottom = true;
        this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);
        if (this._li.isProper()) return true;
        if (intersectsLeft && intersectsBottom) return true;
        if (p0.equals(this._pt)) return true;
        if (p1.equals(this._pt)) return true;
        return false;
    }
    addSnappedNode(segStr, segIndex) {
        const p0 = segStr.getCoordinate(segIndex);
        const p1 = segStr.getCoordinate(segIndex + 1);
        if (this.intersects(p0, p1)) {
            segStr.addIntersection(this.getCoordinate(), segIndex);
            return true;
        }
        return false;
    }
    initCorners(pt) {
        const tolerance = 0.5;
        this._minx = pt.x - tolerance;
        this._maxx = pt.x + tolerance;
        this._miny = pt.y - tolerance;
        this._maxy = pt.y + tolerance;
        this._corner[0] = new (0, _coordinateJsDefault.default)(this._maxx, this._maxy);
        this._corner[1] = new (0, _coordinateJsDefault.default)(this._minx, this._maxy);
        this._corner[2] = new (0, _coordinateJsDefault.default)(this._minx, this._miny);
        this._corner[3] = new (0, _coordinateJsDefault.default)(this._maxx, this._miny);
    }
    intersects(p0, p1) {
        if (this._scaleFactor === 1.0) return this.intersectsScaled(p0, p1);
        this.copyScaled(p0, this._p0Scaled);
        this.copyScaled(p1, this._p1Scaled);
        return this.intersectsScaled(this._p0Scaled, this._p1Scaled);
    }
    scale(val) {
        return Math.round(val * this._scaleFactor);
    }
    getCoordinate() {
        return this._originalPt;
    }
}
exports.default = HotPixel;
HotPixel.SAFE_ENV_EXPANSION_FACTOR = 0.75;

},{"../../geom/Coordinate.js":"3REUb","../../../../../java/lang/IllegalArgumentException.js":"1VQhm","../../geom/Envelope.js":"ha5UZ","../../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"630Xn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _monotoneChainSelectActionJs = require("../../index/chain/MonotoneChainSelectAction.js");
var _monotoneChainSelectActionJsDefault = parcelHelpers.interopDefault(_monotoneChainSelectActionJs);
var _monotoneChainJs = require("../../index/chain/MonotoneChain.js");
var _monotoneChainJsDefault = parcelHelpers.interopDefault(_monotoneChainJs);
var _itemVisitorJs = require("../../index/ItemVisitor.js");
var _itemVisitorJsDefault = parcelHelpers.interopDefault(_itemVisitorJs);
class MCIndexPointSnapper {
    constructor(){
        MCIndexPointSnapper.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._index = null;
        const index = arguments[0];
        this._index = index;
    }
    snap() {
        if (arguments.length === 1) {
            const hotPixel = arguments[0];
            return this.snap(hotPixel, null, -1);
        } else if (arguments.length === 3) {
            const hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2];
            const pixelEnv = hotPixel.getSafeEnvelope();
            const hotPixelSnapAction = new HotPixelSnapAction(hotPixel, parentEdge, hotPixelVertexIndex);
            this._index.query(pixelEnv, new class {
                get interfaces_() {
                    return [
                        (0, _itemVisitorJsDefault.default)
                    ];
                }
                visitItem(item) {
                    const testChain = item;
                    testChain.select(pixelEnv, hotPixelSnapAction);
                }
            }());
            return hotPixelSnapAction.isNodeAdded();
        }
    }
}
exports.default = MCIndexPointSnapper;
class HotPixelSnapAction extends (0, _monotoneChainSelectActionJsDefault.default) {
    constructor(){
        super();
        HotPixelSnapAction.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._hotPixel = null;
        this._parentEdge = null;
        this._hotPixelVertexIndex = null;
        this._isNodeAdded = false;
        const hotPixel = arguments[0], parentEdge = arguments[1], hotPixelVertexIndex = arguments[2];
        this._hotPixel = hotPixel;
        this._parentEdge = parentEdge;
        this._hotPixelVertexIndex = hotPixelVertexIndex;
    }
    select() {
        if (arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof (0, _monotoneChainJsDefault.default)) {
            const mc = arguments[0], startIndex = arguments[1];
            const ss = mc.getContext();
            if (this._parentEdge === ss) {
                if (startIndex === this._hotPixelVertexIndex || startIndex + 1 === this._hotPixelVertexIndex) return null;
            }
            this._isNodeAdded |= this._hotPixel.addSnappedNode(ss, startIndex);
        } else return super.select.apply(this, arguments);
    }
    isNodeAdded() {
        return this._isNodeAdded;
    }
}
MCIndexPointSnapper.HotPixelSnapAction = HotPixelSnapAction;

},{"../../index/chain/MonotoneChainSelectAction.js":"lSNAL","../../index/chain/MonotoneChain.js":"fr1qD","../../index/ItemVisitor.js":"8Rynh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lSNAL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
class MonotoneChainSelectAction {
    constructor(){
        MonotoneChainSelectAction.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.selectedSegment = new (0, _lineSegmentJsDefault.default)();
    }
    select() {
        if (arguments.length === 1) {
            const seg = arguments[0];
        } else if (arguments.length === 2) {
            const mc = arguments[0], startIndex = arguments[1];
            mc.getLineSegment(startIndex, this.selectedSegment);
            this.select(this.selectedSegment);
        }
    }
}
exports.default = MonotoneChainSelectAction;

},{"../../geom/LineSegment.js":"4V3G8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aa40V":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _segmentIntersectorJs = require("./SegmentIntersector.js");
var _segmentIntersectorJsDefault = parcelHelpers.interopDefault(_segmentIntersectorJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class InteriorIntersectionFinderAdder {
    constructor(){
        InteriorIntersectionFinderAdder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = null;
        this._interiorIntersections = null;
        const li = arguments[0];
        this._li = li;
        this._interiorIntersections = new (0, _arrayListJsDefault.default)();
    }
    isDone() {
        return false;
    }
    processIntersections(e0, segIndex0, e1, segIndex1) {
        if (e0 === e1 && segIndex0 === segIndex1) return null;
        const p00 = e0.getCoordinates()[segIndex0];
        const p01 = e0.getCoordinates()[segIndex0 + 1];
        const p10 = e1.getCoordinates()[segIndex1];
        const p11 = e1.getCoordinates()[segIndex1 + 1];
        this._li.computeIntersection(p00, p01, p10, p11);
        if (this._li.hasIntersection()) {
            if (this._li.isInteriorIntersection()) {
                for(let intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++)this._interiorIntersections.add(this._li.getIntersection(intIndex));
                e0.addIntersections(this._li, segIndex0, 0);
                e1.addIntersections(this._li, segIndex1, 1);
            }
        }
    }
    getInteriorIntersections() {
        return this._interiorIntersections;
    }
    get interfaces_() {
        return [
            (0, _segmentIntersectorJsDefault.default)
        ];
    }
}
exports.default = InteriorIntersectionFinderAdder;

},{"./SegmentIntersector.js":"9okdh","../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9okdh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class SegmentIntersector {
    isDone() {}
    processIntersections(e0, segIndex0, e1, segIndex1) {}
}
exports.default = SegmentIntersector;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9lFpX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _bufferSubgraphJs = require("./BufferSubgraph.js");
var _bufferSubgraphJsDefault = parcelHelpers.interopDefault(_bufferSubgraphJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _mcindexNoderJs = require("../../noding/MCIndexNoder.js");
var _mcindexNoderJsDefault = parcelHelpers.interopDefault(_mcindexNoderJs);
var _offsetCurveBuilderJs = require("./OffsetCurveBuilder.js");
var _offsetCurveBuilderJsDefault = parcelHelpers.interopDefault(_offsetCurveBuilderJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
var _labelJs = require("../../geomgraph/Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _planarGraphJs = require("../../geomgraph/PlanarGraph.js");
var _planarGraphJsDefault = parcelHelpers.interopDefault(_planarGraphJs);
var _polygonBuilderJs = require("../overlay/PolygonBuilder.js");
var _polygonBuilderJsDefault = parcelHelpers.interopDefault(_polygonBuilderJs);
var _geometryFactoryJs = require("../../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _subgraphDepthLocaterJs = require("./SubgraphDepthLocater.js");
var _subgraphDepthLocaterJsDefault = parcelHelpers.interopDefault(_subgraphDepthLocaterJs);
var _offsetCurveSetBuilderJs = require("./OffsetCurveSetBuilder.js");
var _offsetCurveSetBuilderJsDefault = parcelHelpers.interopDefault(_offsetCurveSetBuilderJs);
var _overlayNodeFactoryJs = require("../overlay/OverlayNodeFactory.js");
var _overlayNodeFactoryJsDefault = parcelHelpers.interopDefault(_overlayNodeFactoryJs);
var _edgeListJs = require("../../geomgraph/EdgeList.js");
var _edgeListJsDefault = parcelHelpers.interopDefault(_edgeListJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _robustLineIntersectorJs = require("../../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _intersectionAdderJs = require("../../noding/IntersectionAdder.js");
var _intersectionAdderJsDefault = parcelHelpers.interopDefault(_intersectionAdderJs);
var _edgeJs = require("../../geomgraph/Edge.js");
var _edgeJsDefault = parcelHelpers.interopDefault(_edgeJs);
class BufferBuilder {
    constructor(){
        BufferBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._bufParams = null;
        this._workingPrecisionModel = null;
        this._workingNoder = null;
        this._geomFact = null;
        this._graph = null;
        this._edgeList = new (0, _edgeListJsDefault.default)();
        const bufParams = arguments[0];
        this._bufParams = bufParams;
    }
    static convertSegStrings(it) {
        const fact = new (0, _geometryFactoryJsDefault.default)();
        const lines = new (0, _arrayListJsDefault.default)();
        while(it.hasNext()){
            const ss = it.next();
            const line = fact.createLineString(ss.getCoordinates());
            lines.add(line);
        }
        return fact.buildGeometry(lines);
    }
    static depthDelta(label) {
        const lLoc = label.getLocation(0, (0, _positionJsDefault.default).LEFT);
        const rLoc = label.getLocation(0, (0, _positionJsDefault.default).RIGHT);
        if (lLoc === (0, _locationJsDefault.default).INTERIOR && rLoc === (0, _locationJsDefault.default).EXTERIOR) return 1;
        else if (lLoc === (0, _locationJsDefault.default).EXTERIOR && rLoc === (0, _locationJsDefault.default).INTERIOR) return -1;
        return 0;
    }
    createEmptyResultGeometry() {
        const emptyGeom = this._geomFact.createPolygon();
        return emptyGeom;
    }
    getNoder(precisionModel) {
        if (this._workingNoder !== null) return this._workingNoder;
        const noder = new (0, _mcindexNoderJsDefault.default)();
        const li = new (0, _robustLineIntersectorJsDefault.default)();
        li.setPrecisionModel(precisionModel);
        noder.setSegmentIntersector(new (0, _intersectionAdderJsDefault.default)(li));
        return noder;
    }
    buffer(g, distance) {
        let precisionModel = this._workingPrecisionModel;
        if (precisionModel === null) precisionModel = g.getPrecisionModel();
        this._geomFact = g.getFactory();
        const curveBuilder = new (0, _offsetCurveBuilderJsDefault.default)(precisionModel, this._bufParams);
        const curveSetBuilder = new (0, _offsetCurveSetBuilderJsDefault.default)(g, distance, curveBuilder);
        const bufferSegStrList = curveSetBuilder.getCurves();
        if (bufferSegStrList.size() <= 0) return this.createEmptyResultGeometry();
        this.computeNodedEdges(bufferSegStrList, precisionModel);
        this._graph = new (0, _planarGraphJsDefault.default)(new (0, _overlayNodeFactoryJsDefault.default)());
        this._graph.addEdges(this._edgeList.getEdges());
        const subgraphList = this.createSubgraphs(this._graph);
        const polyBuilder = new (0, _polygonBuilderJsDefault.default)(this._geomFact);
        this.buildSubgraphs(subgraphList, polyBuilder);
        const resultPolyList = polyBuilder.getPolygons();
        if (resultPolyList.size() <= 0) return this.createEmptyResultGeometry();
        const resultGeom = this._geomFact.buildGeometry(resultPolyList);
        return resultGeom;
    }
    computeNodedEdges(bufferSegStrList, precisionModel) {
        const noder = this.getNoder(precisionModel);
        noder.computeNodes(bufferSegStrList);
        const nodedSegStrings = noder.getNodedSubstrings();
        for(let i = nodedSegStrings.iterator(); i.hasNext();){
            const segStr = i.next();
            const pts = segStr.getCoordinates();
            if (pts.length === 2 && pts[0].equals2D(pts[1])) continue;
            const oldLabel = segStr.getData();
            const edge = new (0, _edgeJsDefault.default)(segStr.getCoordinates(), new (0, _labelJsDefault.default)(oldLabel));
            this.insertUniqueEdge(edge);
        }
    }
    setNoder(noder) {
        this._workingNoder = noder;
    }
    setWorkingPrecisionModel(pm) {
        this._workingPrecisionModel = pm;
    }
    insertUniqueEdge(e) {
        const existingEdge = this._edgeList.findEqualEdge(e);
        if (existingEdge !== null) {
            const existingLabel = existingEdge.getLabel();
            let labelToMerge = e.getLabel();
            if (!existingEdge.isPointwiseEqual(e)) {
                labelToMerge = new (0, _labelJsDefault.default)(e.getLabel());
                labelToMerge.flip();
            }
            existingLabel.merge(labelToMerge);
            const mergeDelta = BufferBuilder.depthDelta(labelToMerge);
            const existingDelta = existingEdge.getDepthDelta();
            const newDelta = existingDelta + mergeDelta;
            existingEdge.setDepthDelta(newDelta);
        } else {
            this._edgeList.add(e);
            e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));
        }
    }
    buildSubgraphs(subgraphList, polyBuilder) {
        const processedGraphs = new (0, _arrayListJsDefault.default)();
        for(let i = subgraphList.iterator(); i.hasNext();){
            const subgraph = i.next();
            const p = subgraph.getRightmostCoordinate();
            const locater = new (0, _subgraphDepthLocaterJsDefault.default)(processedGraphs);
            const outsideDepth = locater.getDepth(p);
            subgraph.computeDepth(outsideDepth);
            subgraph.findResultEdges();
            processedGraphs.add(subgraph);
            polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());
        }
    }
    createSubgraphs(graph) {
        const subgraphList = new (0, _arrayListJsDefault.default)();
        for(let i = graph.getNodes().iterator(); i.hasNext();){
            const node = i.next();
            if (!node.isVisited()) {
                const subgraph = new (0, _bufferSubgraphJsDefault.default)();
                subgraph.create(node);
                subgraphList.add(subgraph);
            }
        }
        (0, _collectionsJsDefault.default).sort(subgraphList, (0, _collectionsJsDefault.default).reverseOrder());
        return subgraphList;
    }
}
exports.default = BufferBuilder;

},{"../../geom/Location.js":"71R1B","./BufferSubgraph.js":"dV9RF","../../geomgraph/Position.js":"929cL","../../noding/MCIndexNoder.js":"9G0qr","./OffsetCurveBuilder.js":"tO6sL","../../../../../java/util/Collections.js":"hUg9B","../../geomgraph/Label.js":"2NrfJ","../../geomgraph/PlanarGraph.js":"42N6d","../overlay/PolygonBuilder.js":"58e4Z","../../geom/GeometryFactory.js":"6Ct9y","./SubgraphDepthLocater.js":"fgRmL","./OffsetCurveSetBuilder.js":"9WThR","../overlay/OverlayNodeFactory.js":"3i3AP","../../geomgraph/EdgeList.js":"4eJVd","../../../../../java/util/ArrayList.js":"g8omH","../../algorithm/RobustLineIntersector.js":"fBBRl","../../noding/IntersectionAdder.js":"8IYcL","../../geomgraph/Edge.js":"5KXFs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dV9RF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashSetJs = require("../../../../../java/util/HashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _stackJs = require("../../../../../java/util/Stack.js");
var _stackJsDefault = parcelHelpers.interopDefault(_stackJs);
var _rightmostEdgeFinderJs = require("./RightmostEdgeFinder.js");
var _rightmostEdgeFinderJsDefault = parcelHelpers.interopDefault(_rightmostEdgeFinderJs);
var _topologyExceptionJs = require("../../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _linkedListJs = require("../../../../../java/util/LinkedList.js");
var _linkedListJsDefault = parcelHelpers.interopDefault(_linkedListJs);
var _comparableJs = require("../../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _envelopeJs = require("../../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class BufferSubgraph {
    constructor(){
        BufferSubgraph.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._finder = null;
        this._dirEdgeList = new (0, _arrayListJsDefault.default)();
        this._nodes = new (0, _arrayListJsDefault.default)();
        this._rightMostCoord = null;
        this._env = null;
        this._finder = new (0, _rightmostEdgeFinderJsDefault.default)();
    }
    clearVisitedEdges() {
        for(let it = this._dirEdgeList.iterator(); it.hasNext();){
            const de = it.next();
            de.setVisited(false);
        }
    }
    compareTo(o) {
        const graph = o;
        if (this._rightMostCoord.x < graph._rightMostCoord.x) return -1;
        if (this._rightMostCoord.x > graph._rightMostCoord.x) return 1;
        return 0;
    }
    getEnvelope() {
        if (this._env === null) {
            const edgeEnv = new (0, _envelopeJsDefault.default)();
            for(let it = this._dirEdgeList.iterator(); it.hasNext();){
                const dirEdge = it.next();
                const pts = dirEdge.getEdge().getCoordinates();
                for(let i = 0; i < pts.length - 1; i++)edgeEnv.expandToInclude(pts[i]);
            }
            this._env = edgeEnv;
        }
        return this._env;
    }
    addReachable(startNode) {
        const nodeStack = new (0, _stackJsDefault.default)();
        nodeStack.add(startNode);
        while(!nodeStack.empty()){
            const node = nodeStack.pop();
            this.add(node, nodeStack);
        }
    }
    copySymDepths(de) {
        const sym = de.getSym();
        sym.setDepth((0, _positionJsDefault.default).LEFT, de.getDepth((0, _positionJsDefault.default).RIGHT));
        sym.setDepth((0, _positionJsDefault.default).RIGHT, de.getDepth((0, _positionJsDefault.default).LEFT));
    }
    add(node, nodeStack) {
        node.setVisited(true);
        this._nodes.add(node);
        for(let i = node.getEdges().iterator(); i.hasNext();){
            const de = i.next();
            this._dirEdgeList.add(de);
            const sym = de.getSym();
            const symNode = sym.getNode();
            if (!symNode.isVisited()) nodeStack.push(symNode);
        }
    }
    getRightmostCoordinate() {
        return this._rightMostCoord;
    }
    computeNodeDepth(n) {
        let startEdge = null;
        for(let i = n.getEdges().iterator(); i.hasNext();){
            const de = i.next();
            if (de.isVisited() || de.getSym().isVisited()) {
                startEdge = de;
                break;
            }
        }
        if (startEdge === null) throw new (0, _topologyExceptionJsDefault.default)('unable to find edge to compute depths at ' + n.getCoordinate());
        n.getEdges().computeDepths(startEdge);
        for(let i = n.getEdges().iterator(); i.hasNext();){
            const de = i.next();
            de.setVisited(true);
            this.copySymDepths(de);
        }
    }
    computeDepth(outsideDepth) {
        this.clearVisitedEdges();
        const de = this._finder.getEdge();
        const n = de.getNode();
        const label = de.getLabel();
        de.setEdgeDepths((0, _positionJsDefault.default).RIGHT, outsideDepth);
        this.copySymDepths(de);
        this.computeDepths(de);
    }
    create(node) {
        this.addReachable(node);
        this._finder.findEdge(this._dirEdgeList);
        this._rightMostCoord = this._finder.getCoordinate();
    }
    findResultEdges() {
        for(let it = this._dirEdgeList.iterator(); it.hasNext();){
            const de = it.next();
            if (de.getDepth((0, _positionJsDefault.default).RIGHT) >= 1 && de.getDepth((0, _positionJsDefault.default).LEFT) <= 0 && !de.isInteriorAreaEdge()) de.setInResult(true);
        }
    }
    computeDepths(startEdge) {
        const nodesVisited = new (0, _hashSetJsDefault.default)();
        const nodeQueue = new (0, _linkedListJsDefault.default)();
        const startNode = startEdge.getNode();
        nodeQueue.addLast(startNode);
        nodesVisited.add(startNode);
        startEdge.setVisited(true);
        while(!nodeQueue.isEmpty()){
            const n = nodeQueue.removeFirst();
            nodesVisited.add(n);
            this.computeNodeDepth(n);
            for(let i = n.getEdges().iterator(); i.hasNext();){
                const de = i.next();
                const sym = de.getSym();
                if (sym.isVisited()) continue;
                const adjNode = sym.getNode();
                if (!nodesVisited.contains(adjNode)) {
                    nodeQueue.addLast(adjNode);
                    nodesVisited.add(adjNode);
                }
            }
        }
    }
    getNodes() {
        return this._nodes;
    }
    getDirectedEdges() {
        return this._dirEdgeList;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = BufferSubgraph;

},{"../../../../../java/util/HashSet.js":"cNQO2","../../geomgraph/Position.js":"929cL","../../../../../java/util/Stack.js":"edJ9N","./RightmostEdgeFinder.js":"kJpyK","../../geom/TopologyException.js":"cGr97","../../../../../java/util/LinkedList.js":"jqsKz","../../../../../java/lang/Comparable.js":"6Adw4","../../../../../java/util/ArrayList.js":"g8omH","../../geom/Envelope.js":"ha5UZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"edJ9N":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _emptyStackExceptionJs = require("./EmptyStackException.js");
var _emptyStackExceptionJsDefault = parcelHelpers.interopDefault(_emptyStackExceptionJs);
var _indexOutOfBoundsExceptionJs = require("../lang/IndexOutOfBoundsException.js");
var _indexOutOfBoundsExceptionJsDefault = parcelHelpers.interopDefault(_indexOutOfBoundsExceptionJs);
var _listJs = require("./List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
class Stack extends (0, _listJsDefault.default) {
    constructor(){
        super();
        this.array = [];
    }
    add(e) {
        this.array.push(e);
        return true;
    }
    get(index) {
        if (index < 0 || index >= this.size()) throw new (0, _indexOutOfBoundsExceptionJsDefault.default)();
        return this.array[index];
    }
    /**
   * Pushes an item onto the top of this stack.
   * @param {Object} e
   * @return {Object}
   */ push(e) {
        this.array.push(e);
        return e;
    }
    /**
   * Removes the object at the top of this stack and returns that object as the value of this function.
   * @return {Object}
   */ pop() {
        if (this.array.length === 0) throw new (0, _emptyStackExceptionJsDefault.default)();
        return this.array.pop();
    }
    /**
   * Looks at the object at the top of this stack without removing it from the
   * stack.
   * @return {Object}
   */ peek() {
        if (this.array.length === 0) throw new (0, _emptyStackExceptionJsDefault.default)();
        return this.array[this.array.length - 1];
    }
    /**
   * Tests if this stack is empty.
   * @return {boolean} true if and only if this stack contains no items; false
   *         otherwise.
   */ empty() {
        return this.array.length === 0;
    }
    /**
   * @return {boolean}
   */ isEmpty() {
        return this.empty();
    }
    /**
   * Returns the 1-based position where an object is on this stack. If the object
   * o occurs as an item in this stack, this method returns the distance from the
   * top of the stack of the occurrence nearest the top of the stack; the topmost
   * item on the stack is considered to be at distance 1. The equals method is
   * used to compare o to the items in this stack.
   *
   * NOTE: does not currently actually use equals. (=== is used)
   *
   * @param {Object} o
   * @return {number} the 1-based position from the top of the stack where the
   *         object is located; the return value -1 indicates that the object is
   *         not on the stack.
   */ search(o) {
        return this.array.indexOf(o);
    }
    /**
   * @return {number}
   */ size() {
        return this.array.length;
    }
    /**
   * @return {Array}
   */ toArray() {
        return this.array.slice();
    }
}
exports.default = Stack;

},{"./EmptyStackException.js":"gbONY","../lang/IndexOutOfBoundsException.js":"hKwCB","./List.js":"5xM2g","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gbONY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("../lang/Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class EmptyStackException extends (0, _exceptionJsDefault.default) {
    constructor(message){
        super(message);
        this.name = Object.keys({
            EmptyStackException
        })[0];
    }
}
exports.default = EmptyStackException;

},{"../lang/Exception.js":"gSmog","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kJpyK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _orientationJs = require("../../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class RightmostEdgeFinder {
    constructor(){
        RightmostEdgeFinder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._minIndex = -1;
        this._minCoord = null;
        this._minDe = null;
        this._orientedDe = null;
    }
    getCoordinate() {
        return this._minCoord;
    }
    getRightmostSide(de, index) {
        let side = this.getRightmostSideOfSegment(de, index);
        if (side < 0) side = this.getRightmostSideOfSegment(de, index - 1);
        if (side < 0) {
            this._minCoord = null;
            this.checkForRightmostCoordinate(de);
        }
        return side;
    }
    findRightmostEdgeAtVertex() {
        const pts = this._minDe.getEdge().getCoordinates();
        (0, _assertJsDefault.default).isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');
        const pPrev = pts[this._minIndex - 1];
        const pNext = pts[this._minIndex + 1];
        const orientation = (0, _orientationJsDefault.default).index(this._minCoord, pNext, pPrev);
        let usePrev = false;
        if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === (0, _orientationJsDefault.default).COUNTERCLOCKWISE) usePrev = true;
        else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === (0, _orientationJsDefault.default).CLOCKWISE) usePrev = true;
        if (usePrev) this._minIndex = this._minIndex - 1;
    }
    getRightmostSideOfSegment(de, i) {
        const e = de.getEdge();
        const coord = e.getCoordinates();
        if (i < 0 || i + 1 >= coord.length) return -1;
        if (coord[i].y === coord[i + 1].y) return -1;
        let pos = (0, _positionJsDefault.default).LEFT;
        if (coord[i].y < coord[i + 1].y) pos = (0, _positionJsDefault.default).RIGHT;
        return pos;
    }
    getEdge() {
        return this._orientedDe;
    }
    checkForRightmostCoordinate(de) {
        const coord = de.getEdge().getCoordinates();
        for(let i = 0; i < coord.length - 1; i++)if (this._minCoord === null || coord[i].x > this._minCoord.x) {
            this._minDe = de;
            this._minIndex = i;
            this._minCoord = coord[i];
        }
    }
    findRightmostEdgeAtNode() {
        const node = this._minDe.getNode();
        const star = node.getEdges();
        this._minDe = star.getRightmostEdge();
        if (!this._minDe.isForward()) {
            this._minDe = this._minDe.getSym();
            this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;
        }
    }
    findEdge(dirEdgeList) {
        for(let i = dirEdgeList.iterator(); i.hasNext();){
            const de = i.next();
            if (!de.isForward()) continue;
            this.checkForRightmostCoordinate(de);
        }
        (0, _assertJsDefault.default).isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');
        if (this._minIndex === 0) this.findRightmostEdgeAtNode();
        else this.findRightmostEdgeAtVertex();
        this._orientedDe = this._minDe;
        const rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);
        if (rightmostSide === (0, _positionJsDefault.default).LEFT) this._orientedDe = this._minDe.getSym();
    }
}
exports.default = RightmostEdgeFinder;

},{"../../geomgraph/Position.js":"929cL","../../algorithm/Orientation.js":"QDWSa","../../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jqsKz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class LinkedList {
    constructor(){
        this.array = [];
    }
    addLast(e) {
        this.array.push(e);
    }
    removeFirst() {
        return this.array.shift();
    }
    isEmpty() {
        return this.array.length === 0;
    }
}
exports.default = LinkedList;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"tO6sL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bufferParametersJs = require("./BufferParameters.js");
var _bufferParametersJsDefault = parcelHelpers.interopDefault(_bufferParametersJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _bufferInputLineSimplifierJs = require("./BufferInputLineSimplifier.js");
var _bufferInputLineSimplifierJsDefault = parcelHelpers.interopDefault(_bufferInputLineSimplifierJs);
var _coordinateArraysJs = require("../../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _offsetSegmentGeneratorJs = require("./OffsetSegmentGenerator.js");
var _offsetSegmentGeneratorJsDefault = parcelHelpers.interopDefault(_offsetSegmentGeneratorJs);
class OffsetCurveBuilder {
    constructor(){
        OffsetCurveBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._distance = 0.0;
        this._precisionModel = null;
        this._bufParams = null;
        const precisionModel = arguments[0], bufParams = arguments[1];
        this._precisionModel = precisionModel;
        this._bufParams = bufParams;
    }
    static copyCoordinates(pts) {
        const copy = new Array(pts.length).fill(null);
        for(let i = 0; i < copy.length; i++)copy[i] = new (0, _coordinateJsDefault.default)(pts[i]);
        return copy;
    }
    getOffsetCurve(inputPts, distance) {
        this._distance = distance;
        if (distance === 0.0) return null;
        const isRightSide = distance < 0.0;
        const posDistance = Math.abs(distance);
        const segGen = this.getSegGen(posDistance);
        if (inputPts.length <= 1) this.computePointCurve(inputPts[0], segGen);
        else this.computeOffsetCurve(inputPts, isRightSide, segGen);
        const curvePts = segGen.getCoordinates();
        if (isRightSide) (0, _coordinateArraysJsDefault.default).reverse(curvePts);
        return curvePts;
    }
    computeSingleSidedBufferCurve(inputPts, isRightSide, segGen) {
        const distTol = this.simplifyTolerance(this._distance);
        if (isRightSide) {
            segGen.addSegments(inputPts, true);
            const simp2 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, -distTol);
            const n2 = simp2.length - 1;
            segGen.initSideSegments(simp2[n2], simp2[n2 - 1], (0, _positionJsDefault.default).LEFT);
            segGen.addFirstSegment();
            for(let i = n2 - 2; i >= 0; i--)segGen.addNextSegment(simp2[i], true);
        } else {
            segGen.addSegments(inputPts, false);
            const simp1 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, distTol);
            const n1 = simp1.length - 1;
            segGen.initSideSegments(simp1[0], simp1[1], (0, _positionJsDefault.default).LEFT);
            segGen.addFirstSegment();
            for(let i = 2; i <= n1; i++)segGen.addNextSegment(simp1[i], true);
        }
        segGen.addLastSegment();
        segGen.closeRing();
    }
    computeRingBufferCurve(inputPts, side, segGen) {
        let distTol = this.simplifyTolerance(this._distance);
        if (side === (0, _positionJsDefault.default).RIGHT) distTol = -distTol;
        const simp = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, distTol);
        const n = simp.length - 1;
        segGen.initSideSegments(simp[n - 1], simp[0], side);
        for(let i = 1; i <= n; i++){
            const addStartPoint = i !== 1;
            segGen.addNextSegment(simp[i], addStartPoint);
        }
        segGen.closeRing();
    }
    computeLineBufferCurve(inputPts, segGen) {
        const distTol = this.simplifyTolerance(this._distance);
        const simp1 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, distTol);
        const n1 = simp1.length - 1;
        segGen.initSideSegments(simp1[0], simp1[1], (0, _positionJsDefault.default).LEFT);
        for(let i = 2; i <= n1; i++)segGen.addNextSegment(simp1[i], true);
        segGen.addLastSegment();
        segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);
        const simp2 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, -distTol);
        const n2 = simp2.length - 1;
        segGen.initSideSegments(simp2[n2], simp2[n2 - 1], (0, _positionJsDefault.default).LEFT);
        for(let i = n2 - 2; i >= 0; i--)segGen.addNextSegment(simp2[i], true);
        segGen.addLastSegment();
        segGen.addLineEndCap(simp2[1], simp2[0]);
        segGen.closeRing();
    }
    computePointCurve(pt, segGen) {
        switch(this._bufParams.getEndCapStyle()){
            case (0, _bufferParametersJsDefault.default).CAP_ROUND:
                segGen.createCircle(pt);
                break;
            case (0, _bufferParametersJsDefault.default).CAP_SQUARE:
                segGen.createSquare(pt);
                break;
        }
    }
    getLineCurve(inputPts, distance) {
        this._distance = distance;
        if (this.isLineOffsetEmpty(distance)) return null;
        const posDistance = Math.abs(distance);
        const segGen = this.getSegGen(posDistance);
        if (inputPts.length <= 1) this.computePointCurve(inputPts[0], segGen);
        else if (this._bufParams.isSingleSided()) {
            const isRightSide = distance < 0.0;
            this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);
        } else this.computeLineBufferCurve(inputPts, segGen);
        const lineCoord = segGen.getCoordinates();
        return lineCoord;
    }
    getBufferParameters() {
        return this._bufParams;
    }
    simplifyTolerance(bufDistance) {
        return bufDistance * this._bufParams.getSimplifyFactor();
    }
    getRingCurve(inputPts, side, distance) {
        this._distance = distance;
        if (inputPts.length <= 2) return this.getLineCurve(inputPts, distance);
        if (distance === 0.0) return OffsetCurveBuilder.copyCoordinates(inputPts);
        const segGen = this.getSegGen(distance);
        this.computeRingBufferCurve(inputPts, side, segGen);
        return segGen.getCoordinates();
    }
    computeOffsetCurve(inputPts, isRightSide, segGen) {
        const distTol = this.simplifyTolerance(this._distance);
        if (isRightSide) {
            const simp2 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, -distTol);
            const n2 = simp2.length - 1;
            segGen.initSideSegments(simp2[n2], simp2[n2 - 1], (0, _positionJsDefault.default).LEFT);
            segGen.addFirstSegment();
            for(let i = n2 - 2; i >= 0; i--)segGen.addNextSegment(simp2[i], true);
        } else {
            const simp1 = (0, _bufferInputLineSimplifierJsDefault.default).simplify(inputPts, distTol);
            const n1 = simp1.length - 1;
            segGen.initSideSegments(simp1[0], simp1[1], (0, _positionJsDefault.default).LEFT);
            segGen.addFirstSegment();
            for(let i = 2; i <= n1; i++)segGen.addNextSegment(simp1[i], true);
        }
        segGen.addLastSegment();
    }
    isLineOffsetEmpty(distance) {
        if (distance === 0.0) return true;
        if (distance < 0.0 && !this._bufParams.isSingleSided()) return true;
        return false;
    }
    getSegGen(distance) {
        return new (0, _offsetSegmentGeneratorJsDefault.default)(this._precisionModel, this._bufParams, distance);
    }
}
exports.default = OffsetCurveBuilder;

},{"./BufferParameters.js":"frCaq","../../geomgraph/Position.js":"929cL","../../geom/Coordinate.js":"3REUb","./BufferInputLineSimplifier.js":"bbi5g","../../geom/CoordinateArrays.js":"hwXsf","./OffsetSegmentGenerator.js":"6C7Gc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bbi5g":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateListJs = require("../../geom/CoordinateList.js");
var _coordinateListJsDefault = parcelHelpers.interopDefault(_coordinateListJs);
var _orientationJs = require("../../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _distanceJs = require("../../algorithm/Distance.js");
var _distanceJsDefault = parcelHelpers.interopDefault(_distanceJs);
class BufferInputLineSimplifier {
    constructor(){
        BufferInputLineSimplifier.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._inputLine = null;
        this._distanceTol = null;
        this._isDeleted = null;
        this._angleOrientation = (0, _orientationJsDefault.default).COUNTERCLOCKWISE;
        const inputLine = arguments[0];
        this._inputLine = inputLine;
    }
    static simplify(inputLine, distanceTol) {
        const simp = new BufferInputLineSimplifier(inputLine);
        return simp.simplify(distanceTol);
    }
    isDeletable(i0, i1, i2, distanceTol) {
        const p0 = this._inputLine[i0];
        const p1 = this._inputLine[i1];
        const p2 = this._inputLine[i2];
        if (!this.isConcave(p0, p1, p2)) return false;
        if (!this.isShallow(p0, p1, p2, distanceTol)) return false;
        return this.isShallowSampled(p0, p1, i0, i2, distanceTol);
    }
    deleteShallowConcavities() {
        let index = 1;
        let midIndex = this.findNextNonDeletedIndex(index);
        let lastIndex = this.findNextNonDeletedIndex(midIndex);
        let isChanged = false;
        while(lastIndex < this._inputLine.length){
            let isMiddleVertexDeleted = false;
            if (this.isDeletable(index, midIndex, lastIndex, this._distanceTol)) {
                this._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;
                isMiddleVertexDeleted = true;
                isChanged = true;
            }
            if (isMiddleVertexDeleted) index = lastIndex;
            else index = midIndex;
            midIndex = this.findNextNonDeletedIndex(index);
            lastIndex = this.findNextNonDeletedIndex(midIndex);
        }
        return isChanged;
    }
    isShallowConcavity(p0, p1, p2, distanceTol) {
        const orientation = (0, _orientationJsDefault.default).index(p0, p1, p2);
        const isAngleToSimplify = orientation === this._angleOrientation;
        if (!isAngleToSimplify) return false;
        const dist = (0, _distanceJsDefault.default).pointToSegment(p1, p0, p2);
        return dist < distanceTol;
    }
    isShallowSampled(p0, p2, i0, i2, distanceTol) {
        let inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);
        if (inc <= 0) inc = 1;
        for(let i = i0; i < i2; i += inc)if (!this.isShallow(p0, p2, this._inputLine[i], distanceTol)) return false;
        return true;
    }
    isConcave(p0, p1, p2) {
        const orientation = (0, _orientationJsDefault.default).index(p0, p1, p2);
        const isConcave = orientation === this._angleOrientation;
        return isConcave;
    }
    simplify(distanceTol) {
        this._distanceTol = Math.abs(distanceTol);
        if (distanceTol < 0) this._angleOrientation = (0, _orientationJsDefault.default).CLOCKWISE;
        this._isDeleted = new Array(this._inputLine.length).fill(null);
        let isChanged = false;
        do isChanged = this.deleteShallowConcavities();
        while (isChanged);
        return this.collapseLine();
    }
    findNextNonDeletedIndex(index) {
        let next = index + 1;
        while(next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE)next++;
        return next;
    }
    isShallow(p0, p1, p2, distanceTol) {
        const dist = (0, _distanceJsDefault.default).pointToSegment(p1, p0, p2);
        return dist < distanceTol;
    }
    collapseLine() {
        const coordList = new (0, _coordinateListJsDefault.default)();
        for(let i = 0; i < this._inputLine.length; i++)if (this._isDeleted[i] !== BufferInputLineSimplifier.DELETE) coordList.add(this._inputLine[i]);
        return coordList.toCoordinateArray();
    }
}
exports.default = BufferInputLineSimplifier;
BufferInputLineSimplifier.INIT = 0;
BufferInputLineSimplifier.DELETE = 1;
BufferInputLineSimplifier.KEEP = 1;
BufferInputLineSimplifier.NUM_PTS_TO_CHECK = 10;

},{"../../geom/CoordinateList.js":"39sXT","../../algorithm/Orientation.js":"QDWSa","../../algorithm/Distance.js":"gNNl0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6C7Gc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bufferParametersJs = require("./BufferParameters.js");
var _bufferParametersJsDefault = parcelHelpers.interopDefault(_bufferParametersJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
var _offsetSegmentStringJs = require("./OffsetSegmentString.js");
var _offsetSegmentStringJsDefault = parcelHelpers.interopDefault(_offsetSegmentStringJs);
var _orientationJs = require("../../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _intersectionJs = require("../../algorithm/Intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
var _angleJs = require("../../algorithm/Angle.js");
var _angleJsDefault = parcelHelpers.interopDefault(_angleJs);
var _robustLineIntersectorJs = require("../../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
class OffsetSegmentGenerator {
    constructor(){
        OffsetSegmentGenerator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._maxCurveSegmentError = 0.0;
        this._filletAngleQuantum = null;
        this._closingSegLengthFactor = 1;
        this._segList = null;
        this._distance = 0.0;
        this._precisionModel = null;
        this._bufParams = null;
        this._li = null;
        this._s0 = null;
        this._s1 = null;
        this._s2 = null;
        this._seg0 = new (0, _lineSegmentJsDefault.default)();
        this._seg1 = new (0, _lineSegmentJsDefault.default)();
        this._offset0 = new (0, _lineSegmentJsDefault.default)();
        this._offset1 = new (0, _lineSegmentJsDefault.default)();
        this._side = 0;
        this._hasNarrowConcaveAngle = false;
        const precisionModel = arguments[0], bufParams = arguments[1], distance = arguments[2];
        this._precisionModel = precisionModel;
        this._bufParams = bufParams;
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();
        if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === (0, _bufferParametersJsDefault.default).JOIN_ROUND) this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR;
        this.init(distance);
    }
    getCoordinates() {
        const pts = this._segList.getCoordinates();
        return pts;
    }
    addMitreJoin(p, offset0, offset1, distance) {
        const intPt = (0, _intersectionJsDefault.default).intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);
        if (intPt !== null) {
            const mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);
            if (mitreRatio <= this._bufParams.getMitreLimit()) {
                this._segList.addPt(intPt);
                return null;
            }
        }
        this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());
    }
    addLastSegment() {
        this._segList.addPt(this._offset1.p1);
    }
    initSideSegments(s1, s2, side) {
        this._s1 = s1;
        this._s2 = s2;
        this._side = side;
        this._seg1.setCoordinates(s1, s2);
        this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);
    }
    addLimitedMitreJoin(offset0, offset1, distance, mitreLimit) {
        const basePt = this._seg0.p1;
        const ang0 = (0, _angleJsDefault.default).angle(basePt, this._seg0.p0);
        const angDiff = (0, _angleJsDefault.default).angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);
        const angDiffHalf = angDiff / 2;
        const midAng = (0, _angleJsDefault.default).normalize(ang0 + angDiffHalf);
        const mitreMidAng = (0, _angleJsDefault.default).normalize(midAng + Math.PI);
        const mitreDist = mitreLimit * distance;
        const bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));
        const bevelHalfLen = distance - bevelDelta;
        const bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);
        const bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);
        const bevelMidPt = new (0, _coordinateJsDefault.default)(bevelMidX, bevelMidY);
        const mitreMidLine = new (0, _lineSegmentJsDefault.default)(basePt, bevelMidPt);
        const bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);
        const bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);
        if (this._side === (0, _positionJsDefault.default).LEFT) {
            this._segList.addPt(bevelEndLeft);
            this._segList.addPt(bevelEndRight);
        } else {
            this._segList.addPt(bevelEndRight);
            this._segList.addPt(bevelEndLeft);
        }
    }
    addDirectedFillet(p, startAngle, endAngle, direction, radius) {
        const directionFactor = direction === (0, _orientationJsDefault.default).CLOCKWISE ? -1 : 1;
        const totalAngle = Math.abs(startAngle - endAngle);
        const nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);
        if (nSegs < 1) return null;
        const angleInc = totalAngle / nSegs;
        const pt = new (0, _coordinateJsDefault.default)();
        for(let i = 0; i < nSegs; i++){
            const angle = startAngle + directionFactor * i * angleInc;
            pt.x = p.x + radius * Math.cos(angle);
            pt.y = p.y + radius * Math.sin(angle);
            this._segList.addPt(pt);
        }
    }
    computeOffsetSegment(seg, side, distance, offset) {
        const sideSign = side === (0, _positionJsDefault.default).LEFT ? 1 : -1;
        const dx = seg.p1.x - seg.p0.x;
        const dy = seg.p1.y - seg.p0.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        const ux = sideSign * distance * dx / len;
        const uy = sideSign * distance * dy / len;
        offset.p0.x = seg.p0.x - uy;
        offset.p0.y = seg.p0.y + ux;
        offset.p1.x = seg.p1.x - uy;
        offset.p1.y = seg.p1.y + ux;
    }
    addInsideTurn(orientation, addStartPoint) {
        this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);
        if (this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
        else {
            this._hasNarrowConcaveAngle = true;
            if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
            else {
                this._segList.addPt(this._offset0.p1);
                if (this._closingSegLengthFactor > 0) {
                    const mid0 = new (0, _coordinateJsDefault.default)((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                    this._segList.addPt(mid0);
                    const mid1 = new (0, _coordinateJsDefault.default)((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
                    this._segList.addPt(mid1);
                } else this._segList.addPt(this._s1);
                this._segList.addPt(this._offset1.p0);
            }
        }
    }
    createCircle(p) {
        const pt = new (0, _coordinateJsDefault.default)(p.x + this._distance, p.y);
        this._segList.addPt(pt);
        this.addDirectedFillet(p, 0.0, 2.0 * Math.PI, -1, this._distance);
        this._segList.closeRing();
    }
    addBevelJoin(offset0, offset1) {
        this._segList.addPt(offset0.p1);
        this._segList.addPt(offset1.p0);
    }
    init(distance) {
        this._distance = distance;
        this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));
        this._segList = new (0, _offsetSegmentStringJsDefault.default)();
        this._segList.setPrecisionModel(this._precisionModel);
        this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
    }
    addCollinear(addStartPoint) {
        this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
        const numInt = this._li.getIntersectionNum();
        if (numInt >= 2) {
            if (this._bufParams.getJoinStyle() === (0, _bufferParametersJsDefault.default).JOIN_BEVEL || this._bufParams.getJoinStyle() === (0, _bufferParametersJsDefault.default).JOIN_MITRE) {
                if (addStartPoint) this._segList.addPt(this._offset0.p1);
                this._segList.addPt(this._offset1.p0);
            } else this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, (0, _orientationJsDefault.default).CLOCKWISE, this._distance);
        }
    }
    addNextSegment(p, addStartPoint) {
        this._s0 = this._s1;
        this._s1 = this._s2;
        this._s2 = p;
        this._seg0.setCoordinates(this._s0, this._s1);
        this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);
        this._seg1.setCoordinates(this._s1, this._s2);
        this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);
        if (this._s1.equals(this._s2)) return null;
        const orientation = (0, _orientationJsDefault.default).index(this._s0, this._s1, this._s2);
        const outsideTurn = orientation === (0, _orientationJsDefault.default).CLOCKWISE && this._side === (0, _positionJsDefault.default).LEFT || orientation === (0, _orientationJsDefault.default).COUNTERCLOCKWISE && this._side === (0, _positionJsDefault.default).RIGHT;
        if (orientation === 0) this.addCollinear(addStartPoint);
        else if (outsideTurn) this.addOutsideTurn(orientation, addStartPoint);
        else this.addInsideTurn(orientation, addStartPoint);
    }
    addLineEndCap(p0, p1) {
        const seg = new (0, _lineSegmentJsDefault.default)(p0, p1);
        const offsetL = new (0, _lineSegmentJsDefault.default)();
        this.computeOffsetSegment(seg, (0, _positionJsDefault.default).LEFT, this._distance, offsetL);
        const offsetR = new (0, _lineSegmentJsDefault.default)();
        this.computeOffsetSegment(seg, (0, _positionJsDefault.default).RIGHT, this._distance, offsetR);
        const dx = p1.x - p0.x;
        const dy = p1.y - p0.y;
        const angle = Math.atan2(dy, dx);
        switch(this._bufParams.getEndCapStyle()){
            case (0, _bufferParametersJsDefault.default).CAP_ROUND:
                this._segList.addPt(offsetL.p1);
                this.addDirectedFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2, (0, _orientationJsDefault.default).CLOCKWISE, this._distance);
                this._segList.addPt(offsetR.p1);
                break;
            case (0, _bufferParametersJsDefault.default).CAP_FLAT:
                this._segList.addPt(offsetL.p1);
                this._segList.addPt(offsetR.p1);
                break;
            case (0, _bufferParametersJsDefault.default).CAP_SQUARE:
                const squareCapSideOffset = new (0, _coordinateJsDefault.default)();
                squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);
                squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);
                const squareCapLOffset = new (0, _coordinateJsDefault.default)(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);
                const squareCapROffset = new (0, _coordinateJsDefault.default)(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);
                this._segList.addPt(squareCapLOffset);
                this._segList.addPt(squareCapROffset);
                break;
        }
    }
    addOutsideTurn(orientation, addStartPoint) {
        if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {
            this._segList.addPt(this._offset0.p1);
            return null;
        }
        if (this._bufParams.getJoinStyle() === (0, _bufferParametersJsDefault.default).JOIN_MITRE) this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);
        else if (this._bufParams.getJoinStyle() === (0, _bufferParametersJsDefault.default).JOIN_BEVEL) this.addBevelJoin(this._offset0, this._offset1);
        else {
            if (addStartPoint) this._segList.addPt(this._offset0.p1);
            this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);
            this._segList.addPt(this._offset1.p0);
        }
    }
    createSquare(p) {
        this._segList.addPt(new (0, _coordinateJsDefault.default)(p.x + this._distance, p.y + this._distance));
        this._segList.addPt(new (0, _coordinateJsDefault.default)(p.x + this._distance, p.y - this._distance));
        this._segList.addPt(new (0, _coordinateJsDefault.default)(p.x - this._distance, p.y - this._distance));
        this._segList.addPt(new (0, _coordinateJsDefault.default)(p.x - this._distance, p.y + this._distance));
        this._segList.closeRing();
    }
    addSegments(pt, isForward) {
        this._segList.addPts(pt, isForward);
    }
    addFirstSegment() {
        this._segList.addPt(this._offset1.p0);
    }
    addCornerFillet(p, p0, p1, direction, radius) {
        const dx0 = p0.x - p.x;
        const dy0 = p0.y - p.y;
        let startAngle = Math.atan2(dy0, dx0);
        const dx1 = p1.x - p.x;
        const dy1 = p1.y - p.y;
        const endAngle = Math.atan2(dy1, dx1);
        if (direction === (0, _orientationJsDefault.default).CLOCKWISE) {
            if (startAngle <= endAngle) startAngle += 2.0 * Math.PI;
        } else if (startAngle >= endAngle) startAngle -= 2.0 * Math.PI;
        this._segList.addPt(p0);
        this.addDirectedFillet(p, startAngle, endAngle, direction, radius);
        this._segList.addPt(p1);
    }
    closeRing() {
        this._segList.closeRing();
    }
    hasNarrowConcaveAngle() {
        return this._hasNarrowConcaveAngle;
    }
}
exports.default = OffsetSegmentGenerator;
OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR = 1.0E-3;
OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-3;
OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1.0E-6;
OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR = 80;

},{"./BufferParameters.js":"frCaq","../../geomgraph/Position.js":"929cL","../../geom/Coordinate.js":"3REUb","../../geom/LineSegment.js":"4V3G8","./OffsetSegmentString.js":"1bkUR","../../algorithm/Orientation.js":"QDWSa","../../algorithm/Intersection.js":"46jkJ","../../algorithm/Angle.js":"6TTJB","../../algorithm/RobustLineIntersector.js":"fBBRl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1bkUR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryFactoryJs = require("../../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class OffsetSegmentString {
    constructor(){
        OffsetSegmentString.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._ptList = null;
        this._precisionModel = null;
        this._minimimVertexDistance = 0.0;
        this._ptList = new (0, _arrayListJsDefault.default)();
    }
    getCoordinates() {
        const coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);
        return coord;
    }
    setPrecisionModel(precisionModel) {
        this._precisionModel = precisionModel;
    }
    addPt(pt) {
        const bufPt = new (0, _coordinateJsDefault.default)(pt);
        this._precisionModel.makePrecise(bufPt);
        if (this.isRedundant(bufPt)) return null;
        this._ptList.add(bufPt);
    }
    reverse() {}
    addPts(pt, isForward) {
        if (isForward) for(let i = 0; i < pt.length; i++)this.addPt(pt[i]);
        else for(let i = pt.length - 1; i >= 0; i--)this.addPt(pt[i]);
    }
    isRedundant(pt) {
        if (this._ptList.size() < 1) return false;
        const lastPt = this._ptList.get(this._ptList.size() - 1);
        const ptDist = pt.distance(lastPt);
        if (ptDist < this._minimimVertexDistance) return true;
        return false;
    }
    toString() {
        const fact = new (0, _geometryFactoryJsDefault.default)();
        const line = fact.createLineString(this.getCoordinates());
        return line.toString();
    }
    closeRing() {
        if (this._ptList.size() < 1) return null;
        const startPt = new (0, _coordinateJsDefault.default)(this._ptList.get(0));
        const lastPt = this._ptList.get(this._ptList.size() - 1);
        if (startPt.equals(lastPt)) return null;
        this._ptList.add(startPt);
    }
    setMinimumVertexDistance(minimimVertexDistance) {
        this._minimimVertexDistance = minimimVertexDistance;
    }
}
exports.default = OffsetSegmentString;
OffsetSegmentString.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);

},{"../../geom/GeometryFactory.js":"6Ct9y","../../geom/Coordinate.js":"3REUb","../../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6TTJB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _orientationJs = require("./Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
class Angle {
    static toDegrees(radians) {
        return radians * 180 / Math.PI;
    }
    static isAcute(p0, p1, p2) {
        const dx0 = p0.x - p1.x;
        const dy0 = p0.y - p1.y;
        const dx1 = p2.x - p1.x;
        const dy1 = p2.y - p1.y;
        const dotprod = dx0 * dx1 + dy0 * dy1;
        return dotprod > 0;
    }
    static isObtuse(p0, p1, p2) {
        const dx0 = p0.x - p1.x;
        const dy0 = p0.y - p1.y;
        const dx1 = p2.x - p1.x;
        const dy1 = p2.y - p1.y;
        const dotprod = dx0 * dx1 + dy0 * dy1;
        return dotprod < 0;
    }
    static interiorAngle(p0, p1, p2) {
        const anglePrev = Angle.angle(p1, p0);
        const angleNext = Angle.angle(p1, p2);
        return Math.abs(angleNext - anglePrev);
    }
    static normalizePositive(angle) {
        if (angle < 0.0) {
            while(angle < 0.0)angle += Angle.PI_TIMES_2;
            if (angle >= Angle.PI_TIMES_2) angle = 0.0;
        } else {
            while(angle >= Angle.PI_TIMES_2)angle -= Angle.PI_TIMES_2;
            if (angle < 0.0) angle = 0.0;
        }
        return angle;
    }
    static angleBetween(tip1, tail, tip2) {
        const a1 = Angle.angle(tail, tip1);
        const a2 = Angle.angle(tail, tip2);
        return Angle.diff(a1, a2);
    }
    static diff(ang1, ang2) {
        let delAngle = null;
        if (ang1 < ang2) delAngle = ang2 - ang1;
        else delAngle = ang1 - ang2;
        if (delAngle > Math.PI) delAngle = 2 * Math.PI - delAngle;
        return delAngle;
    }
    static toRadians(angleDegrees) {
        return angleDegrees * Math.PI / 180.0;
    }
    static normalize(angle) {
        while(angle > Math.PI)angle -= Angle.PI_TIMES_2;
        while(angle <= -Math.PI)angle += Angle.PI_TIMES_2;
        return angle;
    }
    static angle() {
        if (arguments.length === 1) {
            const p = arguments[0];
            return Math.atan2(p.y, p.x);
        } else if (arguments.length === 2) {
            const p0 = arguments[0], p1 = arguments[1];
            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;
            return Math.atan2(dy, dx);
        }
    }
    static getTurn(ang1, ang2) {
        const crossproduct = Math.sin(ang2 - ang1);
        if (crossproduct > 0) return Angle.COUNTERCLOCKWISE;
        if (crossproduct < 0) return Angle.CLOCKWISE;
        return Angle.NONE;
    }
    static angleBetweenOriented(tip1, tail, tip2) {
        const a1 = Angle.angle(tail, tip1);
        const a2 = Angle.angle(tail, tip2);
        const angDel = a2 - a1;
        if (angDel <= -Math.PI) return angDel + Angle.PI_TIMES_2;
        if (angDel > Math.PI) return angDel - Angle.PI_TIMES_2;
        return angDel;
    }
}
exports.default = Angle;
Angle.PI_TIMES_2 = 2.0 * Math.PI;
Angle.PI_OVER_2 = Math.PI / 2.0;
Angle.PI_OVER_4 = Math.PI / 4.0;
Angle.COUNTERCLOCKWISE = (0, _orientationJsDefault.default).COUNTERCLOCKWISE;
Angle.CLOCKWISE = (0, _orientationJsDefault.default).CLOCKWISE;
Angle.NONE = (0, _orientationJsDefault.default).COLLINEAR;

},{"./Orientation.js":"QDWSa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"58e4Z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pointLocationJs = require("../../algorithm/PointLocation.js");
var _pointLocationJsDefault = parcelHelpers.interopDefault(_pointLocationJs);
var _topologyExceptionJs = require("../../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _maximalEdgeRingJs = require("./MaximalEdgeRing.js");
var _maximalEdgeRingJsDefault = parcelHelpers.interopDefault(_maximalEdgeRingJs);
var _coordinateArraysJs = require("../../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _planarGraphJs = require("../../geomgraph/PlanarGraph.js");
var _planarGraphJsDefault = parcelHelpers.interopDefault(_planarGraphJs);
class PolygonBuilder {
    constructor(){
        PolygonBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geometryFactory = null;
        this._shellList = new (0, _arrayListJsDefault.default)();
        const geometryFactory = arguments[0];
        this._geometryFactory = geometryFactory;
    }
    static findEdgeRingContaining(testEr, shellList) {
        const testRing = testEr.getLinearRing();
        const testEnv = testRing.getEnvelopeInternal();
        let testPt = testRing.getCoordinateN(0);
        let minShell = null;
        let minShellEnv = null;
        for(let it = shellList.iterator(); it.hasNext();){
            const tryShell = it.next();
            const tryShellRing = tryShell.getLinearRing();
            const tryShellEnv = tryShellRing.getEnvelopeInternal();
            if (tryShellEnv.equals(testEnv)) continue;
            if (!tryShellEnv.contains(testEnv)) continue;
            testPt = (0, _coordinateArraysJsDefault.default).ptNotInList(testRing.getCoordinates(), tryShellRing.getCoordinates());
            let isContained = false;
            if ((0, _pointLocationJsDefault.default).isInRing(testPt, tryShellRing.getCoordinates())) isContained = true;
            if (isContained) {
                if (minShell === null || minShellEnv.contains(tryShellEnv)) {
                    minShell = tryShell;
                    minShellEnv = minShell.getLinearRing().getEnvelopeInternal();
                }
            }
        }
        return minShell;
    }
    sortShellsAndHoles(edgeRings, shellList, freeHoleList) {
        for(let it = edgeRings.iterator(); it.hasNext();){
            const er = it.next();
            if (er.isHole()) freeHoleList.add(er);
            else shellList.add(er);
        }
    }
    computePolygons(shellList) {
        const resultPolyList = new (0, _arrayListJsDefault.default)();
        for(let it = shellList.iterator(); it.hasNext();){
            const er = it.next();
            const poly = er.toPolygon(this._geometryFactory);
            resultPolyList.add(poly);
        }
        return resultPolyList;
    }
    placeFreeHoles(shellList, freeHoleList) {
        for(let it = freeHoleList.iterator(); it.hasNext();){
            const hole = it.next();
            if (hole.getShell() === null) {
                const shell = PolygonBuilder.findEdgeRingContaining(hole, shellList);
                if (shell === null) throw new (0, _topologyExceptionJsDefault.default)('unable to assign hole to a shell', hole.getCoordinate(0));
                hole.setShell(shell);
            }
        }
    }
    buildMinimalEdgeRings(maxEdgeRings, shellList, freeHoleList) {
        const edgeRings = new (0, _arrayListJsDefault.default)();
        for(let it = maxEdgeRings.iterator(); it.hasNext();){
            const er = it.next();
            if (er.getMaxNodeDegree() > 2) {
                er.linkDirectedEdgesForMinimalEdgeRings();
                const minEdgeRings = er.buildMinimalRings();
                const shell = this.findShell(minEdgeRings);
                if (shell !== null) {
                    this.placePolygonHoles(shell, minEdgeRings);
                    shellList.add(shell);
                } else freeHoleList.addAll(minEdgeRings);
            } else edgeRings.add(er);
        }
        return edgeRings;
    }
    buildMaximalEdgeRings(dirEdges) {
        const maxEdgeRings = new (0, _arrayListJsDefault.default)();
        for(let it = dirEdges.iterator(); it.hasNext();){
            const de = it.next();
            if (de.isInResult() && de.getLabel().isArea()) {
                if (de.getEdgeRing() === null) {
                    const er = new (0, _maximalEdgeRingJsDefault.default)(de, this._geometryFactory);
                    maxEdgeRings.add(er);
                    er.setInResult();
                }
            }
        }
        return maxEdgeRings;
    }
    placePolygonHoles(shell, minEdgeRings) {
        for(let it = minEdgeRings.iterator(); it.hasNext();){
            const er = it.next();
            if (er.isHole()) er.setShell(shell);
        }
    }
    getPolygons() {
        const resultPolyList = this.computePolygons(this._shellList);
        return resultPolyList;
    }
    findShell(minEdgeRings) {
        let shellCount = 0;
        let shell = null;
        for(let it = minEdgeRings.iterator(); it.hasNext();){
            const er = it.next();
            if (!er.isHole()) {
                shell = er;
                shellCount++;
            }
        }
        (0, _assertJsDefault.default).isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');
        return shell;
    }
    add() {
        if (arguments.length === 1) {
            const graph = arguments[0];
            this.add(graph.getEdgeEnds(), graph.getNodes());
        } else if (arguments.length === 2) {
            const dirEdges = arguments[0], nodes = arguments[1];
            (0, _planarGraphJsDefault.default).linkResultDirectedEdges(nodes);
            const maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);
            const freeHoleList = new (0, _arrayListJsDefault.default)();
            const edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);
            this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);
            this.placeFreeHoles(this._shellList, freeHoleList);
        }
    }
}
exports.default = PolygonBuilder;

},{"../../algorithm/PointLocation.js":"3XiEk","../../geom/TopologyException.js":"cGr97","./MaximalEdgeRing.js":"eF9bN","../../geom/CoordinateArrays.js":"hwXsf","../../../../../java/util/ArrayList.js":"g8omH","../../util/Assert.js":"ePbcB","../../geomgraph/PlanarGraph.js":"42N6d","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eF9bN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _minimalEdgeRingJs = require("./MinimalEdgeRing.js");
var _minimalEdgeRingJsDefault = parcelHelpers.interopDefault(_minimalEdgeRingJs);
var _edgeRingJs = require("../../geomgraph/EdgeRing.js");
var _edgeRingJsDefault = parcelHelpers.interopDefault(_edgeRingJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class MaximalEdgeRing extends (0, _edgeRingJsDefault.default) {
    constructor(){
        super();
        MaximalEdgeRing.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const start = arguments[0], geometryFactory = arguments[1];
        (0, _edgeRingJsDefault.default).constructor_.call(this, start, geometryFactory);
    }
    linkDirectedEdgesForMinimalEdgeRings() {
        let de = this._startDe;
        do {
            const node = de.getNode();
            node.getEdges().linkMinimalDirectedEdges(this);
            de = de.getNext();
        }while (de !== this._startDe);
    }
    buildMinimalRings() {
        const minEdgeRings = new (0, _arrayListJsDefault.default)();
        let de = this._startDe;
        do {
            if (de.getMinEdgeRing() === null) {
                const minEr = new (0, _minimalEdgeRingJsDefault.default)(de, this._geometryFactory);
                minEdgeRings.add(minEr);
            }
            de = de.getNext();
        }while (de !== this._startDe);
        return minEdgeRings;
    }
    getNext(de) {
        return de.getNext();
    }
    setEdgeRing(de, er) {
        de.setEdgeRing(er);
    }
}
exports.default = MaximalEdgeRing;

},{"./MinimalEdgeRing.js":"i1qqJ","../../geomgraph/EdgeRing.js":"gORIt","../../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i1qqJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeRingJs = require("../../geomgraph/EdgeRing.js");
var _edgeRingJsDefault = parcelHelpers.interopDefault(_edgeRingJs);
class MinimalEdgeRing extends (0, _edgeRingJsDefault.default) {
    constructor(){
        super();
        MinimalEdgeRing.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const start = arguments[0], geometryFactory = arguments[1];
        (0, _edgeRingJsDefault.default).constructor_.call(this, start, geometryFactory);
    }
    getNext(de) {
        return de.getNextMin();
    }
    setEdgeRing(de, er) {
        de.setMinEdgeRing(er);
    }
}
exports.default = MinimalEdgeRing;

},{"../../geomgraph/EdgeRing.js":"gORIt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gORIt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _pointLocationJs = require("../algorithm/PointLocation.js");
var _pointLocationJsDefault = parcelHelpers.interopDefault(_pointLocationJs);
var _topologyExceptionJs = require("../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _orientationJs = require("../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class EdgeRing {
    constructor(){
        EdgeRing.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._startDe = null;
        this._maxNodeDegree = -1;
        this._edges = new (0, _arrayListJsDefault.default)();
        this._pts = new (0, _arrayListJsDefault.default)();
        this._label = new (0, _labelJsDefault.default)((0, _locationJsDefault.default).NONE);
        this._ring = null;
        this._isHole = null;
        this._shell = null;
        this._holes = new (0, _arrayListJsDefault.default)();
        this._geometryFactory = null;
        if (arguments.length === 0) ;
        else if (arguments.length === 2) {
            const start = arguments[0], geometryFactory = arguments[1];
            this._geometryFactory = geometryFactory;
            this.computePoints(start);
            this.computeRing();
        }
    }
    computeRing() {
        if (this._ring !== null) return null;
        const coord = new Array(this._pts.size()).fill(null);
        for(let i = 0; i < this._pts.size(); i++)coord[i] = this._pts.get(i);
        this._ring = this._geometryFactory.createLinearRing(coord);
        this._isHole = (0, _orientationJsDefault.default).isCCW(this._ring.getCoordinates());
    }
    isIsolated() {
        return this._label.getGeometryCount() === 1;
    }
    computePoints(start) {
        this._startDe = start;
        let de = start;
        let isFirstEdge = true;
        do {
            if (de === null) throw new (0, _topologyExceptionJsDefault.default)('Found null DirectedEdge');
            if (de.getEdgeRing() === this) throw new (0, _topologyExceptionJsDefault.default)('Directed Edge visited twice during ring-building at ' + de.getCoordinate());
            this._edges.add(de);
            const label = de.getLabel();
            (0, _assertJsDefault.default).isTrue(label.isArea());
            this.mergeLabel(label);
            this.addPoints(de.getEdge(), de.isForward(), isFirstEdge);
            isFirstEdge = false;
            this.setEdgeRing(de, this);
            de = this.getNext(de);
        }while (de !== this._startDe);
    }
    getLinearRing() {
        return this._ring;
    }
    getCoordinate(i) {
        return this._pts.get(i);
    }
    computeMaxNodeDegree() {
        this._maxNodeDegree = 0;
        let de = this._startDe;
        do {
            const node = de.getNode();
            const degree = node.getEdges().getOutgoingDegree(this);
            if (degree > this._maxNodeDegree) this._maxNodeDegree = degree;
            de = this.getNext(de);
        }while (de !== this._startDe);
        this._maxNodeDegree *= 2;
    }
    addPoints(edge, isForward, isFirstEdge) {
        const edgePts = edge.getCoordinates();
        if (isForward) {
            let startIndex = 1;
            if (isFirstEdge) startIndex = 0;
            for(let i = startIndex; i < edgePts.length; i++)this._pts.add(edgePts[i]);
        } else {
            let startIndex = edgePts.length - 2;
            if (isFirstEdge) startIndex = edgePts.length - 1;
            for(let i = startIndex; i >= 0; i--)this._pts.add(edgePts[i]);
        }
    }
    containsPoint(p) {
        const shell = this.getLinearRing();
        const env = shell.getEnvelopeInternal();
        if (!env.contains(p)) return false;
        if (!(0, _pointLocationJsDefault.default).isInRing(p, shell.getCoordinates())) return false;
        for(let i = this._holes.iterator(); i.hasNext();){
            const hole = i.next();
            if (hole.containsPoint(p)) return false;
        }
        return true;
    }
    getMaxNodeDegree() {
        if (this._maxNodeDegree < 0) this.computeMaxNodeDegree();
        return this._maxNodeDegree;
    }
    setShell(shell) {
        this._shell = shell;
        if (shell !== null) shell.addHole(this);
    }
    toPolygon(geometryFactory) {
        const holeLR = new Array(this._holes.size()).fill(null);
        for(let i = 0; i < this._holes.size(); i++)holeLR[i] = this._holes.get(i).getLinearRing();
        const poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);
        return poly;
    }
    isHole() {
        return this._isHole;
    }
    setInResult() {
        let de = this._startDe;
        do {
            de.getEdge().setInResult(true);
            de = de.getNext();
        }while (de !== this._startDe);
    }
    addHole(ring) {
        this._holes.add(ring);
    }
    isShell() {
        return this._shell === null;
    }
    getLabel() {
        return this._label;
    }
    getEdges() {
        return this._edges;
    }
    getShell() {
        return this._shell;
    }
    mergeLabel() {
        if (arguments.length === 1) {
            const deLabel = arguments[0];
            this.mergeLabel(deLabel, 0);
            this.mergeLabel(deLabel, 1);
        } else if (arguments.length === 2) {
            const deLabel = arguments[0], geomIndex = arguments[1];
            const loc = deLabel.getLocation(geomIndex, (0, _positionJsDefault.default).RIGHT);
            if (loc === (0, _locationJsDefault.default).NONE) return null;
            if (this._label.getLocation(geomIndex) === (0, _locationJsDefault.default).NONE) {
                this._label.setLocation(geomIndex, loc);
                return null;
            }
        }
    }
}
exports.default = EdgeRing;

},{"../geom/Location.js":"71R1B","./Position.js":"929cL","../algorithm/PointLocation.js":"3XiEk","../geom/TopologyException.js":"cGr97","../algorithm/Orientation.js":"QDWSa","./Label.js":"2NrfJ","../../../../java/util/ArrayList.js":"g8omH","../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fgRmL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
var _comparableJs = require("../../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _listJs = require("../../../../../java/util/List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
var _directedEdgeJs = require("../../geomgraph/DirectedEdge.js");
var _directedEdgeJsDefault = parcelHelpers.interopDefault(_directedEdgeJs);
var _orientationJs = require("../../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _collectionsJs = require("../../../../../java/util/Collections.js");
var _collectionsJsDefault = parcelHelpers.interopDefault(_collectionsJs);
class SubgraphDepthLocater {
    constructor(){
        SubgraphDepthLocater.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._subgraphs = null;
        this._seg = new (0, _lineSegmentJsDefault.default)();
        const subgraphs = arguments[0];
        this._subgraphs = subgraphs;
    }
    findStabbedSegments() {
        if (arguments.length === 1) {
            const stabbingRayLeftPt = arguments[0];
            const stabbedSegments = new (0, _arrayListJsDefault.default)();
            for(let i = this._subgraphs.iterator(); i.hasNext();){
                const bsg = i.next();
                const env = bsg.getEnvelope();
                if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) continue;
                this.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);
            }
            return stabbedSegments;
        } else if (arguments.length === 3) {
            if ((0, _hasInterfaceJsDefault.default)(arguments[2], (0, _listJsDefault.default)) && arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof (0, _directedEdgeJsDefault.default)) {
                const stabbingRayLeftPt = arguments[0], dirEdge = arguments[1], stabbedSegments = arguments[2];
                const pts = dirEdge.getEdge().getCoordinates();
                for(let i = 0; i < pts.length - 1; i++){
                    this._seg.p0 = pts[i];
                    this._seg.p1 = pts[i + 1];
                    if (this._seg.p0.y > this._seg.p1.y) this._seg.reverse();
                    const maxx = Math.max(this._seg.p0.x, this._seg.p1.x);
                    if (maxx < stabbingRayLeftPt.x) continue;
                    if (this._seg.isHorizontal()) continue;
                    if (stabbingRayLeftPt.y < this._seg.p0.y || stabbingRayLeftPt.y > this._seg.p1.y) continue;
                    if ((0, _orientationJsDefault.default).index(this._seg.p0, this._seg.p1, stabbingRayLeftPt) === (0, _orientationJsDefault.default).RIGHT) continue;
                    let depth = dirEdge.getDepth((0, _positionJsDefault.default).LEFT);
                    if (!this._seg.p0.equals(pts[i])) depth = dirEdge.getDepth((0, _positionJsDefault.default).RIGHT);
                    const ds = new DepthSegment(this._seg, depth);
                    stabbedSegments.add(ds);
                }
            } else if ((0, _hasInterfaceJsDefault.default)(arguments[2], (0, _listJsDefault.default)) && arguments[0] instanceof (0, _coordinateJsDefault.default) && (0, _hasInterfaceJsDefault.default)(arguments[1], (0, _listJsDefault.default))) {
                const stabbingRayLeftPt = arguments[0], dirEdges = arguments[1], stabbedSegments = arguments[2];
                for(let i = dirEdges.iterator(); i.hasNext();){
                    const de = i.next();
                    if (!de.isForward()) continue;
                    this.findStabbedSegments(stabbingRayLeftPt, de, stabbedSegments);
                }
            }
        }
    }
    getDepth(p) {
        const stabbedSegments = this.findStabbedSegments(p);
        if (stabbedSegments.size() === 0) return 0;
        const ds = (0, _collectionsJsDefault.default).min(stabbedSegments);
        return ds._leftDepth;
    }
}
exports.default = SubgraphDepthLocater;
class DepthSegment {
    constructor(){
        DepthSegment.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._upwardSeg = null;
        this._leftDepth = null;
        const seg = arguments[0], depth = arguments[1];
        this._upwardSeg = new (0, _lineSegmentJsDefault.default)(seg);
        this._leftDepth = depth;
    }
    compareX(seg0, seg1) {
        const compare0 = seg0.p0.compareTo(seg1.p0);
        if (compare0 !== 0) return compare0;
        return seg0.p1.compareTo(seg1.p1);
    }
    toString() {
        return this._upwardSeg.toString();
    }
    compareTo(obj) {
        const other = obj;
        if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) return 1;
        if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) return -1;
        let orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);
        if (orientIndex !== 0) return orientIndex;
        orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);
        if (orientIndex !== 0) return orientIndex;
        return this._upwardSeg.compareTo(other._upwardSeg);
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
SubgraphDepthLocater.DepthSegment = DepthSegment;

},{"../../../../../hasInterface.js":"d8mIo","../../geomgraph/Position.js":"929cL","../../geom/Coordinate.js":"3REUb","../../geom/LineSegment.js":"4V3G8","../../../../../java/lang/Comparable.js":"6Adw4","../../../../../java/util/ArrayList.js":"g8omH","../../../../../java/util/List.js":"5xM2g","../../geomgraph/DirectedEdge.js":"4EruM","../../algorithm/Orientation.js":"QDWSa","../../../../../java/util/Collections.js":"hUg9B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9WThR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _lineStringJs = require("../../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _pointJs = require("../../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _linearRingJs = require("../../geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _orientationJs = require("../../algorithm/Orientation.js");
var _orientationJsDefault = parcelHelpers.interopDefault(_orientationJs);
var _multiPolygonJs = require("../../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _labelJs = require("../../geomgraph/Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _coordinateArraysJs = require("../../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _distanceJs = require("../../algorithm/Distance.js");
var _distanceJsDefault = parcelHelpers.interopDefault(_distanceJs);
var _multiLineStringJs = require("../../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _triangleJs = require("../../geom/Triangle.js");
var _triangleJsDefault = parcelHelpers.interopDefault(_triangleJs);
var _nodedSegmentStringJs = require("../../noding/NodedSegmentString.js");
var _nodedSegmentStringJsDefault = parcelHelpers.interopDefault(_nodedSegmentStringJs);
var _polygonJs = require("../../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _multiPointJs = require("../../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _geometryCollectionJs = require("../../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _unsupportedOperationExceptionJs = require("../../../../../java/lang/UnsupportedOperationException.js");
var _unsupportedOperationExceptionJsDefault = parcelHelpers.interopDefault(_unsupportedOperationExceptionJs);
class OffsetCurveSetBuilder {
    constructor(){
        OffsetCurveSetBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._inputGeom = null;
        this._distance = null;
        this._curveBuilder = null;
        this._curveList = new (0, _arrayListJsDefault.default)();
        const inputGeom = arguments[0], distance = arguments[1], curveBuilder = arguments[2];
        this._inputGeom = inputGeom;
        this._distance = distance;
        this._curveBuilder = curveBuilder;
    }
    addRingSide(coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {
        if (offsetDistance === 0.0 && coord.length < (0, _linearRingJsDefault.default).MINIMUM_VALID_SIZE) return null;
        let leftLoc = cwLeftLoc;
        let rightLoc = cwRightLoc;
        if (coord.length >= (0, _linearRingJsDefault.default).MINIMUM_VALID_SIZE && (0, _orientationJsDefault.default).isCCW(coord)) {
            leftLoc = cwRightLoc;
            rightLoc = cwLeftLoc;
            side = (0, _positionJsDefault.default).opposite(side);
        }
        const curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);
        this.addCurve(curve, leftLoc, rightLoc);
    }
    addRingBothSides(coord, distance) {
        this.addRingSide(coord, distance, (0, _positionJsDefault.default).LEFT, (0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR);
        this.addRingSide(coord, distance, (0, _positionJsDefault.default).RIGHT, (0, _locationJsDefault.default).INTERIOR, (0, _locationJsDefault.default).EXTERIOR);
    }
    addPoint(p) {
        if (this._distance <= 0.0) return null;
        const coord = p.getCoordinates();
        const curve = this._curveBuilder.getLineCurve(coord, this._distance);
        this.addCurve(curve, (0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR);
    }
    addPolygon(p) {
        let offsetDistance = this._distance;
        let offsetSide = (0, _positionJsDefault.default).LEFT;
        if (this._distance < 0.0) {
            offsetDistance = -this._distance;
            offsetSide = (0, _positionJsDefault.default).RIGHT;
        }
        const shell = p.getExteriorRing();
        const shellCoord = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(shell.getCoordinates());
        if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) return null;
        if (this._distance <= 0.0 && shellCoord.length < 3) return null;
        this.addRingSide(shellCoord, offsetDistance, offsetSide, (0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR);
        for(let i = 0; i < p.getNumInteriorRing(); i++){
            const hole = p.getInteriorRingN(i);
            const holeCoord = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(hole.getCoordinates());
            if (this._distance > 0.0 && this.isErodedCompletely(hole, -this._distance)) continue;
            this.addRingSide(holeCoord, offsetDistance, (0, _positionJsDefault.default).opposite(offsetSide), (0, _locationJsDefault.default).INTERIOR, (0, _locationJsDefault.default).EXTERIOR);
        }
    }
    isTriangleErodedCompletely(triangleCoord, bufferDistance) {
        const tri = new (0, _triangleJsDefault.default)(triangleCoord[0], triangleCoord[1], triangleCoord[2]);
        const inCentre = tri.inCentre();
        const distToCentre = (0, _distanceJsDefault.default).pointToSegment(inCentre, tri.p0, tri.p1);
        return distToCentre < Math.abs(bufferDistance);
    }
    addLineString(line) {
        if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
        const coord = (0, _coordinateArraysJsDefault.default).removeRepeatedPoints(line.getCoordinates());
        if ((0, _coordinateArraysJsDefault.default).isRing(coord) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(coord, this._distance);
        else {
            const curve = this._curveBuilder.getLineCurve(coord, this._distance);
            this.addCurve(curve, (0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR);
        }
    }
    add(g) {
        if (g.isEmpty()) return null;
        if (g instanceof (0, _polygonJsDefault.default)) this.addPolygon(g);
        else if (g instanceof (0, _lineStringJsDefault.default)) this.addLineString(g);
        else if (g instanceof (0, _pointJsDefault.default)) this.addPoint(g);
        else if (g instanceof (0, _multiPointJsDefault.default)) this.addCollection(g);
        else if (g instanceof (0, _multiLineStringJsDefault.default)) this.addCollection(g);
        else if (g instanceof (0, _multiPolygonJsDefault.default)) this.addCollection(g);
        else if (g instanceof (0, _geometryCollectionJsDefault.default)) this.addCollection(g);
        else throw new (0, _unsupportedOperationExceptionJsDefault.default)(g.getGeometryType());
    }
    addCurve(coord, leftLoc, rightLoc) {
        if (coord === null || coord.length < 2) return null;
        const e = new (0, _nodedSegmentStringJsDefault.default)(coord, new (0, _labelJsDefault.default)(0, (0, _locationJsDefault.default).BOUNDARY, leftLoc, rightLoc));
        this._curveList.add(e);
    }
    getCurves() {
        this.add(this._inputGeom);
        return this._curveList;
    }
    isErodedCompletely(ring, bufferDistance) {
        const ringCoord = ring.getCoordinates();
        if (ringCoord.length < 4) return bufferDistance < 0;
        if (ringCoord.length === 4) return this.isTriangleErodedCompletely(ringCoord, bufferDistance);
        const env = ring.getEnvelopeInternal();
        const envMinDimension = Math.min(env.getHeight(), env.getWidth());
        if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) return true;
        return false;
    }
    addCollection(gc) {
        for(let i = 0; i < gc.getNumGeometries(); i++){
            const g = gc.getGeometryN(i);
            this.add(g);
        }
    }
}
exports.default = OffsetCurveSetBuilder;

},{"../../geom/Location.js":"71R1B","../../geom/LineString.js":"1Hc8p","../../geomgraph/Position.js":"929cL","../../geom/Point.js":"i9MoJ","../../geom/LinearRing.js":"iks2I","../../algorithm/Orientation.js":"QDWSa","../../geom/MultiPolygon.js":"56YaT","../../geomgraph/Label.js":"2NrfJ","../../geom/CoordinateArrays.js":"hwXsf","../../../../../java/util/ArrayList.js":"g8omH","../../algorithm/Distance.js":"gNNl0","../../geom/MultiLineString.js":"fdpMS","../../geom/Triangle.js":"jShNO","../../noding/NodedSegmentString.js":"lhvbm","../../geom/Polygon.js":"jawWe","../../geom/MultiPoint.js":"ikww2","../../geom/GeometryCollection.js":"9xeCT","../../../../../java/lang/UnsupportedOperationException.js":"fEx26","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jShNO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _ddJs = require("../math/DD.js");
var _ddJsDefault = parcelHelpers.interopDefault(_ddJs);
var _angleJs = require("../algorithm/Angle.js");
var _angleJsDefault = parcelHelpers.interopDefault(_angleJs);
var _hcoordinateJs = require("../algorithm/HCoordinate.js");
var _hcoordinateJsDefault = parcelHelpers.interopDefault(_hcoordinateJs);
var _coordinateJs = require("./Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _illegalArgumentExceptionJs = require("../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
class Triangle {
    constructor(){
        Triangle.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.p0 = null;
        this.p1 = null;
        this.p2 = null;
        const p0 = arguments[0], p1 = arguments[1], p2 = arguments[2];
        this.p0 = p0;
        this.p1 = p1;
        this.p2 = p2;
    }
    static isAcute(a, b, c) {
        if (!(0, _angleJsDefault.default).isAcute(a, b, c)) return false;
        if (!(0, _angleJsDefault.default).isAcute(b, c, a)) return false;
        if (!(0, _angleJsDefault.default).isAcute(c, a, b)) return false;
        return true;
    }
    static circumcentre(a, b, c) {
        const cx = c.x;
        const cy = c.y;
        const ax = a.x - cx;
        const ay = a.y - cy;
        const bx = b.x - cx;
        const by = b.y - cy;
        const denom = 2 * Triangle.det(ax, ay, bx, by);
        const numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);
        const numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);
        const ccx = cx - numx / denom;
        const ccy = cy + numy / denom;
        return new (0, _coordinateJsDefault.default)(ccx, ccy);
    }
    static perpendicularBisector(a, b) {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const l1 = new (0, _hcoordinateJsDefault.default)(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);
        const l2 = new (0, _hcoordinateJsDefault.default)(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);
        return new (0, _hcoordinateJsDefault.default)(l1, l2);
    }
    static angleBisector(a, b, c) {
        const len0 = b.distance(a);
        const len2 = b.distance(c);
        const frac = len0 / (len0 + len2);
        const dx = c.x - a.x;
        const dy = c.y - a.y;
        const splitPt = new (0, _coordinateJsDefault.default)(a.x + frac * dx, a.y + frac * dy);
        return splitPt;
    }
    static inCentre(a, b, c) {
        const len0 = b.distance(c);
        const len1 = a.distance(c);
        const len2 = a.distance(b);
        const circum = len0 + len1 + len2;
        const inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;
        const inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;
        return new (0, _coordinateJsDefault.default)(inCentreX, inCentreY);
    }
    static area(a, b, c) {
        return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2);
    }
    static signedArea(a, b, c) {
        return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2;
    }
    static det(m00, m01, m10, m11) {
        return m00 * m11 - m01 * m10;
    }
    static interpolateZ(p, v0, v1, v2) {
        const x0 = v0.x;
        const y0 = v0.y;
        const a = v1.x - x0;
        const b = v2.x - x0;
        const c = v1.y - y0;
        const d = v2.y - y0;
        const det = a * d - b * c;
        const dx = p.x - x0;
        const dy = p.y - y0;
        const t = (d * dx - b * dy) / det;
        const u = (-c * dx + a * dy) / det;
        const z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());
        return z;
    }
    static longestSideLength(a, b, c) {
        const lenAB = a.distance(b);
        const lenBC = b.distance(c);
        const lenCA = c.distance(a);
        let maxLen = lenAB;
        if (lenBC > maxLen) maxLen = lenBC;
        if (lenCA > maxLen) maxLen = lenCA;
        return maxLen;
    }
    static circumcentreDD(a, b, c) {
        const ax = (0, _ddJsDefault.default).valueOf(a.x).subtract(c.x);
        const ay = (0, _ddJsDefault.default).valueOf(a.y).subtract(c.y);
        const bx = (0, _ddJsDefault.default).valueOf(b.x).subtract(c.x);
        const by = (0, _ddJsDefault.default).valueOf(b.y).subtract(c.y);
        const denom = (0, _ddJsDefault.default).determinant(ax, ay, bx, by).multiply(2);
        const asqr = ax.sqr().add(ay.sqr());
        const bsqr = bx.sqr().add(by.sqr());
        const numx = (0, _ddJsDefault.default).determinant(ay, asqr, by, bsqr);
        const numy = (0, _ddJsDefault.default).determinant(ax, asqr, bx, bsqr);
        const ccx = (0, _ddJsDefault.default).valueOf(c.x).subtract(numx.divide(denom)).doubleValue();
        const ccy = (0, _ddJsDefault.default).valueOf(c.y).add(numy.divide(denom)).doubleValue();
        return new (0, _coordinateJsDefault.default)(ccx, ccy);
    }
    static area3D(a, b, c) {
        const ux = b.x - a.x;
        const uy = b.y - a.y;
        const uz = b.getZ() - a.getZ();
        const vx = c.x - a.x;
        const vy = c.y - a.y;
        const vz = c.getZ() - a.getZ();
        const crossx = uy * vz - uz * vy;
        const crossy = uz * vx - ux * vz;
        const crossz = ux * vy - uy * vx;
        const absSq = crossx * crossx + crossy * crossy + crossz * crossz;
        const area3D = Math.sqrt(absSq) / 2;
        return area3D;
    }
    static centroid(a, b, c) {
        const x = (a.x + b.x + c.x) / 3;
        const y = (a.y + b.y + c.y) / 3;
        return new (0, _coordinateJsDefault.default)(x, y);
    }
    interpolateZ(p) {
        if (p === null) throw new (0, _illegalArgumentExceptionJsDefault.default)('Supplied point is null.');
        return Triangle.interpolateZ(p, this.p0, this.p1, this.p2);
    }
    longestSideLength() {
        return Triangle.longestSideLength(this.p0, this.p1, this.p2);
    }
    isAcute() {
        return Triangle.isAcute(this.p0, this.p1, this.p2);
    }
    circumcentre() {
        return Triangle.circumcentre(this.p0, this.p1, this.p2);
    }
    inCentre() {
        return Triangle.inCentre(this.p0, this.p1, this.p2);
    }
    area() {
        return Triangle.area(this.p0, this.p1, this.p2);
    }
    signedArea() {
        return Triangle.signedArea(this.p0, this.p1, this.p2);
    }
    area3D() {
        return Triangle.area3D(this.p0, this.p1, this.p2);
    }
    centroid() {
        return Triangle.centroid(this.p0, this.p1, this.p2);
    }
}
exports.default = Triangle;

},{"../math/DD.js":"jc3gq","../algorithm/Angle.js":"6TTJB","../algorithm/HCoordinate.js":"buucn","./Coordinate.js":"3REUb","../../../../java/lang/IllegalArgumentException.js":"1VQhm","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"buucn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _notRepresentableExceptionJs = require("./NotRepresentableException.js");
var _notRepresentableExceptionJsDefault = parcelHelpers.interopDefault(_notRepresentableExceptionJs);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
class HCoordinate {
    constructor(){
        HCoordinate.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.x = null;
        this.y = null;
        this.w = null;
        if (arguments.length === 0) {
            this.x = 0.0;
            this.y = 0.0;
            this.w = 1.0;
        } else if (arguments.length === 1) {
            const p = arguments[0];
            this.x = p.x;
            this.y = p.y;
            this.w = 1.0;
        } else if (arguments.length === 2) {
            if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
                const _x = arguments[0], _y = arguments[1];
                this.x = _x;
                this.y = _y;
                this.w = 1.0;
            } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {
                const p1 = arguments[0], p2 = arguments[1];
                this.x = p1.y * p2.w - p2.y * p1.w;
                this.y = p2.x * p1.w - p1.x * p2.w;
                this.w = p1.x * p2.y - p2.x * p1.y;
            } else if (arguments[0] instanceof (0, _coordinateJsDefault.default) && arguments[1] instanceof (0, _coordinateJsDefault.default)) {
                const p1 = arguments[0], p2 = arguments[1];
                this.x = p1.y - p2.y;
                this.y = p2.x - p1.x;
                this.w = p1.x * p2.y - p2.x * p1.y;
            }
        } else if (arguments.length === 3) {
            const _x = arguments[0], _y = arguments[1], _w = arguments[2];
            this.x = _x;
            this.y = _y;
            this.w = _w;
        } else if (arguments.length === 4) {
            const p1 = arguments[0], p2 = arguments[1], q1 = arguments[2], q2 = arguments[3];
            const px = p1.y - p2.y;
            const py = p2.x - p1.x;
            const pw = p1.x * p2.y - p2.x * p1.y;
            const qx = q1.y - q2.y;
            const qy = q2.x - q1.x;
            const qw = q1.x * q2.y - q2.x * q1.y;
            this.x = py * qw - qy * pw;
            this.y = qx * pw - px * qw;
            this.w = px * qy - qx * py;
        }
    }
    getCoordinate() {
        const p = new (0, _coordinateJsDefault.default)();
        p.x = this.getX();
        p.y = this.getY();
        return p;
    }
    getX() {
        const a = this.x / this.w;
        if ((0, _doubleJsDefault.default).isNaN(a) || (0, _doubleJsDefault.default).isInfinite(a)) throw new (0, _notRepresentableExceptionJsDefault.default)();
        return a;
    }
    getY() {
        const a = this.y / this.w;
        if ((0, _doubleJsDefault.default).isNaN(a) || (0, _doubleJsDefault.default).isInfinite(a)) throw new (0, _notRepresentableExceptionJsDefault.default)();
        return a;
    }
}
exports.default = HCoordinate;

},{"./NotRepresentableException.js":"egjrO","../geom/Coordinate.js":"3REUb","../../../../java/lang/Double.js":"jCc26","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"egjrO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _exceptionJs = require("../../../../java/lang/Exception.js");
var _exceptionJsDefault = parcelHelpers.interopDefault(_exceptionJs);
class NotRepresentableException extends (0, _exceptionJsDefault.default) {
    constructor(){
        super();
        NotRepresentableException.constructor_.apply(this, arguments);
    }
    static constructor_() {
        (0, _exceptionJsDefault.default).constructor_.call(this, 'Projective point not representable on the Cartesian plane.');
    }
}
exports.default = NotRepresentableException;

},{"../../../../java/lang/Exception.js":"gSmog","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3i3AP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _directedEdgeStarJs = require("../../geomgraph/DirectedEdgeStar.js");
var _directedEdgeStarJsDefault = parcelHelpers.interopDefault(_directedEdgeStarJs);
var _nodeJs = require("../../geomgraph/Node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
var _nodeFactoryJs = require("../../geomgraph/NodeFactory.js");
var _nodeFactoryJsDefault = parcelHelpers.interopDefault(_nodeFactoryJs);
class OverlayNodeFactory extends (0, _nodeFactoryJsDefault.default) {
    constructor(){
        super();
    }
    createNode(coord) {
        return new (0, _nodeJsDefault.default)(coord, new (0, _directedEdgeStarJsDefault.default)());
    }
}
exports.default = OverlayNodeFactory;

},{"../../geomgraph/DirectedEdgeStar.js":"b7jFb","../../geomgraph/Node.js":"fKSwC","../../geomgraph/NodeFactory.js":"ig4eg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b7jFb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _positionJs = require("./Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _topologyExceptionJs = require("../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _labelJs = require("./Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _edgeEndStarJs = require("./EdgeEndStar.js");
var _edgeEndStarJsDefault = parcelHelpers.interopDefault(_edgeEndStarJs);
var _systemJs = require("../../../../java/lang/System.js");
var _systemJsDefault = parcelHelpers.interopDefault(_systemJs);
var _quadrantJs = require("./Quadrant.js");
var _quadrantJsDefault = parcelHelpers.interopDefault(_quadrantJs);
var _assertJs = require("../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class DirectedEdgeStar extends (0, _edgeEndStarJsDefault.default) {
    constructor(){
        super();
        DirectedEdgeStar.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._resultAreaEdgeList = null;
        this._label = null;
        this._SCANNING_FOR_INCOMING = 1;
        this._LINKING_TO_OUTGOING = 2;
    }
    linkResultDirectedEdges() {
        this.getResultAreaEdges();
        let firstOut = null;
        let incoming = null;
        let state = this._SCANNING_FOR_INCOMING;
        for(let i = 0; i < this._resultAreaEdgeList.size(); i++){
            const nextOut = this._resultAreaEdgeList.get(i);
            const nextIn = nextOut.getSym();
            if (!nextOut.getLabel().isArea()) continue;
            if (firstOut === null && nextOut.isInResult()) firstOut = nextOut;
            switch(state){
                case this._SCANNING_FOR_INCOMING:
                    if (!nextIn.isInResult()) continue;
                    incoming = nextIn;
                    state = this._LINKING_TO_OUTGOING;
                    break;
                case this._LINKING_TO_OUTGOING:
                    if (!nextOut.isInResult()) continue;
                    incoming.setNext(nextOut);
                    state = this._SCANNING_FOR_INCOMING;
                    break;
            }
        }
        if (state === this._LINKING_TO_OUTGOING) {
            if (firstOut === null) throw new (0, _topologyExceptionJsDefault.default)('no outgoing dirEdge found', this.getCoordinate());
            (0, _assertJsDefault.default).isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');
            incoming.setNext(firstOut);
        }
    }
    insert(ee) {
        const de = ee;
        this.insertEdgeEnd(de, de);
    }
    getRightmostEdge() {
        const edges = this.getEdges();
        const size = edges.size();
        if (size < 1) return null;
        const de0 = edges.get(0);
        if (size === 1) return de0;
        const deLast = edges.get(size - 1);
        const quad0 = de0.getQuadrant();
        const quad1 = deLast.getQuadrant();
        if ((0, _quadrantJsDefault.default).isNorthern(quad0) && (0, _quadrantJsDefault.default).isNorthern(quad1)) return de0;
        else if (!(0, _quadrantJsDefault.default).isNorthern(quad0) && !(0, _quadrantJsDefault.default).isNorthern(quad1)) return deLast;
        else {
            const nonHorizontalEdge = null;
            if (de0.getDy() !== 0) return de0;
            else if (deLast.getDy() !== 0) return deLast;
        }
        (0, _assertJsDefault.default).shouldNeverReachHere('found two horizontal edges incident on node');
        return null;
    }
    updateLabelling(nodeLabel) {
        for(let it = this.iterator(); it.hasNext();){
            const de = it.next();
            const label = de.getLabel();
            label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));
            label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));
        }
    }
    linkAllDirectedEdges() {
        this.getEdges();
        let prevOut = null;
        let firstIn = null;
        for(let i = this._edgeList.size() - 1; i >= 0; i--){
            const nextOut = this._edgeList.get(i);
            const nextIn = nextOut.getSym();
            if (firstIn === null) firstIn = nextIn;
            if (prevOut !== null) nextIn.setNext(prevOut);
            prevOut = nextOut;
        }
        firstIn.setNext(prevOut);
    }
    computeDepths() {
        if (arguments.length === 1) {
            const de = arguments[0];
            const edgeIndex = this.findIndex(de);
            const startDepth = de.getDepth((0, _positionJsDefault.default).LEFT);
            const targetLastDepth = de.getDepth((0, _positionJsDefault.default).RIGHT);
            const nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);
            const lastDepth = this.computeDepths(0, edgeIndex, nextDepth);
            if (lastDepth !== targetLastDepth) throw new (0, _topologyExceptionJsDefault.default)('depth mismatch at ' + de.getCoordinate());
        } else if (arguments.length === 3) {
            const startIndex = arguments[0], endIndex = arguments[1], startDepth = arguments[2];
            let currDepth = startDepth;
            for(let i = startIndex; i < endIndex; i++){
                const nextDe = this._edgeList.get(i);
                nextDe.setEdgeDepths((0, _positionJsDefault.default).RIGHT, currDepth);
                currDepth = nextDe.getDepth((0, _positionJsDefault.default).LEFT);
            }
            return currDepth;
        }
    }
    mergeSymLabels() {
        for(let it = this.iterator(); it.hasNext();){
            const de = it.next();
            const label = de.getLabel();
            label.merge(de.getSym().getLabel());
        }
    }
    linkMinimalDirectedEdges(er) {
        let firstOut = null;
        let incoming = null;
        let state = this._SCANNING_FOR_INCOMING;
        for(let i = this._resultAreaEdgeList.size() - 1; i >= 0; i--){
            const nextOut = this._resultAreaEdgeList.get(i);
            const nextIn = nextOut.getSym();
            if (firstOut === null && nextOut.getEdgeRing() === er) firstOut = nextOut;
            switch(state){
                case this._SCANNING_FOR_INCOMING:
                    if (nextIn.getEdgeRing() !== er) continue;
                    incoming = nextIn;
                    state = this._LINKING_TO_OUTGOING;
                    break;
                case this._LINKING_TO_OUTGOING:
                    if (nextOut.getEdgeRing() !== er) continue;
                    incoming.setNextMin(nextOut);
                    state = this._SCANNING_FOR_INCOMING;
                    break;
            }
        }
        if (state === this._LINKING_TO_OUTGOING) {
            (0, _assertJsDefault.default).isTrue(firstOut !== null, 'found null for first outgoing dirEdge');
            (0, _assertJsDefault.default).isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');
            incoming.setNextMin(firstOut);
        }
    }
    getOutgoingDegree() {
        if (arguments.length === 0) {
            let degree = 0;
            for(let it = this.iterator(); it.hasNext();){
                const de = it.next();
                if (de.isInResult()) degree++;
            }
            return degree;
        } else if (arguments.length === 1) {
            const er = arguments[0];
            let degree = 0;
            for(let it = this.iterator(); it.hasNext();){
                const de = it.next();
                if (de.getEdgeRing() === er) degree++;
            }
            return degree;
        }
    }
    getLabel() {
        return this._label;
    }
    findCoveredLineEdges() {
        let startLoc = (0, _locationJsDefault.default).NONE;
        for(let it = this.iterator(); it.hasNext();){
            const nextOut = it.next();
            const nextIn = nextOut.getSym();
            if (!nextOut.isLineEdge()) {
                if (nextOut.isInResult()) {
                    startLoc = (0, _locationJsDefault.default).INTERIOR;
                    break;
                }
                if (nextIn.isInResult()) {
                    startLoc = (0, _locationJsDefault.default).EXTERIOR;
                    break;
                }
            }
        }
        if (startLoc === (0, _locationJsDefault.default).NONE) return null;
        let currLoc = startLoc;
        for(let it = this.iterator(); it.hasNext();){
            const nextOut = it.next();
            const nextIn = nextOut.getSym();
            if (nextOut.isLineEdge()) nextOut.getEdge().setCovered(currLoc === (0, _locationJsDefault.default).INTERIOR);
            else {
                if (nextOut.isInResult()) currLoc = (0, _locationJsDefault.default).EXTERIOR;
                if (nextIn.isInResult()) currLoc = (0, _locationJsDefault.default).INTERIOR;
            }
        }
    }
    computeLabelling(geom) {
        super.computeLabelling.call(this, geom);
        this._label = new (0, _labelJsDefault.default)((0, _locationJsDefault.default).NONE);
        for(let it = this.iterator(); it.hasNext();){
            const ee = it.next();
            const e = ee.getEdge();
            const eLabel = e.getLabel();
            for(let i = 0; i < 2; i++){
                const eLoc = eLabel.getLocation(i);
                if (eLoc === (0, _locationJsDefault.default).INTERIOR || eLoc === (0, _locationJsDefault.default).BOUNDARY) this._label.setLocation(i, (0, _locationJsDefault.default).INTERIOR);
            }
        }
    }
    print(out) {
        (0, _systemJsDefault.default).out.println('DirectedEdgeStar: ' + this.getCoordinate());
        for(let it = this.iterator(); it.hasNext();){
            const de = it.next();
            out.print('out ');
            de.print(out);
            out.println();
            out.print('in ');
            de.getSym().print(out);
            out.println();
        }
    }
    getResultAreaEdges() {
        if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
        this._resultAreaEdgeList = new (0, _arrayListJsDefault.default)();
        for(let it = this.iterator(); it.hasNext();){
            const de = it.next();
            if (de.isInResult() || de.getSym().isInResult()) this._resultAreaEdgeList.add(de);
        }
        return this._resultAreaEdgeList;
    }
}
exports.default = DirectedEdgeStar;

},{"../geom/Location.js":"71R1B","./Position.js":"929cL","../geom/TopologyException.js":"cGr97","./Label.js":"2NrfJ","../../../../java/util/ArrayList.js":"g8omH","./EdgeEndStar.js":"4v1Qe","../../../../java/lang/System.js":"11VqP","./Quadrant.js":"hwMrb","../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4eJVd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _orientedCoordinateArrayJs = require("../noding/OrientedCoordinateArray.js");
var _orientedCoordinateArrayJsDefault = parcelHelpers.interopDefault(_orientedCoordinateArrayJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _treeMapJs = require("../../../../java/util/TreeMap.js");
var _treeMapJsDefault = parcelHelpers.interopDefault(_treeMapJs);
class EdgeList {
    constructor(){
        EdgeList.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._edges = new (0, _arrayListJsDefault.default)();
        this._ocaMap = new (0, _treeMapJsDefault.default)();
    }
    print(out) {
        out.print('MULTILINESTRING ( ');
        for(let j = 0; j < this._edges.size(); j++){
            const e = this._edges.get(j);
            if (j > 0) out.print(',');
            out.print('(');
            const pts = e.getCoordinates();
            for(let i = 0; i < pts.length; i++){
                if (i > 0) out.print(',');
                out.print(pts[i].x + ' ' + pts[i].y);
            }
            out.println(')');
        }
        out.print(')  ');
    }
    addAll(edgeColl) {
        for(let i = edgeColl.iterator(); i.hasNext();)this.add(i.next());
    }
    findEdgeIndex(e) {
        for(let i = 0; i < this._edges.size(); i++)if (this._edges.get(i).equals(e)) return i;
        return -1;
    }
    iterator() {
        return this._edges.iterator();
    }
    getEdges() {
        return this._edges;
    }
    get(i) {
        return this._edges.get(i);
    }
    findEqualEdge(e) {
        const oca = new (0, _orientedCoordinateArrayJsDefault.default)(e.getCoordinates());
        const matchEdge = this._ocaMap.get(oca);
        return matchEdge;
    }
    add(e) {
        this._edges.add(e);
        const oca = new (0, _orientedCoordinateArrayJsDefault.default)(e.getCoordinates());
        this._ocaMap.put(oca, e);
    }
}
exports.default = EdgeList;

},{"../noding/OrientedCoordinateArray.js":"5pN20","../../../../java/util/ArrayList.js":"g8omH","../../../../java/util/TreeMap.js":"3VPI6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5pN20":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparableJs = require("../../../../java/lang/Comparable.js");
var _comparableJsDefault = parcelHelpers.interopDefault(_comparableJs);
var _coordinateArraysJs = require("../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
class OrientedCoordinateArray {
    constructor(){
        OrientedCoordinateArray.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._pts = null;
        this._orientation = null;
        const pts = arguments[0];
        this._pts = pts;
        this._orientation = OrientedCoordinateArray.orientation(pts);
    }
    static orientation(pts) {
        return (0, _coordinateArraysJsDefault.default).increasingDirection(pts) === 1;
    }
    static compareOriented(pts1, orientation1, pts2, orientation2) {
        const dir1 = orientation1 ? 1 : -1;
        const dir2 = orientation2 ? 1 : -1;
        const limit1 = orientation1 ? pts1.length : -1;
        const limit2 = orientation2 ? pts2.length : -1;
        let i1 = orientation1 ? 0 : pts1.length - 1;
        let i2 = orientation2 ? 0 : pts2.length - 1;
        while(true){
            const compPt = pts1[i1].compareTo(pts2[i2]);
            if (compPt !== 0) return compPt;
            i1 += dir1;
            i2 += dir2;
            const done1 = i1 === limit1;
            const done2 = i2 === limit2;
            if (done1 && !done2) return -1;
            if (!done1 && done2) return 1;
            if (done1 && done2) return 0;
        }
    }
    compareTo(o1) {
        const oca = o1;
        const comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);
        return comp;
    }
    get interfaces_() {
        return [
            (0, _comparableJsDefault.default)
        ];
    }
}
exports.default = OrientedCoordinateArray;

},{"../../../../java/lang/Comparable.js":"6Adw4","../geom/CoordinateArrays.js":"hwXsf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8IYcL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _segmentIntersectorJs = require("./SegmentIntersector.js");
var _segmentIntersectorJsDefault = parcelHelpers.interopDefault(_segmentIntersectorJs);
class IntersectionAdder {
    constructor(){
        IntersectionAdder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._hasIntersection = false;
        this._hasProper = false;
        this._hasProperInterior = false;
        this._hasInterior = false;
        this._properIntersectionPoint = null;
        this._li = null;
        this._isSelfIntersection = null;
        this.numIntersections = 0;
        this.numInteriorIntersections = 0;
        this.numProperIntersections = 0;
        this.numTests = 0;
        const li = arguments[0];
        this._li = li;
    }
    static isAdjacentSegments(i1, i2) {
        return Math.abs(i1 - i2) === 1;
    }
    isTrivialIntersection(e0, segIndex0, e1, segIndex1) {
        if (e0 === e1) {
            if (this._li.getIntersectionNum() === 1) {
                if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) return true;
                if (e0.isClosed()) {
                    const maxSegIndex = e0.size() - 1;
                    if (segIndex0 === 0 && segIndex1 === maxSegIndex || segIndex1 === 0 && segIndex0 === maxSegIndex) return true;
                }
            }
        }
        return false;
    }
    getProperIntersectionPoint() {
        return this._properIntersectionPoint;
    }
    hasProperInteriorIntersection() {
        return this._hasProperInterior;
    }
    getLineIntersector() {
        return this._li;
    }
    hasProperIntersection() {
        return this._hasProper;
    }
    processIntersections(e0, segIndex0, e1, segIndex1) {
        if (e0 === e1 && segIndex0 === segIndex1) return null;
        this.numTests++;
        const p00 = e0.getCoordinates()[segIndex0];
        const p01 = e0.getCoordinates()[segIndex0 + 1];
        const p10 = e1.getCoordinates()[segIndex1];
        const p11 = e1.getCoordinates()[segIndex1 + 1];
        this._li.computeIntersection(p00, p01, p10, p11);
        if (this._li.hasIntersection()) {
            this.numIntersections++;
            if (this._li.isInteriorIntersection()) {
                this.numInteriorIntersections++;
                this._hasInterior = true;
            }
            if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {
                this._hasIntersection = true;
                e0.addIntersections(this._li, segIndex0, 0);
                e1.addIntersections(this._li, segIndex1, 1);
                if (this._li.isProper()) {
                    this.numProperIntersections++;
                    this._hasProper = true;
                    this._hasProperInterior = true;
                }
            }
        }
    }
    hasIntersection() {
        return this._hasIntersection;
    }
    isDone() {
        return false;
    }
    hasInteriorIntersection() {
        return this._hasInterior;
    }
    get interfaces_() {
        return [
            (0, _segmentIntersectorJsDefault.default)
        ];
    }
}
exports.default = IntersectionAdder;

},{"./SegmentIntersector.js":"9okdh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"krn45":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../../../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _coordinateListJs = require("../../../geom/CoordinateList.js");
var _coordinateListJsDefault = parcelHelpers.interopDefault(_coordinateListJs);
var _coordinateJs = require("../../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _doubleJs = require("../../../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _lineSegmentJs = require("../../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
class LineStringSnapper {
    constructor(){
        LineStringSnapper.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._snapTolerance = 0.0;
        this._srcPts = null;
        this._seg = new (0, _lineSegmentJsDefault.default)();
        this._allowSnappingToSourceVertices = false;
        this._isClosed = false;
        if (arguments[0] instanceof (0, _lineStringJsDefault.default) && typeof arguments[1] === 'number') {
            const srcLine = arguments[0], snapTolerance = arguments[1];
            LineStringSnapper.constructor_.call(this, srcLine.getCoordinates(), snapTolerance);
        } else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') {
            const srcPts = arguments[0], snapTolerance = arguments[1];
            this._srcPts = srcPts;
            this._isClosed = LineStringSnapper.isClosed(srcPts);
            this._snapTolerance = snapTolerance;
        }
    }
    static isClosed(pts) {
        if (pts.length <= 1) return false;
        return pts[0].equals2D(pts[pts.length - 1]);
    }
    snapVertices(srcCoords, snapPts) {
        const end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();
        for(let i = 0; i < end; i++){
            const srcPt = srcCoords.get(i);
            const snapVert = this.findSnapForVertex(srcPt, snapPts);
            if (snapVert !== null) {
                srcCoords.set(i, new (0, _coordinateJsDefault.default)(snapVert));
                if (i === 0 && this._isClosed) srcCoords.set(srcCoords.size() - 1, new (0, _coordinateJsDefault.default)(snapVert));
            }
        }
    }
    findSnapForVertex(pt, snapPts) {
        for(let i = 0; i < snapPts.length; i++){
            if (pt.equals2D(snapPts[i])) return null;
            if (pt.distance(snapPts[i]) < this._snapTolerance) return snapPts[i];
        }
        return null;
    }
    snapTo(snapPts) {
        const coordList = new (0, _coordinateListJsDefault.default)(this._srcPts);
        this.snapVertices(coordList, snapPts);
        this.snapSegments(coordList, snapPts);
        const newPts = coordList.toCoordinateArray();
        return newPts;
    }
    snapSegments(srcCoords, snapPts) {
        if (snapPts.length === 0) return null;
        let distinctPtCount = snapPts.length;
        if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) distinctPtCount = snapPts.length - 1;
        for(let i = 0; i < distinctPtCount; i++){
            const snapPt = snapPts[i];
            const index = this.findSegmentIndexToSnap(snapPt, srcCoords);
            if (index >= 0) srcCoords.add(index + 1, new (0, _coordinateJsDefault.default)(snapPt), false);
        }
    }
    findSegmentIndexToSnap(snapPt, srcCoords) {
        let minDist = (0, _doubleJsDefault.default).MAX_VALUE;
        let snapIndex = -1;
        for(let i = 0; i < srcCoords.size() - 1; i++){
            this._seg.p0 = srcCoords.get(i);
            this._seg.p1 = srcCoords.get(i + 1);
            if (this._seg.p0.equals2D(snapPt) || this._seg.p1.equals2D(snapPt)) {
                if (this._allowSnappingToSourceVertices) continue;
                else return -1;
            }
            const dist = this._seg.distance(snapPt);
            if (dist < this._snapTolerance && dist < minDist) {
                minDist = dist;
                snapIndex = i;
            }
        }
        return snapIndex;
    }
    setAllowSnappingToSourceVertices(allowSnappingToSourceVertices) {
        this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;
    }
}
exports.default = LineStringSnapper;

},{"../../../geom/LineString.js":"1Hc8p","../../../geom/CoordinateList.js":"39sXT","../../../geom/Coordinate.js":"3REUb","../../../../../../java/lang/Double.js":"jCc26","../../../geom/LineSegment.js":"4V3G8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Tw5K":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _geometryFactoryJs = require("../GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _linearRingJs = require("../LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _multiPolygonJs = require("../MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _geometryCollectionJs = require("../GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _multiLineStringJs = require("../MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _illegalArgumentExceptionJs = require("../../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _pointJs = require("../Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("../Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _multiPointJs = require("../MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
class GeometryTransformer {
    constructor(){
        GeometryTransformer.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._inputGeom = null;
        this._factory = null;
        this._pruneEmptyGeometry = true;
        this._preserveGeometryCollectionType = true;
        this._preserveCollections = false;
        this._preserveType = false;
    }
    transformPoint(geom, parent) {
        return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom));
    }
    transformPolygon(geom, parent) {
        let isAllValidLinearRings = true;
        const shell = this.transformLinearRing(geom.getExteriorRing(), geom);
        if (shell === null || !(shell instanceof (0, _linearRingJsDefault.default)) || shell.isEmpty()) isAllValidLinearRings = false;
        const holes = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumInteriorRing(); i++){
            const hole = this.transformLinearRing(geom.getInteriorRingN(i), geom);
            if (hole === null || hole.isEmpty()) continue;
            if (!(hole instanceof (0, _linearRingJsDefault.default))) isAllValidLinearRings = false;
            holes.add(hole);
        }
        if (isAllValidLinearRings) return this._factory.createPolygon(shell, holes.toArray([]));
        else {
            const components = new (0, _arrayListJsDefault.default)();
            if (shell !== null) components.add(shell);
            components.addAll(holes);
            return this._factory.buildGeometry(components);
        }
    }
    createCoordinateSequence(coords) {
        return this._factory.getCoordinateSequenceFactory().create(coords);
    }
    getInputGeometry() {
        return this._inputGeom;
    }
    transformMultiLineString(geom, parent) {
        const transGeomList = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const transformGeom = this.transformLineString(geom.getGeometryN(i), geom);
            if (transformGeom === null) continue;
            if (transformGeom.isEmpty()) continue;
            transGeomList.add(transformGeom);
        }
        return this._factory.buildGeometry(transGeomList);
    }
    transformCoordinates(coords, parent) {
        return this.copy(coords);
    }
    transformLineString(geom, parent) {
        return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom));
    }
    transformMultiPoint(geom, parent) {
        const transGeomList = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const transformGeom = this.transformPoint(geom.getGeometryN(i), geom);
            if (transformGeom === null) continue;
            if (transformGeom.isEmpty()) continue;
            transGeomList.add(transformGeom);
        }
        return this._factory.buildGeometry(transGeomList);
    }
    transformMultiPolygon(geom, parent) {
        const transGeomList = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const transformGeom = this.transformPolygon(geom.getGeometryN(i), geom);
            if (transformGeom === null) continue;
            if (transformGeom.isEmpty()) continue;
            transGeomList.add(transformGeom);
        }
        return this._factory.buildGeometry(transGeomList);
    }
    copy(seq) {
        return seq.copy();
    }
    transformLinearRing(geom, parent) {
        const seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);
        if (seq === null) return this._factory.createLinearRing(null);
        const seqSize = seq.size();
        if (seqSize > 0 && seqSize < 4 && !this._preserveType) return this._factory.createLineString(seq);
        return this._factory.createLinearRing(seq);
    }
    transformGeometryCollection(geom, parent) {
        const transGeomList = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const transformGeom = this.transform(geom.getGeometryN(i));
            if (transformGeom === null) continue;
            if (this._pruneEmptyGeometry && transformGeom.isEmpty()) continue;
            transGeomList.add(transformGeom);
        }
        if (this._preserveGeometryCollectionType) return this._factory.createGeometryCollection((0, _geometryFactoryJsDefault.default).toGeometryArray(transGeomList));
        return this._factory.buildGeometry(transGeomList);
    }
    transform(inputGeom) {
        this._inputGeom = inputGeom;
        this._factory = inputGeom.getFactory();
        if (inputGeom instanceof (0, _pointJsDefault.default)) return this.transformPoint(inputGeom, null);
        if (inputGeom instanceof (0, _multiPointJsDefault.default)) return this.transformMultiPoint(inputGeom, null);
        if (inputGeom instanceof (0, _linearRingJsDefault.default)) return this.transformLinearRing(inputGeom, null);
        if (inputGeom instanceof (0, _lineStringJsDefault.default)) return this.transformLineString(inputGeom, null);
        if (inputGeom instanceof (0, _multiLineStringJsDefault.default)) return this.transformMultiLineString(inputGeom, null);
        if (inputGeom instanceof (0, _polygonJsDefault.default)) return this.transformPolygon(inputGeom, null);
        if (inputGeom instanceof (0, _multiPolygonJsDefault.default)) return this.transformMultiPolygon(inputGeom, null);
        if (inputGeom instanceof (0, _geometryCollectionJsDefault.default)) return this.transformGeometryCollection(inputGeom, null);
        throw new (0, _illegalArgumentExceptionJsDefault.default)('Unknown Geometry subtype: ' + inputGeom.getGeometryType());
    }
}
exports.default = GeometryTransformer;

},{"../LineString.js":"1Hc8p","../GeometryFactory.js":"6Ct9y","../LinearRing.js":"iks2I","../MultiPolygon.js":"56YaT","../GeometryCollection.js":"9xeCT","../../../../../java/util/ArrayList.js":"g8omH","../MultiLineString.js":"fdpMS","../../../../../java/lang/IllegalArgumentException.js":"1VQhm","../Point.js":"i9MoJ","../Polygon.js":"jawWe","../MultiPoint.js":"ikww2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"duHyp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _coordinateSequenceFilterJs = require("../geom/CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
var _commonBitsJs = require("./CommonBits.js");
var _commonBitsJsDefault = parcelHelpers.interopDefault(_commonBitsJs);
var _coordinateFilterJs = require("../geom/CoordinateFilter.js");
var _coordinateFilterJsDefault = parcelHelpers.interopDefault(_coordinateFilterJs);
class CommonBitsRemover {
    constructor(){
        CommonBitsRemover.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._commonCoord = null;
        this._ccFilter = new CommonCoordinateFilter();
    }
    add(geom) {
        geom.apply(this._ccFilter);
        this._commonCoord = this._ccFilter.getCommonCoordinate();
    }
    removeCommonBits(geom) {
        if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) return geom;
        const invCoord = new (0, _coordinateJsDefault.default)(this._commonCoord);
        invCoord.x = -invCoord.x;
        invCoord.y = -invCoord.y;
        const trans = new Translater(invCoord);
        geom.apply(trans);
        geom.geometryChanged();
        return geom;
    }
    addCommonBits(geom) {
        const trans = new Translater(this._commonCoord);
        geom.apply(trans);
        geom.geometryChanged();
    }
    getCommonCoordinate() {
        return this._commonCoord;
    }
}
exports.default = CommonBitsRemover;
class CommonCoordinateFilter {
    constructor(){
        CommonCoordinateFilter.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._commonBitsX = new (0, _commonBitsJsDefault.default)();
        this._commonBitsY = new (0, _commonBitsJsDefault.default)();
    }
    filter(coord) {
        this._commonBitsX.add(coord.x);
        this._commonBitsY.add(coord.y);
    }
    getCommonCoordinate() {
        return new (0, _coordinateJsDefault.default)(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
    }
    get interfaces_() {
        return [
            (0, _coordinateFilterJsDefault.default)
        ];
    }
}
class Translater {
    constructor(){
        Translater.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this.trans = null;
        const trans = arguments[0];
        this.trans = trans;
    }
    filter(seq, i) {
        const xp = seq.getOrdinate(i, 0) + this.trans.x;
        const yp = seq.getOrdinate(i, 1) + this.trans.y;
        seq.setOrdinate(i, 0, xp);
        seq.setOrdinate(i, 1, yp);
    }
    isGeometryChanged() {
        return true;
    }
    isDone() {
        return false;
    }
    get interfaces_() {
        return [
            (0, _coordinateSequenceFilterJsDefault.default)
        ];
    }
}
CommonBitsRemover.CommonCoordinateFilter = CommonCoordinateFilter;
CommonBitsRemover.Translater = Translater;

},{"../geom/Coordinate.js":"3REUb","../geom/CoordinateSequenceFilter.js":"8HUHX","./CommonBits.js":"4xVJB","../geom/CoordinateFilter.js":"9F02P","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4xVJB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doubleJs = require("../../../../java/lang/Double.js");
var _doubleJsDefault = parcelHelpers.interopDefault(_doubleJs);
var _longJs = require("../../../../java/lang/Long.js");
var _longJsDefault = parcelHelpers.interopDefault(_longJs);
class CommonBits {
    constructor(){
        this._isFirst = true;
        this._commonMantissaBitsCount = 53;
        this._commonBits = new (0, _longJsDefault.default)();
        this._commonSignExp = null;
    }
    getCommon() {
        return (0, _doubleJsDefault.default).longBitsToDouble(this._commonBits);
    }
    add(num) {
        const numBits = (0, _doubleJsDefault.default).doubleToLongBits(num);
        if (this._isFirst) {
            this._commonBits = numBits;
            this._commonSignExp = CommonBits.signExpBits(this._commonBits);
            this._isFirst = false;
            return null;
        }
        const numSignExp = CommonBits.signExpBits(numBits);
        if (numSignExp !== this._commonSignExp) {
            this._commonBits.high = 0;
            this._commonBits.low = 0;
            return null;
        }
        this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);
        this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
    }
    toString() {
        if (arguments.length === 1) {
            const bits = arguments[0];
            const x = (0, _doubleJsDefault.default).longBitsToDouble(bits);
            const numStr = (0, _longJsDefault.default).toBinaryString(bits);
            const padStr = '0000000000000000000000000000000000000000000000000000000000000000' + numStr;
            const bitStr = padStr.substring(padStr.length - 64);
            const str = bitStr.substring(0, 1) + '  ' + bitStr.substring(1, 12) + '(exp) ' + bitStr.substring(12) + ' [ ' + x + ' ]';
            return str;
        }
    }
    getClass() {
        return CommonBits;
    }
    get interfaces_() {
        return [];
    }
    static getBit(bits, i) {
        const mask = 1 << i % 32;
        if (i < 32) return (bits.low & mask) !== 0 ? 1 : 0;
        return (bits.high & mask) !== 0 ? 1 : 0;
    }
    static signExpBits(num) {
        return num.high >>> 20;
    }
    static zeroLowerBits(bits, nBits) {
        let prop = 'low';
        if (nBits > 32) {
            bits.low = 0;
            nBits %= 32;
            prop = 'high';
        }
        if (nBits > 0) {
            const mask = nBits < 32 ? ~((1 << nBits) - 1) : 0;
            bits[prop] &= mask;
        }
        return bits;
    }
    static numCommonMostSigMantissaBits(num1, num2) {
        let count = 0;
        for(let i = 52; i >= 0; i--){
            if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) return count;
            count++;
        }
        return 52;
    }
}
exports.default = CommonBits;

},{"../../../../java/lang/Double.js":"jCc26","../../../../java/lang/Long.js":"lCWie","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eclqj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _polygonBuilderJs = require("./PolygonBuilder.js");
var _polygonBuilderJsDefault = parcelHelpers.interopDefault(_polygonBuilderJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _illegalArgumentExceptionJs = require("../../../../../java/lang/IllegalArgumentException.js");
var _illegalArgumentExceptionJsDefault = parcelHelpers.interopDefault(_illegalArgumentExceptionJs);
var _lineBuilderJs = require("./LineBuilder.js");
var _lineBuilderJsDefault = parcelHelpers.interopDefault(_lineBuilderJs);
var _pointBuilderJs = require("./PointBuilder.js");
var _pointBuilderJsDefault = parcelHelpers.interopDefault(_pointBuilderJs);
var _snapIfNeededOverlayOpJs = require("./snap/SnapIfNeededOverlayOp.js");
var _snapIfNeededOverlayOpJsDefault = parcelHelpers.interopDefault(_snapIfNeededOverlayOpJs);
var _labelJs = require("../../geomgraph/Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _planarGraphJs = require("../../geomgraph/PlanarGraph.js");
var _planarGraphJsDefault = parcelHelpers.interopDefault(_planarGraphJs);
var _pointLocatorJs = require("../../algorithm/PointLocator.js");
var _pointLocatorJsDefault = parcelHelpers.interopDefault(_pointLocatorJs);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _edgeNodingValidatorJs = require("../../geomgraph/EdgeNodingValidator.js");
var _edgeNodingValidatorJsDefault = parcelHelpers.interopDefault(_edgeNodingValidatorJs);
var _geometryCollectionMapperJs = require("../../geom/util/GeometryCollectionMapper.js");
var _geometryCollectionMapperJsDefault = parcelHelpers.interopDefault(_geometryCollectionMapperJs);
var _overlayNodeFactoryJs = require("./OverlayNodeFactory.js");
var _overlayNodeFactoryJsDefault = parcelHelpers.interopDefault(_overlayNodeFactoryJs);
var _geometryGraphOperationJs = require("../GeometryGraphOperation.js");
var _geometryGraphOperationJsDefault = parcelHelpers.interopDefault(_geometryGraphOperationJs);
var _edgeListJs = require("../../geomgraph/EdgeList.js");
var _edgeListJsDefault = parcelHelpers.interopDefault(_edgeListJs);
class OverlayOp extends (0, _geometryGraphOperationJsDefault.default) {
    constructor(){
        super();
        OverlayOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._ptLocator = new (0, _pointLocatorJsDefault.default)();
        this._geomFact = null;
        this._resultGeom = null;
        this._graph = null;
        this._edgeList = new (0, _edgeListJsDefault.default)();
        this._resultPolyList = new (0, _arrayListJsDefault.default)();
        this._resultLineList = new (0, _arrayListJsDefault.default)();
        this._resultPointList = new (0, _arrayListJsDefault.default)();
        const g0 = arguments[0], g1 = arguments[1];
        (0, _geometryGraphOperationJsDefault.default).constructor_.call(this, g0, g1);
        this._graph = new (0, _planarGraphJsDefault.default)(new (0, _overlayNodeFactoryJsDefault.default)());
        this._geomFact = g0.getFactory();
    }
    static overlayOp(geom0, geom1, opCode) {
        const gov = new OverlayOp(geom0, geom1);
        const geomOv = gov.getResultGeometry(opCode);
        return geomOv;
    }
    static union(geom, other) {
        if (geom.isEmpty() || other.isEmpty()) {
            if (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.UNION, geom, other, geom.getFactory());
            if (geom.isEmpty()) return other.copy();
            if (other.isEmpty()) return geom.copy();
        }
        if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new (0, _illegalArgumentExceptionJsDefault.default)('This method does not support GeometryCollection arguments');
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(geom, other, OverlayOp.UNION);
    }
    static intersection(geom, other) {
        if (geom.isEmpty() || other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, geom, other, geom.getFactory());
        if (geom.isGeometryCollection()) {
            const g2 = other;
            return (0, _geometryCollectionMapperJsDefault.default).map(geom, new class {
                get interfaces_() {
                    return [
                        MapOp
                    ];
                }
                map(g) {
                    return OverlayOp.intersection(g, g2);
                }
            }());
        }
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(geom, other, OverlayOp.INTERSECTION);
    }
    static symDifference(geom, other) {
        if (geom.isEmpty() || other.isEmpty()) {
            if (geom.isEmpty() && other.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, geom, other, geom.getFactory());
            if (geom.isEmpty()) return other.copy();
            if (other.isEmpty()) return geom.copy();
        }
        if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new (0, _illegalArgumentExceptionJsDefault.default)('This method does not support GeometryCollection arguments');
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(geom, other, OverlayOp.SYMDIFFERENCE);
    }
    static resultDimension(opCode, g0, g1) {
        const dim0 = g0.getDimension();
        const dim1 = g1.getDimension();
        let resultDimension = -1;
        switch(opCode){
            case OverlayOp.INTERSECTION:
                resultDimension = Math.min(dim0, dim1);
                break;
            case OverlayOp.UNION:
                resultDimension = Math.max(dim0, dim1);
                break;
            case OverlayOp.DIFFERENCE:
                resultDimension = dim0;
                break;
            case OverlayOp.SYMDIFFERENCE:
                resultDimension = Math.max(dim0, dim1);
                break;
        }
        return resultDimension;
    }
    static createEmptyResult(overlayOpCode, a, b, geomFact) {
        let result = null;
        const resultDim = OverlayOp.resultDimension(overlayOpCode, a, b);
        return result = geomFact.createEmpty(resultDim);
    }
    static difference(geom, other) {
        if (geom.isEmpty()) return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, geom, other, geom.getFactory());
        if (other.isEmpty()) return geom.copy();
        if (geom.isGeometryCollection() || other.isGeometryCollection()) throw new (0, _illegalArgumentExceptionJsDefault.default)('This method does not support GeometryCollection arguments');
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(geom, other, OverlayOp.DIFFERENCE);
    }
    static isResultOfOp() {
        if (arguments.length === 2) {
            const label = arguments[0], opCode = arguments[1];
            const loc0 = label.getLocation(0);
            const loc1 = label.getLocation(1);
            return OverlayOp.isResultOfOp(loc0, loc1, opCode);
        } else if (arguments.length === 3) {
            let loc0 = arguments[0], loc1 = arguments[1], overlayOpCode = arguments[2];
            if (loc0 === (0, _locationJsDefault.default).BOUNDARY) loc0 = (0, _locationJsDefault.default).INTERIOR;
            if (loc1 === (0, _locationJsDefault.default).BOUNDARY) loc1 = (0, _locationJsDefault.default).INTERIOR;
            switch(overlayOpCode){
                case OverlayOp.INTERSECTION:
                    return loc0 === (0, _locationJsDefault.default).INTERIOR && loc1 === (0, _locationJsDefault.default).INTERIOR;
                case OverlayOp.UNION:
                    return loc0 === (0, _locationJsDefault.default).INTERIOR || loc1 === (0, _locationJsDefault.default).INTERIOR;
                case OverlayOp.DIFFERENCE:
                    return loc0 === (0, _locationJsDefault.default).INTERIOR && loc1 !== (0, _locationJsDefault.default).INTERIOR;
                case OverlayOp.SYMDIFFERENCE:
                    return loc0 === (0, _locationJsDefault.default).INTERIOR && loc1 !== (0, _locationJsDefault.default).INTERIOR || loc0 !== (0, _locationJsDefault.default).INTERIOR && loc1 === (0, _locationJsDefault.default).INTERIOR;
            }
            return false;
        }
    }
    insertUniqueEdge(e) {
        const existingEdge = this._edgeList.findEqualEdge(e);
        if (existingEdge !== null) {
            const existingLabel = existingEdge.getLabel();
            let labelToMerge = e.getLabel();
            if (!existingEdge.isPointwiseEqual(e)) {
                labelToMerge = new (0, _labelJsDefault.default)(e.getLabel());
                labelToMerge.flip();
            }
            const depth = existingEdge.getDepth();
            if (depth.isNull()) depth.add(existingLabel);
            depth.add(labelToMerge);
            existingLabel.merge(labelToMerge);
        } else this._edgeList.add(e);
    }
    getGraph() {
        return this._graph;
    }
    cancelDuplicateResultEdges() {
        for(let it = this._graph.getEdgeEnds().iterator(); it.hasNext();){
            const de = it.next();
            const sym = de.getSym();
            if (de.isInResult() && sym.isInResult()) {
                de.setInResult(false);
                sym.setInResult(false);
            }
        }
    }
    mergeSymLabels() {
        for(let nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().mergeSymLabels();
        }
    }
    computeOverlay(opCode) {
        this.copyPoints(0);
        this.copyPoints(1);
        this._arg[0].computeSelfNodes(this._li, false);
        this._arg[1].computeSelfNodes(this._li, false);
        this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
        const baseSplitEdges = new (0, _arrayListJsDefault.default)();
        this._arg[0].computeSplitEdges(baseSplitEdges);
        this._arg[1].computeSplitEdges(baseSplitEdges);
        const splitEdges = baseSplitEdges;
        this.insertUniqueEdges(baseSplitEdges);
        this.computeLabelsFromDepths();
        this.replaceCollapsedEdges();
        (0, _edgeNodingValidatorJsDefault.default).checkValid(this._edgeList.getEdges());
        this._graph.addEdges(this._edgeList.getEdges());
        this.computeLabelling();
        this.labelIncompleteNodes();
        this.findResultAreaEdges(opCode);
        this.cancelDuplicateResultEdges();
        const polyBuilder = new (0, _polygonBuilderJsDefault.default)(this._geomFact);
        polyBuilder.add(this._graph);
        this._resultPolyList = polyBuilder.getPolygons();
        const lineBuilder = new (0, _lineBuilderJsDefault.default)(this, this._geomFact, this._ptLocator);
        this._resultLineList = lineBuilder.build(opCode);
        const pointBuilder = new (0, _pointBuilderJsDefault.default)(this, this._geomFact, this._ptLocator);
        this._resultPointList = pointBuilder.build(opCode);
        this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);
    }
    findResultAreaEdges(opCode) {
        for(let it = this._graph.getEdgeEnds().iterator(); it.hasNext();){
            const de = it.next();
            const label = de.getLabel();
            if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, (0, _positionJsDefault.default).RIGHT), label.getLocation(1, (0, _positionJsDefault.default).RIGHT), opCode)) de.setInResult(true);
        }
    }
    computeLabelsFromDepths() {
        for(let it = this._edgeList.iterator(); it.hasNext();){
            const e = it.next();
            const lbl = e.getLabel();
            const depth = e.getDepth();
            if (!depth.isNull()) {
                depth.normalize();
                for(let i = 0; i < 2; i++)if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {
                    if (depth.getDelta(i) === 0) lbl.toLine(i);
                    else {
                        (0, _assertJsDefault.default).isTrue(!depth.isNull(i, (0, _positionJsDefault.default).LEFT), 'depth of LEFT side has not been initialized');
                        lbl.setLocation(i, (0, _positionJsDefault.default).LEFT, depth.getLocation(i, (0, _positionJsDefault.default).LEFT));
                        (0, _assertJsDefault.default).isTrue(!depth.isNull(i, (0, _positionJsDefault.default).RIGHT), 'depth of RIGHT side has not been initialized');
                        lbl.setLocation(i, (0, _positionJsDefault.default).RIGHT, depth.getLocation(i, (0, _positionJsDefault.default).RIGHT));
                    }
                }
            }
        }
    }
    isCoveredByA(coord) {
        if (this.isCovered(coord, this._resultPolyList)) return true;
        return false;
    }
    isCoveredByLA(coord) {
        if (this.isCovered(coord, this._resultLineList)) return true;
        if (this.isCovered(coord, this._resultPolyList)) return true;
        return false;
    }
    computeGeometry(resultPointList, resultLineList, resultPolyList, opcode) {
        const geomList = new (0, _arrayListJsDefault.default)();
        geomList.addAll(resultPointList);
        geomList.addAll(resultLineList);
        geomList.addAll(resultPolyList);
        if (geomList.isEmpty()) return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact);
        return this._geomFact.buildGeometry(geomList);
    }
    isCovered(coord, geomList) {
        for(let it = geomList.iterator(); it.hasNext();){
            const geom = it.next();
            const loc = this._ptLocator.locate(coord, geom);
            if (loc !== (0, _locationJsDefault.default).EXTERIOR) return true;
        }
        return false;
    }
    replaceCollapsedEdges() {
        const newEdges = new (0, _arrayListJsDefault.default)();
        for(let it = this._edgeList.iterator(); it.hasNext();){
            const e = it.next();
            if (e.isCollapsed()) {
                it.remove();
                newEdges.add(e.getCollapsedEdge());
            }
        }
        this._edgeList.addAll(newEdges);
    }
    updateNodeLabelling() {
        for(let nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            const lbl = node.getEdges().getLabel();
            node.getLabel().merge(lbl);
        }
    }
    getResultGeometry(overlayOpCode) {
        this.computeOverlay(overlayOpCode);
        return this._resultGeom;
    }
    insertUniqueEdges(edges) {
        for(let i = edges.iterator(); i.hasNext();){
            const e = i.next();
            this.insertUniqueEdge(e);
        }
    }
    labelIncompleteNode(n, targetIndex) {
        const loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
        n.getLabel().setLocation(targetIndex, loc);
    }
    copyPoints(argIndex) {
        for(let i = this._arg[argIndex].getNodeIterator(); i.hasNext();){
            const graphNode = i.next();
            const newNode = this._graph.addNode(graphNode.getCoordinate());
            newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
        }
    }
    computeLabelling() {
        for(let nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().computeLabelling(this._arg);
        }
        this.mergeSymLabels();
        this.updateNodeLabelling();
    }
    labelIncompleteNodes() {
        for(let ni = this._graph.getNodes().iterator(); ni.hasNext();){
            const n = ni.next();
            const label = n.getLabel();
            if (n.isIsolated()) {
                if (label.isNull(0)) this.labelIncompleteNode(n, 0);
                else this.labelIncompleteNode(n, 1);
            }
            n.getEdges().updateLabelling(label);
        }
    }
}
exports.default = OverlayOp;
OverlayOp.INTERSECTION = 1;
OverlayOp.UNION = 2;
OverlayOp.DIFFERENCE = 3;
OverlayOp.SYMDIFFERENCE = 4;

},{"./PolygonBuilder.js":"58e4Z","../../geomgraph/Position.js":"929cL","../../../../../java/lang/IllegalArgumentException.js":"1VQhm","./LineBuilder.js":"6xiXn","./PointBuilder.js":"8yJxn","./snap/SnapIfNeededOverlayOp.js":"3ISyI","../../geomgraph/Label.js":"2NrfJ","../../../../../java/util/ArrayList.js":"g8omH","../../util/Assert.js":"ePbcB","../../geomgraph/PlanarGraph.js":"42N6d","../../algorithm/PointLocator.js":"5OxlZ","../../geom/Location.js":"71R1B","../../geomgraph/EdgeNodingValidator.js":"7XtPs","../../geom/util/GeometryCollectionMapper.js":"2jwbQ","./OverlayNodeFactory.js":"3i3AP","../GeometryGraphOperation.js":"6c8UI","../../geomgraph/EdgeList.js":"4eJVd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6xiXn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _overlayOpJs = require("./OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
class LineBuilder {
    constructor(){
        LineBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._op = null;
        this._geometryFactory = null;
        this._ptLocator = null;
        this._lineEdgesList = new (0, _arrayListJsDefault.default)();
        this._resultLineList = new (0, _arrayListJsDefault.default)();
        const op = arguments[0], geometryFactory = arguments[1], ptLocator = arguments[2];
        this._op = op;
        this._geometryFactory = geometryFactory;
        this._ptLocator = ptLocator;
    }
    collectLines(opCode) {
        for(let it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();){
            const de = it.next();
            this.collectLineEdge(de, opCode, this._lineEdgesList);
            this.collectBoundaryTouchEdge(de, opCode, this._lineEdgesList);
        }
    }
    labelIsolatedLine(e, targetIndex) {
        const loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));
        e.getLabel().setLocation(targetIndex, loc);
    }
    build(opCode) {
        this.findCoveredLineEdges();
        this.collectLines(opCode);
        this.buildLines(opCode);
        return this._resultLineList;
    }
    collectLineEdge(de, opCode, edges) {
        const label = de.getLabel();
        const e = de.getEdge();
        if (de.isLineEdge()) {
            if (!de.isVisited() && (0, _overlayOpJsDefault.default).isResultOfOp(label, opCode) && !e.isCovered()) {
                edges.add(e);
                de.setVisitedEdge(true);
            }
        }
    }
    findCoveredLineEdges() {
        for(let nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();){
            const node = nodeit.next();
            node.getEdges().findCoveredLineEdges();
        }
        for(let it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();){
            const de = it.next();
            const e = de.getEdge();
            if (de.isLineEdge() && !e.isCoveredSet()) {
                const isCovered = this._op.isCoveredByA(de.getCoordinate());
                e.setCovered(isCovered);
            }
        }
    }
    labelIsolatedLines(edgesList) {
        for(let it = edgesList.iterator(); it.hasNext();){
            const e = it.next();
            const label = e.getLabel();
            if (e.isIsolated()) {
                if (label.isNull(0)) this.labelIsolatedLine(e, 0);
                else this.labelIsolatedLine(e, 1);
            }
        }
    }
    buildLines(opCode) {
        for(let it = this._lineEdgesList.iterator(); it.hasNext();){
            const e = it.next();
            const line = this._geometryFactory.createLineString(e.getCoordinates());
            this._resultLineList.add(line);
            e.setInResult(true);
        }
    }
    collectBoundaryTouchEdge(de, opCode, edges) {
        const label = de.getLabel();
        if (de.isLineEdge()) return null;
        if (de.isVisited()) return null;
        if (de.isInteriorAreaEdge()) return null;
        if (de.getEdge().isInResult()) return null;
        (0, _assertJsDefault.default).isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());
        if ((0, _overlayOpJsDefault.default).isResultOfOp(label, opCode) && opCode === (0, _overlayOpJsDefault.default).INTERSECTION) {
            edges.add(de.getEdge());
            de.setVisitedEdge(true);
        }
    }
}
exports.default = LineBuilder;

},{"../../../../../java/util/ArrayList.js":"g8omH","../../util/Assert.js":"ePbcB","./OverlayOp.js":"eclqj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8yJxn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _overlayOpJs = require("./OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
class PointBuilder {
    constructor(){
        PointBuilder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._op = null;
        this._geometryFactory = null;
        this._resultPointList = new (0, _arrayListJsDefault.default)();
        const op = arguments[0], geometryFactory = arguments[1], ptLocator = arguments[2];
        this._op = op;
        this._geometryFactory = geometryFactory;
    }
    build(opCode) {
        this.extractNonCoveredResultNodes(opCode);
        return this._resultPointList;
    }
    extractNonCoveredResultNodes(opCode) {
        for(let nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();){
            const n = nodeit.next();
            if (n.isInResult()) continue;
            if (n.isIncidentEdgeInResult()) continue;
            if (n.getEdges().getDegree() === 0 || opCode === (0, _overlayOpJsDefault.default).INTERSECTION) {
                const label = n.getLabel();
                if ((0, _overlayOpJsDefault.default).isResultOfOp(label, opCode)) this.filterCoveredNodeToPoint(n);
            }
        }
    }
    filterCoveredNodeToPoint(n) {
        const coord = n.getCoordinate();
        if (!this._op.isCoveredByLA(coord)) {
            const pt = this._geometryFactory.createPoint(coord);
            this._resultPointList.add(pt);
        }
    }
}
exports.default = PointBuilder;

},{"../../../../../java/util/ArrayList.js":"g8omH","./OverlayOp.js":"eclqj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7XtPs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _basicSegmentStringJs = require("../noding/BasicSegmentString.js");
var _basicSegmentStringJsDefault = parcelHelpers.interopDefault(_basicSegmentStringJs);
var _fastNodingValidatorJs = require("../noding/FastNodingValidator.js");
var _fastNodingValidatorJsDefault = parcelHelpers.interopDefault(_fastNodingValidatorJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class EdgeNodingValidator {
    constructor(){
        EdgeNodingValidator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._nv = null;
        const edges = arguments[0];
        this._nv = new (0, _fastNodingValidatorJsDefault.default)(EdgeNodingValidator.toSegmentStrings(edges));
    }
    static toSegmentStrings(edges) {
        const segStrings = new (0, _arrayListJsDefault.default)();
        for(let i = edges.iterator(); i.hasNext();){
            const e = i.next();
            segStrings.add(new (0, _basicSegmentStringJsDefault.default)(e.getCoordinates(), e));
        }
        return segStrings;
    }
    static checkValid(edges) {
        const validator = new EdgeNodingValidator(edges);
        validator.checkValid();
    }
    checkValid() {
        this._nv.checkValid();
    }
}
exports.default = EdgeNodingValidator;

},{"../noding/BasicSegmentString.js":"d0i74","../noding/FastNodingValidator.js":"hqAPW","../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d0i74":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktwriterJs = require("../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _coordinateArraySequenceJs = require("../geom/impl/CoordinateArraySequence.js");
var _coordinateArraySequenceJsDefault = parcelHelpers.interopDefault(_coordinateArraySequenceJs);
var _octantJs = require("./Octant.js");
var _octantJsDefault = parcelHelpers.interopDefault(_octantJs);
var _segmentStringJs = require("./SegmentString.js");
var _segmentStringJsDefault = parcelHelpers.interopDefault(_segmentStringJs);
class BasicSegmentString {
    constructor(){
        BasicSegmentString.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._pts = null;
        this._data = null;
        const pts = arguments[0], data = arguments[1];
        this._pts = pts;
        this._data = data;
    }
    getCoordinates() {
        return this._pts;
    }
    size() {
        return this._pts.length;
    }
    getCoordinate(i) {
        return this._pts[i];
    }
    isClosed() {
        return this._pts[0].equals(this._pts[this._pts.length - 1]);
    }
    getSegmentOctant(index) {
        if (index === this._pts.length - 1) return -1;
        return (0, _octantJsDefault.default).octant(this.getCoordinate(index), this.getCoordinate(index + 1));
    }
    setData(data) {
        this._data = data;
    }
    getData() {
        return this._data;
    }
    toString() {
        return (0, _wktwriterJsDefault.default).toLineString(new (0, _coordinateArraySequenceJsDefault.default)(this._pts));
    }
    get interfaces_() {
        return [
            (0, _segmentStringJsDefault.default)
        ];
    }
}
exports.default = BasicSegmentString;

},{"../io/WKTWriter.js":"gvRTy","../geom/impl/CoordinateArraySequence.js":"bdL5X","./Octant.js":"cMygk","./SegmentString.js":"dLqAE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hqAPW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wktwriterJs = require("../io/WKTWriter.js");
var _wktwriterJsDefault = parcelHelpers.interopDefault(_wktwriterJs);
var _mcindexNoderJs = require("./MCIndexNoder.js");
var _mcindexNoderJsDefault = parcelHelpers.interopDefault(_mcindexNoderJs);
var _topologyExceptionJs = require("../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _robustLineIntersectorJs = require("../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _nodingIntersectionFinderJs = require("./NodingIntersectionFinder.js");
var _nodingIntersectionFinderJsDefault = parcelHelpers.interopDefault(_nodingIntersectionFinderJs);
class FastNodingValidator {
    constructor(){
        FastNodingValidator.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._segStrings = null;
        this._findAllIntersections = false;
        this._segInt = null;
        this._isValid = true;
        const segStrings = arguments[0];
        this._segStrings = segStrings;
    }
    static computeIntersections(segStrings) {
        const nv = new FastNodingValidator(segStrings);
        nv.setFindAllIntersections(true);
        nv.isValid();
        return nv.getIntersections();
    }
    isValid() {
        this.execute();
        return this._isValid;
    }
    setFindAllIntersections(findAllIntersections) {
        this._findAllIntersections = findAllIntersections;
    }
    checkInteriorIntersections() {
        this._isValid = true;
        this._segInt = new (0, _nodingIntersectionFinderJsDefault.default)(this._li);
        this._segInt.setFindAllIntersections(this._findAllIntersections);
        const noder = new (0, _mcindexNoderJsDefault.default)();
        noder.setSegmentIntersector(this._segInt);
        noder.computeNodes(this._segStrings);
        if (this._segInt.hasIntersection()) {
            this._isValid = false;
            return null;
        }
    }
    checkValid() {
        this.execute();
        if (!this._isValid) throw new (0, _topologyExceptionJsDefault.default)(this.getErrorMessage(), this._segInt.getIntersection());
    }
    getErrorMessage() {
        if (this._isValid) return 'no intersections found';
        const intSegs = this._segInt.getIntersectionSegments();
        return 'found non-noded intersection between ' + (0, _wktwriterJsDefault.default).toLineString(intSegs[0], intSegs[1]) + ' and ' + (0, _wktwriterJsDefault.default).toLineString(intSegs[2], intSegs[3]);
    }
    execute() {
        if (this._segInt !== null) return null;
        this.checkInteriorIntersections();
    }
    getIntersections() {
        return this._segInt.getIntersections();
    }
}
exports.default = FastNodingValidator;

},{"../io/WKTWriter.js":"gvRTy","./MCIndexNoder.js":"9G0qr","../geom/TopologyException.js":"cGr97","../algorithm/RobustLineIntersector.js":"fBBRl","./NodingIntersectionFinder.js":"9T4LK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9T4LK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _segmentIntersectorJs = require("./SegmentIntersector.js");
var _segmentIntersectorJsDefault = parcelHelpers.interopDefault(_segmentIntersectorJs);
var _arrayListJs = require("../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class NodingIntersectionFinder {
    constructor(){
        NodingIntersectionFinder.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._findAllIntersections = false;
        this._isCheckEndSegmentsOnly = false;
        this._keepIntersections = true;
        this._isInteriorIntersectionsOnly = false;
        this._li = null;
        this._interiorIntersection = null;
        this._intSegments = null;
        this._intersections = new (0, _arrayListJsDefault.default)();
        this._intersectionCount = 0;
        const li = arguments[0];
        this._li = li;
        this._interiorIntersection = null;
    }
    static createAllIntersectionsFinder(li) {
        const finder = new NodingIntersectionFinder(li);
        finder.setFindAllIntersections(true);
        return finder;
    }
    static isInteriorVertexIntersection() {
        if (arguments.length === 4) {
            const p0 = arguments[0], p1 = arguments[1], isEnd0 = arguments[2], isEnd1 = arguments[3];
            if (isEnd0 && isEnd1) return false;
            if (p0.equals2D(p1)) return true;
            return false;
        } else if (arguments.length === 8) {
            const p00 = arguments[0], p01 = arguments[1], p10 = arguments[2], p11 = arguments[3], isEnd00 = arguments[4], isEnd01 = arguments[5], isEnd10 = arguments[6], isEnd11 = arguments[7];
            if (NodingIntersectionFinder.isInteriorVertexIntersection(p00, p10, isEnd00, isEnd10)) return true;
            if (NodingIntersectionFinder.isInteriorVertexIntersection(p00, p11, isEnd00, isEnd11)) return true;
            if (NodingIntersectionFinder.isInteriorVertexIntersection(p01, p10, isEnd01, isEnd10)) return true;
            if (NodingIntersectionFinder.isInteriorVertexIntersection(p01, p11, isEnd01, isEnd11)) return true;
            return false;
        }
    }
    static createInteriorIntersectionCounter(li) {
        const finder = new NodingIntersectionFinder(li);
        finder.setInteriorIntersectionsOnly(true);
        finder.setFindAllIntersections(true);
        finder.setKeepIntersections(false);
        return finder;
    }
    static createIntersectionCounter(li) {
        const finder = new NodingIntersectionFinder(li);
        finder.setFindAllIntersections(true);
        finder.setKeepIntersections(false);
        return finder;
    }
    static isEndSegment(segStr, index) {
        if (index === 0) return true;
        if (index >= segStr.size() - 2) return true;
        return false;
    }
    static createAnyIntersectionFinder(li) {
        return new NodingIntersectionFinder(li);
    }
    static createInteriorIntersectionsFinder(li) {
        const finder = new NodingIntersectionFinder(li);
        finder.setFindAllIntersections(true);
        finder.setInteriorIntersectionsOnly(true);
        return finder;
    }
    count() {
        return this._intersectionCount;
    }
    getIntersections() {
        return this._intersections;
    }
    setFindAllIntersections(findAllIntersections) {
        this._findAllIntersections = findAllIntersections;
    }
    setKeepIntersections(keepIntersections) {
        this._keepIntersections = keepIntersections;
    }
    getIntersection() {
        return this._interiorIntersection;
    }
    processIntersections(e0, segIndex0, e1, segIndex1) {
        if (!this._findAllIntersections && this.hasIntersection()) return null;
        const isSameSegString = e0 === e1;
        const isSameSegment = isSameSegString && segIndex0 === segIndex1;
        if (isSameSegment) return null;
        if (this._isCheckEndSegmentsOnly) {
            const isEndSegPresent = NodingIntersectionFinder.isEndSegment(e0, segIndex0) || NodingIntersectionFinder.isEndSegment(e1, segIndex1);
            if (!isEndSegPresent) return null;
        }
        const p00 = e0.getCoordinate(segIndex0);
        const p01 = e0.getCoordinate(segIndex0 + 1);
        const p10 = e1.getCoordinate(segIndex1);
        const p11 = e1.getCoordinate(segIndex1 + 1);
        const isEnd00 = segIndex0 === 0;
        const isEnd01 = segIndex0 + 2 === e0.size();
        const isEnd10 = segIndex1 === 0;
        const isEnd11 = segIndex1 + 2 === e1.size();
        this._li.computeIntersection(p00, p01, p10, p11);
        const isInteriorInt = this._li.hasIntersection() && this._li.isInteriorIntersection();
        let isInteriorVertexInt = false;
        if (!this._isInteriorIntersectionsOnly) {
            const isAdjacentSegment = isSameSegString && Math.abs(segIndex1 - segIndex0) <= 1;
            isInteriorVertexInt = !isAdjacentSegment && NodingIntersectionFinder.isInteriorVertexIntersection(p00, p01, p10, p11, isEnd00, isEnd01, isEnd10, isEnd11);
        }
        if (isInteriorInt || isInteriorVertexInt) {
            this._intSegments = new Array(4).fill(null);
            this._intSegments[0] = p00;
            this._intSegments[1] = p01;
            this._intSegments[2] = p10;
            this._intSegments[3] = p11;
            this._interiorIntersection = this._li.getIntersection(0);
            if (this._keepIntersections) this._intersections.add(this._interiorIntersection);
            this._intersectionCount++;
        }
    }
    hasIntersection() {
        return this._interiorIntersection !== null;
    }
    isDone() {
        if (this._findAllIntersections) return false;
        return this._interiorIntersection !== null;
    }
    setInteriorIntersectionsOnly(isInteriorIntersectionsOnly) {
        this._isInteriorIntersectionsOnly = isInteriorIntersectionsOnly;
    }
    setCheckEndSegmentsOnly(isCheckEndSegmentsOnly) {
        this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;
    }
    getIntersectionSegments() {
        return this._intSegments;
    }
    get interfaces_() {
        return [
            (0, _segmentIntersectorJsDefault.default)
        ];
    }
}
exports.default = NodingIntersectionFinder;

},{"./SegmentIntersector.js":"9okdh","../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2jwbQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryFactoryJs = require("../GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class GeometryCollectionMapper {
    constructor(){
        GeometryCollectionMapper.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._mapOp = null;
        const mapOp = arguments[0];
        this._mapOp = mapOp;
    }
    static map(gc, op) {
        const mapper = new GeometryCollectionMapper(op);
        return mapper.map(gc);
    }
    map(gc) {
        const mapped = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < gc.getNumGeometries(); i++){
            const g = this._mapOp.map(gc.getGeometryN(i));
            if (!g.isEmpty()) mapped.add(g);
        }
        return gc.getFactory().createGeometryCollection((0, _geometryFactoryJsDefault.default).toGeometryArray(mapped));
    }
}
exports.default = GeometryCollectionMapper;

},{"../GeometryFactory.js":"6Ct9y","../../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f3jox":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _geometryJs = require("../../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _collectionJs = require("../../../../../java/util/Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _pointJs = require("../../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("../../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _geometryCollectionJs = require("../../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _dimensionJs = require("../../geom/Dimension.js");
var _dimensionJsDefault = parcelHelpers.interopDefault(_dimensionJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _geometryFilterJs = require("../../geom/GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
class InputExtracter {
    constructor(){
        InputExtracter.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geomFactory = null;
        this._polygons = new (0, _arrayListJsDefault.default)();
        this._lines = new (0, _arrayListJsDefault.default)();
        this._points = new (0, _arrayListJsDefault.default)();
        this._dimension = (0, _dimensionJsDefault.default).FALSE;
    }
    static extract() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const geoms = arguments[0];
            const extracter = new InputExtracter();
            extracter.add(geoms);
            return extracter;
        } else if (arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const geom = arguments[0];
            const extracter = new InputExtracter();
            extracter.add(geom);
            return extracter;
        }
    }
    getFactory() {
        return this._geomFactory;
    }
    filter(geom) {
        this.recordDimension(geom.getDimension());
        if (geom instanceof (0, _geometryCollectionJsDefault.default)) return null;
        if (geom.isEmpty()) return null;
        if (geom instanceof (0, _polygonJsDefault.default)) {
            this._polygons.add(geom);
            return null;
        } else if (geom instanceof (0, _lineStringJsDefault.default)) {
            this._lines.add(geom);
            return null;
        } else if (geom instanceof (0, _pointJsDefault.default)) {
            this._points.add(geom);
            return null;
        }
        (0, _assertJsDefault.default).shouldNeverReachHere('Unhandled geometry type: ' + geom.getGeometryType());
    }
    getExtract(dim) {
        switch(dim){
            case 0:
                return this._points;
            case 1:
                return this._lines;
            case 2:
                return this._polygons;
        }
        (0, _assertJsDefault.default).shouldNeverReachHere('Invalid dimension: ' + dim);
        return null;
    }
    recordDimension(dim) {
        if (dim > this._dimension) this._dimension = dim;
    }
    getDimension() {
        return this._dimension;
    }
    isEmpty() {
        return this._polygons.isEmpty() && this._lines.isEmpty() && this._points.isEmpty();
    }
    add() {
        if ((0, _hasInterfaceJsDefault.default)(arguments[0], (0, _collectionJsDefault.default))) {
            const geoms = arguments[0];
            for (const geom of geoms)this.add(geom);
        } else if (arguments[0] instanceof (0, _geometryJsDefault.default)) {
            const geom = arguments[0];
            if (this._geomFactory === null) this._geomFactory = geom.getFactory();
            geom.apply(this);
        }
    }
    get interfaces_() {
        return [
            (0, _geometryFilterJsDefault.default)
        ];
    }
}
exports.default = InputExtracter;

},{"../../geom/LineString.js":"1Hc8p","../../geom/Geometry.js":"d5V2e","../../../../../hasInterface.js":"d8mIo","../../../../../java/util/Collection.js":"fbl5V","../../geom/Point.js":"i9MoJ","../../geom/Polygon.js":"jawWe","../../geom/GeometryCollection.js":"9xeCT","../../geom/Dimension.js":"966Ye","../../../../../java/util/ArrayList.js":"g8omH","../../geom/GeometryFilter.js":"djHvd","../../util/Assert.js":"ePbcB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9OJ3y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _treeSetJs = require("../../../../../java/util/TreeSet.js");
var _treeSetJsDefault = parcelHelpers.interopDefault(_treeSetJs);
var _geometryCombinerJs = require("../../geom/util/GeometryCombiner.js");
var _geometryCombinerJsDefault = parcelHelpers.interopDefault(_geometryCombinerJs);
var _coordinateArraysJs = require("../../geom/CoordinateArrays.js");
var _coordinateArraysJsDefault = parcelHelpers.interopDefault(_coordinateArraysJs);
var _pointLocatorJs = require("../../algorithm/PointLocator.js");
var _pointLocatorJsDefault = parcelHelpers.interopDefault(_pointLocatorJs);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
class PointGeometryUnion {
    constructor(){
        PointGeometryUnion.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._pointGeom = null;
        this._otherGeom = null;
        this._geomFact = null;
        const pointGeom = arguments[0], otherGeom = arguments[1];
        this._pointGeom = pointGeom;
        this._otherGeom = otherGeom;
        this._geomFact = otherGeom.getFactory();
    }
    static union(pointGeom, otherGeom) {
        const unioner = new PointGeometryUnion(pointGeom, otherGeom);
        return unioner.union();
    }
    union() {
        const locater = new (0, _pointLocatorJsDefault.default)();
        const exteriorCoords = new (0, _treeSetJsDefault.default)();
        for(let i = 0; i < this._pointGeom.getNumGeometries(); i++){
            const point = this._pointGeom.getGeometryN(i);
            const coord = point.getCoordinate();
            const loc = locater.locate(coord, this._otherGeom);
            if (loc === (0, _locationJsDefault.default).EXTERIOR) exteriorCoords.add(coord);
        }
        if (exteriorCoords.size() === 0) return this._otherGeom;
        let ptComp = null;
        const coords = (0, _coordinateArraysJsDefault.default).toCoordinateArray(exteriorCoords);
        if (coords.length === 1) ptComp = this._geomFact.createPoint(coords[0]);
        else ptComp = this._geomFact.createMultiPointFromCoords(coords);
        return (0, _geometryCombinerJsDefault.default).combine(ptComp, this._otherGeom);
    }
}
exports.default = PointGeometryUnion;

},{"../../../../../java/util/TreeSet.js":"iQa9l","../../geom/util/GeometryCombiner.js":"8TPyt","../../geom/CoordinateArrays.js":"hwXsf","../../algorithm/PointLocator.js":"5OxlZ","../../geom/Location.js":"71R1B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8TPyt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class GeometryCombiner {
    constructor(){
        GeometryCombiner.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geomFactory = null;
        this._skipEmpty = false;
        this._inputGeoms = null;
        const geoms = arguments[0];
        this._geomFactory = GeometryCombiner.extractFactory(geoms);
        this._inputGeoms = geoms;
    }
    static extractFactory(geoms) {
        if (geoms.isEmpty()) return null;
        return geoms.iterator().next().getFactory();
    }
    static createList() {
        if (arguments.length === 2) {
            const obj0 = arguments[0], obj1 = arguments[1];
            const list = new (0, _arrayListJsDefault.default)();
            list.add(obj0);
            list.add(obj1);
            return list;
        } else if (arguments.length === 3) {
            const obj0 = arguments[0], obj1 = arguments[1], obj2 = arguments[2];
            const list = new (0, _arrayListJsDefault.default)();
            list.add(obj0);
            list.add(obj1);
            list.add(obj2);
            return list;
        }
    }
    static combine() {
        if (arguments.length === 1) {
            const geoms = arguments[0];
            const combiner = new GeometryCombiner(geoms);
            return combiner.combine();
        } else if (arguments.length === 2) {
            const g0 = arguments[0], g1 = arguments[1];
            const combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1));
            return combiner.combine();
        } else if (arguments.length === 3) {
            const g0 = arguments[0], g1 = arguments[1], g2 = arguments[2];
            const combiner = new GeometryCombiner(GeometryCombiner.createList(g0, g1, g2));
            return combiner.combine();
        }
    }
    extractElements(geom, elems) {
        if (geom === null) return null;
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const elemGeom = geom.getGeometryN(i);
            if (this._skipEmpty && elemGeom.isEmpty()) continue;
            elems.add(elemGeom);
        }
    }
    combine() {
        const elems = new (0, _arrayListJsDefault.default)();
        for(let i = this._inputGeoms.iterator(); i.hasNext();){
            const g = i.next();
            this.extractElements(g, elems);
        }
        if (elems.size() === 0) {
            if (this._geomFactory !== null) return this._geomFactory.createGeometryCollection();
            return null;
        }
        return this._geomFactory.buildGeometry(elems);
    }
}
exports.default = GeometryCombiner;

},{"../../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3cZut":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _polygonExtracterJs = require("../../geom/util/PolygonExtracter.js");
var _polygonExtracterJsDefault = parcelHelpers.interopDefault(_polygonExtracterJs);
var _overlapUnionJs = require("./OverlapUnion.js");
var _overlapUnionJsDefault = parcelHelpers.interopDefault(_overlapUnionJs);
var _strtreeJs = require("../../index/strtree/STRtree.js");
var _strtreeJsDefault = parcelHelpers.interopDefault(_strtreeJs);
var _geometryJs = require("../../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _listJs = require("../../../../../java/util/List.js");
var _listJsDefault = parcelHelpers.interopDefault(_listJs);
var _illegalStateExceptionJs = require("../../../../../java/lang/IllegalStateException.js");
var _illegalStateExceptionJsDefault = parcelHelpers.interopDefault(_illegalStateExceptionJs);
var _hasInterfaceJs = require("../../../../../hasInterface.js");
var _hasInterfaceJsDefault = parcelHelpers.interopDefault(_hasInterfaceJs);
var _geometryFactoryJs = require("../../geom/GeometryFactory.js");
var _geometryFactoryJsDefault = parcelHelpers.interopDefault(_geometryFactoryJs);
var _polygonalJs = require("../../geom/Polygonal.js");
var _polygonalJsDefault = parcelHelpers.interopDefault(_polygonalJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class CascadedPolygonUnion {
    constructor(){
        CascadedPolygonUnion.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._inputPolys = null;
        this._geomFactory = null;
        const polys = arguments[0];
        this._inputPolys = polys;
        if (this._inputPolys === null) this._inputPolys = new (0, _arrayListJsDefault.default)();
    }
    static getGeometry(list, index) {
        if (index >= list.size()) return null;
        return list.get(index);
    }
    static union(polys) {
        const op = new CascadedPolygonUnion(polys);
        return op.union();
    }
    static restrictToPolygons(g) {
        if ((0, _hasInterfaceJsDefault.default)(g, (0, _polygonalJsDefault.default))) return g;
        const polygons = (0, _polygonExtracterJsDefault.default).getPolygons(g);
        if (polygons.size() === 1) return polygons.get(0);
        return g.getFactory().createMultiPolygon((0, _geometryFactoryJsDefault.default).toPolygonArray(polygons));
    }
    reduceToGeometries(geomTree) {
        const geoms = new (0, _arrayListJsDefault.default)();
        for(let i = geomTree.iterator(); i.hasNext();){
            const o = i.next();
            let geom = null;
            if ((0, _hasInterfaceJsDefault.default)(o, (0, _listJsDefault.default))) geom = this.unionTree(o);
            else if (o instanceof (0, _geometryJsDefault.default)) geom = o;
            geoms.add(geom);
        }
        return geoms;
    }
    union() {
        if (this._inputPolys === null) throw new (0, _illegalStateExceptionJsDefault.default)('union() method cannot be called twice');
        if (this._inputPolys.isEmpty()) return null;
        this._geomFactory = this._inputPolys.iterator().next().getFactory();
        const index = new (0, _strtreeJsDefault.default)(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);
        for(let i = this._inputPolys.iterator(); i.hasNext();){
            const item = i.next();
            index.insert(item.getEnvelopeInternal(), item);
        }
        this._inputPolys = null;
        const itemTree = index.itemsTree();
        const unionAll = this.unionTree(itemTree);
        return unionAll;
    }
    binaryUnion() {
        if (arguments.length === 1) {
            const geoms = arguments[0];
            return this.binaryUnion(geoms, 0, geoms.size());
        } else if (arguments.length === 3) {
            const geoms = arguments[0], start = arguments[1], end = arguments[2];
            if (end - start <= 1) {
                const g0 = CascadedPolygonUnion.getGeometry(geoms, start);
                return this.unionSafe(g0, null);
            } else if (end - start === 2) return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms, start), CascadedPolygonUnion.getGeometry(geoms, start + 1));
            else {
                const mid = Math.trunc((end + start) / 2);
                const g0 = this.binaryUnion(geoms, start, mid);
                const g1 = this.binaryUnion(geoms, mid, end);
                return this.unionSafe(g0, g1);
            }
        }
    }
    unionSafe(g0, g1) {
        if (g0 === null && g1 === null) return null;
        if (g0 === null) return g1.copy();
        if (g1 === null) return g0.copy();
        return this.unionActual(g0, g1);
    }
    unionActual(g0, g1) {
        const union = (0, _overlapUnionJsDefault.default).union(g0, g1);
        return CascadedPolygonUnion.restrictToPolygons(union);
    }
    unionTree(geomTree) {
        const geoms = this.reduceToGeometries(geomTree);
        const union = this.binaryUnion(geoms);
        return union;
    }
}
exports.default = CascadedPolygonUnion;
CascadedPolygonUnion.STRTREE_NODE_CAPACITY = 4;

},{"../../geom/util/PolygonExtracter.js":"kAQpi","./OverlapUnion.js":"5KK2e","../../index/strtree/STRtree.js":"55J20","../../geom/Geometry.js":"d5V2e","../../../../../java/util/List.js":"5xM2g","../../../../../java/lang/IllegalStateException.js":"4MAFg","../../../../../hasInterface.js":"d8mIo","../../geom/GeometryFactory.js":"6Ct9y","../../geom/Polygonal.js":"gO2Qf","../../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kAQpi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _polygonJs = require("../Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _geometryCollectionJs = require("../GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _geometryFilterJs = require("../GeometryFilter.js");
var _geometryFilterJsDefault = parcelHelpers.interopDefault(_geometryFilterJs);
class PolygonExtracter {
    constructor(){
        PolygonExtracter.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._comps = null;
        const comps = arguments[0];
        this._comps = comps;
    }
    static getPolygons() {
        if (arguments.length === 1) {
            const geom = arguments[0];
            return PolygonExtracter.getPolygons(geom, new (0, _arrayListJsDefault.default)());
        } else if (arguments.length === 2) {
            const geom = arguments[0], list = arguments[1];
            if (geom instanceof (0, _polygonJsDefault.default)) list.add(geom);
            else if (geom instanceof (0, _geometryCollectionJsDefault.default)) geom.apply(new PolygonExtracter(list));
            return list;
        }
    }
    filter(geom) {
        if (geom instanceof (0, _polygonJsDefault.default)) this._comps.add(geom);
    }
    get interfaces_() {
        return [
            (0, _geometryFilterJsDefault.default)
        ];
    }
}
exports.default = PolygonExtracter;

},{"../Polygon.js":"jawWe","../GeometryCollection.js":"9xeCT","../../../../../java/util/ArrayList.js":"g8omH","../GeometryFilter.js":"djHvd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5KK2e":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashSetJs = require("../../../../../java/util/HashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
var _unionOpJs = require("./UnionOp.js");
var _unionOpJsDefault = parcelHelpers.interopDefault(_unionOpJs);
var _topologyExceptionJs = require("../../geom/TopologyException.js");
var _topologyExceptionJsDefault = parcelHelpers.interopDefault(_topologyExceptionJs);
var _lineSegmentJs = require("../../geom/LineSegment.js");
var _lineSegmentJsDefault = parcelHelpers.interopDefault(_lineSegmentJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _coordinateSequenceFilterJs = require("../../geom/CoordinateSequenceFilter.js");
var _coordinateSequenceFilterJsDefault = parcelHelpers.interopDefault(_coordinateSequenceFilterJs);
var _bufferOpJs = require("../buffer/BufferOp.js");
var _bufferOpJsDefault = parcelHelpers.interopDefault(_bufferOpJs);
var _geometryCombinerJs = require("../../geom/util/GeometryCombiner.js");
var _geometryCombinerJsDefault = parcelHelpers.interopDefault(_geometryCombinerJs);
class OverlapUnion {
    constructor(){
        OverlapUnion.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._geomFactory = null;
        this._g0 = null;
        this._g1 = null;
        this._isUnionSafe = null;
        const g0 = arguments[0], g1 = arguments[1];
        this._g0 = g0;
        this._g1 = g1;
        this._geomFactory = g0.getFactory();
    }
    static containsProperly() {
        if (arguments.length === 2) {
            const env = arguments[0], p = arguments[1];
            if (env.isNull()) return false;
            return p.getX() > env.getMinX() && p.getX() < env.getMaxX() && p.getY() > env.getMinY() && p.getY() < env.getMaxY();
        } else if (arguments.length === 3) {
            const env = arguments[0], p0 = arguments[1], p1 = arguments[2];
            return OverlapUnion.containsProperly(env, p0) && OverlapUnion.containsProperly(env, p1);
        }
    }
    static union(g0, g1) {
        const union = new OverlapUnion(g0, g1);
        return union.union();
    }
    static intersects(env, p0, p1) {
        return env.intersects(p0) || env.intersects(p1);
    }
    static overlapEnvelope(g0, g1) {
        const g0Env = g0.getEnvelopeInternal();
        const g1Env = g1.getEnvelopeInternal();
        const overlapEnv = g0Env.intersection(g1Env);
        return overlapEnv;
    }
    static extractBorderSegments(geom, env, segs) {
        geom.apply(new class {
            get interfaces_() {
                return [
                    (0, _coordinateSequenceFilterJsDefault.default)
                ];
            }
            filter(seq, i) {
                if (i <= 0) return null;
                const p0 = seq.getCoordinate(i - 1);
                const p1 = seq.getCoordinate(i);
                const isBorder = OverlapUnion.intersects(env, p0, p1) && !OverlapUnion.containsProperly(env, p0, p1);
                if (isBorder) {
                    const seg = new (0, _lineSegmentJsDefault.default)(p0, p1);
                    segs.add(seg);
                }
            }
            isDone() {
                return false;
            }
            isGeometryChanged() {
                return false;
            }
        }());
    }
    static unionBuffer(g0, g1) {
        const factory = g0.getFactory();
        const gColl = factory.createGeometryCollection([
            g0,
            g1
        ]);
        const union = (0, _bufferOpJsDefault.default).bufferOp(gColl, 0.0);
        return union;
    }
    isBorderSegmentsSame(result, env) {
        const segsBefore = this.extractBorderSegments(this._g0, this._g1, env);
        const segsAfter = new (0, _arrayListJsDefault.default)();
        OverlapUnion.extractBorderSegments(result, env, segsAfter);
        return this.isEqual(segsBefore, segsAfter);
    }
    union() {
        const overlapEnv = OverlapUnion.overlapEnvelope(this._g0, this._g1);
        if (overlapEnv.isNull()) {
            const g0Copy = this._g0.copy();
            const g1Copy = this._g1.copy();
            return (0, _geometryCombinerJsDefault.default).combine(g0Copy, g1Copy);
        }
        const disjointPolys = new (0, _arrayListJsDefault.default)();
        const g0Overlap = this.extractByEnvelope(overlapEnv, this._g0, disjointPolys);
        const g1Overlap = this.extractByEnvelope(overlapEnv, this._g1, disjointPolys);
        const unionGeom = this.unionFull(g0Overlap, g1Overlap);
        let result = null;
        this._isUnionSafe = this.isBorderSegmentsSame(unionGeom, overlapEnv);
        if (!this._isUnionSafe) result = this.unionFull(this._g0, this._g1);
        else result = this.combine(unionGeom, disjointPolys);
        return result;
    }
    extractBorderSegments(geom0, geom1, env) {
        const segs = new (0, _arrayListJsDefault.default)();
        OverlapUnion.extractBorderSegments(geom0, env, segs);
        if (geom1 !== null) OverlapUnion.extractBorderSegments(geom1, env, segs);
        return segs;
    }
    isUnionOptimized() {
        return this._isUnionSafe;
    }
    extractByEnvelope(env, geom, disjointGeoms) {
        const intersectingGeoms = new (0, _arrayListJsDefault.default)();
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const elem = geom.getGeometryN(i);
            if (elem.getEnvelopeInternal().intersects(env)) intersectingGeoms.add(elem);
            else {
                const copy = elem.copy();
                disjointGeoms.add(copy);
            }
        }
        return this._geomFactory.buildGeometry(intersectingGeoms);
    }
    isEqual(segs0, segs1) {
        if (segs0.size() !== segs1.size()) return false;
        const segIndex = new (0, _hashSetJsDefault.default)(segs0);
        for (const seg of segs1)if (!segIndex.contains(seg)) return false;
        return true;
    }
    combine(unionGeom, disjointPolys) {
        if (disjointPolys.size() <= 0) return unionGeom;
        disjointPolys.add(unionGeom);
        const result = (0, _geometryCombinerJsDefault.default).combine(disjointPolys);
        return result;
    }
    unionFull(geom0, geom1) {
        try {
            return (0, _unionOpJsDefault.default).union(geom0, geom1);
        } catch (ex) {
            if (ex instanceof (0, _topologyExceptionJsDefault.default)) return OverlapUnion.unionBuffer(geom0, geom1);
            else throw ex;
        } finally{}
    }
}
exports.default = OverlapUnion;

},{"../../../../../java/util/HashSet.js":"cNQO2","./UnionOp.js":"IoxtK","../../geom/TopologyException.js":"cGr97","../../geom/LineSegment.js":"4V3G8","../../../../../java/util/ArrayList.js":"g8omH","../../geom/CoordinateSequenceFilter.js":"8HUHX","../buffer/BufferOp.js":"a028O","../../geom/util/GeometryCombiner.js":"8TPyt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"IoxtK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryJs = require("../../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _snapIfNeededOverlayOpJs = require("../overlay/snap/SnapIfNeededOverlayOp.js");
var _snapIfNeededOverlayOpJsDefault = parcelHelpers.interopDefault(_snapIfNeededOverlayOpJs);
var _overlayOpJs = require("../overlay/OverlayOp.js");
var _overlayOpJsDefault = parcelHelpers.interopDefault(_overlayOpJs);
class UnionOp {
    static union(g, other) {
        if (g.isEmpty() || other.isEmpty()) {
            if (g.isEmpty() && other.isEmpty()) return (0, _overlayOpJsDefault.default).createEmptyResult((0, _overlayOpJsDefault.default).UNION, g, other, g.getFactory());
            if (g.isEmpty()) return other.copy();
            if (other.isEmpty()) return g.copy();
        }
        (0, _geometryJsDefault.default).checkNotGeometryCollection(g);
        (0, _geometryJsDefault.default).checkNotGeometryCollection(other);
        return (0, _snapIfNeededOverlayOpJsDefault.default).overlayOp(g, other, (0, _overlayOpJsDefault.default).UNION);
    }
}
exports.default = UnionOp;

},{"../../geom/Geometry.js":"d5V2e","../overlay/snap/SnapIfNeededOverlayOp.js":"3ISyI","../overlay/OverlayOp.js":"eclqj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["2yM6G"], null, "parcelRequired761", {})

//# sourceMappingURL=draw.aae26ee7.js.map
