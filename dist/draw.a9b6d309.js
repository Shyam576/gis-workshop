// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  externals,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        if (externals[name]) {
          return externals[name];
        }
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  // INSERT_LOAD_HERE

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"eOIEV":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "c11c19e3a9b6d309";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            // Ignore cloudflare workers error.
            if (err.message && !err.message.includes('Disallowed operation called within global scope')) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"2A9xt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Check if a feature intersects with any existing features in the layer
 * @param {Feature} feature - The feature to check
 * @param {VectorLayer} layer - The vector layer containing existing features
 * @param {boolean} showAlert - Whether to show an alert message
 * @returns {boolean} - True if intersection found, false otherwise
 */ parcelHelpers.export(exports, "checkIntersection", ()=>checkIntersection);
/**
 * Calculate area of a polygon feature in square meters and hectares
 * @param {Feature} feature - The feature to calculate area for
 * @returns {Object} - Object containing area in square meters and hectares
 */ parcelHelpers.export(exports, "calculateArea", ()=>calculateArea);
parcelHelpers.export(exports, "enableDraw", ()=>enableDraw);
parcelHelpers.export(exports, "createDrawLayer", ()=>createDrawLayer);
parcelHelpers.export(exports, "checkInteraction", ()=>checkInteraction);
/**
 * Initialize drawing tools on an existing map
 * @param {import('ol/Map.js').default} map - The OpenLayers map instance
 * @returns {Object} - Object containing drawing tools and methods
 */ parcelHelpers.export(exports, "initDrawTools", ()=>initDrawTools);
/**
 * Union selected features using JSTS
 * @param {Array<Feature>} features - Array of features to union
 * @param {VectorSource} source - Vector source to add the result to and remove original features from
 * @returns {Feature|null} - The union result as a feature, or null if operation fails
 */ parcelHelpers.export(exports, "unionSelectedFeatures", ()=>unionSelectedFeatures);
var _draw = require("ol/interaction/Draw");
var _drawDefault = parcelHelpers.interopDefault(_draw);
var _geoserverCrudJs = require("./geoserver-crud.js");
var _ol = require("ol");
var _vector = require("ol/source/Vector");
var _vectorDefault = parcelHelpers.interopDefault(_vector);
var _vector1 = require("ol/layer/Vector");
var _vectorDefault1 = parcelHelpers.interopDefault(_vector1);
var _style = require("ol/style/Style");
var _styleDefault = parcelHelpers.interopDefault(_style);
var _circle = require("ol/style/Circle");
var _circleDefault = parcelHelpers.interopDefault(_circle);
var _fill = require("ol/style/Fill");
var _fillDefault = parcelHelpers.interopDefault(_fill);
var _stroke = require("ol/style/Stroke");
var _strokeDefault = parcelHelpers.interopDefault(_stroke);
var _modifyJs = require("ol/interaction/Modify.js");
var _modifyJsDefault = parcelHelpers.interopDefault(_modifyJs);
var _snapJs = require("ol/interaction/Snap.js");
var _snapJsDefault = parcelHelpers.interopDefault(_snapJs);
var _popupMessageJs = require("./popup-message.js");
var _extentJs = require("ol/extent.js");
var _geoJSON = require("ol/format/GeoJSON");
var _geoJSONDefault = parcelHelpers.interopDefault(_geoJSON);
var _sphere = require("ol/sphere");
// Import OpenLayers geometry classes for JSTS parser
var _point = require("ol/geom/Point");
var _pointDefault = parcelHelpers.interopDefault(_point);
var _lineString = require("ol/geom/LineString");
var _lineStringDefault = parcelHelpers.interopDefault(_lineString);
var _linearRing = require("ol/geom/LinearRing");
var _linearRingDefault = parcelHelpers.interopDefault(_linearRing);
var _polygon = require("ol/geom/Polygon");
var _polygonDefault = parcelHelpers.interopDefault(_polygon);
var _multiPoint = require("ol/geom/MultiPoint");
var _multiPointDefault = parcelHelpers.interopDefault(_multiPoint);
var _multiLineString = require("ol/geom/MultiLineString");
var _multiLineStringDefault = parcelHelpers.interopDefault(_multiLineString);
var _multiPolygon = require("ol/geom/MultiPolygon");
var _multiPolygonDefault = parcelHelpers.interopDefault(_multiPolygon);
var _geometryCollection = require("ol/geom/GeometryCollection");
var _geometryCollectionDefault = parcelHelpers.interopDefault(_geometryCollection);
// Import JSTS for precise intersection checking
var _ol3Parser = require("jsts/org/locationtech/jts/io/OL3Parser");
var _ol3ParserDefault = parcelHelpers.interopDefault(_ol3Parser);
var _relate = require("jsts/org/locationtech/jts/operation/relate");
var _union = require("jsts/org/locationtech/jts/operation/union");
function checkIntersection(feature, layer, showAlert = true) {
    if (!feature || !layer) return false;
    const drawGeom = feature.getGeometry();
    if (!drawGeom) return false;
    // Validate geometry before proceeding
    if (drawGeom.getType() === 'Polygon') {
        const coords = drawGeom.getCoordinates();
        if (!coords || !coords[0] || coords[0].length < 4) {
            console.warn("Invalid polygon: not enough points for a LinearRing", coords);
            return false;
        }
    }
    // Use JSTS for precise intersection checking
    const parser = new (0, _ol3ParserDefault.default)();
    parser.inject((0, _pointDefault.default), (0, _lineStringDefault.default), (0, _linearRingDefault.default), (0, _polygonDefault.default), (0, _multiPointDefault.default), (0, _multiLineStringDefault.default), (0, _multiPolygonDefault.default), (0, _geometryCollectionDefault.default));
    try {
        // Convert the drawn geometry to JSTS geometry
        const jstsGeom = parser.read(drawGeom);
        // Get the extent of the drawn geometry for quick filtering
        const drawGeomExtent = drawGeom.getExtent();
        let hasIntersection = false;
        let intersectingFeature = null;
        // Check against each existing feature
        layer.getSource().getFeatures().forEach((existingFeature)=>{
            // Skip checking against itself
            if (existingFeature === feature) return;
            const existingGeom = existingFeature.getGeometry();
            if (!existingGeom) return;
            // Validate existing geometry
            if (existingGeom.getType() === 'Polygon') {
                const coords = existingGeom.getCoordinates();
                if (!coords || !coords[0] || coords[0].length < 4) {
                    console.warn("Invalid existing polygon: not enough points for a LinearRing", coords);
                    return;
                }
            }
            // Quick check with extents first (bounding boxes)
            if ((0, _extentJs.intersects)(drawGeomExtent, existingGeom.getExtent())) try {
                // Convert existing geometry to JSTS geometry
                const jstsExistingGeom = parser.read(existingGeom);
                // Perform precise intersection check
                if ((0, _relate.RelateOp).intersects(jstsGeom, jstsExistingGeom)) {
                    hasIntersection = true;
                    intersectingFeature = existingFeature;
                    // Show alert if requested
                    if (showAlert) {
                        const featureType = drawGeom.getType();
                        const existingType = existingGeom.getType();
                        (0, _popupMessageJs.showPopupMessage)(`Intersection detected between ${featureType} and existing ${existingType}`, "warning");
                        // Highlight the intersecting feature
                        highlightIntersectingFeature(existingFeature, layer);
                    }
                    // We found an intersection, no need to check further
                    return;
                }
            } catch (error) {
                console.error("Error checking intersection:", error);
            }
        });
        return hasIntersection;
    } catch (error) {
        console.error("Error in checkIntersection:", error);
        return false;
    }
}
/**
 * Temporarily highlight an intersecting feature
 * @param {Feature} feature - The feature to highlight
 * @param {VectorLayer} layer - The vector layer containing the feature
 */ function highlightIntersectingFeature(feature, layer) {
    // Store the original style
    const originalStyle = feature.getStyle() || layer.getStyle();
    // Set a highlight style
    feature.setStyle(new (0, _styleDefault.default)({
        stroke: new (0, _strokeDefault.default)({
            color: "red",
            width: 3
        }),
        fill: new (0, _fillDefault.default)({
            color: "rgba(255, 0, 0, 0.3)"
        }),
        image: new (0, _circleDefault.default)({
            radius: 7,
            fill: new (0, _fillDefault.default)({
                color: "red"
            })
        })
    }));
    // Reset to original style after 2 seconds
    setTimeout(()=>{
        feature.setStyle(originalStyle);
    }, 2000);
}
function calculateArea(feature) {
    if (!feature) return {
        m2: 0,
        ha: 0
    };
    const geometry = feature.getGeometry();
    if (!geometry || geometry.getType() !== "Polygon") return {
        m2: 0,
        ha: 0
    };
    // Get area in square meters
    const areaInM2 = (0, _sphere.getArea)(geometry);
    // Convert to hectares (1 hectare = 10,000 m²)
    const areaInHa = areaInM2 / 10000;
    return {
        m2: Math.round(areaInM2 * 100) / 100,
        ha: Math.round(areaInHa * 10000) / 10000
    };
}
function enableDraw(map, vectorLayer, drawType = "Polygon", geoserverURL) {
    let drawnfeatures = [];
    let modifiedFeatures = [];
    let isDrawing = false;
    let originalFeatureGeometries = new Map(); // Store original geometries for potential rollback
    // Create draw interaction
    const draw = new (0, _drawDefault.default)({
        source: vectorLayer.getSource(),
        type: drawType
    });
    map.addInteraction(draw);
    // Track when drawing starts
    draw.on("drawstart", (event)=>{
        isDrawing = true;
        const hasIntersection = checkIntersection(event.feature, vectorLayer);
        console.log("Has Intersection: ", hasIntersection);
        const preventIntersections = document.getElementById("prevent-intersections")?.checked || false;
        if (hasIntersection && preventIntersections) {
            // Remove the feature that was just drawn
            vectorLayer.getSource().removeFeature(event.feature);
            (0, _popupMessageJs.showPopupMessage)("Drawing removed due to intersection with existing feature", "warning");
            return;
        }
        console.log("Drawing started");
    });
    // Handle drawing end
    draw.on("drawend", async (event)=>{
        isDrawing = false;
        console.log("Drawing ended");
        const feature = event.feature;
        // Check for intersections with existing features
        const hasIntersection = checkIntersection(feature, vectorLayer);
        console.log("Intersection check result:", hasIntersection);
        // If intersection is found and we want to prevent it
        const preventIntersections = document.getElementById("prevent-intersections")?.checked || false;
        if (hasIntersection && preventIntersections) {
            // Remove the feature that was just drawn
            vectorLayer.getSource().removeFeature(feature);
            (0, _popupMessageJs.showPopupMessage)("Drawing removed due to intersection with existing feature", "warning");
            return;
        }
        // Calculate area for polygons
        if (drawType === "Polygon") {
            const area = calculateArea(feature);
            feature.setProperties({
                area_m2: area.m2,
                area_ha: area.ha
            });
            // Show area information
            (0, _popupMessageJs.showPopupMessage)(`Area: ${area.m2} m\xb2 (${area.ha} ha)`, "info");
        }
        const newFeat = new (0, _ol.Feature)();
        newFeat.setGeometryName("geom");
        newFeat.setGeometry(feature.getGeometry());
        newFeat.setProperties({
            name: "test",
            ...feature.getProperties()
        });
        const autoSave = document.getElementById("auto-save")?.checked || false;
        if (autoSave) try {
            const res = await (0, _geoserverCrudJs.transactWFS)("insert", [
                newFeat
            ], "ne", "draw_layer", "EPSG:3857", "admin", "geoserver", geoserverURL);
            const featureId = parseInt(res.insertedFIDs[0].split(".")[1]);
            event.feature.setProperties({
                fid: featureId
            });
            console.log("Feature drawn and saved to server");
        } catch (error) {
            console.error("Error saving feature:", error);
            (0, _popupMessageJs.showPopupMessage)("Error saving feature to server", "error");
        }
        else {
            drawnfeatures.push(newFeat);
            console.log("Feature drawn and saved to memory");
        }
    });
    const modify = new (0, _modifyJsDefault.default)({
        source: vectorLayer.getSource()
    });
    map.addInteraction(modify);
    // Store original geometry before modification
    modify.on("modifystart", (event)=>{
        const features = event.features.getArray();
        features.forEach((feature)=>{
            // Store a clone of the original geometry
            originalFeatureGeometries.set(feature, feature.getGeometry().clone());
        });
    });
    // Handle feature modification
    modify.on("modifyend", (event)=>{
        console.log("Modification ended");
        const features = event.features.getArray();
        features.forEach(async (feature)=>{
            // Check for intersections with existing features
            const hasIntersection = checkIntersection(feature, vectorLayer);
            console.log("Modification intersection check result:", hasIntersection);
            // If intersection is found and we want to prevent it
            const preventIntersections = document.getElementById("prevent-intersections")?.checked || false;
            if (hasIntersection && preventIntersections) {
                // Revert the modification using the stored original geometry
                const originalGeometry = originalFeatureGeometries.get(feature);
                if (originalGeometry) {
                    feature.setGeometry(originalGeometry);
                    (0, _popupMessageJs.showPopupMessage)("Modification reverted due to intersection with existing feature", "warning");
                    return; // Skip the rest of the processing for this feature
                } else (0, _popupMessageJs.showPopupMessage)("Modification creates intersection with existing feature", "warning");
            }
            // Recalculate area for polygons
            if (feature.getGeometry().getType() === "Polygon") {
                const area = calculateArea(feature);
                feature.setProperties({
                    area_m2: area.m2,
                    area_ha: area.ha
                });
                // Show updated area information
                (0, _popupMessageJs.showPopupMessage)(`Updated area: ${area.m2} m\xb2 (${area.ha} ha)`, "info");
            }
            const newFeat = new (0, _ol.Feature)();
            newFeat.setGeometryName("geom");
            newFeat.setGeometry(feature.getGeometry());
            newFeat.setId(feature.getProperties().fid);
            const autoSave = document.getElementById("auto-save")?.checked || false;
            if (autoSave) try {
                await (0, _geoserverCrudJs.transactWFS)("update", [
                    newFeat
                ], "ne", "draw_layer", "EPSG:3857", "admin", "geoserver", geoserverURL);
                console.log("Feature modified and saved to server");
            } catch (error) {
                console.error("Error updating feature:", error);
                (0, _popupMessageJs.showPopupMessage)("Error updating feature on server", "error");
            }
            else {
                modifiedFeatures.push(newFeat);
                console.log("Feature modified and saved to memory");
            }
        });
        // Clear the stored geometries
        originalFeatureGeometries.clear();
    });
    const snap = new (0, _snapJsDefault.default)({
        source: vectorLayer.getSource()
    });
    map.addInteraction(snap);
    return {
        draw,
        modify,
        snap,
        disable: ()=>{
            map.removeInteraction(draw);
            map.removeInteraction(modify);
            map.removeInteraction(snap);
        },
        save: async ()=>{
            let res;
            let savedCount = 0;
            if (drawnfeatures.length > 0) try {
                res = await (0, _geoserverCrudJs.transactWFS)("insert", drawnfeatures, "ne", "draw_layer", "EPSG:3857", "admin", "geoserver", geoserverURL);
                savedCount += drawnfeatures.length;
                drawnfeatures = [];
            } catch (error) {
                console.error("Error saving drawn features:", error);
                (0, _popupMessageJs.showPopupMessage)("Error saving drawn features", "error");
            }
            if (modifiedFeatures.length > 0) try {
                res = await (0, _geoserverCrudJs.transactWFS)("update", modifiedFeatures, "ne", "draw_layer", "EPSG:3857", "admin", "geoserver", geoserverURL);
                savedCount += modifiedFeatures.length;
                modifiedFeatures = [];
            } catch (error) {
                console.error("Error saving modified features:", error);
                (0, _popupMessageJs.showPopupMessage)("Error saving modified features", "error");
            }
            if (savedCount > 0) (0, _popupMessageJs.showPopupMessage)(`Successfully saved ${savedCount} feature(s)!`, "success");
            else if (drawnfeatures.length === 0 && modifiedFeatures.length === 0) (0, _popupMessageJs.showPopupMessage)("No features to save", "info");
            return res;
        },
        delete: async ()=>{
            const source = vectorLayer.getSource();
            const features = source.getFeatures();
            if (features.length > 0) {
                const autoSave = document.getElementById("auto-save")?.checked || false;
                if (autoSave) {
                    // Get all features with FIDs
                    const featuresToDelete = features.filter((f)=>f.getProperties().fid);
                    if (featuresToDelete.length > 0) try {
                        await (0, _geoserverCrudJs.transactWFS)("delete", featuresToDelete, "ne", "draw_layer", "EPSG:3857", "admin", "geoserver", geoserverURL);
                    } catch (error) {
                        console.error("Error deleting features:", error);
                        (0, _popupMessageJs.showPopupMessage)("Error deleting features from server", "error");
                    }
                }
                // Clear all features from the source
                source.clear();
                drawnfeatures = [];
                modifiedFeatures = [];
                (0, _popupMessageJs.showPopupMessage)("All features deleted", "success");
            } else (0, _popupMessageJs.showPopupMessage)("No features to delete", "info");
        },
        exportGeoJSON: ()=>{
            const source = vectorLayer.getSource();
            const features = source.getFeatures();
            if (features.length === 0) {
                (0, _popupMessageJs.showPopupMessage)("No features to export", "info");
                return null;
            }
            const format = new (0, _geoJSONDefault.default)();
            const geojson = format.writeFeaturesObject(features);
            // Add area properties for polygons
            geojson.features.forEach((feature)=>{
                if (feature.geometry.type === "Polygon") {
                    const olFeature = source.getFeatureById(feature.id);
                    const area = calculateArea(olFeature);
                    feature.properties.area_m2 = area.m2;
                    feature.properties.area_ha = area.ha;
                }
            });
            return geojson;
        }
    };
}
function createDrawLayer() {
    const drawSource = new (0, _vectorDefault.default)();
    const drawStyle = (feature)=>{
        const type = feature.getGeometry().getType();
        if (type === "Point" || type === "MultiPoint") return new (0, _styleDefault.default)({
            image: new (0, _circleDefault.default)({
                radius: 5,
                fill: new (0, _fillDefault.default)({
                    color: "blue"
                }),
                stroke: new (0, _strokeDefault.default)({
                    color: "white",
                    width: 1
                })
            })
        });
        if (type.includes("Line")) return new (0, _styleDefault.default)({
            stroke: new (0, _strokeDefault.default)({
                color: "green",
                width: 2
            })
        });
        if (type.includes("Polygon")) return new (0, _styleDefault.default)({
            stroke: new (0, _strokeDefault.default)({
                color: "orange",
                width: 1
            }),
            fill: new (0, _fillDefault.default)({
                color: "rgba(255,165,0,0.3)"
            })
        });
        return new (0, _styleDefault.default)({
            stroke: new (0, _strokeDefault.default)({
                color: "gray",
                width: 1
            }),
            fill: new (0, _fillDefault.default)({
                color: "rgba(200, 200, 200, 0.3)"
            })
        });
    };
    const drawLayer = new (0, _vectorDefault1.default)({
        source: drawSource,
        style: drawStyle,
        title: "draw-layer"
    });
    return drawLayer;
}
function checkInteraction(lineDraw, polyDraw, pointDraw) {
    if (lineDraw) lineDraw.disable();
    if (polyDraw) polyDraw.disable();
    if (pointDraw) pointDraw.disable();
}
function initDrawTools(map) {
    // Create a vector source and layer for the drawings
    const drawLayer = createDrawLayer();
    map.addLayer(drawLayer);
    // Get the source from the layer
    const source = drawLayer.getSource();
    // Create draw, modify, and snap interactions
    const typeSelect = document.getElementById("type");
    let draw, modify, snap;
    function addInteractions() {
        // Get the GeoServer URL from the global variable or use a default
        const geoserverURL = window.geoserverURL || "http://localhost:8080/geoserver";
        // Create drawing tools with the selected geometry type
        const drawingTools = enableDraw(map, drawLayer, typeSelect.value, geoserverURL);
        // Store references to the interactions
        draw = drawingTools.draw;
        modify = drawingTools.modify;
        snap = drawingTools.snap;
        return drawingTools;
    }
    // Initialize interactions with the default geometry type
    let drawingTools = addInteractions();
    // Handle change in geometry type
    if (typeSelect) typeSelect.onchange = function() {
        // Remove existing interactions
        if (drawingTools && drawingTools.disable) drawingTools.disable();
        // Add new interactions with the selected geometry type
        drawingTools = addInteractions();
    };
    // Return an object with methods to control the drawing tools
    return {
        source: source,
        layer: drawLayer,
        // Method to enable/disable drawing tools
        setActive: function(active) {
            if (active) // Re-add interactions if they were removed
            {
                if (!map.getInteractions().getArray().includes(draw)) drawingTools = addInteractions();
            } else // Remove interactions if they exist
            if (drawingTools && drawingTools.disable) drawingTools.disable();
        },
        // Method to save drawings
        save: function() {
            if (drawingTools && drawingTools.save) return drawingTools.save();
            return Promise.resolve({
                status: "error",
                message: "Drawing tools not initialized"
            });
        },
        // Method to delete drawings
        delete: function() {
            if (drawingTools && drawingTools.delete) return drawingTools.delete();
            return Promise.resolve({
                status: "error",
                message: "Drawing tools not initialized"
            });
        },
        // Method to export drawings as GeoJSON
        exportGeoJSON: function() {
            if (drawingTools && drawingTools.exportGeoJSON) return drawingTools.exportGeoJSON();
            return null;
        },
        // Reference to the source for direct access
        source: source
    };
}
function unionSelectedFeatures(features, source) {
    if (!features || features.length < 2) {
        (0, _popupMessageJs.showPopupMessage)("Select at least two features to union", "warning");
        return null;
    }
    try {
        // Create a JSTS parser
        const parser = new (0, _ol3ParserDefault.default)();
        parser.inject((0, _pointDefault.default), (0, _lineStringDefault.default), (0, _linearRingDefault.default), (0, _polygonDefault.default), (0, _multiPointDefault.default), (0, _multiLineStringDefault.default), (0, _multiPolygonDefault.default), (0, _geometryCollectionDefault.default));
        // Convert all features to JSTS geometries
        const jstsGeometries = features.map((feature)=>{
            const geometry = feature.getGeometry();
            if (!geometry) {
                console.warn("Feature has no geometry:", feature);
                return null;
            }
            return parser.read(geometry);
        }).filter((geom)=>geom !== null);
        if (jstsGeometries.length < 2) {
            (0, _popupMessageJs.showPopupMessage)("Not enough valid geometries to union", "warning");
            return null;
        }
        console.log("JSTS geometries for union:", jstsGeometries);
        // Perform the union operation
        const unionGeometry = (0, _union.UnaryUnionOp).union(jstsGeometries);
        console.log("Union result:", unionGeometry);
        if (!unionGeometry) {
            (0, _popupMessageJs.showPopupMessage)("Union operation failed", "error");
            return null;
        }
        // Convert back to OpenLayers geometry
        const olGeometry = parser.write(unionGeometry);
        // Create a new feature with the union geometry
        const unionFeature = new (0, _ol.Feature)({
            geometry: olGeometry
        });
        // Remove original features and add the union result
        if (source) {
            features.forEach((feature)=>{
                source.removeFeature(feature);
            });
            source.addFeature(unionFeature);
        }
        (0, _popupMessageJs.showPopupMessage)("Union operation completed successfully", "success");
        return unionFeature;
    } catch (error) {
        console.error("Error in unionSelectedFeatures:", error);
        (0, _popupMessageJs.showPopupMessage)("Union operation failed: " + error.message, "error");
        return null;
    }
}

},{"ol/interaction/Draw":"43MZd","./geoserver-crud.js":"agqRu","ol":"3a1E4","ol/source/Vector":"9w7Fr","ol/layer/Vector":"iTrAy","ol/style/Style":"fW7vC","ol/style/Circle":"cSS3Y","ol/style/Fill":"4fB56","ol/style/Stroke":"5Cq04","ol/interaction/Modify.js":"4T7TT","ol/interaction/Snap.js":"0zhsh","./popup-message.js":"gi4gx","ol/extent.js":"6YrVc","ol/format/GeoJSON":"1bsdX","ol/sphere":"eJjHw","ol/geom/Point":"hx2Ar","ol/geom/LineString":"jLUiq","ol/geom/LinearRing":"jg1hj","ol/geom/Polygon":"cJuQF","ol/geom/MultiPoint":"k4LcJ","ol/geom/MultiLineString":"030lt","ol/geom/MultiPolygon":"2XIqx","ol/geom/GeometryCollection":"fDMaj","jsts/org/locationtech/jts/io/OL3Parser":"5NDio","jsts/org/locationtech/jts/operation/relate":"fii18","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","jsts/org/locationtech/jts/operation/union":"kMEug"}],"43MZd":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Draw
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */ parcelHelpers.export(exports, "DrawEvent", ()=>DrawEvent);
/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of a
 * {@link import("../geom/Circle.js").Circle} geometry.
 * @param {number} [sides] Number of sides of the regular polygon.
 *     Default is 32.
 * @param {number} [angle] Angle of the first point in counter-clockwise
 *     radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a polygon.
 * @api
 */ parcelHelpers.export(exports, "createRegularPolygon", ()=>createRegularPolygon);
/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */ parcelHelpers.export(exports, "createBox", ()=>createBox);
var _circleJs = require("../geom/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geometryCollectionJs = require("../geom/GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _mapBrowserEventJs = require("../MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPointJs = require("../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _vectorJs = require("../layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _vectorJs1 = require("../source/Vector.js");
var _vectorJsDefault1 = parcelHelpers.interopDefault(_vectorJs1);
var _functionsJs = require("../functions.js");
var _conditionJs = require("../events/condition.js");
var _extentJs = require("../extent.js");
var _mathJs = require("../math.js");
var _styleJs = require("../style/Style.js");
var _coordinateJs = require("../coordinate.js");
var _projJs = require("../proj.js");
var _simpleGeometryJs = require("../geom/SimpleGeometry.js");
/**
 * @typedef {Object} Options
 * @property {import("../geom/Geometry.js").Type} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish. Must be greater than `0`.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished. Not used when drawing
 * POINT or MULTI_POINT geometries.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style for sketch features. The draw interaction can have up to three sketch features, depending on the mode.
 * It will always contain a feature with a `Point` geometry that corresponds to the current cursor position.
 * If the mode is `LineString` or `Polygon`, and there is at least one drawn point, it will also contain a feature with
 * a `LineString` geometry that corresponds to the line between the already drawn points and the current cursor position.
 * If the mode is `Polygon`, and there is at least one drawn point, it will also contain a feature with a `Polygon`
 * geometry that corresponds to the polygon between the already drawn points and the current cursor position
 * (note that this polygon has only two points if only one point is drawn).
 * If the mode is `Circle`, and there is one point drawn, it will also contain a feature with a `Circle` geometry whose
 * center is the drawn point and the radius is determined by the distance between the drawn point and the cursor.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean|import("../events/condition.js").Condition} [trace=false] Trace a portion of another geometry.
 * Ignored when in freehand mode.
 * @property {VectorSource} [traceSource] Source for features to trace.  If tracing is active and a `traceSource` is
 * not provided, the interaction's `source` will be used.  Tracing requires that the interaction is configured with
 * either a `traceSource` or a `source`.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {import("../geom/Geometry.js").GeometryLayout} [geometryLayout='XY'] Layout of the
 * feature geometries created by the draw interaction.
 */ /**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */ /**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */ /**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */ /**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */ /**
 * @typedef {Object} TraceState
 * @property {boolean} active Tracing active.
 * @property {import("../pixel.js").Pixel} [startPx] The initially clicked pixel location.
 * @property {Array<TraceTarget>} [targets] Targets available for tracing.
 * @property {number} [targetIndex] The index of the currently traced target.  A value of -1 indicates
 * that no trace target is active.
 */ /**
 * @typedef {Object} TraceTarget
 * @property {Array<import("../coordinate.js").Coordinate>} coordinates Target coordinates.
 * @property {boolean} ring The target coordinates are a linear ring.
 * @property {number} startIndex The index of first traced coordinate.  A fractional index represents an
 * edge intersection.  Index values for rings will wrap (may be negative or larger than coordinates length).
 * @property {number} endIndex The index of last traced coordinate.  Details from startIndex also apply here.
 */ /**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default,
 *     import("../proj/Projection.js").default):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */ /**
 * @typedef {'Point' | 'LineString' | 'Polygon' | 'Circle'} Mode
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 */ /**
 * @enum {string}
 */ const DrawEventType = {
    /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */ DRAWSTART: 'drawstart',
    /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */ DRAWEND: 'drawend',
    /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */ DRAWABORT: 'drawabort'
};
class DrawEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */ constructor(type, feature){
        super(type);
        /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */ this.feature = feature;
    }
}
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {Array<Feature>} features The candidate features.
 * @return {Array<TraceTarget>} The trace targets.
 */ function getTraceTargets(coordinate, features) {
    /**
   * @type {Array<TraceTarget>}
   */ const targets = [];
    for(let i = 0; i < features.length; ++i){
        const feature = features[i];
        const geometry = feature.getGeometry();
        appendGeometryTraceTargets(coordinate, geometry, targets);
    }
    return targets;
}
/**
 * @param {import("../coordinate.js").Coordinate} a One coordinate.
 * @param {import("../coordinate.js").Coordinate} b Another coordinate.
 * @return {number} The squared distance between the two coordinates.
 */ function getSquaredDistance(a, b) {
    return (0, _mathJs.squaredDistance)(a[0], a[1], b[0], b[1]);
}
/**
 * @param {LineCoordType} coordinates The ring coordinates.
 * @param {number} index The index.  May be wrapped.
 * @return {import("../coordinate.js").Coordinate} The coordinate.
 */ function getCoordinate(coordinates, index) {
    const count = coordinates.length;
    if (index < 0) return coordinates[index + count];
    if (index >= count) return coordinates[index - count];
    return coordinates[index];
}
/**
 * Get the cumulative squared distance along a ring path.  The end index index may be "wrapped" and it may
 * be less than the start index to indicate the direction of travel.  The start and end index may have
 * a fractional part to indicate a point between two coordinates.
 * @param {LineCoordType} coordinates Ring coordinates.
 * @param {number} startIndex The start index.
 * @param {number} endIndex The end index.
 * @return {number} The cumulative squared distance along the ring path.
 */ function getCumulativeSquaredDistance(coordinates, startIndex, endIndex) {
    let lowIndex, highIndex;
    if (startIndex < endIndex) {
        lowIndex = startIndex;
        highIndex = endIndex;
    } else {
        lowIndex = endIndex;
        highIndex = startIndex;
    }
    const lowWholeIndex = Math.ceil(lowIndex);
    const highWholeIndex = Math.floor(highIndex);
    if (lowWholeIndex > highWholeIndex) {
        // both start and end are on the same segment
        const start = interpolateCoordinate(coordinates, lowIndex);
        const end = interpolateCoordinate(coordinates, highIndex);
        return getSquaredDistance(start, end);
    }
    let sd = 0;
    if (lowIndex < lowWholeIndex) {
        const start = interpolateCoordinate(coordinates, lowIndex);
        const end = getCoordinate(coordinates, lowWholeIndex);
        sd += getSquaredDistance(start, end);
    }
    if (highWholeIndex < highIndex) {
        const start = getCoordinate(coordinates, highWholeIndex);
        const end = interpolateCoordinate(coordinates, highIndex);
        sd += getSquaredDistance(start, end);
    }
    for(let i = lowWholeIndex; i < highWholeIndex - 1; ++i){
        const start = getCoordinate(coordinates, i);
        const end = getCoordinate(coordinates, i + 1);
        sd += getSquaredDistance(start, end);
    }
    return sd;
}
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {import("../geom/Geometry.js").default} geometry The candidate geometry.
 * @param {Array<TraceTarget>} targets The trace targets.
 */ function appendGeometryTraceTargets(coordinate, geometry, targets) {
    if (geometry instanceof (0, _lineStringJsDefault.default)) {
        appendTraceTarget(coordinate, geometry.getCoordinates(), false, targets);
        return;
    }
    if (geometry instanceof (0, _multiLineStringJsDefault.default)) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length; i < ii; ++i)appendTraceTarget(coordinate, coordinates[i], false, targets);
        return;
    }
    if (geometry instanceof (0, _polygonJsDefault.default)) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length; i < ii; ++i)appendTraceTarget(coordinate, coordinates[i], true, targets);
        return;
    }
    if (geometry instanceof (0, _multiPolygonJsDefault.default)) {
        const polys = geometry.getCoordinates();
        for(let i = 0, ii = polys.length; i < ii; ++i){
            const coordinates = polys[i];
            for(let j = 0, jj = coordinates.length; j < jj; ++j)appendTraceTarget(coordinate, coordinates[j], true, targets);
        }
        return;
    }
    if (geometry instanceof (0, _geometryCollectionJsDefault.default)) {
        const geometries = geometry.getGeometries();
        for(let i = 0; i < geometries.length; ++i)appendGeometryTraceTargets(coordinate, geometries[i], targets);
        return;
    }
// other types cannot be traced
}
/**
 * @typedef {Object} TraceTargetUpdateInfo
 * @property {number} index The new target index.
 * @property {number} endIndex The new segment end index.
 */ /**
 * @type {TraceTargetUpdateInfo}
 */ const sharedUpdateInfo = {
    index: -1,
    endIndex: NaN
};
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The coordinate.
 * @param {TraceState} traceState The trace state.
 * @param {import("../Map.js").default} map The map.
 * @param {number} snapTolerance The snap tolerance.
 * @return {TraceTargetUpdateInfo} Information about the new trace target.  The returned
 * object is reused between calls and must not be modified by the caller.
 */ function getTraceTargetUpdate(coordinate, traceState, map, snapTolerance) {
    const x = coordinate[0];
    const y = coordinate[1];
    let closestTargetDistance = Infinity;
    let newTargetIndex = -1;
    let newEndIndex = NaN;
    for(let targetIndex = 0; targetIndex < traceState.targets.length; ++targetIndex){
        const target = traceState.targets[targetIndex];
        const coordinates = target.coordinates;
        let minSegmentDistance = Infinity;
        let endIndex;
        for(let coordinateIndex = 0; coordinateIndex < coordinates.length - 1; ++coordinateIndex){
            const start = coordinates[coordinateIndex];
            const end = coordinates[coordinateIndex + 1];
            const rel = getPointSegmentRelationship(x, y, start, end);
            if (rel.squaredDistance < minSegmentDistance) {
                minSegmentDistance = rel.squaredDistance;
                endIndex = coordinateIndex + rel.along;
            }
        }
        if (minSegmentDistance < closestTargetDistance) {
            closestTargetDistance = minSegmentDistance;
            if (target.ring && traceState.targetIndex === targetIndex) {
                // same target, maintain the same trace direction
                if (target.endIndex > target.startIndex) // forward trace
                {
                    if (endIndex < target.startIndex) endIndex += coordinates.length;
                } else if (target.endIndex < target.startIndex) // reverse trace
                {
                    if (endIndex > target.startIndex) endIndex -= coordinates.length;
                }
            }
            newEndIndex = endIndex;
            newTargetIndex = targetIndex;
        }
    }
    const newTarget = traceState.targets[newTargetIndex];
    let considerBothDirections = newTarget.ring;
    if (traceState.targetIndex === newTargetIndex && considerBothDirections) {
        // only consider switching trace direction if close to the start
        const newCoordinate = interpolateCoordinate(newTarget.coordinates, newEndIndex);
        const pixel = map.getPixelFromCoordinate(newCoordinate);
        if ((0, _coordinateJs.distance)(pixel, traceState.startPx) > snapTolerance) considerBothDirections = false;
    }
    if (considerBothDirections) {
        const coordinates = newTarget.coordinates;
        const count = coordinates.length;
        const startIndex = newTarget.startIndex;
        const endIndex = newEndIndex;
        if (startIndex < endIndex) {
            const forwardDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex);
            const reverseDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex - count);
            if (reverseDistance < forwardDistance) newEndIndex -= count;
        } else {
            const reverseDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex);
            const forwardDistance = getCumulativeSquaredDistance(coordinates, startIndex, endIndex + count);
            if (forwardDistance < reverseDistance) newEndIndex += count;
        }
    }
    sharedUpdateInfo.index = newTargetIndex;
    sharedUpdateInfo.endIndex = newEndIndex;
    return sharedUpdateInfo;
}
/**
 * @param {import("../coordinate.js").Coordinate} coordinate The clicked coordinate.
 * @param {Array<import("../coordinate.js").Coordinate>} coordinates The geometry component coordinates.
 * @param {boolean} ring The coordinates represent a linear ring.
 * @param {Array<TraceTarget>} targets The trace targets.
 */ function appendTraceTarget(coordinate, coordinates, ring, targets) {
    const x = coordinate[0];
    const y = coordinate[1];
    for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
        const start = coordinates[i];
        const end = coordinates[i + 1];
        const rel = getPointSegmentRelationship(x, y, start, end);
        if (rel.squaredDistance === 0) {
            const index = i + rel.along;
            targets.push({
                coordinates: coordinates,
                ring: ring,
                startIndex: index,
                endIndex: index
            });
            return;
        }
    }
}
/**
 * @typedef {Object} PointSegmentRelationship
 * @property {number} along The closest point expressed as a fraction along the segment length.
 * @property {number} squaredDistance The squared distance of the point to the segment.
 */ /**
 * @type {PointSegmentRelationship}
 */ const sharedRel = {
    along: 0,
    squaredDistance: 0
};
/**
 * @param {number} x The point x.
 * @param {number} y The point y.
 * @param {import("../coordinate.js").Coordinate} start The segment start.
 * @param {import("../coordinate.js").Coordinate} end The segment end.
 * @return {PointSegmentRelationship} The point segment relationship.  The returned object is
 * shared between calls and must not be modified by the caller.
 */ function getPointSegmentRelationship(x, y, start, end) {
    const x1 = start[0];
    const y1 = start[1];
    const x2 = end[0];
    const y2 = end[1];
    const dx = x2 - x1;
    const dy = y2 - y1;
    let along = 0;
    let px = x1;
    let py = y1;
    if (dx !== 0 || dy !== 0) {
        along = (0, _mathJs.clamp)(((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy), 0, 1);
        px += dx * along;
        py += dy * along;
    }
    sharedRel.along = along;
    sharedRel.squaredDistance = (0, _mathJs.toFixed)((0, _mathJs.squaredDistance)(x, y, px, py), 10);
    return sharedRel;
}
/**
 * @param {LineCoordType} coordinates The coordinates.
 * @param {number} index The index.  May be fractional and may wrap.
 * @return {import("../coordinate.js").Coordinate} The interpolated coordinate.
 */ function interpolateCoordinate(coordinates, index) {
    const count = coordinates.length;
    let startIndex = Math.floor(index);
    const along = index - startIndex;
    if (startIndex >= count) startIndex -= count;
    else if (startIndex < 0) startIndex += count;
    let endIndex = startIndex + 1;
    if (endIndex >= count) endIndex -= count;
    const start = coordinates[startIndex];
    const x0 = start[0];
    const y0 = start[1];
    const end = coordinates[endIndex];
    const dx = end[0] - x0;
    const dy = end[1] - y0;
    return [
        x0 + dx * along,
        y0 + dy * along
    ];
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature
 */ /**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */ class Draw extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        const pointerOptions = /** @type {import("./Pointer.js").Options} */ options;
        if (!pointerOptions.stopDown) pointerOptions.stopDown = (0, _functionsJs.FALSE);
        super(pointerOptions);
        /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {DrawOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {DrawOnSignature<void>}
     */ this.un;
        /**
     * @type {boolean}
     * @private
     */ this.shouldHandle_ = false;
        /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */ this.downPx_ = null;
        /**
     * @type {ReturnType<typeof setTimeout>}
     * @private
     */ this.downTimeout_;
        /**
     * @type {number|undefined}
     * @private
     */ this.lastDragTime_;
        /**
     * Pointer type of the last pointermove event
     * @type {string}
     * @private
     */ this.pointerType_;
        /**
     * @type {boolean}
     * @private
     */ this.freehand_ = false;
        /**
     * Target source for drawn features.
     * @type {VectorSource|null}
     * @private
     */ this.source_ = options.source ? options.source : null;
        /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>|null}
     * @private
     */ this.features_ = options.features ? options.features : null;
        /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */ this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
        /**
     * Geometry type.
     * @type {import("../geom/Geometry.js").Type}
     * @private
     */ this.type_ = /** @type {import("../geom/Geometry.js").Type} */ options.type;
        /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */ this.mode_ = getMode(this.type_);
        /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */ this.stopClick_ = !!options.stopClick;
        /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */ this.minPoints_ = options.minPoints ? options.minPoints : this.mode_ === 'Polygon' ? 3 : 2;
        /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */ this.maxPoints_ = this.mode_ === 'Circle' ? 2 : options.maxPoints ? options.maxPoints : Infinity;
        /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.finishCondition_ = options.finishCondition ? options.finishCondition : (0, _functionsJs.TRUE);
        /**
     * @private
     * @type {import("../geom/Geometry.js").GeometryLayout}
     */ this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : 'XY';
        let geometryFunction = options.geometryFunction;
        if (!geometryFunction) {
            const mode = this.mode_;
            if (mode === 'Circle') /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */ geometryFunction = function(coordinates, geometry, projection) {
                const circle = geometry ? /** @type {Circle} */ geometry : new (0, _circleJsDefault.default)([
                    NaN,
                    NaN
                ]);
                const center = (0, _projJs.fromUserCoordinate)(coordinates[0], projection);
                const squaredLength = (0, _coordinateJs.squaredDistance)(center, (0, _projJs.fromUserCoordinate)(coordinates[coordinates.length - 1], projection));
                circle.setCenterAndRadius(center, Math.sqrt(squaredLength), this.geometryLayout_);
                const userProjection = (0, _projJs.getUserProjection)();
                if (userProjection) circle.transform(projection, userProjection);
                return circle;
            };
            else {
                let Constructor;
                if (mode === 'Point') Constructor = (0, _pointJsDefault.default);
                else if (mode === 'LineString') Constructor = (0, _lineStringJsDefault.default);
                else if (mode === 'Polygon') Constructor = (0, _polygonJsDefault.default);
                /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */ geometryFunction = function(coordinates, geometry, projection) {
                    if (geometry) {
                        if (mode === 'Polygon') {
                            if (coordinates[0].length) // Add a closing coordinate to match the first
                            geometry.setCoordinates([
                                coordinates[0].concat([
                                    coordinates[0][0]
                                ])
                            ], this.geometryLayout_);
                            else geometry.setCoordinates([], this.geometryLayout_);
                        } else geometry.setCoordinates(coordinates, this.geometryLayout_);
                    } else geometry = new Constructor(coordinates, this.geometryLayout_);
                    return geometry;
                };
            }
        }
        /**
     * @type {GeometryFunction}
     * @private
     */ this.geometryFunction_ = geometryFunction;
        /**
     * @type {number}
     * @private
     */ this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;
        /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */ this.finishCoordinate_ = null;
        /**
     * Sketch feature.
     * @type {Feature<import('../geom/SimpleGeometry.js').default>}
     * @private
     */ this.sketchFeature_ = null;
        /**
     * Sketch point.
     * @type {Feature<Point>}
     * @private
     */ this.sketchPoint_ = null;
        /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */ this.sketchCoords_ = null;
        /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature<LineString>}
     * @private
     */ this.sketchLine_ = null;
        /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */ this.sketchLineCoords_ = null;
        /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */ this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
        /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */ this.overlay_ = new (0, _vectorJsDefault.default)({
            source: new (0, _vectorJsDefault1.default)({
                useSpatialIndex: false,
                wrapX: options.wrapX ? options.wrapX : false
            }),
            style: options.style ? options.style : getDefaultStyleFunction(),
            updateWhileInteracting: true
        });
        /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */ this.geometryName_ = options.geometryName;
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : (0, _conditionJs.noModifierKeys);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.freehandCondition_;
        if (options.freehand) this.freehandCondition_ = (0, _conditionJs.always);
        else this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : (0, _conditionJs.shiftKeyOnly);
        /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */ this.traceCondition_;
        this.setTrace(options.trace || false);
        /**
     * @type {TraceState}
     * @private
     */ this.traceState_ = {
            active: false
        };
        /**
     * @type {VectorSource|null}
     * @private
     */ this.traceSource_ = options.traceSource || options.source || null;
        this.addChangeListener((0, _propertyJsDefault.default).ACTIVE, this.updateState_);
    }
    /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */ setTrace(trace) {
        let condition;
        if (!trace) condition = (0, _conditionJs.never);
        else if (trace === true) condition = (0, _conditionJs.always);
        else condition = trace;
        this.traceCondition_ = condition;
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */ setMap(map) {
        super.setMap(map);
        this.updateState_();
    }
    /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */ getOverlay() {
        return this.overlay_;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(event) {
        if (event.originalEvent.type === (0, _eventTypeJsDefault.default).CONTEXTMENU) // Avoid context menu for long taps when drawing on mobile
        event.originalEvent.preventDefault();
        this.freehand_ = this.mode_ !== 'Point' && this.freehandCondition_(event);
        let move = event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE;
        let pass = true;
        if (!this.freehand_ && this.lastDragTime_ && event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG) {
            const now = Date.now();
            if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
                this.downPx_ = event.pixel;
                this.shouldHandle_ = !this.freehand_;
                move = true;
            } else this.lastDragTime_ = undefined;
            if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = undefined;
            }
        }
        if (this.freehand_ && event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG && this.sketchFeature_ !== null) {
            this.addToDrawing_(event.coordinate);
            pass = false;
        } else if (this.freehand_ && event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERDOWN) pass = false;
        else if (move && this.getPointerCount() < 2) {
            pass = event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE;
            if (pass && this.freehand_) {
                this.handlePointerMove_(event);
                if (this.shouldHandle_) // Avoid page scrolling when freehand drawing on mobile
                event.originalEvent.preventDefault();
            } else if (event.originalEvent.pointerType === 'mouse' || event.type === (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG && this.downTimeout_ === undefined) this.handlePointerMove_(event);
        } else if (event.type === (0, _mapBrowserEventTypeJsDefault.default).DBLCLICK) pass = false;
        return super.handleEvent(event) && pass;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(event) {
        this.shouldHandle_ = !this.freehand_;
        if (this.freehand_) {
            this.downPx_ = event.pixel;
            if (!this.finishCoordinate_) this.startDrawing_(event.coordinate);
            return true;
        }
        if (!this.condition_(event)) {
            this.lastDragTime_ = undefined;
            return false;
        }
        this.lastDragTime_ = Date.now();
        this.downTimeout_ = setTimeout(()=>{
            this.handlePointerMove_(new (0, _mapBrowserEventJsDefault.default)((0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
        }, this.dragVertexDelay_);
        this.downPx_ = event.pixel;
        return true;
    }
    /**
   * @private
   */ deactivateTrace_() {
        this.traceState_ = {
            active: false
        };
    }
    /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */ toggleTraceState_(event) {
        if (!this.traceSource_ || !this.traceCondition_(event)) return;
        if (this.traceState_.active) {
            this.deactivateTrace_();
            return;
        }
        const map = this.getMap();
        const lowerLeft = map.getCoordinateFromPixel([
            event.pixel[0] - this.snapTolerance_,
            event.pixel[1] + this.snapTolerance_
        ]);
        const upperRight = map.getCoordinateFromPixel([
            event.pixel[0] + this.snapTolerance_,
            event.pixel[1] - this.snapTolerance_
        ]);
        const extent = (0, _extentJs.boundingExtent)([
            lowerLeft,
            upperRight
        ]);
        const features = this.traceSource_.getFeaturesInExtent(extent);
        if (features.length === 0) return;
        const targets = getTraceTargets(event.coordinate, features);
        if (targets.length) this.traceState_ = {
            active: true,
            startPx: event.pixel.slice(),
            targets: targets,
            targetIndex: -1
        };
    }
    /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */ addOrRemoveTracedCoordinates_(target, endIndex) {
        // three cases to handle:
        //  1. traced in the same direction and points need adding
        //  2. traced in the same direction and points need removing
        //  3. traced in a new direction
        const previouslyForward = target.startIndex <= target.endIndex;
        const currentlyForward = target.startIndex <= endIndex;
        if (previouslyForward === currentlyForward) {
            // same direction
            if (previouslyForward && endIndex > target.endIndex || !previouslyForward && endIndex < target.endIndex) // case 1 - add new points
            this.addTracedCoordinates_(target, target.endIndex, endIndex);
            else if (previouslyForward && endIndex < target.endIndex || !previouslyForward && endIndex > target.endIndex) // case 2 - remove old points
            this.removeTracedCoordinates_(endIndex, target.endIndex);
        } else {
            // case 3 - remove old points, add new points
            this.removeTracedCoordinates_(target.startIndex, target.endIndex);
            this.addTracedCoordinates_(target, target.startIndex, endIndex);
        }
    }
    /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */ removeTracedCoordinates_(fromIndex, toIndex) {
        if (fromIndex === toIndex) return;
        let remove = 0;
        if (fromIndex < toIndex) {
            const start = Math.ceil(fromIndex);
            let end = Math.floor(toIndex);
            if (end === toIndex) end -= 1;
            remove = end - start + 1;
        } else {
            const start = Math.floor(fromIndex);
            let end = Math.ceil(toIndex);
            if (end === toIndex) end += 1;
            remove = start - end + 1;
        }
        if (remove > 0) this.removeLastPoints_(remove);
    }
    /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */ addTracedCoordinates_(target, fromIndex, toIndex) {
        if (fromIndex === toIndex) return;
        const coordinates = [];
        if (fromIndex < toIndex) {
            // forward trace
            const start = Math.ceil(fromIndex);
            let end = Math.floor(toIndex);
            if (end === toIndex) // if end is snapped to a vertex, it will be added later
            end -= 1;
            for(let i = start; i <= end; ++i)coordinates.push(getCoordinate(target.coordinates, i));
        } else {
            // reverse trace
            const start = Math.floor(fromIndex);
            let end = Math.ceil(toIndex);
            if (end === toIndex) end += 1;
            for(let i = start; i >= end; --i)coordinates.push(getCoordinate(target.coordinates, i));
        }
        if (coordinates.length) this.appendCoordinates(coordinates);
    }
    /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */ updateTrace_(event) {
        const traceState = this.traceState_;
        if (!traceState.active) return;
        if (traceState.targetIndex === -1) {
            // check if we are ready to pick a target
            if ((0, _coordinateJs.distance)(traceState.startPx, event.pixel) < this.snapTolerance_) return;
        }
        const updatedTraceTarget = getTraceTargetUpdate(event.coordinate, traceState, this.getMap(), this.snapTolerance_);
        if (traceState.targetIndex !== updatedTraceTarget.index) {
            // target changed
            if (traceState.targetIndex !== -1) {
                // remove points added during previous trace
                const oldTarget = traceState.targets[traceState.targetIndex];
                this.removeTracedCoordinates_(oldTarget.startIndex, oldTarget.endIndex);
            }
            // add points for the new target
            const newTarget = traceState.targets[updatedTraceTarget.index];
            this.addTracedCoordinates_(newTarget, newTarget.startIndex, updatedTraceTarget.endIndex);
        } else {
            // target stayed the same
            const target = traceState.targets[traceState.targetIndex];
            this.addOrRemoveTracedCoordinates_(target, updatedTraceTarget.endIndex);
        }
        // modify the state with updated info
        traceState.targetIndex = updatedTraceTarget.index;
        const target = traceState.targets[traceState.targetIndex];
        target.endIndex = updatedTraceTarget.endIndex;
        // update event coordinate and pixel to match end point of final segment
        const coordinate = interpolateCoordinate(target.coordinates, target.endIndex);
        const pixel = this.getMap().getPixelFromCoordinate(coordinate);
        event.coordinate = coordinate;
        event.pixel = [
            Math.round(pixel[0]),
            Math.round(pixel[1])
        ];
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(event) {
        let pass = true;
        if (this.getPointerCount() === 0) {
            if (this.downTimeout_) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = undefined;
            }
            this.handlePointerMove_(event);
            const tracing = this.traceState_.active;
            this.toggleTraceState_(event);
            if (this.shouldHandle_) {
                const startingToDraw = !this.finishCoordinate_;
                if (startingToDraw) this.startDrawing_(event.coordinate);
                if (!startingToDraw && this.freehand_) this.finishDrawing();
                else if (!this.freehand_ && (!startingToDraw || this.mode_ === 'Point')) {
                    if (this.atFinish_(event.pixel, tracing)) {
                        if (this.finishCondition_(event)) this.finishDrawing();
                    } else this.addToDrawing_(event.coordinate);
                }
                pass = false;
            } else if (this.freehand_) this.abortDrawing();
        }
        if (!pass && this.stopClick_) event.preventDefault();
        return pass;
    }
    /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */ handlePointerMove_(event) {
        this.pointerType_ = event.originalEvent.pointerType;
        if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
            const downPx = this.downPx_;
            const clickPx = event.pixel;
            const dx = downPx[0] - clickPx[0];
            const dy = downPx[1] - clickPx[1];
            const squaredDistance = dx * dx + dy * dy;
            this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;
            if (!this.shouldHandle_) return;
        }
        if (!this.finishCoordinate_) {
            this.createOrUpdateSketchPoint_(event.coordinate.slice());
            return;
        }
        this.updateTrace_(event);
        this.modifyDrawing_(event.coordinate);
    }
    /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */ atFinish_(pixel, tracing) {
        let at = false;
        if (this.sketchFeature_) {
            let potentiallyDone = false;
            let potentiallyFinishCoordinates = [
                this.finishCoordinate_
            ];
            const mode = this.mode_;
            if (mode === 'Point') at = true;
            else if (mode === 'Circle') at = this.sketchCoords_.length === 2;
            else if (mode === 'LineString') potentiallyDone = !tracing && this.sketchCoords_.length > this.minPoints_;
            else if (mode === 'Polygon') {
                const sketchCoords = /** @type {PolyCoordType} */ this.sketchCoords_;
                potentiallyDone = sketchCoords[0].length > this.minPoints_;
                potentiallyFinishCoordinates = [
                    sketchCoords[0][0],
                    sketchCoords[0][sketchCoords[0].length - 2]
                ];
                if (tracing) potentiallyFinishCoordinates = [
                    sketchCoords[0][0]
                ];
                else potentiallyFinishCoordinates = [
                    sketchCoords[0][0],
                    sketchCoords[0][sketchCoords[0].length - 2]
                ];
            }
            if (potentiallyDone) {
                const map = this.getMap();
                for(let i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++){
                    const finishCoordinate = potentiallyFinishCoordinates[i];
                    const finishPixel = map.getPixelFromCoordinate(finishCoordinate);
                    const dx = pixel[0] - finishPixel[0];
                    const dy = pixel[1] - finishPixel[1];
                    const snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
                    at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
                    if (at) {
                        this.finishCoordinate_ = finishCoordinate;
                        break;
                    }
                }
            }
        }
        return at;
    }
    /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */ createOrUpdateSketchPoint_(coordinates) {
        if (!this.sketchPoint_) {
            this.sketchPoint_ = new (0, _featureJsDefault.default)(new (0, _pointJsDefault.default)(coordinates));
            this.updateSketchFeatures_();
        } else {
            const sketchPointGeom = this.sketchPoint_.getGeometry();
            sketchPointGeom.setCoordinates(coordinates);
        }
    }
    /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */ createOrUpdateCustomSketchLine_(geometry) {
        if (!this.sketchLine_) this.sketchLine_ = new (0, _featureJsDefault.default)();
        const ring = geometry.getLinearRing(0);
        let sketchLineGeom = this.sketchLine_.getGeometry();
        if (!sketchLineGeom) {
            sketchLineGeom = new (0, _lineStringJsDefault.default)(ring.getFlatCoordinates(), ring.getLayout());
            this.sketchLine_.setGeometry(sketchLineGeom);
        } else {
            sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
            sketchLineGeom.changed();
        }
    }
    /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */ startDrawing_(start) {
        const projection = this.getMap().getView().getProjection();
        const stride = (0, _simpleGeometryJs.getStrideForLayout)(this.geometryLayout_);
        while(start.length < stride)start.push(0);
        this.finishCoordinate_ = start;
        if (this.mode_ === 'Point') this.sketchCoords_ = start.slice();
        else if (this.mode_ === 'Polygon') {
            this.sketchCoords_ = [
                [
                    start.slice(),
                    start.slice()
                ]
            ];
            this.sketchLineCoords_ = this.sketchCoords_[0];
        } else this.sketchCoords_ = [
            start.slice(),
            start.slice()
        ];
        if (this.sketchLineCoords_) this.sketchLine_ = new (0, _featureJsDefault.default)(new (0, _lineStringJsDefault.default)(this.sketchLineCoords_));
        const geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);
        this.sketchFeature_ = new (0, _featureJsDefault.default)();
        if (this.geometryName_) this.sketchFeature_.setGeometryName(this.geometryName_);
        this.sketchFeature_.setGeometry(geometry);
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
    }
    /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */ modifyDrawing_(coordinate) {
        const map = this.getMap();
        const geometry = this.sketchFeature_.getGeometry();
        const projection = map.getView().getProjection();
        const stride = (0, _simpleGeometryJs.getStrideForLayout)(this.geometryLayout_);
        let coordinates, last;
        while(coordinate.length < stride)coordinate.push(0);
        if (this.mode_ === 'Point') last = this.sketchCoords_;
        else if (this.mode_ === 'Polygon') {
            coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
            last = coordinates[coordinates.length - 1];
            if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) // snap to finish
            coordinate = this.finishCoordinate_.slice();
        } else {
            coordinates = this.sketchCoords_;
            last = coordinates[coordinates.length - 1];
        }
        last[0] = coordinate[0];
        last[1] = coordinate[1];
        this.geometryFunction_(/** @type {!LineCoordType} */ this.sketchCoords_, geometry, projection);
        if (this.sketchPoint_) {
            const sketchPointGeom = this.sketchPoint_.getGeometry();
            sketchPointGeom.setCoordinates(coordinate);
        }
        if (geometry.getType() === 'Polygon' && this.mode_ !== 'Polygon') this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ geometry);
        else if (this.sketchLineCoords_) {
            const sketchLineGeom = this.sketchLine_.getGeometry();
            sketchLineGeom.setCoordinates(this.sketchLineCoords_);
        }
        this.updateSketchFeatures_();
    }
    /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */ addToDrawing_(coordinate) {
        const geometry = this.sketchFeature_.getGeometry();
        const projection = this.getMap().getView().getProjection();
        let done;
        let coordinates;
        const mode = this.mode_;
        if (mode === 'LineString' || mode === 'Circle') {
            this.finishCoordinate_ = coordinate.slice();
            coordinates = /** @type {LineCoordType} */ this.sketchCoords_;
            if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) coordinates.pop();
                else done = true;
            }
            coordinates.push(coordinate.slice());
            this.geometryFunction_(coordinates, geometry, projection);
        } else if (mode === 'Polygon') {
            coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
            if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) coordinates.pop();
                else done = true;
            }
            coordinates.push(coordinate.slice());
            if (done) this.finishCoordinate_ = coordinates[0];
            this.geometryFunction_(this.sketchCoords_, geometry, projection);
        }
        this.createOrUpdateSketchPoint_(coordinate.slice());
        this.updateSketchFeatures_();
        if (done) this.finishDrawing();
    }
    /**
   * @param {number} n The number of points to remove.
   */ removeLastPoints_(n) {
        if (!this.sketchFeature_) return;
        const geometry = this.sketchFeature_.getGeometry();
        const projection = this.getMap().getView().getProjection();
        const mode = this.mode_;
        for(let i = 0; i < n; ++i){
            let coordinates;
            if (mode === 'LineString' || mode === 'Circle') {
                coordinates = /** @type {LineCoordType} */ this.sketchCoords_;
                coordinates.splice(-2, 1);
                if (coordinates.length >= 2) {
                    this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
                    const finishCoordinate = this.finishCoordinate_.slice();
                    coordinates[coordinates.length - 1] = finishCoordinate;
                    this.createOrUpdateSketchPoint_(finishCoordinate);
                }
                this.geometryFunction_(coordinates, geometry, projection);
                if (geometry.getType() === 'Polygon' && this.sketchLine_) this.createOrUpdateCustomSketchLine_(/** @type {Polygon} */ geometry);
            } else if (mode === 'Polygon') {
                coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
                coordinates.splice(-2, 1);
                const sketchLineGeom = this.sketchLine_.getGeometry();
                if (coordinates.length >= 2) {
                    const finishCoordinate = coordinates[coordinates.length - 2].slice();
                    coordinates[coordinates.length - 1] = finishCoordinate;
                    this.createOrUpdateSketchPoint_(finishCoordinate);
                }
                sketchLineGeom.setCoordinates(coordinates);
                this.geometryFunction_(this.sketchCoords_, geometry, projection);
            }
            if (coordinates.length === 1) {
                this.abortDrawing();
                break;
            }
        }
        this.updateSketchFeatures_();
    }
    /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */ removeLastPoint() {
        this.removeLastPoints_(1);
    }
    /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */ finishDrawing() {
        const sketchFeature = this.abortDrawing_();
        if (!sketchFeature) return;
        let coordinates = this.sketchCoords_;
        const geometry = sketchFeature.getGeometry();
        const projection = this.getMap().getView().getProjection();
        if (this.mode_ === 'LineString') {
            // remove the redundant last point
            coordinates.pop();
            this.geometryFunction_(coordinates, geometry, projection);
        } else if (this.mode_ === 'Polygon') {
            // remove the redundant last point in ring
            /** @type {PolyCoordType} */ coordinates[0].pop();
            this.geometryFunction_(coordinates, geometry, projection);
            coordinates = geometry.getCoordinates();
        }
        // cast multi-part geometries
        if (this.type_ === 'MultiPoint') sketchFeature.setGeometry(new (0, _multiPointJsDefault.default)([
            /** @type {PointCoordType} */ coordinates
        ]));
        else if (this.type_ === 'MultiLineString') sketchFeature.setGeometry(new (0, _multiLineStringJsDefault.default)([
            /** @type {LineCoordType} */ coordinates
        ]));
        else if (this.type_ === 'MultiPolygon') sketchFeature.setGeometry(new (0, _multiPolygonJsDefault.default)([
            /** @type {PolyCoordType} */ coordinates
        ]));
        // First dispatch event to allow full set up of feature
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));
        // Then insert feature
        if (this.features_) this.features_.push(sketchFeature);
        if (this.source_) this.source_.addFeature(sketchFeature);
    }
    /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */ abortDrawing_() {
        this.finishCoordinate_ = null;
        const sketchFeature = this.sketchFeature_;
        this.sketchFeature_ = null;
        this.sketchPoint_ = null;
        this.sketchLine_ = null;
        this.overlay_.getSource().clear(true);
        this.deactivateTrace_();
        return sketchFeature;
    }
    /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */ abortDrawing() {
        const sketchFeature = this.abortDrawing_();
        if (sketchFeature) this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
    }
    /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */ appendCoordinates(coordinates) {
        const mode = this.mode_;
        const newDrawing = !this.sketchFeature_;
        if (newDrawing) this.startDrawing_(coordinates[0]);
        /** @type {LineCoordType} */ let sketchCoords;
        if (mode === 'LineString' || mode === 'Circle') sketchCoords = /** @type {LineCoordType} */ this.sketchCoords_;
        else if (mode === 'Polygon') sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? /** @type {PolyCoordType} */ this.sketchCoords_[0] : [];
        else return;
        if (newDrawing) sketchCoords.shift();
        // Remove last coordinate from sketch drawing (this coordinate follows cursor position)
        sketchCoords.pop();
        // Append coordinate list
        for(let i = 0; i < coordinates.length; i++)this.addToDrawing_(coordinates[i]);
        const ending = coordinates[coordinates.length - 1];
        // Duplicate last coordinate for sketch drawing (cursor position)
        this.addToDrawing_(ending);
        this.modifyDrawing_(ending);
    }
    /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */ extend(feature) {
        const geometry = feature.getGeometry();
        const lineString = geometry;
        this.sketchFeature_ = feature;
        this.sketchCoords_ = lineString.getCoordinates();
        const last = this.sketchCoords_[this.sketchCoords_.length - 1];
        this.finishCoordinate_ = last.slice();
        this.sketchCoords_.push(last.slice());
        this.sketchPoint_ = new (0, _featureJsDefault.default)(new (0, _pointJsDefault.default)(last));
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
    }
    /**
   * Redraw the sketch features.
   * @private
   */ updateSketchFeatures_() {
        const sketchFeatures = [];
        if (this.sketchFeature_) sketchFeatures.push(this.sketchFeature_);
        if (this.sketchLine_) sketchFeatures.push(this.sketchLine_);
        if (this.sketchPoint_) sketchFeatures.push(this.sketchPoint_);
        const overlaySource = this.overlay_.getSource();
        overlaySource.clear(true);
        overlaySource.addFeatures(sketchFeatures);
    }
    /**
   * @private
   */ updateState_() {
        const map = this.getMap();
        const active = this.getActive();
        if (!map || !active) this.abortDrawing();
        this.overlay_.setMap(active ? map : null);
    }
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    const styles = (0, _styleJs.createEditingStyle)();
    return function(feature, resolution) {
        return styles[feature.getGeometry().getType()];
    };
}
function createRegularPolygon(sides, angle) {
    return function(coordinates, geometry, projection) {
        const center = (0, _projJs.fromUserCoordinate)(/** @type {LineCoordType} */ coordinates[0], projection);
        const end = (0, _projJs.fromUserCoordinate)(/** @type {LineCoordType} */ coordinates[coordinates.length - 1], projection);
        const radius = Math.sqrt((0, _coordinateJs.squaredDistance)(center, end));
        geometry = geometry || (0, _polygonJs.fromCircle)(new (0, _circleJsDefault.default)(center), sides);
        let internalAngle = angle;
        if (!angle && angle !== 0) {
            const x = end[0] - center[0];
            const y = end[1] - center[1];
            internalAngle = Math.atan2(y, x);
        }
        (0, _polygonJs.makeRegular)(/** @type {Polygon} */ geometry, center, radius, internalAngle);
        const userProjection = (0, _projJs.getUserProjection)();
        if (userProjection) geometry.transform(projection, userProjection);
        return geometry;
    };
}
function createBox() {
    return function(coordinates, geometry, projection) {
        const extent = (0, _extentJs.boundingExtent)(/** @type {LineCoordType} */ [
            coordinates[0],
            coordinates[coordinates.length - 1]
        ].map(function(coordinate) {
            return (0, _projJs.fromUserCoordinate)(coordinate, projection);
        }));
        const boxCoordinates = [
            [
                (0, _extentJs.getBottomLeft)(extent),
                (0, _extentJs.getBottomRight)(extent),
                (0, _extentJs.getTopRight)(extent),
                (0, _extentJs.getTopLeft)(extent),
                (0, _extentJs.getBottomLeft)(extent)
            ]
        ];
        if (geometry) geometry.setCoordinates(boxCoordinates);
        else geometry = new (0, _polygonJsDefault.default)(boxCoordinates);
        const userProjection = (0, _projJs.getUserProjection)();
        if (userProjection) geometry.transform(projection, userProjection);
        return geometry;
    };
}
/**
 * Get the drawing mode.  The mode for multi-part geometries is the same as for
 * their single-part cousins.
 * @param {import("../geom/Geometry.js").Type} type Geometry type.
 * @return {Mode} Drawing mode.
 */ function getMode(type) {
    switch(type){
        case 'Point':
        case 'MultiPoint':
            return 'Point';
        case 'LineString':
        case 'MultiLineString':
            return 'LineString';
        case 'Polygon':
        case 'MultiPolygon':
            return 'Polygon';
        case 'Circle':
            return 'Circle';
        default:
            throw new Error('Invalid type: ' + type);
    }
}
exports.default = Draw;

},{"../geom/Circle.js":"7Crtc","../events/Event.js":"hwXQP","../events/EventType.js":"hrQJ6","../Feature.js":"liabO","../geom/GeometryCollection.js":"fDMaj","./Property.js":"lHt12","../geom/LineString.js":"jLUiq","../MapBrowserEvent.js":"32Can","../MapBrowserEventType.js":"fB9ae","../geom/MultiLineString.js":"030lt","../geom/MultiPoint.js":"k4LcJ","../geom/MultiPolygon.js":"2XIqx","../geom/Point.js":"hx2Ar","./Pointer.js":"1GIxf","../geom/Polygon.js":"cJuQF","../layer/Vector.js":"iTrAy","../source/Vector.js":"9w7Fr","../functions.js":"iqv8I","../events/condition.js":"iQTYY","../extent.js":"6YrVc","../math.js":"5jEFr","../style/Style.js":"fW7vC","../coordinate.js":"85Vu7","../proj.js":"SznqC","../geom/SimpleGeometry.js":"hLwk3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Crtc":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/Circle
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _transformJs = require("./flat/transform.js");
/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */ class Circle extends (0, _simpleGeometryJsDefault.default) {
    /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius in units of the projection.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */ constructor(center, radius, layout){
        super();
        if (layout !== undefined && radius === undefined) this.setFlatCoordinates(layout, center);
        else {
            radius = radius ? radius : 0;
            this.setCenterAndRadius(center, radius, layout);
        }
    }
    /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */ clone() {
        const circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);
        circle.applyProperties(this);
        return circle;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */ closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const dx = x - flatCoordinates[0];
        const dy = y - flatCoordinates[1];
        const squaredDistance = dx * dx + dy * dy;
        if (squaredDistance < minSquaredDistance) {
            if (squaredDistance === 0) for(let i = 0; i < this.stride; ++i)closestPoint[i] = flatCoordinates[i];
            else {
                const delta = this.getRadius() / Math.sqrt(squaredDistance);
                closestPoint[0] = flatCoordinates[0] + delta * dx;
                closestPoint[1] = flatCoordinates[1] + delta * dy;
                for(let i = 2; i < this.stride; ++i)closestPoint[i] = flatCoordinates[i];
            }
            closestPoint.length = this.stride;
            return squaredDistance;
        }
        return minSquaredDistance;
    }
    /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */ containsXY(x, y) {
        const flatCoordinates = this.flatCoordinates;
        const dx = x - flatCoordinates[0];
        const dy = y - flatCoordinates[1];
        return dx * dx + dy * dy <= this.getRadiusSquared_();
    }
    /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */ getCenter() {
        return this.flatCoordinates.slice(0, this.stride);
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */ computeExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const radius = flatCoordinates[this.stride] - flatCoordinates[0];
        return (0, _extentJs.createOrUpdate)(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
    }
    /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */ getRadius() {
        return Math.sqrt(this.getRadiusSquared_());
    }
    /**
   * @private
   * @return {number} Radius squared.
   */ getRadiusSquared_() {
        const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
        const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
        return dx * dx + dy * dy;
    }
    /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */ getType() {
        return 'Circle';
    }
    /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */ intersectsExtent(extent) {
        const circleExtent = this.getExtent();
        if ((0, _extentJs.intersects)(extent, circleExtent)) {
            const center = this.getCenter();
            if (extent[0] <= center[0] && extent[2] >= center[0]) return true;
            if (extent[1] <= center[1] && extent[3] >= center[1]) return true;
            return (0, _extentJs.forEachCorner)(extent, this.intersectsCoordinate.bind(this));
        }
        return false;
    }
    /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */ setCenter(center) {
        const stride = this.stride;
        const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
        const flatCoordinates = center.slice();
        flatCoordinates[stride] = flatCoordinates[0] + radius;
        for(let i = 1; i < stride; ++i)flatCoordinates[stride + i] = center[i];
        this.setFlatCoordinates(this.layout, flatCoordinates);
        this.changed();
    }
    /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */ setCenterAndRadius(center, radius, layout) {
        this.setLayout(layout, center, 0);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        /** @type {Array<number>} */ const flatCoordinates = this.flatCoordinates;
        let offset = (0, _deflateJs.deflateCoordinate)(flatCoordinates, 0, center, this.stride);
        flatCoordinates[offset++] = flatCoordinates[0] + radius;
        for(let i = 1, ii = this.stride; i < ii; ++i)flatCoordinates[offset++] = flatCoordinates[i];
        flatCoordinates.length = offset;
        this.changed();
    }
    getCoordinates() {
        return null;
    }
    setCoordinates(coordinates, layout) {}
    /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */ setRadius(radius) {
        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
        this.changed();
    }
    /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */ rotate(angle, anchor) {
        const center = this.getCenter();
        const stride = this.getStride();
        this.setCenter((0, _transformJs.rotate)(center, 0, center.length, stride, angle, anchor, center));
        this.changed();
    }
}
/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */ Circle.prototype.transform;
exports.default = Circle;

},{"./SimpleGeometry.js":"hLwk3","../extent.js":"6YrVc","./flat/deflate.js":"3TE5l","./flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lHt12":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Property
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    ACTIVE: 'active'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"32Can":[function(require,module,exports,__globalThis) {
/**
 * @module ol/MapBrowserEvent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapEventJs = require("./MapEvent.js");
var _mapEventJsDefault = parcelHelpers.interopDefault(_mapEventJs);
/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */ class MapBrowserEvent extends (0, _mapEventJsDefault.default) {
    /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */ constructor(type, map, originalEvent, dragging, frameState, activePointers){
        super(type, map, frameState);
        /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */ this.originalEvent = originalEvent;
        /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     */ this.pixel_ = null;
        /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     */ this.coordinate_ = null;
        /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */ this.dragging = dragging !== undefined ? dragging : false;
        /**
     * @type {Array<PointerEvent>|undefined}
     */ this.activePointers = activePointers;
    }
    /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */ get pixel() {
        if (!this.pixel_) this.pixel_ = this.map.getEventPixel(this.originalEvent);
        return this.pixel_;
    }
    set pixel(pixel) {
        this.pixel_ = pixel;
    }
    /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */ get coordinate() {
        if (!this.coordinate_) this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
        return this.coordinate_;
    }
    set coordinate(coordinate) {
        this.coordinate_ = coordinate;
    }
    /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */ preventDefault() {
        super.preventDefault();
        if ('preventDefault' in this.originalEvent) /** @type {UIEvent} */ this.originalEvent.preventDefault();
    }
    /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */ stopPropagation() {
        super.stopPropagation();
        if ('stopPropagation' in this.originalEvent) /** @type {UIEvent} */ this.originalEvent.stopPropagation();
    }
}
exports.default = MapBrowserEvent;

},{"./MapEvent.js":"1APU6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1APU6":[function(require,module,exports,__globalThis) {
/**
 * @module ol/MapEvent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/Map~Map} for which events trigger a map event.
 */ class MapEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */ constructor(type, map, frameState){
        super(type);
        /**
     * The map where the event occurred.
     * @type {import("./Map.js").default}
     * @api
     */ this.map = map;
        /**
     * The frame state at the time of the event.
     * @type {?import("./Map.js").FrameState}
     * @api
     */ this.frameState = frameState !== undefined ? frameState : null;
    }
}
exports.default = MapEvent;

},{"./events/Event.js":"hwXQP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fB9ae":[function(require,module,exports,__globalThis) {
/**
 * @module ol/MapBrowserEventType
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
/**
 * Constants for event names.
 * @enum {string}
 */ exports.default = {
    /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */ SINGLECLICK: 'singleclick',
    /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */ CLICK: (0, _eventTypeJsDefault.default).CLICK,
    /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */ DBLCLICK: (0, _eventTypeJsDefault.default).DBLCLICK,
    /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */ POINTERDRAG: 'pointerdrag',
    /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */ POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel'
}; /***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */ 

},{"./events/EventType.js":"hrQJ6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1GIxf":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Pointer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {{clientX: number, clientY: number}} Centroid pixel.
 */ parcelHelpers.export(exports, "centroid", ()=>centroid);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */ /**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */ class PointerInteraction extends (0, _interactionJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        super(/** @type {import("./Interaction.js").InteractionOptions} */ options);
        if (options.handleDownEvent) this.handleDownEvent = options.handleDownEvent;
        if (options.handleDragEvent) this.handleDragEvent = options.handleDragEvent;
        if (options.handleMoveEvent) this.handleMoveEvent = options.handleMoveEvent;
        if (options.handleUpEvent) this.handleUpEvent = options.handleUpEvent;
        if (options.stopDown) this.stopDown = options.stopDown;
        /**
     * @type {boolean}
     * @protected
     */ this.handlingDownUpSequence = false;
        /**
     * @type {Array<PointerEvent>}
     * @protected
     */ this.targetPointers = [];
    }
    /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */ getPointerCount() {
        return this.targetPointers.length;
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */ handleDownEvent(mapBrowserEvent) {
        return false;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */ handleDragEvent(mapBrowserEvent) {}
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) return true;
        let stopEvent = false;
        this.updateTrackedPointers_(mapBrowserEvent);
        if (this.handlingDownUpSequence) {
            if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG) {
                this.handleDragEvent(mapBrowserEvent);
                // prevent page scrolling during dragging
                mapBrowserEvent.originalEvent.preventDefault();
            } else if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERUP) {
                const handledUp = this.handleUpEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
            }
        } else {
            if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERDOWN) {
                const handled = this.handleDownEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handled;
                stopEvent = this.stopDown(handled);
            } else if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE) this.handleMoveEvent(mapBrowserEvent);
        }
        return !stopEvent;
    }
    /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */ handleMoveEvent(mapBrowserEvent) {}
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */ handleUpEvent(mapBrowserEvent) {
        return false;
    }
    /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */ stopDown(handled) {
        return handled;
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */ updateTrackedPointers_(mapBrowserEvent) {
        if (mapBrowserEvent.activePointers) this.targetPointers = mapBrowserEvent.activePointers;
    }
}
function centroid(pointerEvents) {
    const length = pointerEvents.length;
    let clientX = 0;
    let clientY = 0;
    for(let i = 0; i < length; i++){
        clientX += pointerEvents[i].clientX;
        clientY += pointerEvents[i].clientY;
    }
    return {
        clientX: clientX / length,
        clientY: clientY / length
    };
}
exports.default = PointerInteraction;

},{"./Interaction.js":"g1FUs","../MapBrowserEventType.js":"fB9ae","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g1FUs":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Interaction
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number} [duration] Duration.
 */ parcelHelpers.export(exports, "pan", ()=>pan);
/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate} [anchor] Anchor coordinate in the user projection.
 * @param {number} [duration] Duration.
 */ parcelHelpers.export(exports, "zoomByDelta", ()=>zoomByDelta);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _easingJs = require("../easing.js");
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */ /**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */ class Interaction extends (0, _objectJsDefault.default) {
    /**
   * @param {InteractionOptions} [options] Options.
   */ constructor(options){
        super();
        /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {InteractionOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {InteractionOnSignature<void>}
     */ this.un;
        if (options && options.handleEvent) this.handleEvent = options.handleEvent;
        /**
     * @private
     * @type {import("../Map.js").default|null}
     */ this.map_ = null;
        this.setActive(true);
    }
    /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */ getActive() {
        return /** @type {boolean} */ this.get((0, _propertyJsDefault.default).ACTIVE);
    }
    /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */ getMap() {
        return this.map_;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(mapBrowserEvent) {
        return true;
    }
    /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */ setActive(active) {
        this.set((0, _propertyJsDefault.default).ACTIVE, active);
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */ setMap(map) {
        this.map_ = map;
    }
}
function pan(view, delta, duration) {
    const currentCenter = view.getCenterInternal();
    if (currentCenter) {
        const center = [
            currentCenter[0] + delta[0],
            currentCenter[1] + delta[1]
        ];
        view.animateInternal({
            duration: duration !== undefined ? duration : 250,
            easing: (0, _easingJs.linear),
            center: view.getConstrainedCenter(center)
        });
    }
}
function zoomByDelta(view, delta, anchor, duration) {
    const currentZoom = view.getZoom();
    if (currentZoom === undefined) return;
    const newZoom = view.getConstrainedZoom(currentZoom + delta);
    const newResolution = view.getResolutionForZoom(newZoom);
    if (view.getAnimating()) view.cancelAnimations();
    view.animate({
        resolution: newResolution,
        anchor: anchor,
        duration: duration !== undefined ? duration : 250,
        easing: (0, _easingJs.easeOut)
    });
}
exports.default = Interaction;

},{"../Object.js":"1zG8z","./Property.js":"lHt12","../easing.js":"fYITA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fYITA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/easing
 */ /**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "easeIn", ()=>easeIn);
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "easeOut", ()=>easeOut);
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "inAndOut", ()=>inAndOut);
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "linear", ()=>linear);
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "upAndDown", ()=>upAndDown);
function easeIn(t) {
    return Math.pow(t, 3);
}
function easeOut(t) {
    return 1 - easeIn(1 - t);
}
function inAndOut(t) {
    return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
    return t;
}
function upAndDown(t) {
    if (t < 0.5) return inAndOut(2 * t);
    return 1 - inAndOut(2 * (t - 0.5));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iTrAy":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/Vector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseVectorJs = require("./BaseVector.js");
var _baseVectorJsDefault = parcelHelpers.interopDefault(_baseVectorJs);
var _vectorLayerJs = require("../renderer/canvas/VectorLayer.js");
var _vectorLayerJsDefault = parcelHelpers.interopDefault(_vectorLayerJs);
/**
 * @classdesc
 * Vector data is rendered client-side, as vectors. This layer type provides most accurate rendering
 * even during animations. Points and labels stay upright on rotated views. For very large
 * amounts of vector data, performance may suffer during pan and zoom animations. In this case,
 * try {@link module:ol/layer/VectorImage~VectorImageLayer}.
 *
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType, CanvasVectorLayerRenderer>}
 * @api
 */ class VectorLayer extends (0, _baseVectorJsDefault.default) {
    /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */ constructor(options){
        super(options);
    }
    createRenderer() {
        return new (0, _vectorLayerJsDefault.default)(this);
    }
}
exports.default = VectorLayer;

},{"./BaseVector.js":"2tWeN","../renderer/canvas/VectorLayer.js":"kTTmt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2tWeN":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/BaseVector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _rbush = require("rbush");
var _rbushDefault = parcelHelpers.interopDefault(_rbush);
var _styleJs = require("../style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _styleJs1 = require("../render/canvas/style.js");
/**
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style
 * which will be used if this is not set.
 * @property {import("./Base.js").BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @enum {string}
 * @private
 */ const Property = {
    RENDER_ORDER: 'renderOrder'
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @template {import("../renderer/canvas/VectorLayer.js").default|import("../renderer/canvas/VectorTileLayer.js").default|import("../renderer/canvas/VectorImageLayer.js").default|import("../renderer/webgl/PointsLayer.js").default} RendererType
 * @extends {Layer<VectorSourceType, RendererType>}
 * @api
 */ class BaseVectorLayer extends (0, _layerJsDefault.default) {
    /**
   * @param {Options<VectorSourceType>} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        super(baseOptions);
        /**
     * @private
     * @type {boolean}
     */ this.declutter_ = options.declutter !== undefined ? options.declutter : false;
        /**
     * @type {number}
     * @private
     */ this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
        /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike}
     * @private
     */ this.style_ = null;
        /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */ this.styleFunction_ = undefined;
        this.setStyle(options.style);
        /**
     * @type {boolean}
     * @private
     */ this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
        /**
     * @type {boolean}
     * @private
     */ this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
    }
    /**
   * @return {boolean} Declutter.
   */ getDeclutter() {
        return this.declutter_;
    }
    /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */ getFeatures(pixel) {
        return super.getFeatures(pixel);
    }
    /**
   * @return {number|undefined} Render buffer.
   */ getRenderBuffer() {
        return this.renderBuffer_;
    }
    /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */ getRenderOrder() {
        return /** @type {import("../render.js").OrderFunction|null|undefined} */ this.get(Property.RENDER_ORDER);
    }
    /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */ getStyle() {
        return this.style_;
    }
    /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */ getStyleFunction() {
        return this.styleFunction_;
    }
    /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */ getUpdateWhileAnimating() {
        return this.updateWhileAnimating_;
    }
    /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */ getUpdateWhileInteracting() {
        return this.updateWhileInteracting_;
    }
    /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */ renderDeclutter(frameState) {
        if (!frameState.declutterTree) frameState.declutterTree = new (0, _rbushDefault.default)(9);
        /** @type {*} */ this.getRenderer().renderDeclutter(frameState);
    }
    /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */ setRenderOrder(renderOrder) {
        this.set(Property.RENDER_ORDER, renderOrder);
    }
    /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */ setStyle(style) {
        this.style_ = toStyleLike(style);
        this.styleFunction_ = style === null ? undefined : (0, _styleJs.toFunction)(this.style_);
        this.changed();
    }
}
/**
 * Coerce the allowed style types into a shorter list of types.  Flat styles, arrays of flat
 * styles, and arrays of rules are converted into style functions.
 *
 * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
 * @return {import("../style/Style.js").StyleLike|null} The style.
 */ function toStyleLike(style) {
    if (style === undefined) return 0, _styleJs.createDefaultStyle;
    if (!style) return null;
    if (typeof style === 'function') return style;
    if (style instanceof (0, _styleJsDefault.default)) return style;
    if (!Array.isArray(style)) return (0, _styleJs1.flatStylesToStyleFunction)([
        style
    ]);
    if (style.length === 0) return [];
    const length = style.length;
    const first = style[0];
    if (first instanceof (0, _styleJsDefault.default)) {
        /**
     * @type {Array<Style>}
     */ const styles = new Array(length);
        for(let i = 0; i < length; ++i){
            const candidate = style[i];
            if (!(candidate instanceof (0, _styleJsDefault.default))) throw new Error('Expected a list of style instances');
            styles[i] = candidate;
        }
        return styles;
    }
    if ('style' in first) {
        /**
     * @type Array<import("../style/flat.js").Rule>
     */ const rules = new Array(length);
        for(let i = 0; i < length; ++i){
            const candidate = style[i];
            if (!('style' in candidate)) throw new Error('Expected a list of rules with a style property');
            rules[i] = candidate;
        }
        return (0, _styleJs1.rulesToStyleFunction)(rules);
    }
    const flatStyles = /** @type {Array<import("../style/flat.js").FlatStyle>} */ style;
    return (0, _styleJs1.flatStylesToStyleFunction)(flatStyles);
}
exports.default = BaseVectorLayer;

},{"./Layer.js":"8J9Kf","rbush":"k2VZu","../style/Style.js":"fW7vC","../render/canvas/style.js":"grY67","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8J9Kf":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/Layer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */ parcelHelpers.export(exports, "inView", ()=>inView);
var _baseJs = require("./Base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _eventTypeJs1 = require("../render/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _viewJs = require("../View.js");
var _viewJsDefault = parcelHelpers.interopDefault(_viewJs);
var _assertsJs = require("../asserts.js");
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
/**
 * @typedef {function(import("../Map.js").FrameState):HTMLElement} RenderFunction
 */ /**
 * @typedef {'sourceready'|'change:source'} LayerEventType
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     LayerEventType, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|LayerEventType|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */ /**
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../Map.js").default|null} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number | undefined} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */ /**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with [map.addLayer()]{@link import("../Map.js").default#addLayer}.
 * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 * A `sourceready` event is fired when the layer's source is ready.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 * @fires import("../events/Event.js").BaseEvent#sourceready
 *
 * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
 * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
 * @api
 */ class Layer extends (0, _baseJsDefault.default) {
    /**
   * @param {Options<SourceType>} options Layer options.
   */ constructor(options){
        const baseOptions = Object.assign({}, options);
        delete baseOptions.source;
        super(baseOptions);
        /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {LayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {LayerOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.mapPrecomposeKey_ = null;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.mapRenderKey_ = null;
        /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */ this.sourceChangeKey_ = null;
        /**
     * @private
     * @type {RendererType}
     */ this.renderer_ = null;
        /**
     * @private
     * @type {boolean}
     */ this.sourceReady_ = false;
        /**
     * @protected
     * @type {boolean}
     */ this.rendered = false;
        // Overwrite default render method with a custom one
        if (options.render) this.render = options.render;
        if (options.map) this.setMap(options.map);
        this.addChangeListener((0, _propertyJsDefault.default).SOURCE, this.handleSourcePropertyChange_);
        const source = options.source ? /** @type {SourceType} */ options.source : null;
        this.setSource(source);
    }
    /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */ getLayersArray(array) {
        array = array ? array : [];
        array.push(this);
        return array;
    }
    /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */ getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
    }
    /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */ getSource() {
        return /** @type {SourceType} */ this.get((0, _propertyJsDefault.default).SOURCE) || null;
    }
    /**
   * @return {SourceType|null} The source being rendered.
   */ getRenderSource() {
        return this.getSource();
    }
    /**
   * @return {import("../source/Source.js").State} Source state.
   */ getSourceState() {
        const source = this.getSource();
        return !source ? 'undefined' : source.getState();
    }
    /**
   * @private
   */ handleSourceChange_() {
        this.changed();
        if (this.sourceReady_ || this.getSource().getState() !== 'ready') return;
        this.sourceReady_ = true;
        this.dispatchEvent('sourceready');
    }
    /**
   * @private
   */ handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
            (0, _eventsJs.unlistenByKey)(this.sourceChangeKey_);
            this.sourceChangeKey_ = null;
        }
        this.sourceReady_ = false;
        const source = this.getSource();
        if (source) {
            this.sourceChangeKey_ = (0, _eventsJs.listen)(source, (0, _eventTypeJsDefault.default).CHANGE, this.handleSourceChange_, this);
            if (source.getState() === 'ready') {
                this.sourceReady_ = true;
                setTimeout(()=>{
                    this.dispatchEvent('sourceready');
                }, 0);
            }
        }
        this.changed();
    }
    /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */ getFeatures(pixel) {
        if (!this.renderer_) return Promise.resolve([]);
        return this.renderer_.getFeatures(pixel);
    }
    /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */ getData(pixel) {
        if (!this.renderer_ || !this.rendered) return null;
        return this.renderer_.getData(pixel);
    }
    /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */ isVisible(view) {
        let frameState;
        const map = this.getMapInternal();
        if (!view && map) view = map.getView();
        if (view instanceof (0, _viewJsDefault.default)) frameState = {
            viewState: view.getState(),
            extent: view.calculateExtent()
        };
        else frameState = view;
        if (!frameState.layerStatesArray && map) frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
        let layerState;
        if (frameState.layerStatesArray) layerState = frameState.layerStatesArray.find((layerState)=>layerState.layer === this);
        else layerState = this.getLayerState();
        const layerExtent = this.getExtent();
        return inView(layerState, frameState.viewState) && (!layerExtent || (0, _extentJs.intersects)(layerExtent, frameState.extent));
    }
    /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */ getAttributions(view) {
        if (!this.isVisible(view)) return [];
        let getAttributions;
        const source = this.getSource();
        if (source) getAttributions = source.getAttributions();
        if (!getAttributions) return [];
        const frameState = view instanceof (0, _viewJsDefault.default) ? view.getViewStateAndExtent() : view;
        let attributions = getAttributions(frameState);
        if (!Array.isArray(attributions)) attributions = [
            attributions
        ];
        return attributions;
    }
    /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */ render(frameState, target) {
        const layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
            this.rendered = true;
            return layerRenderer.renderFrame(frameState, target);
        }
        return null;
    }
    /**
   * Called when a layer is not visible during a map render.
   */ unrender() {
        this.rendered = false;
    }
    /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */ setMapInternal(map) {
        if (!map) this.unrender();
        this.set((0, _propertyJsDefault.default).MAP, map);
    }
    /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */ getMapInternal() {
        return this.get((0, _propertyJsDefault.default).MAP);
    }
    /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */ setMap(map) {
        if (this.mapPrecomposeKey_) {
            (0, _eventsJs.unlistenByKey)(this.mapPrecomposeKey_);
            this.mapPrecomposeKey_ = null;
        }
        if (!map) this.changed();
        if (this.mapRenderKey_) {
            (0, _eventsJs.unlistenByKey)(this.mapRenderKey_);
            this.mapRenderKey_ = null;
        }
        if (map) {
            this.mapPrecomposeKey_ = (0, _eventsJs.listen)(map, (0, _eventTypeJsDefault1.default).PRECOMPOSE, function(evt) {
                const renderEvent = /** @type {import("../render/Event.js").default} */ evt;
                const layerStatesArray = renderEvent.frameState.layerStatesArray;
                const layerState = this.getLayerState(false);
                (0, _assertsJs.assert)(!layerStatesArray.some(function(arrayLayerState) {
                    return arrayLayerState.layer === layerState.layer;
                }), 'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.');
                layerStatesArray.push(layerState);
            }, this);
            this.mapRenderKey_ = (0, _eventsJs.listen)(this, (0, _eventTypeJsDefault.default).CHANGE, map.render, map);
            this.changed();
        }
    }
    /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */ setSource(source) {
        this.set((0, _propertyJsDefault.default).SOURCE, source);
    }
    /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */ getRenderer() {
        if (!this.renderer_) this.renderer_ = this.createRenderer();
        return this.renderer_;
    }
    /**
   * @return {boolean} The layer has a renderer.
   */ hasRenderer() {
        return !!this.renderer_;
    }
    /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */ createRenderer() {
        return null;
    }
    /**
   * Clean up.
   */ disposeInternal() {
        if (this.renderer_) {
            this.renderer_.dispose();
            delete this.renderer_;
        }
        this.setSource(null);
        super.disposeInternal();
    }
}
function inView(layerState, viewState) {
    if (!layerState.visible) return false;
    const resolution = viewState.resolution;
    if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) return false;
    const zoom = viewState.zoom;
    return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
exports.default = Layer;

},{"./Base.js":"ag0tc","../events/EventType.js":"hrQJ6","./Property.js":"kCuCK","../render/EventType.js":"5G9JA","../View.js":"8xbkS","../asserts.js":"e4TiF","../extent.js":"6YrVc","../events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ag0tc":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/Base
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _utilJs = require("../util.js");
var _assertsJs = require("../asserts.js");
var _mathJs = require("../math.js");
/**
 * A css color, or a function called with a view resolution returning a css color.
 *
 * @typedef {string|function(number):string} BackgroundColor
 * @api
 */ /**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number | undefined} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
 * will be rendered.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */ class BaseLayer extends (0, _objectJsDefault.default) {
    /**
   * @param {Options} options Layer options.
   */ constructor(options){
        super();
        /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {BaseLayerOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {BaseLayerOnSignature<void>}
     */ this.un;
        /**
     * @type {BackgroundColor|false}
     * @private
     */ this.background_ = options.background;
        /**
     * @type {Object<string, *>}
     */ const properties = Object.assign({}, options);
        if (typeof options.properties === 'object') {
            delete properties.properties;
            Object.assign(properties, options.properties);
        }
        properties[(0, _propertyJsDefault.default).OPACITY] = options.opacity !== undefined ? options.opacity : 1;
        (0, _assertsJs.assert)(typeof properties[(0, _propertyJsDefault.default).OPACITY] === 'number', 'Layer opacity must be a number');
        properties[(0, _propertyJsDefault.default).VISIBLE] = options.visible !== undefined ? options.visible : true;
        properties[(0, _propertyJsDefault.default).Z_INDEX] = options.zIndex;
        properties[(0, _propertyJsDefault.default).MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
        properties[(0, _propertyJsDefault.default).MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
        properties[(0, _propertyJsDefault.default).MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
        properties[(0, _propertyJsDefault.default).MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;
        /**
     * @type {string}
     * @private
     */ this.className_ = properties.className !== undefined ? properties.className : 'ol-layer';
        delete properties.className;
        this.setProperties(properties);
        /**
     * @type {import("./Layer.js").State}
     * @private
     */ this.state_ = null;
    }
    /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */ getBackground() {
        return this.background_;
    }
    /**
   * @return {string} CSS class name.
   */ getClassName() {
        return this.className_;
    }
    /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */ getLayerState(managed) {
        /** @type {import("./Layer.js").State} */ const state = this.state_ || /** @type {?} */ {
            layer: this,
            managed: managed === undefined ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = (0, _mathJs.clamp)(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
    }
    /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */ getLayersArray(array) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */ getLayerStatesArray(states) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */ getExtent() {
        return /** @type {import("../extent.js").Extent|undefined} */ this.get((0, _propertyJsDefault.default).EXTENT);
    }
    /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */ getMaxResolution() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MAX_RESOLUTION);
    }
    /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */ getMinResolution() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MIN_RESOLUTION);
    }
    /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */ getMinZoom() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MIN_ZOOM);
    }
    /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */ getMaxZoom() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).MAX_ZOOM);
    }
    /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */ getOpacity() {
        return /** @type {number} */ this.get((0, _propertyJsDefault.default).OPACITY);
    }
    /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */ getSourceState() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */ getVisible() {
        return /** @type {boolean} */ this.get((0, _propertyJsDefault.default).VISIBLE);
    }
    /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */ getZIndex() {
        return /** @type {number|undefined} */ this.get((0, _propertyJsDefault.default).Z_INDEX);
    }
    /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */ setBackground(background) {
        this.background_ = background;
        this.changed();
    }
    /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */ setExtent(extent) {
        this.set((0, _propertyJsDefault.default).EXTENT, extent);
    }
    /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */ setMaxResolution(maxResolution) {
        this.set((0, _propertyJsDefault.default).MAX_RESOLUTION, maxResolution);
    }
    /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */ setMinResolution(minResolution) {
        this.set((0, _propertyJsDefault.default).MIN_RESOLUTION, minResolution);
    }
    /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */ setMaxZoom(maxZoom) {
        this.set((0, _propertyJsDefault.default).MAX_ZOOM, maxZoom);
    }
    /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */ setMinZoom(minZoom) {
        this.set((0, _propertyJsDefault.default).MIN_ZOOM, minZoom);
    }
    /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */ setOpacity(opacity) {
        (0, _assertsJs.assert)(typeof opacity === 'number', 'Layer opacity must be a number');
        this.set((0, _propertyJsDefault.default).OPACITY, opacity);
    }
    /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */ setVisible(visible) {
        this.set((0, _propertyJsDefault.default).VISIBLE, visible);
    }
    /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */ setZIndex(zindex) {
        this.set((0, _propertyJsDefault.default).Z_INDEX, zindex);
    }
    /**
   * Clean up.
   */ disposeInternal() {
        if (this.state_) {
            this.state_.layer = null;
            this.state_ = null;
        }
        super.disposeInternal();
    }
}
exports.default = BaseLayer;

},{"../Object.js":"1zG8z","./Property.js":"kCuCK","../util.js":"pLBjQ","../asserts.js":"e4TiF","../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kCuCK":[function(require,module,exports,__globalThis) {
/**
 * @module ol/layer/Property
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    OPACITY: 'opacity',
    VISIBLE: 'visible',
    EXTENT: 'extent',
    Z_INDEX: 'zIndex',
    MAX_RESOLUTION: 'maxResolution',
    MIN_RESOLUTION: 'minResolution',
    MAX_ZOOM: 'maxZoom',
    MIN_ZOOM: 'minZoom',
    SOURCE: 'source',
    MAP: 'map'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5G9JA":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/EventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */ PRERENDER: 'prerender',
    /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */ POSTRENDER: 'postrender',
    /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */ PRECOMPOSE: 'precompose',
    /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */ POSTCOMPOSE: 'postcompose',
    /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */ RENDERCOMPLETE: 'rendercomplete'
}; /**
 * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
 */  /**
 * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8xbkS":[function(require,module,exports,__globalThis) {
/**
 * @module ol/View
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */ parcelHelpers.export(exports, "createCenterConstraint", ()=>createCenterConstraint);
/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */ parcelHelpers.export(exports, "createResolutionConstraint", ()=>createResolutionConstraint);
/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createRotationConstraint", ()=>createRotationConstraint);
/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */ parcelHelpers.export(exports, "isNoopAnimation", ()=>isNoopAnimation);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _viewHintJs = require("./ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _viewPropertyJs = require("./ViewProperty.js");
var _viewPropertyJsDefault = parcelHelpers.interopDefault(_viewPropertyJs);
var _commonJs = require("./tilegrid/common.js");
var _projJs = require("./proj.js");
var _functionsJs = require("./functions.js");
var _coordinateJs = require("./coordinate.js");
var _assertsJs = require("./asserts.js");
var _centerconstraintJs = require("./centerconstraint.js");
var _mathJs = require("./math.js");
var _resolutionconstraintJs = require("./resolutionconstraint.js");
var _rotationconstraintJs = require("./rotationconstraint.js");
var _easingJs = require("./easing.js");
var _extentJs = require("./extent.js");
var _arrayJs = require("./array.js");
var _polygonJs = require("./geom/Polygon.js");
/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */ /**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */ /**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to
 * fit the extent into. Defaults to the size of the map the view is associated with.
 * If no map or multiple maps are connected to the view, provide the desired box size
 * (e.g. `map.getSize()`).
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */ /**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */ /**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */ /**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center (in view projection coordinates).
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */ /**
 * Like {@link import("./Map.js").FrameState}, but just `viewState` and `extent`.
 * @typedef {Object} ViewStateLayerStateExtent
 * @property {State} viewState View state.
 * @property {import("./extent.js").Extent} extent Extent (in user projection coordinates).
 * @property {Array<import("./layer/Layer.js").State>} [layerStatesArray] Layer states.
 */ /**
 * Default min zoom level for the map view.
 * @type {number}
 */ const DEFAULT_MIN_ZOOM = 0;
/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */ /**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Web Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */ class View extends (0, _objectJsDefault.default) {
    /**
   * @param {ViewOptions} [options] View options.
   */ constructor(options){
        super();
        /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {ViewOnSignature<import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {ViewOnSignature<void>}
     */ this.un;
        options = Object.assign({}, options);
        /**
     * @private
     * @type {Array<number>}
     */ this.hints_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {Array<Array<Animation>>}
     */ this.animations_ = [];
        /**
     * @private
     * @type {number|undefined}
     */ this.updateAnimationKey_;
        /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */ this.projection_ = (0, _projJs.createProjection)(options.projection, 'EPSG:3857');
        /**
     * @private
     * @type {import("./size.js").Size}
     */ this.viewportSize_ = [
            100,
            100
        ];
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */ this.targetCenter_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.targetResolution_;
        /**
     * @private
     * @type {number|undefined}
     */ this.targetRotation_;
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate}
     */ this.nextCenter_ = null;
        /**
     * @private
     * @type {number}
     */ this.nextResolution_;
        /**
     * @private
     * @type {number}
     */ this.nextRotation_;
        /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */ this.cancelAnchor_ = undefined;
        if (options.projection) (0, _projJs.disableCoordinateWarning)();
        if (options.center) options.center = (0, _projJs.fromUserCoordinate)(options.center, this.projection_);
        if (options.extent) options.extent = (0, _projJs.fromUserExtent)(options.extent, this.projection_);
        this.applyOptions_(options);
    }
    /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */ applyOptions_(options) {
        const properties = Object.assign({}, options);
        for(const key in 0, _viewPropertyJsDefault.default)delete properties[key];
        this.setProperties(properties, true);
        const resolutionConstraintInfo = createResolutionConstraint(options);
        /**
     * @private
     * @type {number}
     */ this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        /**
     * @private
     * @type {number}
     */ this.minResolution_ = resolutionConstraintInfo.minResolution;
        /**
     * @private
     * @type {number}
     */ this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        /**
     * @private
     * @type {Array<number>|undefined}
     */ this.resolutions_ = options.resolutions;
        /**
     * @type {Array<number>|undefined}
     * @private
     */ this.padding_ = options.padding;
        /**
     * @private
     * @type {number}
     */ this.minZoom_ = resolutionConstraintInfo.minZoom;
        const centerConstraint = createCenterConstraint(options);
        const resolutionConstraint = resolutionConstraintInfo.constraint;
        const rotationConstraint = createRotationConstraint(options);
        /**
     * @private
     * @type {Constraints}
     */ this.constraints_ = {
            center: centerConstraint,
            resolution: resolutionConstraint,
            rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== undefined ? options.rotation : 0);
        this.setCenterInternal(options.center !== undefined ? options.center : null);
        if (options.resolution !== undefined) this.setResolution(options.resolution);
        else if (options.zoom !== undefined) this.setZoom(options.zoom);
    }
    /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */ get padding() {
        return this.padding_;
    }
    set padding(padding) {
        let oldPadding = this.padding_;
        this.padding_ = padding;
        const center = this.getCenterInternal();
        if (center) {
            const newPadding = padding || [
                0,
                0,
                0,
                0
            ];
            oldPadding = oldPadding || [
                0,
                0,
                0,
                0
            ];
            const resolution = this.getResolution();
            const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
            const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
            this.setCenterInternal([
                center[0] + offsetX,
                center[1] - offsetY
            ]);
        }
    }
    /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */ getUpdatedOptions_(newOptions) {
        const options = this.getProperties();
        // preserve resolution (or zoom)
        if (options.resolution !== undefined) options.resolution = this.getResolution();
        else options.zoom = this.getZoom();
        // preserve center
        options.center = this.getCenterInternal();
        // preserve rotation
        options.rotation = this.getRotation();
        return Object.assign({}, options, newOptions);
    }
    /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */ animate(var_args) {
        if (this.isDef() && !this.getAnimating()) this.resolveConstraints(0);
        const args = new Array(arguments.length);
        for(let i = 0; i < args.length; ++i){
            let options = arguments[i];
            if (options.center) {
                options = Object.assign({}, options);
                options.center = (0, _projJs.fromUserCoordinate)(options.center, this.getProjection());
            }
            if (options.anchor) {
                options = Object.assign({}, options);
                options.anchor = (0, _projJs.fromUserCoordinate)(options.anchor, this.getProjection());
            }
            args[i] = options;
        }
        this.animateInternal.apply(this, args);
    }
    /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */ animateInternal(var_args) {
        let animationCount = arguments.length;
        let callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
            callback = arguments[animationCount - 1];
            --animationCount;
        }
        let i = 0;
        for(; i < animationCount && !this.isDef(); ++i){
            // if view properties are not yet set, shortcut to the final state
            const state = arguments[i];
            if (state.center) this.setCenterInternal(state.center);
            if (state.zoom !== undefined) this.setZoom(state.zoom);
            else if (state.resolution) this.setResolution(state.resolution);
            if (state.rotation !== undefined) this.setRotation(state.rotation);
        }
        if (i === animationCount) {
            if (callback) animationCallback(callback, true);
            return;
        }
        let start = Date.now();
        let center = this.targetCenter_.slice();
        let resolution = this.targetResolution_;
        let rotation = this.targetRotation_;
        const series = [];
        for(; i < animationCount; ++i){
            const options = /** @type {AnimationOptions} */ arguments[i];
            const animation = {
                start: start,
                complete: false,
                anchor: options.anchor,
                duration: options.duration !== undefined ? options.duration : 1000,
                easing: options.easing || (0, _easingJs.inAndOut),
                callback: callback
            };
            if (options.center) {
                animation.sourceCenter = center;
                animation.targetCenter = options.center.slice();
                center = animation.targetCenter;
            }
            if (options.zoom !== undefined) {
                animation.sourceResolution = resolution;
                animation.targetResolution = this.getResolutionForZoom(options.zoom);
                resolution = animation.targetResolution;
            } else if (options.resolution) {
                animation.sourceResolution = resolution;
                animation.targetResolution = options.resolution;
                resolution = animation.targetResolution;
            }
            if (options.rotation !== undefined) {
                animation.sourceRotation = rotation;
                const delta = (0, _mathJs.modulo)(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                animation.targetRotation = rotation + delta;
                rotation = animation.targetRotation;
            }
            // check if animation is a no-op
            if (isNoopAnimation(animation)) animation.complete = true;
            else start += animation.duration;
            series.push(animation);
        }
        this.animations_.push(series);
        this.setHint((0, _viewHintJsDefault.default).ANIMATING, 1);
        this.updateAnimations_();
    }
    /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */ getAnimating() {
        return this.hints_[(0, _viewHintJsDefault.default).ANIMATING] > 0;
    }
    /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */ getInteracting() {
        return this.hints_[(0, _viewHintJsDefault.default).INTERACTING] > 0;
    }
    /**
   * Cancel any ongoing animations.
   * @api
   */ cancelAnimations() {
        this.setHint((0, _viewHintJsDefault.default).ANIMATING, -this.hints_[(0, _viewHintJsDefault.default).ANIMATING]);
        let anchor;
        for(let i = 0, ii = this.animations_.length; i < ii; ++i){
            const series = this.animations_[i];
            if (series[0].callback) animationCallback(series[0].callback, false);
            if (!anchor) for(let j = 0, jj = series.length; j < jj; ++j){
                const animation = series[j];
                if (!animation.complete) {
                    anchor = animation.anchor;
                    break;
                }
            }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
    }
    /**
   * Update all animations.
   */ updateAnimations_() {
        if (this.updateAnimationKey_ !== undefined) {
            cancelAnimationFrame(this.updateAnimationKey_);
            this.updateAnimationKey_ = undefined;
        }
        if (!this.getAnimating()) return;
        const now = Date.now();
        let more = false;
        for(let i = this.animations_.length - 1; i >= 0; --i){
            const series = this.animations_[i];
            let seriesComplete = true;
            for(let j = 0, jj = series.length; j < jj; ++j){
                const animation = series[j];
                if (animation.complete) continue;
                const elapsed = now - animation.start;
                let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                if (fraction >= 1) {
                    animation.complete = true;
                    fraction = 1;
                } else seriesComplete = false;
                const progress = animation.easing(fraction);
                if (animation.sourceCenter) {
                    const x0 = animation.sourceCenter[0];
                    const y0 = animation.sourceCenter[1];
                    const x1 = animation.targetCenter[0];
                    const y1 = animation.targetCenter[1];
                    this.nextCenter_ = animation.targetCenter;
                    const x = x0 + progress * (x1 - x0);
                    const y = y0 + progress * (y1 - y0);
                    this.targetCenter_ = [
                        x,
                        y
                    ];
                }
                if (animation.sourceResolution && animation.targetResolution) {
                    const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
                    if (animation.anchor) {
                        const size = this.getViewportSize_(this.getRotation());
                        const constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                        this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                    }
                    this.nextResolution_ = animation.targetResolution;
                    this.targetResolution_ = resolution;
                    this.applyTargetState_(true);
                }
                if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
                    const rotation = progress === 1 ? (0, _mathJs.modulo)(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
                    if (animation.anchor) {
                        const constrainedRotation = this.constraints_.rotation(rotation, true);
                        this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                    }
                    this.nextRotation_ = animation.targetRotation;
                    this.targetRotation_ = rotation;
                }
                this.applyTargetState_(true);
                more = true;
                if (!animation.complete) break;
            }
            if (seriesComplete) {
                this.animations_[i] = null;
                this.setHint((0, _viewHintJsDefault.default).ANIMATING, -1);
                this.nextCenter_ = null;
                this.nextResolution_ = NaN;
                this.nextRotation_ = NaN;
                const callback = series[0].callback;
                if (callback) animationCallback(callback, true);
            }
        }
        // prune completed series
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === undefined) this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
    }
    /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */ calculateCenterRotate(rotation, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        if (currentCenter !== undefined) {
            center = [
                currentCenter[0] - anchor[0],
                currentCenter[1] - anchor[1]
            ];
            (0, _coordinateJs.rotate)(center, rotation - this.getRotation());
            (0, _coordinateJs.add)(center, anchor);
        }
        return center;
    }
    /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */ calculateCenterZoom(resolution, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        const currentResolution = this.getResolution();
        if (currentCenter !== undefined && currentResolution !== undefined) {
            const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
            const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
            center = [
                x,
                y
            ];
        }
        return center;
    }
    /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */ getViewportSize_(rotation) {
        const size = this.viewportSize_;
        if (rotation) {
            const w = size[0];
            const h = size[1];
            return [
                Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
                Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
            ];
        }
        return size;
    }
    /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */ setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [
            100,
            100
        ];
        if (!this.getAnimating()) this.resolveConstraints(0);
    }
    /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */ getCenter() {
        const center = this.getCenterInternal();
        if (!center) return center;
        return (0, _projJs.toUserCoordinate)(center, this.getProjection());
    }
    /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */ getCenterInternal() {
        return /** @type {import("./coordinate.js").Coordinate|undefined} */ this.get((0, _viewPropertyJsDefault.default).CENTER);
    }
    /**
   * @return {Constraints} Constraints.
   */ getConstraints() {
        return this.constraints_;
    }
    /**
   * @return {boolean} Resolution constraint is set
   */ getConstrainResolution() {
        return this.get('constrainResolution');
    }
    /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */ getHints(hints) {
        if (hints !== undefined) {
            hints[0] = this.hints_[0];
            hints[1] = this.hints_[1];
            return hints;
        }
        return this.hints_.slice();
    }
    /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */ calculateExtent(size) {
        const extent = this.calculateExtentInternal(size);
        return (0, _projJs.toUserExtent)(extent, this.getProjection());
    }
    /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */ calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        const center = /** @type {!import("./coordinate.js").Coordinate} */ this.getCenterInternal();
        (0, _assertsJs.assert)(center, 'The view center is not defined');
        const resolution = /** @type {!number} */ this.getResolution();
        (0, _assertsJs.assert)(resolution !== undefined, 'The view resolution is not defined');
        const rotation = /** @type {!number} */ this.getRotation();
        (0, _assertsJs.assert)(rotation !== undefined, 'The view rotation is not defined');
        return (0, _extentJs.getForViewAndSize)(center, resolution, rotation, size);
    }
    /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */ getMaxResolution() {
        return this.maxResolution_;
    }
    /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */ getMinResolution() {
        return this.minResolution_;
    }
    /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */ getMaxZoom() {
        return /** @type {number} */ this.getZoomForResolution(this.minResolution_);
    }
    /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */ setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
            maxZoom: zoom
        }));
    }
    /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */ getMinZoom() {
        return /** @type {number} */ this.getZoomForResolution(this.maxResolution_);
    }
    /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */ setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
            minZoom: zoom
        }));
    }
    /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */ setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({
            constrainResolution: enabled
        }));
    }
    /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */ getProjection() {
        return this.projection_;
    }
    /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */ getResolution() {
        return /** @type {number|undefined} */ this.get((0, _viewPropertyJsDefault.default).RESOLUTION);
    }
    /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */ getResolutions() {
        return this.resolutions_;
    }
    /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */ getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal((0, _projJs.fromUserExtent)(extent, this.getProjection()), size);
    }
    /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */ getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        const xResolution = (0, _extentJs.getWidth)(extent) / size[0];
        const yResolution = (0, _extentJs.getHeight)(extent) / size[1];
        return Math.max(xResolution, yResolution);
    }
    /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */ getResolutionForValueFunction(power) {
        power = power || 2;
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return(/**
       * @param {number} value Value.
       * @return {number} Resolution.
       */ function(value) {
            const resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
        });
    }
    /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */ getRotation() {
        return /** @type {number} */ this.get((0, _viewPropertyJsDefault.default).ROTATION);
    }
    /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */ getValueForResolutionFunction(power) {
        const logPower = Math.log(power || 2);
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / logPower;
        return(/**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */ function(resolution) {
            const value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
        });
    }
    /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */ getViewportSizeMinusPadding_(rotation) {
        let size = this.getViewportSize_(rotation);
        const padding = this.padding_;
        if (padding) size = [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
        ];
        return size;
    }
    /**
   * @return {State} View state.
   */ getState() {
        const projection = this.getProjection();
        const resolution = this.getResolution();
        const rotation = this.getRotation();
        let center = /** @type {import("./coordinate.js").Coordinate} */ this.getCenterInternal();
        const padding = this.padding_;
        if (padding) {
            const reducedSize = this.getViewportSizeMinusPadding_();
            center = calculateCenterOn(center, this.getViewportSize_(), [
                reducedSize[0] / 2 + padding[3],
                reducedSize[1] / 2 + padding[0]
            ], resolution, rotation);
        }
        return {
            center: center.slice(0),
            projection: projection !== undefined ? projection : null,
            resolution: resolution,
            nextCenter: this.nextCenter_,
            nextResolution: this.nextResolution_,
            nextRotation: this.nextRotation_,
            rotation: rotation,
            zoom: this.getZoom()
        };
    }
    /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */ getViewStateAndExtent() {
        return {
            viewState: this.getState(),
            extent: this.calculateExtent()
        };
    }
    /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */ getZoom() {
        let zoom;
        const resolution = this.getResolution();
        if (resolution !== undefined) zoom = this.getZoomForResolution(resolution);
        return zoom;
    }
    /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */ getZoomForResolution(resolution) {
        let offset = this.minZoom_ || 0;
        let max, zoomFactor;
        if (this.resolutions_) {
            const nearest = (0, _arrayJs.linearFindNearest)(this.resolutions_, resolution, 1);
            offset = nearest;
            max = this.resolutions_[nearest];
            if (nearest == this.resolutions_.length - 1) zoomFactor = 2;
            else zoomFactor = max / this.resolutions_[nearest + 1];
        } else {
            max = this.maxResolution_;
            zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
    }
    /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */ getResolutionForZoom(zoom) {
        if (this.resolutions_) {
            if (this.resolutions_.length <= 1) return 0;
            const baseLevel = (0, _mathJs.clamp)(Math.floor(zoom), 0, this.resolutions_.length - 2);
            const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
            return this.resolutions_[baseLevel] / Math.pow(zoomFactor, (0, _mathJs.clamp)(zoom - baseLevel, 0, 1));
        }
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
    /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */ fit(geometryOrExtent, options) {
        /** @type {import("./geom/SimpleGeometry.js").default} */ let geometry;
        (0, _assertsJs.assert)(Array.isArray(geometryOrExtent) || typeof /** @type {?} */ geometryOrExtent.getSimplifiedGeometry === 'function', 'Invalid extent or geometry provided as `geometry`');
        if (Array.isArray(geometryOrExtent)) {
            (0, _assertsJs.assert)(!(0, _extentJs.isEmpty)(geometryOrExtent), 'Cannot fit empty extent provided as `geometry`');
            const extent = (0, _projJs.fromUserExtent)(geometryOrExtent, this.getProjection());
            geometry = (0, _polygonJs.fromExtent)(extent);
        } else if (geometryOrExtent.getType() === 'Circle') {
            const extent = (0, _projJs.fromUserExtent)(geometryOrExtent.getExtent(), this.getProjection());
            geometry = (0, _polygonJs.fromExtent)(extent);
            geometry.rotate(this.getRotation(), (0, _extentJs.getCenter)(extent));
        } else {
            const userProjection = (0, _projJs.getUserProjection)();
            if (userProjection) geometry = /** @type {import("./geom/SimpleGeometry.js").default} */ geometryOrExtent.clone().transform(userProjection, this.getProjection());
            else geometry = geometryOrExtent;
        }
        this.fitInternal(geometry, options);
    }
    /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */ rotatedExtentForGeometry(geometry) {
        const rotation = this.getRotation();
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(-rotation);
        const coords = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        let minRotX = Infinity;
        let minRotY = Infinity;
        let maxRotX = -Infinity;
        let maxRotY = -Infinity;
        for(let i = 0, ii = coords.length; i < ii; i += stride){
            const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
            const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
            minRotX = Math.min(minRotX, rotX);
            minRotY = Math.min(minRotY, rotY);
            maxRotX = Math.max(maxRotX, rotX);
            maxRotY = Math.max(maxRotY, rotY);
        }
        return [
            minRotX,
            minRotY,
            maxRotX,
            maxRotY
        ];
    }
    /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */ fitInternal(geometry, options) {
        options = options || {};
        let size = options.size;
        if (!size) size = this.getViewportSizeMinusPadding_();
        const padding = options.padding !== undefined ? options.padding : [
            0,
            0,
            0,
            0
        ];
        const nearest = options.nearest !== undefined ? options.nearest : false;
        let minResolution;
        if (options.minResolution !== undefined) minResolution = options.minResolution;
        else if (options.maxZoom !== undefined) minResolution = this.getResolutionForZoom(options.maxZoom);
        else minResolution = 0;
        const rotatedExtent = this.rotatedExtentForGeometry(geometry);
        // calculate resolution
        let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        // calculate center
        const rotation = this.getRotation();
        const sinAngle = Math.sin(rotation);
        const cosAngle = Math.cos(rotation);
        const centerRot = (0, _extentJs.getCenter)(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        const center = this.getConstrainedCenter([
            centerX,
            centerY
        ], resolution);
        const callback = options.callback ? options.callback : (0, _functionsJs.VOID);
        if (options.duration !== undefined) this.animateInternal({
            resolution: resolution,
            center: center,
            duration: options.duration,
            easing: options.easing
        }, callback);
        else {
            this.targetResolution_ = resolution;
            this.targetCenter_ = center;
            this.applyTargetState_(false, true);
            animationCallback(callback, true);
        }
    }
    /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */ centerOn(coordinate, size, position) {
        this.centerOnInternal((0, _projJs.fromUserCoordinate)(coordinate, this.getProjection()), size, position);
    }
    /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */ centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
    }
    /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */ calculateCenterShift(center, resolution, rotation, size) {
        let centerShift;
        const padding = this.padding_;
        if (padding && center) {
            const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
            const shiftedCenter = calculateCenterOn(center, size, [
                reducedSize[0] / 2 + padding[3],
                reducedSize[1] / 2 + padding[0]
            ], resolution, rotation);
            centerShift = [
                center[0] - shiftedCenter[0],
                center[1] - shiftedCenter[1]
            ];
        }
        return centerShift;
    }
    /**
   * @return {boolean} Is defined.
   */ isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== undefined;
    }
    /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */ adjustCenter(deltaCoordinates) {
        const center = (0, _projJs.toUserCoordinate)(this.targetCenter_, this.getProjection());
        this.setCenter([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1]
        ]);
    }
    /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */ adjustCenterInternal(deltaCoordinates) {
        const center = this.targetCenter_;
        this.setCenterInternal([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1]
        ]);
    }
    /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ adjustResolution(ratio, anchor) {
        anchor = anchor && (0, _projJs.fromUserCoordinate)(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
    }
    /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ adjustResolutionInternal(ratio, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const size = this.getViewportSize_(this.getRotation());
        const newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
        if (anchor) this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
    }
    /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
    }
    /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */ adjustRotation(delta, anchor) {
        if (anchor) anchor = (0, _projJs.fromUserCoordinate)(anchor, this.getProjection());
        this.adjustRotationInternal(delta, anchor);
    }
    /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */ adjustRotationInternal(delta, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
        if (anchor) this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        this.targetRotation_ += delta;
        this.applyTargetState_();
    }
    /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */ setCenter(center) {
        this.setCenterInternal(center ? (0, _projJs.fromUserCoordinate)(center, this.getProjection()) : center);
    }
    /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */ setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
    }
    /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */ setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
    }
    /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */ setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
    }
    /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */ setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
    }
    /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */ setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
    }
    /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */ applyTargetState_(doNotCancelAnims, forceMoving) {
        const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
        // compute rotation
        const newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
        const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (this.get((0, _viewPropertyJsDefault.default).ROTATION) !== newRotation) this.set((0, _viewPropertyJsDefault.default).ROTATION, newRotation);
        if (this.get((0, _viewPropertyJsDefault.default).RESOLUTION) !== newResolution) {
            this.set((0, _viewPropertyJsDefault.default).RESOLUTION, newResolution);
            this.set('zoom', this.getZoom(), true);
        }
        if (!newCenter || !this.get((0, _viewPropertyJsDefault.default).CENTER) || !(0, _coordinateJs.equals)(this.get((0, _viewPropertyJsDefault.default).CENTER), newCenter)) this.set((0, _viewPropertyJsDefault.default).CENTER, newCenter);
        if (this.getAnimating() && !doNotCancelAnims) this.cancelAnimations();
        this.cancelAnchor_ = undefined;
    }
    /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== undefined ? duration : 200;
        const direction = resolutionDirection || 0;
        const newRotation = this.constraints_.rotation(this.targetRotation_);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
        const newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (duration === 0 && !this.cancelAnchor_) {
            this.targetResolution_ = newResolution;
            this.targetRotation_ = newRotation;
            this.targetCenter_ = newCenter;
            this.applyTargetState_();
            return;
        }
        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
        this.cancelAnchor_ = undefined;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !(0, _coordinateJs.equals)(this.getCenterInternal(), newCenter)) {
            if (this.getAnimating()) this.cancelAnimations();
            this.animateInternal({
                rotation: newRotation,
                center: newCenter,
                resolution: newResolution,
                duration: duration,
                easing: (0, _easingJs.easeOut),
                anchor: anchor
            });
        }
    }
    /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */ beginInteraction() {
        this.resolveConstraints(0);
        this.setHint((0, _viewHintJsDefault.default).INTERACTING, 1);
    }
    /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */ endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && (0, _projJs.fromUserCoordinate)(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
    }
    /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */ endInteractionInternal(duration, resolutionDirection, anchor) {
        if (!this.getInteracting()) return;
        this.setHint((0, _viewHintJsDefault.default).INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
    }
    /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */ getConstrainedCenter(targetCenter, targetResolution) {
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(targetCenter, targetResolution || this.getResolution(), size);
    }
    /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */ getConstrainedZoom(targetZoom, direction) {
        const targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(this.getConstrainedResolution(targetRes, direction));
    }
    /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */ getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
    }
}
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */ function animationCallback(callback, returnValue) {
    setTimeout(function() {
        callback(returnValue);
    }, 0);
}
function createCenterConstraint(options) {
    if (options.extent !== undefined) {
        const smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
        return (0, _centerconstraintJs.createExtent)(options.extent, options.constrainOnlyCenter, smooth);
    }
    const projection = (0, _projJs.createProjection)(options.projection, 'EPSG:3857');
    if (options.multiWorld !== true && projection.isGlobal()) {
        const extent = projection.getExtent().slice();
        extent[0] = -Infinity;
        extent[2] = Infinity;
        return (0, _centerconstraintJs.createExtent)(extent, false, false);
    }
    return 0, _centerconstraintJs.none;
}
function createResolutionConstraint(options) {
    let resolutionConstraint;
    let maxResolution;
    let minResolution;
    // TODO: move these to be ol constants
    // see https://github.com/openlayers/openlayers/issues/2076
    const defaultMaxZoom = 28;
    const defaultZoomFactor = 2;
    let minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
    let maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
    const zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
    const multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
    const smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
    const showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
    const projection = (0, _projJs.createProjection)(options.projection, 'EPSG:3857');
    const projExtent = projection.getExtent();
    let constrainOnlyCenter = options.constrainOnlyCenter;
    let extent = options.extent;
    if (!multiWorld && !extent && projection.isGlobal()) {
        constrainOnlyCenter = false;
        extent = projExtent;
    }
    if (options.resolutions !== undefined) {
        const resolutions = options.resolutions;
        maxResolution = resolutions[minZoom];
        minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
        if (options.constrainResolution) resolutionConstraint = (0, _resolutionconstraintJs.createSnapToResolutions)(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
        else resolutionConstraint = (0, _resolutionconstraintJs.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
        // calculate the default min and max resolution
        const size = !projExtent ? 360 * (0, _projJs.METERS_PER_UNIT).degrees / projection.getMetersPerUnit() : Math.max((0, _extentJs.getWidth)(projExtent), (0, _extentJs.getHeight)(projExtent));
        const defaultMaxResolution = size / (0, _commonJs.DEFAULT_TILE_SIZE) / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
        const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
        // user provided maxResolution takes precedence
        maxResolution = options.maxResolution;
        if (maxResolution !== undefined) minZoom = 0;
        else maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
        // user provided minResolution takes precedence
        minResolution = options.minResolution;
        if (minResolution === undefined) {
            if (options.maxZoom !== undefined) {
                if (options.maxResolution !== undefined) minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                else minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
            } else minResolution = defaultMinResolution;
        }
        // given discrete zoom levels, minResolution may be different than provided
        maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
        minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
        if (options.constrainResolution) resolutionConstraint = (0, _resolutionconstraintJs.createSnapToPower)(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
        else resolutionConstraint = (0, _resolutionconstraintJs.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
    return {
        constraint: resolutionConstraint,
        maxResolution: maxResolution,
        minResolution: minResolution,
        minZoom: minZoom,
        zoomFactor: zoomFactor
    };
}
function createRotationConstraint(options) {
    const enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
    if (enableRotation) {
        const constrainRotation = options.constrainRotation;
        if (constrainRotation === undefined || constrainRotation === true) return (0, _rotationconstraintJs.createSnapToZero)();
        if (constrainRotation === false) return 0, _rotationconstraintJs.none;
        if (typeof constrainRotation === 'number') return (0, _rotationconstraintJs.createSnapToN)(constrainRotation);
        return 0, _rotationconstraintJs.none;
    }
    return 0, _rotationconstraintJs.disable;
}
function isNoopAnimation(animation) {
    if (animation.sourceCenter && animation.targetCenter) {
        if (!(0, _coordinateJs.equals)(animation.sourceCenter, animation.targetCenter)) return false;
    }
    if (animation.sourceResolution !== animation.targetResolution) return false;
    if (animation.sourceRotation !== animation.targetRotation) return false;
    return true;
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */ function calculateCenterOn(coordinate, size, position, resolution, rotation) {
    // calculate rotated position
    const cosAngle = Math.cos(-rotation);
    let sinAngle = Math.sin(-rotation);
    let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution;
    // go back to original angle
    sinAngle = -sinAngle; // go back to original rotation
    const centerX = rotX * cosAngle - rotY * sinAngle;
    const centerY = rotY * cosAngle + rotX * sinAngle;
    return [
        centerX,
        centerY
    ];
}
exports.default = View;

},{"./Object.js":"1zG8z","./ViewHint.js":"6THmF","./ViewProperty.js":"lWCek","./tilegrid/common.js":"bxYGl","./proj.js":"SznqC","./functions.js":"iqv8I","./coordinate.js":"85Vu7","./asserts.js":"e4TiF","./centerconstraint.js":"g3NLx","./math.js":"5jEFr","./resolutionconstraint.js":"j8WKZ","./rotationconstraint.js":"hSWd8","./easing.js":"fYITA","./extent.js":"6YrVc","./array.js":"1Fbic","./geom/Polygon.js":"cJuQF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6THmF":[function(require,module,exports,__globalThis) {
/**
 * @module ol/ViewHint
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    ANIMATING: 0,
    INTERACTING: 1
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lWCek":[function(require,module,exports,__globalThis) {
/**
 * @module ol/ViewProperty
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    CENTER: 'center',
    RESOLUTION: 'resolution',
    ROTATION: 'rotation'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bxYGl":[function(require,module,exports,__globalThis) {
/**
 * @module ol/tilegrid/common
 */ /**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_MAX_ZOOM", ()=>DEFAULT_MAX_ZOOM);
parcelHelpers.export(exports, "DEFAULT_TILE_SIZE", ()=>DEFAULT_TILE_SIZE);
const DEFAULT_MAX_ZOOM = 42;
const DEFAULT_TILE_SIZE = 256;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g3NLx":[function(require,module,exports,__globalThis) {
/**
 * @module ol/centerconstraint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */ /**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */ parcelHelpers.export(exports, "createExtent", ()=>createExtent);
/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */ parcelHelpers.export(exports, "none", ()=>none);
var _mathJs = require("./math.js");
function createExtent(extent, onlyCenter, smooth) {
    return(/**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */ function(center, resolution, size, isMoving, centerShift) {
        if (!center) return undefined;
        if (!resolution && !onlyCenter) return center;
        const viewWidth = onlyCenter ? 0 : size[0] * resolution;
        const viewHeight = onlyCenter ? 0 : size[1] * resolution;
        const shiftX = centerShift ? centerShift[0] : 0;
        const shiftY = centerShift ? centerShift[1] : 0;
        let minX = extent[0] + viewWidth / 2 + shiftX;
        let maxX = extent[2] - viewWidth / 2 + shiftX;
        let minY = extent[1] + viewHeight / 2 + shiftY;
        let maxY = extent[3] - viewHeight / 2 + shiftY;
        // note: when zooming out of bounds, min and max values for x and y may
        // end up inverted (min > max); this has to be accounted for
        if (minX > maxX) {
            minX = (maxX + minX) / 2;
            maxX = minX;
        }
        if (minY > maxY) {
            minY = (maxY + minY) / 2;
            maxY = minY;
        }
        let x = (0, _mathJs.clamp)(center[0], minX, maxX);
        let y = (0, _mathJs.clamp)(center[1], minY, maxY);
        // during an interaction, allow some overscroll
        if (isMoving && smooth && resolution) {
            const ratio = 30 * resolution;
            x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
            y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
        }
        return [
            x,
            y
        ];
    });
}
function none(center) {
    return center;
}

},{"./math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j8WKZ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/resolutionconstraint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createSnapToResolutions", ()=>createSnapToResolutions);
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [minResolution] Minimum resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createSnapToPower", ()=>createSnapToPower);
/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
 * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createMinMaxResolution", ()=>createMinMaxResolution);
var _mathJs = require("./math.js");
var _extentJs = require("./extent.js");
var _arrayJs = require("./array.js");
/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */ /**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */ function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
    const xResolution = (0, _extentJs.getWidth)(maxExtent) / viewportSize[0];
    const yResolution = (0, _extentJs.getHeight)(maxExtent) / viewportSize[1];
    if (showFullExtent) return Math.min(resolution, Math.max(xResolution, yResolution));
    return Math.min(resolution, Math.min(xResolution, yResolution));
}
/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */ function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
    let result = Math.min(resolution, maxResolution);
    const ratio = 50;
    result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
    if (minResolution) {
        result = Math.max(result, minResolution);
        result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
    }
    return (0, _mathJs.clamp)(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const maxResolution = resolutions[0];
            const minResolution = resolutions[resolutions.length - 1];
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            // during interacting or animating, allow intermediary values
            if (isMoving) {
                if (!smooth) return (0, _mathJs.clamp)(resolution, minResolution, cappedMaxRes);
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            const capped = Math.min(cappedMaxRes, resolution);
            const z = Math.floor((0, _arrayJs.linearFindNearest)(resolutions, capped, direction));
            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) return resolutions[z + 1];
            return resolutions[z];
        }
        return undefined;
    });
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    minResolution = minResolution !== undefined ? minResolution : 0;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            // during interacting or animating, allow intermediary values
            if (isMoving) {
                if (!smooth) return (0, _mathJs.clamp)(resolution, minResolution, cappedMaxRes);
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            const tolerance = 1e-9;
            const minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
            const offset = -direction * (0.5 - tolerance) + 0.5;
            const capped = Math.min(cappedMaxRes, resolution);
            const cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
            const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
            const newResolution = maxResolution / Math.pow(power, zoomLevel);
            return (0, _mathJs.clamp)(newResolution, minResolution, cappedMaxRes);
        }
        return undefined;
    });
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
            const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;
            if (!smooth || !isMoving) return (0, _mathJs.clamp)(resolution, minResolution, cappedMaxRes);
            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }
        return undefined;
    });
}

},{"./math.js":"5jEFr","./extent.js":"6YrVc","./array.js":"1Fbic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hSWd8":[function(require,module,exports,__globalThis) {
/**
 * @module ol/rotationconstraint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */ /**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */ parcelHelpers.export(exports, "disable", ()=>disable);
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */ parcelHelpers.export(exports, "none", ()=>none);
/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createSnapToN", ()=>createSnapToN);
/**
 * @param {number} [tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createSnapToZero", ()=>createSnapToZero);
var _mathJs = require("./math.js");
function disable(rotation) {
    if (rotation !== undefined) return 0;
    return undefined;
}
function none(rotation) {
    if (rotation !== undefined) return rotation;
    return undefined;
}
function createSnapToN(n) {
    const theta = 2 * Math.PI / n;
    return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */ function(rotation, isMoving) {
        if (isMoving) return rotation;
        if (rotation !== undefined) {
            rotation = Math.floor(rotation / theta + 0.5) * theta;
            return rotation;
        }
        return undefined;
    });
}
function createSnapToZero(tolerance) {
    const t = tolerance === undefined ? (0, _mathJs.toRadians)(5) : tolerance;
    return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */ function(rotation, isMoving) {
        if (isMoving || rotation === undefined) return rotation;
        if (Math.abs(rotation) <= t) return 0;
        return rotation;
    });
}

},{"./math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k2VZu":[function(require,module,exports,__globalThis) {
!function(t, i) {
    module.exports = i();
}(this, function() {
    "use strict";
    function t(t, r, e, a, h) {
        !function t(n, r, e, a, h) {
            for(; a > e;){
                if (a - e > 600) {
                    var o = a - e + 1, s = r - e + 1, l = Math.log(o), f = .5 * Math.exp(2 * l / 3), u = .5 * Math.sqrt(l * f * (o - f) / o) * (s - o / 2 < 0 ? -1 : 1), m = Math.max(e, Math.floor(r - s * f / o + u)), c = Math.min(a, Math.floor(r + (o - s) * f / o + u));
                    t(n, r, m, c, h);
                }
                var p = n[r], d = e, x = a;
                for(i(n, e, r), h(n[a], p) > 0 && i(n, e, a); d < x;){
                    for(i(n, d, x), d++, x--; h(n[d], p) < 0;)d++;
                    for(; h(n[x], p) > 0;)x--;
                }
                0 === h(n[e], p) ? i(n, e, x) : i(n, ++x, a), x <= r && (e = x + 1), r <= x && (a = x - 1);
            }
        }(t, r, e || 0, a || t.length - 1, h || n);
    }
    function i(t, i, n) {
        var r = t[i];
        t[i] = t[n], t[n] = r;
    }
    function n(t, i) {
        return t < i ? -1 : t > i ? 1 : 0;
    }
    var r = function(t) {
        void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear();
    };
    function e(t, i, n) {
        if (!n) return i.indexOf(t);
        for(var r = 0; r < i.length; r++)if (n(t, i[r])) return r;
        return -1;
    }
    function a(t, i) {
        h(t, 0, t.children.length, i, t);
    }
    function h(t, i, n, r, e) {
        e || (e = p(null)), e.minX = 1 / 0, e.minY = 1 / 0, e.maxX = -1 / 0, e.maxY = -1 / 0;
        for(var a = i; a < n; a++){
            var h = t.children[a];
            o(e, t.leaf ? r(h) : h);
        }
        return e;
    }
    function o(t, i) {
        return t.minX = Math.min(t.minX, i.minX), t.minY = Math.min(t.minY, i.minY), t.maxX = Math.max(t.maxX, i.maxX), t.maxY = Math.max(t.maxY, i.maxY), t;
    }
    function s(t, i) {
        return t.minX - i.minX;
    }
    function l(t, i) {
        return t.minY - i.minY;
    }
    function f(t) {
        return (t.maxX - t.minX) * (t.maxY - t.minY);
    }
    function u(t) {
        return t.maxX - t.minX + (t.maxY - t.minY);
    }
    function m(t, i) {
        return t.minX <= i.minX && t.minY <= i.minY && i.maxX <= t.maxX && i.maxY <= t.maxY;
    }
    function c(t, i) {
        return i.minX <= t.maxX && i.minY <= t.maxY && i.maxX >= t.minX && i.maxY >= t.minY;
    }
    function p(t) {
        return {
            children: t,
            height: 1,
            leaf: !0,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
        };
    }
    function d(i, n, r, e, a) {
        for(var h = [
            n,
            r
        ]; h.length;)if (!((r = h.pop()) - (n = h.pop()) <= e)) {
            var o = n + Math.ceil((r - n) / e / 2) * e;
            t(i, o, n, r, a), h.push(n, o, o, r);
        }
    }
    return r.prototype.all = function() {
        return this._all(this.data, []);
    }, r.prototype.search = function(t) {
        var i = this.data, n = [];
        if (!c(t, i)) return n;
        for(var r = this.toBBox, e = []; i;){
            for(var a = 0; a < i.children.length; a++){
                var h = i.children[a], o = i.leaf ? r(h) : h;
                c(t, o) && (i.leaf ? n.push(h) : m(t, o) ? this._all(h, n) : e.push(h));
            }
            i = e.pop();
        }
        return n;
    }, r.prototype.collides = function(t) {
        var i = this.data;
        if (!c(t, i)) return !1;
        for(var n = []; i;){
            for(var r = 0; r < i.children.length; r++){
                var e = i.children[r], a = i.leaf ? this.toBBox(e) : e;
                if (c(t, a)) {
                    if (i.leaf || m(t, a)) return !0;
                    n.push(e);
                }
            }
            i = n.pop();
        }
        return !1;
    }, r.prototype.load = function(t) {
        if (!t || !t.length) return this;
        if (t.length < this._minEntries) {
            for(var i = 0; i < t.length; i++)this.insert(t[i]);
            return this;
        }
        var n = this._build(t.slice(), 0, t.length - 1, 0);
        if (this.data.children.length) {
            if (this.data.height === n.height) this._splitRoot(this.data, n);
            else {
                if (this.data.height < n.height) {
                    var r = this.data;
                    this.data = n, n = r;
                }
                this._insert(n, this.data.height - n.height - 1, !0);
            }
        } else this.data = n;
        return this;
    }, r.prototype.insert = function(t) {
        return t && this._insert(t, this.data.height - 1), this;
    }, r.prototype.clear = function() {
        return this.data = p([]), this;
    }, r.prototype.remove = function(t, i) {
        if (!t) return this;
        for(var n, r, a, h = this.data, o = this.toBBox(t), s = [], l = []; h || s.length;){
            if (h || (h = s.pop(), r = s[s.length - 1], n = l.pop(), a = !0), h.leaf) {
                var f = e(t, h.children, i);
                if (-1 !== f) return h.children.splice(f, 1), s.push(h), this._condense(s), this;
            }
            a || h.leaf || !m(h, o) ? r ? (n++, h = r.children[n], a = !1) : h = null : (s.push(h), l.push(n), n = 0, r = h, h = h.children[0]);
        }
        return this;
    }, r.prototype.toBBox = function(t) {
        return t;
    }, r.prototype.compareMinX = function(t, i) {
        return t.minX - i.minX;
    }, r.prototype.compareMinY = function(t, i) {
        return t.minY - i.minY;
    }, r.prototype.toJSON = function() {
        return this.data;
    }, r.prototype.fromJSON = function(t) {
        return this.data = t, this;
    }, r.prototype._all = function(t, i) {
        for(var n = []; t;)t.leaf ? i.push.apply(i, t.children) : n.push.apply(n, t.children), t = n.pop();
        return i;
    }, r.prototype._build = function(t, i, n, r) {
        var e, h = n - i + 1, o = this._maxEntries;
        if (h <= o) return a(e = p(t.slice(i, n + 1)), this.toBBox), e;
        r || (r = Math.ceil(Math.log(h) / Math.log(o)), o = Math.ceil(h / Math.pow(o, r - 1))), (e = p([])).leaf = !1, e.height = r;
        var s = Math.ceil(h / o), l = s * Math.ceil(Math.sqrt(o));
        d(t, i, n, l, this.compareMinX);
        for(var f = i; f <= n; f += l){
            var u = Math.min(f + l - 1, n);
            d(t, f, u, s, this.compareMinY);
            for(var m = f; m <= u; m += s){
                var c = Math.min(m + s - 1, u);
                e.children.push(this._build(t, m, c, r - 1));
            }
        }
        return a(e, this.toBBox), e;
    }, r.prototype._chooseSubtree = function(t, i, n, r) {
        for(; r.push(i), !i.leaf && r.length - 1 !== n;){
            for(var e = 1 / 0, a = 1 / 0, h = void 0, o = 0; o < i.children.length; o++){
                var s = i.children[o], l = f(s), u = (m = t, c = s, (Math.max(c.maxX, m.maxX) - Math.min(c.minX, m.minX)) * (Math.max(c.maxY, m.maxY) - Math.min(c.minY, m.minY)) - l);
                u < a ? (a = u, e = l < e ? l : e, h = s) : u === a && l < e && (e = l, h = s);
            }
            i = h || i.children[0];
        }
        var m, c;
        return i;
    }, r.prototype._insert = function(t, i, n) {
        var r = n ? t : this.toBBox(t), e = [], a = this._chooseSubtree(r, this.data, i, e);
        for(a.children.push(t), o(a, r); i >= 0 && e[i].children.length > this._maxEntries;)this._split(e, i), i--;
        this._adjustParentBBoxes(r, e, i);
    }, r.prototype._split = function(t, i) {
        var n = t[i], r = n.children.length, e = this._minEntries;
        this._chooseSplitAxis(n, e, r);
        var h = this._chooseSplitIndex(n, e, r), o = p(n.children.splice(h, n.children.length - h));
        o.height = n.height, o.leaf = n.leaf, a(n, this.toBBox), a(o, this.toBBox), i ? t[i - 1].children.push(o) : this._splitRoot(n, o);
    }, r.prototype._splitRoot = function(t, i) {
        this.data = p([
            t,
            i
        ]), this.data.height = t.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);
    }, r.prototype._chooseSplitIndex = function(t, i, n) {
        for(var r, e, a, o, s, l, u, m = 1 / 0, c = 1 / 0, p = i; p <= n - i; p++){
            var d = h(t, 0, p, this.toBBox), x = h(t, p, n, this.toBBox), v = (e = d, a = x, o = void 0, s = void 0, l = void 0, u = void 0, o = Math.max(e.minX, a.minX), s = Math.max(e.minY, a.minY), l = Math.min(e.maxX, a.maxX), u = Math.min(e.maxY, a.maxY), Math.max(0, l - o) * Math.max(0, u - s)), M = f(d) + f(x);
            v < m ? (m = v, r = p, c = M < c ? M : c) : v === m && M < c && (c = M, r = p);
        }
        return r || n - i;
    }, r.prototype._chooseSplitAxis = function(t, i, n) {
        var r = t.leaf ? this.compareMinX : s, e = t.leaf ? this.compareMinY : l;
        this._allDistMargin(t, i, n, r) < this._allDistMargin(t, i, n, e) && t.children.sort(r);
    }, r.prototype._allDistMargin = function(t, i, n, r) {
        t.children.sort(r);
        for(var e = this.toBBox, a = h(t, 0, i, e), s = h(t, n - i, n, e), l = u(a) + u(s), f = i; f < n - i; f++){
            var m = t.children[f];
            o(a, t.leaf ? e(m) : m), l += u(a);
        }
        for(var c = n - i - 1; c >= i; c--){
            var p = t.children[c];
            o(s, t.leaf ? e(p) : p), l += u(s);
        }
        return l;
    }, r.prototype._adjustParentBBoxes = function(t, i, n) {
        for(var r = n; r >= 0; r--)o(i[r], t);
    }, r.prototype._condense = function(t) {
        for(var i = t.length - 1, n = void 0; i >= 0; i--)0 === t[i].children.length ? i > 0 ? (n = t[i - 1].children).splice(n.indexOf(t[i]), 1) : this.clear() : a(t[i], this.toBBox);
    }, r;
});

},{}],"fW7vC":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Style
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */ parcelHelpers.export(exports, "toFunction", ()=>toFunction);
/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */ parcelHelpers.export(exports, "createDefaultStyle", ()=>createDefaultStyle);
/**
 * Default styles for editing features.
 * @return {Object<import("../geom/Geometry.js").Type, Array<Style>>} Styles
 */ parcelHelpers.export(exports, "createEditingStyle", ()=>createEditingStyle);
var _circleJs = require("./Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("./Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _strokeJs = require("./Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _assertsJs = require("../asserts.js");
/**
 * A function that takes an {@link module:ol/Feature~Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style~Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */ /**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */ /**
 * A function that takes an {@link module:ol/Feature~Feature} as argument and returns an
 * {@link module:ol/geom/Geometry~Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */ /**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>|Array<Array<Array<import("../coordinate.js").Coordinate>>>),import("../render.js").State): void} RenderFunction
 */ /**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {RenderFunction} [hitDetectionRenderer] Custom renderer for hit detection. If provided will be used
 * in hit detection rendering.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */ /**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)',
 *  });
 *  const stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25,
 *  });
 *  const styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5,
 *      }),
 *      fill: fill,
 *      stroke: stroke,
 *    }),
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Circle, Fill, Stroke, Style} from 'ol/style.js';
 *
 *  const styles = {};
 *  const white = [255, 255, 255, 1];
 *  const blue = [0, 153, 255, 1];
 *  const width = 3;
 *  styles['Polygon'] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5],
 *      }),
 *    }),
 *  ];
 *  styles['MultiPolygon'] =
 *      styles['Polygon'];
 *  styles['LineString'] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2,
 *      }),
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width,
 *      }),
 *    }),
 *  ];
 *  styles['MultiLineString'] = styles['LineString'];
 *
 *  styles['Circle'] = styles['Polygon'].concat(
 *    styles['LineString']
 *  );
 *
 *  styles['Point'] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue,
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2,
 *        }),
 *      }),
 *      zIndex: Infinity,
 *    }),
 *  ];
 *  styles['MultiPoint'] =
 *      styles['Point'];
 *  styles['GeometryCollection'] =
 *      styles['Polygon'].concat(
 *          styles['LineString'],
 *          styles['Point']
 *      );
 * ```
 *
 * @api
 */ class Style {
    /**
   * @param {Options} [options] Style options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction|null}
     */ this.geometry_ = null;
        /**
     * @private
     * @type {!GeometryFunction}
     */ this.geometryFunction_ = defaultGeometryFunction;
        if (options.geometry !== undefined) this.setGeometry(options.geometry);
        /**
     * @private
     * @type {import("./Fill.js").default|null}
     */ this.fill_ = options.fill !== undefined ? options.fill : null;
        /**
     * @private
     * @type {import("./Image.js").default|null}
     */ this.image_ = options.image !== undefined ? options.image : null;
        /**
     * @private
     * @type {RenderFunction|null}
     */ this.renderer_ = options.renderer !== undefined ? options.renderer : null;
        /**
     * @private
     * @type {RenderFunction|null}
     */ this.hitDetectionRenderer_ = options.hitDetectionRenderer !== undefined ? options.hitDetectionRenderer : null;
        /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
     * @private
     * @type {import("./Text.js").default|null}
     */ this.text_ = options.text !== undefined ? options.text : null;
        /**
     * @private
     * @type {number|undefined}
     */ this.zIndex_ = options.zIndex;
    }
    /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */ clone() {
        let geometry = this.getGeometry();
        if (geometry && typeof geometry === 'object') geometry = /** @type {import("../geom/Geometry.js").default} */ geometry.clone();
        return new Style({
            geometry: geometry ?? undefined,
            fill: this.getFill() ? this.getFill().clone() : undefined,
            image: this.getImage() ? this.getImage().clone() : undefined,
            renderer: this.getRenderer() ?? undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            text: this.getText() ? this.getText().clone() : undefined,
            zIndex: this.getZIndex()
        });
    }
    /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */ getRenderer() {
        return this.renderer_;
    }
    /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */ setRenderer(renderer) {
        this.renderer_ = renderer;
    }
    /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */ setHitDetectionRenderer(renderer) {
        this.hitDetectionRenderer_ = renderer;
    }
    /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */ getHitDetectionRenderer() {
        return this.hitDetectionRenderer_;
    }
    /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */ getGeometry() {
        return this.geometry_;
    }
    /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */ getGeometryFunction() {
        return this.geometryFunction_;
    }
    /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */ getFill() {
        return this.fill_;
    }
    /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */ setFill(fill) {
        this.fill_ = fill;
    }
    /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */ getImage() {
        return this.image_;
    }
    /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */ setImage(image) {
        this.image_ = image;
    }
    /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */ getStroke() {
        return this.stroke_;
    }
    /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */ setStroke(stroke) {
        this.stroke_ = stroke;
    }
    /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */ getText() {
        return this.text_;
    }
    /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */ setText(text) {
        this.text_ = text;
    }
    /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */ getZIndex() {
        return this.zIndex_;
    }
    /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */ setGeometry(geometry) {
        if (typeof geometry === 'function') this.geometryFunction_ = geometry;
        else if (typeof geometry === 'string') this.geometryFunction_ = function(feature) {
            return /** @type {import("../geom/Geometry.js").default} */ feature.get(geometry);
        };
        else if (!geometry) this.geometryFunction_ = defaultGeometryFunction;
        else if (geometry !== undefined) this.geometryFunction_ = function() {
            return /** @type {import("../geom/Geometry.js").default} */ geometry;
        };
        this.geometry_ = geometry;
    }
    /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */ setZIndex(zIndex) {
        this.zIndex_ = zIndex;
    }
}
function toFunction(obj) {
    let styleFunction;
    if (typeof obj === 'function') styleFunction = obj;
    else {
        /**
     * @type {Array<Style>}
     */ let styles;
        if (Array.isArray(obj)) styles = obj;
        else {
            (0, _assertsJs.assert)(typeof /** @type {?} */ obj.getZIndex === 'function', 'Expected an `Style` or an array of `Style`');
            const style = /** @type {Style} */ obj;
            styles = [
                style
            ];
        }
        styleFunction = function() {
            return styles;
        };
    }
    return styleFunction;
}
/**
 * @type {Array<Style>|null}
 */ let defaultStyles = null;
function createDefaultStyle(feature, resolution) {
    // We don't use an immediately-invoked function
    // and a closure so we don't get an error at script evaluation time in
    // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
    // canvas.getContext('2d') at construction time, which will cause an.error
    // in such browsers.)
    if (!defaultStyles) {
        const fill = new (0, _fillJsDefault.default)({
            color: 'rgba(255,255,255,0.4)'
        });
        const stroke = new (0, _strokeJsDefault.default)({
            color: '#3399CC',
            width: 1.25
        });
        defaultStyles = [
            new Style({
                image: new (0, _circleJsDefault.default)({
                    fill: fill,
                    stroke: stroke,
                    radius: 5
                }),
                fill: fill,
                stroke: stroke
            })
        ];
    }
    return defaultStyles;
}
function createEditingStyle() {
    /** @type {Object<import("../geom/Geometry.js").Type, Array<Style>>} */ const styles = {};
    const white = [
        255,
        255,
        255,
        1
    ];
    const blue = [
        0,
        153,
        255,
        1
    ];
    const width = 3;
    styles['Polygon'] = [
        new Style({
            fill: new (0, _fillJsDefault.default)({
                color: [
                    255,
                    255,
                    255,
                    0.5
                ]
            })
        })
    ];
    styles['MultiPolygon'] = styles['Polygon'];
    styles['LineString'] = [
        new Style({
            stroke: new (0, _strokeJsDefault.default)({
                color: white,
                width: width + 2
            })
        }),
        new Style({
            stroke: new (0, _strokeJsDefault.default)({
                color: blue,
                width: width
            })
        })
    ];
    styles['MultiLineString'] = styles['LineString'];
    styles['Circle'] = styles['Polygon'].concat(styles['LineString']);
    styles['Point'] = [
        new Style({
            image: new (0, _circleJsDefault.default)({
                radius: width * 2,
                fill: new (0, _fillJsDefault.default)({
                    color: blue
                }),
                stroke: new (0, _strokeJsDefault.default)({
                    color: white,
                    width: width / 2
                })
            }),
            zIndex: Infinity
        })
    ];
    styles['MultiPoint'] = styles['Point'];
    styles['GeometryCollection'] = styles['Polygon'].concat(styles['LineString'], styles['Point']);
    return styles;
}
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */ function defaultGeometryFunction(feature) {
    return feature.getGeometry();
}
exports.default = Style;

},{"./Circle.js":"cSS3Y","./Fill.js":"4fB56","./Stroke.js":"5Cq04","../asserts.js":"e4TiF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cSS3Y":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Circle
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regularShapeJs = require("./RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode
 */ /**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */ class CircleStyle extends (0, _regularShapeJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {
            radius: 5
        };
        super({
            points: Infinity,
            fill: options.fill,
            radius: options.radius,
            stroke: options.stroke,
            scale: options.scale !== undefined ? options.scale : 1,
            rotation: options.rotation !== undefined ? options.rotation : 0,
            rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ],
            declutterMode: options.declutterMode
        });
    }
    /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        const style = new CircleStyle({
            fill: this.getFill() ? this.getFill().clone() : undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            radius: this.getRadius(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
    }
    /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */ setRadius(radius) {
        this.radius_ = radius;
        this.render();
    }
}
exports.default = CircleStyle;

},{"./RegularShape.js":"44xDg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"44xDg":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/RegularShape
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("./Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _colorJs = require("../color.js");
var _colorlikeJs = require("../colorlike.js");
var _domJs = require("../dom.js");
var _canvasJs = require("../render/canvas.js");
/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [radius2] Second radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's points facing up.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the shape in pixels.
 * Positive values will shift the shape right and up.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */ /**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike|undefined} strokeStyle StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {CanvasLineCap} lineCap LineCap.
 * @property {Array<number>|null} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */ /**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */ class RegularShape extends (0, _imageJsDefault.default) {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        /**
     * @type {boolean}
     */ const rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
        super({
            opacity: 1,
            rotateWithView: rotateWithView,
            rotation: options.rotation !== undefined ? options.rotation : 0,
            scale: options.scale !== undefined ? options.scale : 1,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ],
            declutterMode: options.declutterMode
        });
        /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */ this.canvases_;
        /**
     * @private
     * @type {HTMLCanvasElement|null}
     */ this.hitDetectionCanvas_ = null;
        /**
     * @private
     * @type {import("./Fill.js").default|null}
     */ this.fill_ = options.fill !== undefined ? options.fill : null;
        /**
     * @private
     * @type {Array<number>}
     */ this.origin_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {number}
     */ this.points_ = options.points;
        /**
     * @protected
     * @type {number}
     */ this.radius_ = options.radius !== undefined ? options.radius : options.radius1;
        /**
     * @private
     * @type {number|undefined}
     */ this.radius2_ = options.radius2;
        /**
     * @private
     * @type {number}
     */ this.angle_ = options.angle !== undefined ? options.angle : 0;
        /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.size_;
        /**
     * @private
     * @type {RenderOptions}
     */ this.renderOptions_;
        this.render();
    }
    /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        const style = new RegularShape({
            fill: this.getFill() ? this.getFill().clone() : undefined,
            points: this.getPoints(),
            radius: this.getRadius(),
            radius2: this.getRadius2(),
            angle: this.getAngle(),
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
    }
    /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */ getAnchor() {
        const size = this.size_;
        const displacement = this.getDisplacement();
        const scale = this.getScaleArray();
        // anchor is scaled by renderer but displacement should not be scaled
        // so divide by scale here
        return [
            size[0] / 2 - displacement[0] / scale[0],
            size[1] / 2 + displacement[1] / scale[1]
        ];
    }
    /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */ getAngle() {
        return this.angle_;
    }
    /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */ getFill() {
        return this.fill_;
    }
    /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */ setFill(fill) {
        this.fill_ = fill;
        this.render();
    }
    /**
   * @return {HTMLCanvasElement} Image element.
   */ getHitDetectionImage() {
        if (!this.hitDetectionCanvas_) this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(this.renderOptions_);
        return this.hitDetectionCanvas_;
    }
    /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */ getImage(pixelRatio) {
        let image = this.canvases_[pixelRatio];
        if (!image) {
            const renderOptions = this.renderOptions_;
            const context = (0, _domJs.createCanvasContext2D)(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
            this.draw_(renderOptions, context, pixelRatio);
            image = context.canvas;
            this.canvases_[pixelRatio] = image;
        }
        return image;
    }
    /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */ getPixelRatio(pixelRatio) {
        return pixelRatio;
    }
    /**
   * @return {import("../size.js").Size} Image size.
   */ getImageSize() {
        return this.size_;
    }
    /**
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return (0, _imageStateJsDefault.default).LOADED;
    }
    /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */ getOrigin() {
        return this.origin_;
    }
    /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */ getPoints() {
        return this.points_;
    }
    /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */ getRadius() {
        return this.radius_;
    }
    /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */ getRadius2() {
        return this.radius2_;
    }
    /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */ getSize() {
        return this.size_;
    }
    /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */ getStroke() {
        return this.stroke_;
    }
    /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */ setStroke(stroke) {
        this.stroke_ = stroke;
        this.render();
    }
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ listenImageChange(listener) {}
    /**
   * Load not yet loaded URI.
   */ load() {}
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ unlistenImageChange(listener) {}
    /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */ calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== 'bevel' && lineJoin !== 'miter') return strokeWidth;
        // m  | ^
        // i  | |\                  .
        // t >|  #\
        // e  | |\ \              .
        // r      \s\
        //      |  \t\          .                 .
        //          \r\                      .   .
        //      |    \o\      .          .  . . .
        //          e \k\            .  .    . .
        //      |      \e\  .    .  .       . .
        //       d      \ \  .  .          . .
        //      | _ _a_ _\#  .            . .
        //   r1          / `             . .
        //      |                       . .
        //       b     /               . .
        //      |                     . .
        //           / r2            . .
        //      |                        .   .
        //         /                           .   .
        //      |α                                   .   .
        //       /                                         .   .
        //      ° center
        let r1 = this.radius_;
        let r2 = this.radius2_ === undefined ? r1 : this.radius2_;
        if (r1 < r2) {
            const tmp = r1;
            r1 = r2;
            r2 = tmp;
        }
        const points = this.radius2_ === undefined ? this.points_ : this.points_ * 2;
        const alpha = 2 * Math.PI / points;
        const a = r2 * Math.sin(alpha);
        const b = Math.sqrt(r2 * r2 - a * a);
        const d = r1 - b;
        const e = Math.sqrt(a * a + d * d);
        const miterRatio = e / a;
        if (lineJoin === 'miter' && miterRatio <= miterLimit) return miterRatio * strokeWidth;
        // Calculate the distance from center to the stroke corner where
        // it was cut short because of the miter limit.
        //              l
        //        ----+---- <= distance from center to here is maxr
        //       /####|k ##\
        //      /#####^#####\
        //     /#### /+\# s #\
        //    /### h/+++\# t #\
        //   /### t/+++++\# r #\
        //  /### a/+++++++\# o #\
        // /### p/++ fill +\# k #\
        ///#### /+++++^+++++\# e #\
        //#####/+++++/+\+++++\#####\
        const k = strokeWidth / 2 / miterRatio;
        const l = strokeWidth / 2 * (d / e);
        const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
        const bevelAdd = maxr - r1;
        if (this.radius2_ === undefined || lineJoin === 'bevel') return bevelAdd * 2;
        // If outer miter is over the miter limit the inner miter may reach through the
        // center and be longer than the bevel, same calculation as above but swap r1 / r2.
        const aa = r1 * Math.sin(alpha);
        const bb = Math.sqrt(r1 * r1 - aa * aa);
        const dd = r2 - bb;
        const ee = Math.sqrt(aa * aa + dd * dd);
        const innerMiterRatio = ee / aa;
        if (innerMiterRatio <= miterLimit) {
            const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
            return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
    }
    /**
   * @return {RenderOptions}  The render options
   * @protected
   */ createRenderOptions() {
        let lineCap = (0, _canvasJs.defaultLineCap);
        let lineJoin = (0, _canvasJs.defaultLineJoin);
        let miterLimit = 0;
        let lineDash = null;
        let lineDashOffset = 0;
        let strokeStyle;
        let strokeWidth = 0;
        if (this.stroke_) {
            strokeStyle = (0, _colorlikeJs.asColorLike)(this.stroke_.getColor() ?? (0, _canvasJs.defaultStrokeStyle));
            strokeWidth = this.stroke_.getWidth() ?? (0, _canvasJs.defaultLineWidth);
            lineDash = this.stroke_.getLineDash();
            lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
            lineJoin = this.stroke_.getLineJoin() ?? (0, _canvasJs.defaultLineJoin);
            lineCap = this.stroke_.getLineCap() ?? (0, _canvasJs.defaultLineCap);
            miterLimit = this.stroke_.getMiterLimit() ?? (0, _canvasJs.defaultMiterLimit);
        }
        const add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
        const size = Math.ceil(2 * maxRadius + add);
        return {
            strokeStyle: strokeStyle,
            strokeWidth: strokeWidth,
            size: size,
            lineCap: lineCap,
            lineDash: lineDash,
            lineDashOffset: lineDashOffset,
            lineJoin: lineJoin,
            miterLimit: miterLimit
        };
    }
    /**
   * @protected
   */ render() {
        this.renderOptions_ = this.createRenderOptions();
        const size = this.renderOptions_.size;
        this.canvases_ = {};
        this.hitDetectionCanvas_ = null;
        this.size_ = [
            size,
            size
        ];
    }
    /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */ draw_(renderOptions, context, pixelRatio) {
        context.scale(pixelRatio, pixelRatio);
        // set origin to canvas center
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        if (this.fill_) {
            let color = this.fill_.getColor();
            if (color === null) color = (0, _canvasJs.defaultFillStyle);
            context.fillStyle = (0, _colorlikeJs.asColorLike)(color);
            context.fill();
        }
        if (renderOptions.strokeStyle) {
            context.strokeStyle = renderOptions.strokeStyle;
            context.lineWidth = renderOptions.strokeWidth;
            if (renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
            }
            context.lineCap = renderOptions.lineCap;
            context.lineJoin = renderOptions.lineJoin;
            context.miterLimit = renderOptions.miterLimit;
            context.stroke();
        }
    }
    /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */ createHitDetectionCanvas_(renderOptions) {
        let context;
        if (this.fill_) {
            let color = this.fill_.getColor();
            // determine if fill is transparent (or pattern or gradient)
            let opacity = 0;
            if (typeof color === 'string') color = (0, _colorJs.asArray)(color);
            if (color === null) opacity = 1;
            else if (Array.isArray(color)) opacity = color.length === 4 ? color[3] : 1;
            if (opacity === 0) {
                // if a transparent fill style is set, create an extra hit-detection image
                // with a default fill style
                context = (0, _domJs.createCanvasContext2D)(renderOptions.size, renderOptions.size);
                this.drawHitDetectionCanvas_(renderOptions, context);
            }
        }
        return context ? context.canvas : this.getImage(1);
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */ createPath_(context) {
        let points = this.points_;
        const radius = this.radius_;
        if (points === Infinity) context.arc(0, 0, radius, 0, 2 * Math.PI);
        else {
            const radius2 = this.radius2_ === undefined ? radius : this.radius2_;
            if (this.radius2_ !== undefined) points *= 2;
            const startAngle = this.angle_ - Math.PI / 2;
            const step = 2 * Math.PI / points;
            for(let i = 0; i < points; i++){
                const angle0 = startAngle + i * step;
                const radiusC = i % 2 === 0 ? radius : radius2;
                context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
            }
            context.closePath();
        }
    }
    /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */ drawHitDetectionCanvas_(renderOptions, context) {
        // set origin to canvas center
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        context.fillStyle = (0, _canvasJs.defaultFillStyle);
        context.fill();
        if (renderOptions.strokeStyle) {
            context.strokeStyle = renderOptions.strokeStyle;
            context.lineWidth = renderOptions.strokeWidth;
            if (renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
            }
            context.lineJoin = renderOptions.lineJoin;
            context.miterLimit = renderOptions.miterLimit;
            context.stroke();
        }
    }
}
exports.default = RegularShape;

},{"../ImageState.js":"c4jJS","./Image.js":"eyoR9","../color.js":"4tahz","../colorlike.js":"ftcFo","../dom.js":"84QzQ","../render/canvas.js":"e85iQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c4jJS":[function(require,module,exports,__globalThis) {
/**
 * @module ol/ImageState
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyoR9":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilJs = require("../util.js");
var _sizeJs = require("../size.js");
/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 * @property {"declutter"|"obstacle"|"none"|undefined} declutterMode Declutter mode: `declutter`, `obstacle`, 'none */ /**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */ class ImageStyle {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        /**
     * @private
     * @type {number}
     */ this.opacity_ = options.opacity;
        /**
     * @private
     * @type {boolean}
     */ this.rotateWithView_ = options.rotateWithView;
        /**
     * @private
     * @type {number}
     */ this.rotation_ = options.rotation;
        /**
     * @private
     * @type {number|import("../size.js").Size}
     */ this.scale_ = options.scale;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.scaleArray_ = (0, _sizeJs.toSize)(options.scale);
        /**
     * @private
     * @type {Array<number>}
     */ this.displacement_ = options.displacement;
        /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */ this.declutterMode_ = options.declutterMode;
    }
    /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        return new ImageStyle({
            opacity: this.getOpacity(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
    }
    /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */ getOpacity() {
        return this.opacity_;
    }
    /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */ getRotateWithView() {
        return this.rotateWithView_;
    }
    /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */ getRotation() {
        return this.rotation_;
    }
    /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */ getScale() {
        return this.scale_;
    }
    /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */ getScaleArray() {
        return this.scaleArray_;
    }
    /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */ getDisplacement() {
        return this.displacement_;
    }
    /**
   * Get the declutter mode of the shape
   * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
   * @api
   */ getDeclutterMode() {
        return this.declutterMode_;
    }
    /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */ getAnchor() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */ getImage(pixelRatio) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */ getHitDetectionImage() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */ getPixelRatio(pixelRatio) {
        return 1;
    }
    /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */ getImageSize() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */ getOrigin() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */ getSize() {
        return (0, _utilJs.abstract)();
    }
    /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */ setDisplacement(displacement) {
        this.displacement_ = displacement;
    }
    /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */ setOpacity(opacity) {
        this.opacity_ = opacity;
    }
    /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */ setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
    }
    /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */ setRotation(rotation) {
        this.rotation_ = rotation;
    }
    /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */ setScale(scale) {
        this.scale_ = scale;
        this.scaleArray_ = (0, _sizeJs.toSize)(scale);
    }
    /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ listenImageChange(listener) {
        (0, _utilJs.abstract)();
    }
    /**
   * Load not yet loaded URI.
   * @abstract
   */ load() {
        (0, _utilJs.abstract)();
    }
    /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ unlistenImageChange(listener) {
        (0, _utilJs.abstract)();
    }
}
exports.default = ImageStyle;

},{"../util.js":"pLBjQ","../size.js":"lKEPe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lKEPe":[function(require,module,exports,__globalThis) {
/**
 * @module ol/size
 */ /**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */ /**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The buffered size.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buffer", ()=>buffer);
/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */ parcelHelpers.export(exports, "hasArea", ()=>hasArea);
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} The scaled size.
 */ parcelHelpers.export(exports, "scale", ()=>scale);
/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [dest] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */ parcelHelpers.export(exports, "toSize", ()=>toSize);
function buffer(size, num, dest) {
    if (dest === undefined) dest = [
        0,
        0
    ];
    dest[0] = size[0] + 2 * num;
    dest[1] = size[1] + 2 * num;
    return dest;
}
function hasArea(size) {
    return size[0] > 0 && size[1] > 0;
}
function scale(size, ratio, dest) {
    if (dest === undefined) dest = [
        0,
        0
    ];
    dest[0] = size[0] * ratio + 0.5 | 0;
    dest[1] = size[1] * ratio + 0.5 | 0;
    return dest;
}
function toSize(size, dest) {
    if (Array.isArray(size)) return size;
    if (dest === undefined) dest = [
        size,
        size
    ];
    else {
        dest[0] = size;
        dest[1] = size;
    }
    return dest;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4tahz":[function(require,module,exports,__globalThis) {
/**
 * @module ol/color
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */ /**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */ parcelHelpers.export(exports, "asString", ()=>asString);
/**
 * @param {Color} color A color that may or may not have an alpha channel.
 * @return {Color} The input color with an alpha channel.  If the input color has
 * an alpha channel, the input color will be returned unchanged.  Otherwise, a new
 * array will be returned with the input color and an alpha channel of 1.
 */ parcelHelpers.export(exports, "withAlpha", ()=>withAlpha);
/**
 * @param {Color} color RGBA color.
 * @return {Color} LCHuv color with alpha.
 */ parcelHelpers.export(exports, "rgbaToLcha", ()=>rgbaToLcha);
/**
 * @param {Color} color LCHuv color with alpha.
 * @return {Color} RGBA color.
 */ parcelHelpers.export(exports, "lchaToRgba", ()=>lchaToRgba);
/**
 * @param {string} s String.
 * @return {Color} Color.
 */ parcelHelpers.export(exports, "fromString", ()=>fromString);
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */ parcelHelpers.export(exports, "asArray", ()=>asArray);
/**
 * Exported for the tests.
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */ parcelHelpers.export(exports, "normalize", ()=>normalize);
/**
 * @param {Color} color Color.
 * @return {string} String.
 */ parcelHelpers.export(exports, "toString", ()=>toString);
/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */ parcelHelpers.export(exports, "isStringColor", ()=>isStringColor);
var _lchuvJs = require("color-space/lchuv.js");
var _lchuvJsDefault = parcelHelpers.interopDefault(_lchuvJs);
var _colorRgba = require("color-rgba");
var _colorRgbaDefault = parcelHelpers.interopDefault(_colorRgba);
var _rgbJs = require("color-space/rgb.js");
var _rgbJsDefault = parcelHelpers.interopDefault(_rgbJs);
var _xyzJs = require("color-space/xyz.js");
var _xyzJsDefault = parcelHelpers.interopDefault(_xyzJs);
var _mathJs = require("./math.js");
function asString(color) {
    if (typeof color === 'string') return color;
    return toString(color);
}
/**
 * @type {number}
 */ const MAX_CACHE_SIZE = 1024;
/**
 * We maintain a small cache of parsed strings.  Whenever the cache grows too large,
 * we delete an arbitrary set of the entries.
 *
 * @type {Object<string, Color>}
 */ const cache = {};
/**
 * @type {number}
 */ let cacheSize = 0;
function withAlpha(color) {
    if (color.length === 4) return color;
    const output = color.slice();
    output[3] = 1;
    return output;
}
function rgbaToLcha(color) {
    const output = (0, _xyzJsDefault.default).lchuv((0, _rgbJsDefault.default).xyz(color));
    output[3] = color[3];
    return output;
}
function lchaToRgba(color) {
    const output = (0, _xyzJsDefault.default).rgb((0, _lchuvJsDefault.default).xyz(color));
    output[3] = color[3];
    return output;
}
function fromString(s) {
    if (cache.hasOwnProperty(s)) return cache[s];
    if (cacheSize >= MAX_CACHE_SIZE) {
        let i = 0;
        for(const key in cache)if ((i++ & 3) === 0) {
            delete cache[key];
            --cacheSize;
        }
    }
    const color = (0, _colorRgbaDefault.default)(s);
    if (color.length !== 4) throw new Error('Failed to parse "' + s + '" as color');
    for (const c of color){
        if (isNaN(c)) throw new Error('Failed to parse "' + s + '" as color');
    }
    normalize(color);
    cache[s] = color;
    ++cacheSize;
    return color;
}
function asArray(color) {
    if (Array.isArray(color)) return color;
    return fromString(color);
}
function normalize(color) {
    color[0] = (0, _mathJs.clamp)(color[0] + 0.5 | 0, 0, 255);
    color[1] = (0, _mathJs.clamp)(color[1] + 0.5 | 0, 0, 255);
    color[2] = (0, _mathJs.clamp)(color[2] + 0.5 | 0, 0, 255);
    color[3] = (0, _mathJs.clamp)(color[3], 0, 1);
    return color;
}
function toString(color) {
    let r = color[0];
    if (r != (r | 0)) r = r + 0.5 | 0;
    let g = color[1];
    if (g != (g | 0)) g = g + 0.5 | 0;
    let b = color[2];
    if (b != (b | 0)) b = b + 0.5 | 0;
    const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}
function isStringColor(s) {
    try {
        fromString(s);
        return true;
    } catch (_) {
        return false;
    }
}

},{"color-space/lchuv.js":"cwSjJ","color-rgba":"4wFCR","color-space/rgb.js":"3FDnE","color-space/xyz.js":"eEtI6","./math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cwSjJ":[function(require,module,exports,__globalThis) {
/**
 * Cylindrical CIE LUV
 *
 * @module color-space/lchuv
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _luvJs = require("./luv.js");
var _luvJsDefault = parcelHelpers.interopDefault(_luvJs);
var _xyzJs = require("./xyz.js");
var _xyzJsDefault = parcelHelpers.interopDefault(_xyzJs);
// cylindrical luv
var lchuv = {
    name: 'lchuv',
    channel: [
        'lightness',
        'chroma',
        'hue'
    ],
    alias: [
        'LCHuv',
        'cielchuv'
    ],
    min: [
        0,
        0,
        0
    ],
    max: [
        100,
        100,
        360
    ],
    luv: function(luv) {
        var l = luv[0], c = luv[1], h = luv[2], u, v, hr;
        hr = h / 360 * 2 * Math.PI;
        u = c * Math.cos(hr);
        v = c * Math.sin(hr);
        return [
            l,
            u,
            v
        ];
    },
    xyz: function(arg) {
        return (0, _luvJsDefault.default).xyz(lchuv.luv(arg));
    }
};
exports.default = lchuv;
(0, _luvJsDefault.default).lchuv = function(luv) {
    var l = luv[0], u = luv[1], v = luv[2];
    var c = Math.sqrt(u * u + v * v);
    var hr = Math.atan2(v, u);
    var h = hr * 360 / 2 / Math.PI;
    if (h < 0) h += 360;
    return [
        l,
        c,
        h
    ];
};
(0, _xyzJsDefault.default).lchuv = function(arg) {
    return (0, _luvJsDefault.default).lchuv((0, _xyzJsDefault.default).luv(arg));
};

},{"./luv.js":"aBUX7","./xyz.js":"eEtI6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aBUX7":[function(require,module,exports,__globalThis) {
/**
 * CIE LUV (C'est la vie)
 *
 * @module color-space/luv
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _xyzJs = require("./xyz.js");
var _xyzJsDefault = parcelHelpers.interopDefault(_xyzJs);
var luv = {
    name: 'luv',
    //NOTE: luv has no rigidly defined limits
    //easyrgb fails to get proper coords
    //boronine states no rigid limits
    //colorMine refers this ones:
    min: [
        0,
        -134,
        -140
    ],
    max: [
        100,
        224,
        122
    ],
    channel: [
        'lightness',
        'u',
        'v'
    ],
    alias: [
        'LUV',
        'cieluv',
        'cie1976'
    ],
    xyz: function(arg, i, o) {
        var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
        l = arg[0], u = arg[1], v = arg[2];
        if (l === 0) return [
            0,
            0,
            0
        ];
        //get constants
        //var e = 0.008856451679035631; //(6/29)^3
        var k = 0.0011070564598794539; //(3/29)^3
        //get illuminant/observer
        i = i || 'D65';
        o = o || 2;
        xn = (0, _xyzJsDefault.default).whitepoint[o][i][0];
        yn = (0, _xyzJsDefault.default).whitepoint[o][i][1];
        zn = (0, _xyzJsDefault.default).whitepoint[o][i][2];
        un = 4 * xn / (xn + 15 * yn + 3 * zn);
        vn = 9 * yn / (xn + 15 * yn + 3 * zn);
        // un = 0.19783000664283;
        // vn = 0.46831999493879;
        _u = u / (13 * l) + un || 0;
        _v = v / (13 * l) + vn || 0;
        y = l > 8 ? yn * Math.pow((l + 16) / 116, 3) : yn * l * k;
        //wikipedia method
        x = y * 9 * _u / (4 * _v) || 0;
        z = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;
        //boronine method
        //https://github.com/boronine/husl/blob/master/husl.coffee#L201
        // x = 0 - (9 * y * _u) / ((_u - 4) * _v - _u * _v);
        // z = (9 * y - (15 * _v * y) - (_v * x)) / (3 * _v);
        return [
            x,
            y,
            z
        ];
    }
};
exports.default = luv;
// http://www.brucelindbloom.com/index.html?Equations.html
// https://github.com/boronine/husl/blob/master/husl.coffee
//i - illuminant
//o - observer
(0, _xyzJsDefault.default).luv = function(arg, i, o) {
    var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
    //get constants
    var e = 0.008856451679035631; //(6/29)^3
    var k = 903.2962962962961; //(29/3)^3
    //get illuminant/observer coords
    i = i || 'D65';
    o = o || 2;
    xn = (0, _xyzJsDefault.default).whitepoint[o][i][0];
    yn = (0, _xyzJsDefault.default).whitepoint[o][i][1];
    zn = (0, _xyzJsDefault.default).whitepoint[o][i][2];
    un = 4 * xn / (xn + 15 * yn + 3 * zn);
    vn = 9 * yn / (xn + 15 * yn + 3 * zn);
    x = arg[0], y = arg[1], z = arg[2];
    _u = 4 * x / (x + 15 * y + 3 * z) || 0;
    _v = 9 * y / (x + 15 * y + 3 * z) || 0;
    var yr = y / yn;
    l = yr <= e ? k * yr : 116 * Math.pow(yr, 1 / 3) - 16;
    u = 13 * l * (_u - un);
    v = 13 * l * (_v - vn);
    return [
        l,
        u,
        v
    ];
};

},{"./xyz.js":"eEtI6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eEtI6":[function(require,module,exports,__globalThis) {
/**
 * CIE XYZ
 *
 * @module  color-space/xyz
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rgbJs = require("./rgb.js");
var _rgbJsDefault = parcelHelpers.interopDefault(_rgbJs);
const xyz = {
    name: 'xyz',
    min: [
        0,
        0,
        0
    ],
    channel: [
        'X',
        'Y',
        'Z'
    ],
    alias: [
        'XYZ',
        'ciexyz',
        'cie1931'
    ],
    // Whitepoint reference values with observer/illuminant
    // http://en.wikipedia.org/wiki/Standard_illuminant
    whitepoint: {
        //1931 2°
        2: {
            //incadescent
            A: [
                109.85,
                100,
                35.585
            ],
            // B:[],
            C: [
                98.074,
                100,
                118.232
            ],
            D50: [
                96.422,
                100,
                82.521
            ],
            D55: [
                95.682,
                100,
                92.149
            ],
            //daylight
            D65: [
                95.045592705167,
                100,
                108.9057750759878
            ],
            D75: [
                94.972,
                100,
                122.638
            ],
            //flourescent
            // F1: [],
            F2: [
                99.187,
                100,
                67.395
            ],
            // F3: [],
            // F4: [],
            // F5: [],
            // F6:[],
            F7: [
                95.044,
                100,
                108.755
            ],
            // F8: [],
            // F9: [],
            // F10: [],
            F11: [
                100.966,
                100,
                64.370
            ],
            // F12: [],
            E: [
                100,
                100,
                100
            ]
        },
        //1964  10°
        10: {
            //incadescent
            A: [
                111.144,
                100,
                35.200
            ],
            C: [
                97.285,
                100,
                116.145
            ],
            D50: [
                96.720,
                100,
                81.427
            ],
            D55: [
                95.799,
                100,
                90.926
            ],
            //daylight
            D65: [
                94.811,
                100,
                107.304
            ],
            D75: [
                94.416,
                100,
                120.641
            ],
            //flourescent
            F2: [
                103.280,
                100,
                69.026
            ],
            F7: [
                95.792,
                100,
                107.687
            ],
            F11: [
                103.866,
                100,
                65.627
            ],
            E: [
                100,
                100,
                100
            ]
        }
    }
};
/**
 * Top values are the whitepoint’s top values, default are D65
 */ xyz.max = xyz.whitepoint[2].D65;
/**
 * Transform xyz to rgb
 *
 * @param {Array<number>} _xyz Array of xyz values
 * @param {Array<number>} white Whitepoint reference
 * @return {Array<number>} RGB values
 */ xyz.rgb = function(_xyz, white) {
    // FIXME: make sure we have to divide like this. Probably we have to replace matrix as well then
    white = white || xyz.whitepoint[2].E;
    var x = _xyz[0] / white[0], y = _xyz[1] / white[1], z = _xyz[2] / white[2], r, g, b;
    // assume sRGB
    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
    r = x * 3.240969941904521 + y * -1.537383177570093 + z * -0.498610760293;
    g = x * -0.96924363628087 + y * 1.87596750150772 + z * 0.041555057407175;
    b = x * 0.055630079696993 + y * -0.20397695888897 + z * 1.056971514242878;
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [
        r * 255,
        g * 255,
        b * 255
    ];
};
/**
 * RGB to XYZ
 *
 * @param {Array<number>} rgb RGB channels
 *
 * @return {Array<number>} XYZ channels
 */ (0, _rgbJsDefault.default).xyz = function(rgb, white) {
    var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
    // assume sRGB
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.41239079926595 + g * 0.35758433938387 + b * 0.18048078840183;
    var y = r * 0.21263900587151 + g * 0.71516867876775 + b * 0.072192315360733;
    var z = r * 0.019330818715591 + g * 0.11919477979462 + b * 0.95053215224966;
    white = white || xyz.whitepoint[2].E;
    return [
        x * white[0],
        y * white[1],
        z * white[2]
    ];
};
exports.default = xyz;

},{"./rgb.js":"3FDnE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3FDnE":[function(require,module,exports,__globalThis) {
/**
 * RGB space.
 *
 * @module  color-space/rgb
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const rgb = {
    name: 'rgb',
    min: [
        0,
        0,
        0
    ],
    max: [
        255,
        255,
        255
    ],
    channel: [
        'red',
        'green',
        'blue'
    ],
    alias: [
        'RGB'
    ]
};
exports.default = rgb;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4wFCR":[function(require,module,exports,__globalThis) {
/** @module  color-rgba */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>rgba);
var _colorParse = require("color-parse");
var _colorParseDefault = parcelHelpers.interopDefault(_colorParse);
var _rgbJs = require("color-space/rgb.js");
var _rgbJsDefault = parcelHelpers.interopDefault(_rgbJs);
var _hslJs = require("color-space/hsl.js");
var _hslJsDefault = parcelHelpers.interopDefault(_hslJs);
function rgba(color) {
    // template literals
    if (Array.isArray(color) && color.raw) color = String.raw(...arguments);
    if (color instanceof Number) color = +color;
    var values, i, l;
    //attempt to parse non-array arguments
    var parsed = (0, _colorParseDefault.default)(color);
    if (!parsed.space) return [];
    const min = parsed.space[0] === 'h' ? (0, _hslJsDefault.default).min : (0, _rgbJsDefault.default).min;
    const max = parsed.space[0] === 'h' ? (0, _hslJsDefault.default).max : (0, _rgbJsDefault.default).max;
    values = Array(3);
    values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
    values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
    values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);
    if (parsed.space[0] === 'h') values = (0, _hslJsDefault.default).rgb(values);
    values.push(Math.min(Math.max(parsed.alpha, 0), 1));
    return values;
}

},{"color-parse":"6IyDt","color-space/rgb.js":"3FDnE","color-space/hsl.js":"7h1FD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6IyDt":[function(require,module,exports,__globalThis) {
/**
 * @module color-parse
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorName = require("color-name");
var _colorNameDefault = parcelHelpers.interopDefault(_colorName);
exports.default = parse;
/**
 * Base hues
 * http://dev.w3.org/csswg/css-color/#typedef-named-hue
 */ //FIXME: use external hue detector
var baseHues = {
    red: 0,
    orange: 60,
    yellow: 120,
    green: 180,
    blue: 240,
    purple: 300
};
/**
 * Parse color from the string passed
 *
 * @return {Object} A space indicator `space`, an array `values` and `alpha`
 */ function parse(cstr) {
    var m, parts = [], alpha = 1, space;
    //numeric case
    if (typeof cstr === 'number') return {
        space: 'rgb',
        values: [
            cstr >>> 16,
            (cstr & 0x00ff00) >>> 8,
            cstr & 0x0000ff
        ],
        alpha: 1
    };
    if (typeof cstr === 'number') return {
        space: 'rgb',
        values: [
            cstr >>> 16,
            (cstr & 0x00ff00) >>> 8,
            cstr & 0x0000ff
        ],
        alpha: 1
    };
    cstr = String(cstr).toLowerCase();
    //keyword
    if ((0, _colorNameDefault.default)[cstr]) {
        parts = (0, _colorNameDefault.default)[cstr].slice();
        space = 'rgb';
    } else if (cstr === 'transparent') {
        alpha = 0;
        space = 'rgb';
        parts = [
            0,
            0,
            0
        ];
    } else if (cstr[0] === '#') {
        var base = cstr.slice(1);
        var size = base.length;
        var isShort = size <= 4;
        alpha = 1;
        if (isShort) {
            parts = [
                parseInt(base[0] + base[0], 16),
                parseInt(base[1] + base[1], 16),
                parseInt(base[2] + base[2], 16)
            ];
            if (size === 4) alpha = parseInt(base[3] + base[3], 16) / 255;
        } else {
            parts = [
                parseInt(base[0] + base[1], 16),
                parseInt(base[2] + base[3], 16),
                parseInt(base[4] + base[5], 16)
            ];
            if (size === 8) alpha = parseInt(base[6] + base[7], 16) / 255;
        }
        if (!parts[0]) parts[0] = 0;
        if (!parts[1]) parts[1] = 0;
        if (!parts[2]) parts[2] = 0;
        space = 'rgb';
    } else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
        var name = m[1];
        space = name.replace(/a$/, '');
        var dims = space === 'cmyk' ? 4 : space === 'gray' ? 1 : 3;
        parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);
        // color(srgb-linear x x x) -> srgb-linear(x x x)
        if (space === 'color') space = parts.shift();
        parts = parts.map(function(x, i) {
            //<percentage>
            if (x[x.length - 1] === '%') {
                x = parseFloat(x) / 100;
                // alpha -> 0..1
                if (i === 3) return x;
                // rgb -> 0..255
                if (space === 'rgb') return x * 255;
                // hsl, hwb H -> 0..100
                if (space[0] === 'h') return x * 100;
                // lch, lab L -> 0..100
                if (space[0] === 'l' && !i) return x * 100;
                // lab A B -> -125..125
                if (space === 'lab') return x * 125;
                // lch C -> 0..150, H -> 0..360
                if (space === 'lch') return i < 2 ? x * 150 : x * 360;
                // oklch/oklab L -> 0..1
                if (space[0] === 'o' && !i) return x;
                // oklab A B -> -0.4..0.4
                if (space === 'oklab') return x * 0.4;
                // oklch C -> 0..0.4, H -> 0..360
                if (space === 'oklch') return i < 2 ? x * 0.4 : x * 360;
                // color(xxx) -> 0..1
                return x;
            }
            //hue
            if (space[i] === 'h' || i === 2 && space[space.length - 1] === 'h') {
                //<base-hue>
                if (baseHues[x] !== undefined) return baseHues[x];
                //<deg>
                if (x.endsWith('deg')) return parseFloat(x);
                //<turn>
                if (x.endsWith('turn')) return parseFloat(x) * 360;
                if (x.endsWith('grad')) return parseFloat(x) * 360 / 400;
                if (x.endsWith('rad')) return parseFloat(x) * 180 / Math.PI;
            }
            if (x === 'none') return 0;
            return parseFloat(x);
        });
        alpha = parts.length > dims ? parts.pop() : 1;
    } else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
        parts = cstr.match(/([0-9]+)/g).map(function(value) {
            return parseFloat(value);
        });
        space = cstr.match(/([a-z])/ig)?.join('')?.toLowerCase() || 'rgb';
    }
    return {
        space,
        values: parts,
        alpha
    };
}

},{"color-name":"dOQo1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dOQo1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    aliceblue: [
        240,
        248,
        255
    ],
    antiquewhite: [
        250,
        235,
        215
    ],
    aqua: [
        0,
        255,
        255
    ],
    aquamarine: [
        127,
        255,
        212
    ],
    azure: [
        240,
        255,
        255
    ],
    beige: [
        245,
        245,
        220
    ],
    bisque: [
        255,
        228,
        196
    ],
    black: [
        0,
        0,
        0
    ],
    blanchedalmond: [
        255,
        235,
        205
    ],
    blue: [
        0,
        0,
        255
    ],
    blueviolet: [
        138,
        43,
        226
    ],
    brown: [
        165,
        42,
        42
    ],
    burlywood: [
        222,
        184,
        135
    ],
    cadetblue: [
        95,
        158,
        160
    ],
    chartreuse: [
        127,
        255,
        0
    ],
    chocolate: [
        210,
        105,
        30
    ],
    coral: [
        255,
        127,
        80
    ],
    cornflowerblue: [
        100,
        149,
        237
    ],
    cornsilk: [
        255,
        248,
        220
    ],
    crimson: [
        220,
        20,
        60
    ],
    cyan: [
        0,
        255,
        255
    ],
    darkblue: [
        0,
        0,
        139
    ],
    darkcyan: [
        0,
        139,
        139
    ],
    darkgoldenrod: [
        184,
        134,
        11
    ],
    darkgray: [
        169,
        169,
        169
    ],
    darkgreen: [
        0,
        100,
        0
    ],
    darkgrey: [
        169,
        169,
        169
    ],
    darkkhaki: [
        189,
        183,
        107
    ],
    darkmagenta: [
        139,
        0,
        139
    ],
    darkolivegreen: [
        85,
        107,
        47
    ],
    darkorange: [
        255,
        140,
        0
    ],
    darkorchid: [
        153,
        50,
        204
    ],
    darkred: [
        139,
        0,
        0
    ],
    darksalmon: [
        233,
        150,
        122
    ],
    darkseagreen: [
        143,
        188,
        143
    ],
    darkslateblue: [
        72,
        61,
        139
    ],
    darkslategray: [
        47,
        79,
        79
    ],
    darkslategrey: [
        47,
        79,
        79
    ],
    darkturquoise: [
        0,
        206,
        209
    ],
    darkviolet: [
        148,
        0,
        211
    ],
    deeppink: [
        255,
        20,
        147
    ],
    deepskyblue: [
        0,
        191,
        255
    ],
    dimgray: [
        105,
        105,
        105
    ],
    dimgrey: [
        105,
        105,
        105
    ],
    dodgerblue: [
        30,
        144,
        255
    ],
    firebrick: [
        178,
        34,
        34
    ],
    floralwhite: [
        255,
        250,
        240
    ],
    forestgreen: [
        34,
        139,
        34
    ],
    fuchsia: [
        255,
        0,
        255
    ],
    gainsboro: [
        220,
        220,
        220
    ],
    ghostwhite: [
        248,
        248,
        255
    ],
    gold: [
        255,
        215,
        0
    ],
    goldenrod: [
        218,
        165,
        32
    ],
    gray: [
        128,
        128,
        128
    ],
    green: [
        0,
        128,
        0
    ],
    greenyellow: [
        173,
        255,
        47
    ],
    grey: [
        128,
        128,
        128
    ],
    honeydew: [
        240,
        255,
        240
    ],
    hotpink: [
        255,
        105,
        180
    ],
    indianred: [
        205,
        92,
        92
    ],
    indigo: [
        75,
        0,
        130
    ],
    ivory: [
        255,
        255,
        240
    ],
    khaki: [
        240,
        230,
        140
    ],
    lavender: [
        230,
        230,
        250
    ],
    lavenderblush: [
        255,
        240,
        245
    ],
    lawngreen: [
        124,
        252,
        0
    ],
    lemonchiffon: [
        255,
        250,
        205
    ],
    lightblue: [
        173,
        216,
        230
    ],
    lightcoral: [
        240,
        128,
        128
    ],
    lightcyan: [
        224,
        255,
        255
    ],
    lightgoldenrodyellow: [
        250,
        250,
        210
    ],
    lightgray: [
        211,
        211,
        211
    ],
    lightgreen: [
        144,
        238,
        144
    ],
    lightgrey: [
        211,
        211,
        211
    ],
    lightpink: [
        255,
        182,
        193
    ],
    lightsalmon: [
        255,
        160,
        122
    ],
    lightseagreen: [
        32,
        178,
        170
    ],
    lightskyblue: [
        135,
        206,
        250
    ],
    lightslategray: [
        119,
        136,
        153
    ],
    lightslategrey: [
        119,
        136,
        153
    ],
    lightsteelblue: [
        176,
        196,
        222
    ],
    lightyellow: [
        255,
        255,
        224
    ],
    lime: [
        0,
        255,
        0
    ],
    limegreen: [
        50,
        205,
        50
    ],
    linen: [
        250,
        240,
        230
    ],
    magenta: [
        255,
        0,
        255
    ],
    maroon: [
        128,
        0,
        0
    ],
    mediumaquamarine: [
        102,
        205,
        170
    ],
    mediumblue: [
        0,
        0,
        205
    ],
    mediumorchid: [
        186,
        85,
        211
    ],
    mediumpurple: [
        147,
        112,
        219
    ],
    mediumseagreen: [
        60,
        179,
        113
    ],
    mediumslateblue: [
        123,
        104,
        238
    ],
    mediumspringgreen: [
        0,
        250,
        154
    ],
    mediumturquoise: [
        72,
        209,
        204
    ],
    mediumvioletred: [
        199,
        21,
        133
    ],
    midnightblue: [
        25,
        25,
        112
    ],
    mintcream: [
        245,
        255,
        250
    ],
    mistyrose: [
        255,
        228,
        225
    ],
    moccasin: [
        255,
        228,
        181
    ],
    navajowhite: [
        255,
        222,
        173
    ],
    navy: [
        0,
        0,
        128
    ],
    oldlace: [
        253,
        245,
        230
    ],
    olive: [
        128,
        128,
        0
    ],
    olivedrab: [
        107,
        142,
        35
    ],
    orange: [
        255,
        165,
        0
    ],
    orangered: [
        255,
        69,
        0
    ],
    orchid: [
        218,
        112,
        214
    ],
    palegoldenrod: [
        238,
        232,
        170
    ],
    palegreen: [
        152,
        251,
        152
    ],
    paleturquoise: [
        175,
        238,
        238
    ],
    palevioletred: [
        219,
        112,
        147
    ],
    papayawhip: [
        255,
        239,
        213
    ],
    peachpuff: [
        255,
        218,
        185
    ],
    peru: [
        205,
        133,
        63
    ],
    pink: [
        255,
        192,
        203
    ],
    plum: [
        221,
        160,
        221
    ],
    powderblue: [
        176,
        224,
        230
    ],
    purple: [
        128,
        0,
        128
    ],
    rebeccapurple: [
        102,
        51,
        153
    ],
    red: [
        255,
        0,
        0
    ],
    rosybrown: [
        188,
        143,
        143
    ],
    royalblue: [
        65,
        105,
        225
    ],
    saddlebrown: [
        139,
        69,
        19
    ],
    salmon: [
        250,
        128,
        114
    ],
    sandybrown: [
        244,
        164,
        96
    ],
    seagreen: [
        46,
        139,
        87
    ],
    seashell: [
        255,
        245,
        238
    ],
    sienna: [
        160,
        82,
        45
    ],
    silver: [
        192,
        192,
        192
    ],
    skyblue: [
        135,
        206,
        235
    ],
    slateblue: [
        106,
        90,
        205
    ],
    slategray: [
        112,
        128,
        144
    ],
    slategrey: [
        112,
        128,
        144
    ],
    snow: [
        255,
        250,
        250
    ],
    springgreen: [
        0,
        255,
        127
    ],
    steelblue: [
        70,
        130,
        180
    ],
    tan: [
        210,
        180,
        140
    ],
    teal: [
        0,
        128,
        128
    ],
    thistle: [
        216,
        191,
        216
    ],
    tomato: [
        255,
        99,
        71
    ],
    turquoise: [
        64,
        224,
        208
    ],
    violet: [
        238,
        130,
        238
    ],
    wheat: [
        245,
        222,
        179
    ],
    white: [
        255,
        255,
        255
    ],
    whitesmoke: [
        245,
        245,
        245
    ],
    yellow: [
        255,
        255,
        0
    ],
    yellowgreen: [
        154,
        205,
        50
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7h1FD":[function(require,module,exports,__globalThis) {
/**
 * @module color-space/hsl
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rgbJs = require("./rgb.js");
var _rgbJsDefault = parcelHelpers.interopDefault(_rgbJs);
var hsl = {
    name: 'hsl',
    min: [
        0,
        0,
        0
    ],
    max: [
        360,
        100,
        100
    ],
    channel: [
        'hue',
        'saturation',
        'lightness'
    ],
    alias: [
        'HSL'
    ],
    rgb: function(hsl) {
        var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val, i = 0;
        if (s === 0) return val = l * 255, [
            val,
            val,
            val
        ];
        t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
        t1 = 2 * l - t2;
        rgb = [
            0,
            0,
            0
        ];
        for(; i < 3;){
            t3 = h + 1 / 3 * -(i - 1);
            t3 < 0 ? t3++ : t3 > 1 && t3--;
            val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
            rgb[i++] = val * 255;
        }
        return rgb;
    }
};
exports.default = hsl;
//extend rgb
(0, _rgbJsDefault.default).hsl = function(rgb) {
    var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
    if (max === min) h = 0;
    else if (r === max) h = (g - b) / delta;
    else if (g === max) h = 2 + (b - r) / delta;
    else if (b === max) h = 4 + (r - g) / delta;
    //FIXME h is possibly undefined
    //@ts-ignore
    h = Math.min(h * 60, 360);
    if (h < 0) h += 360;
    l = (min + max) / 2;
    if (max === min) s = 0;
    else if (l <= 0.5) s = delta / (max + min);
    else s = delta / (2 - max - min);
    return [
        h,
        s * 100,
        l * 100
    ];
};

},{"./rgb.js":"3FDnE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ftcFo":[function(require,module,exports,__globalThis) {
/**
 * @module ol/colorlike
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */ /**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */ parcelHelpers.export(exports, "asColorLike", ()=>asColorLike);
var _colorJs = require("./color.js");
function asColorLike(color) {
    if (Array.isArray(color)) return (0, _colorJs.toString)(color);
    return color;
}

},{"./color.js":"4tahz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"84QzQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/dom
 */ //FIXME Move this function to the canvas module
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [width] Canvas width.
 * @param {number} [height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */ parcelHelpers.export(exports, "createCanvasContext2D", ()=>createCanvasContext2D);
/**
 * Releases canvas memory to avoid exceeding memory limits in Safari.
 * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
 * @param {CanvasRenderingContext2D} context Context.
 */ parcelHelpers.export(exports, "releaseCanvas", ()=>releaseCanvas);
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */ parcelHelpers.export(exports, "outerWidth", ()=>outerWidth);
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */ parcelHelpers.export(exports, "outerHeight", ()=>outerHeight);
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */ parcelHelpers.export(exports, "replaceNode", ()=>replaceNode);
/**
 * @param {Node} node The node to remove.
 * @return {Node|null} The node that was removed or null.
 */ parcelHelpers.export(exports, "removeNode", ()=>removeNode);
/**
 * @param {Node} node The node to remove the children from.
 */ parcelHelpers.export(exports, "removeChildren", ()=>removeChildren);
/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */ parcelHelpers.export(exports, "replaceChildren", ()=>replaceChildren);
var _hasJs = require("./has.js");
function createCanvasContext2D(width, height, canvasPool, settings) {
    /** @type {HTMLCanvasElement|OffscreenCanvas} */ let canvas;
    if (canvasPool && canvasPool.length) canvas = /** @type {HTMLCanvasElement} */ canvasPool.shift();
    else if (0, _hasJs.WORKER_OFFSCREEN_CANVAS) canvas = new OffscreenCanvas(width || 300, height || 300);
    else canvas = document.createElement('canvas');
    if (width) canvas.width = width;
    if (height) canvas.height = height;
    //FIXME Allow OffscreenCanvasRenderingContext2D as return type
    return /** @type {CanvasRenderingContext2D} */ canvas.getContext('2d', settings);
}
function releaseCanvas(context) {
    const canvas = context.canvas;
    canvas.width = 1;
    canvas.height = 1;
    context.clearRect(0, 0, 1, 1);
}
function outerWidth(element) {
    let width = element.offsetWidth;
    const style = getComputedStyle(element);
    width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
    return width;
}
function outerHeight(element) {
    let height = element.offsetHeight;
    const style = getComputedStyle(element);
    height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
    return height;
}
function replaceNode(newNode, oldNode) {
    const parent = oldNode.parentNode;
    if (parent) parent.replaceChild(newNode, oldNode);
}
function removeNode(node) {
    return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
function removeChildren(node) {
    while(node.lastChild)node.removeChild(node.lastChild);
}
function replaceChildren(node, children) {
    const oldChildren = node.childNodes;
    for(let i = 0;; ++i){
        const oldChild = oldChildren[i];
        const newChild = children[i];
        // check if our work is done
        if (!oldChild && !newChild) break;
        // check if children match
        if (oldChild === newChild) continue;
        // check if a new child needs to be added
        if (!oldChild) {
            node.appendChild(newChild);
            continue;
        }
        // check if an old child needs to be removed
        if (!newChild) {
            node.removeChild(oldChild);
            --i;
            continue;
        }
        // reorder
        node.insertBefore(newChild, oldChild);
    }
}

},{"./has.js":"6BDNi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e85iQ":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultFont", ()=>defaultFont);
parcelHelpers.export(exports, "defaultFillStyle", ()=>defaultFillStyle);
parcelHelpers.export(exports, "defaultLineCap", ()=>defaultLineCap);
parcelHelpers.export(exports, "defaultLineDash", ()=>defaultLineDash);
parcelHelpers.export(exports, "defaultLineDashOffset", ()=>defaultLineDashOffset);
parcelHelpers.export(exports, "defaultLineJoin", ()=>defaultLineJoin);
parcelHelpers.export(exports, "defaultMiterLimit", ()=>defaultMiterLimit);
parcelHelpers.export(exports, "defaultStrokeStyle", ()=>defaultStrokeStyle);
parcelHelpers.export(exports, "defaultTextAlign", ()=>defaultTextAlign);
parcelHelpers.export(exports, "defaultTextBaseline", ()=>defaultTextBaseline);
parcelHelpers.export(exports, "defaultPadding", ()=>defaultPadding);
parcelHelpers.export(exports, "defaultLineWidth", ()=>defaultLineWidth);
parcelHelpers.export(exports, "checkedFonts", ()=>checkedFonts);
parcelHelpers.export(exports, "textHeights", ()=>textHeights);
parcelHelpers.export(exports, "registerFont", ()=>registerFont);
parcelHelpers.export(exports, "measureTextHeight", ()=>measureTextHeight);
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */ parcelHelpers.export(exports, "measureTextWidth", ()=>measureTextWidth);
/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */ parcelHelpers.export(exports, "measureAndCacheTextWidth", ()=>measureAndCacheTextWidth);
/**
 * @param {TextState} baseStyle Base style.
 * @param {Array<string>} chunks Text chunks to measure.
 * @return {{width: number, height: number, widths: Array<number>, heights: Array<number>, lineWidths: Array<number>}}} Text metrics.
 */ parcelHelpers.export(exports, "getTextDimensions", ()=>getTextDimensions);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */ parcelHelpers.export(exports, "rotateAtOffset", ()=>rotateAtOffset);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */ parcelHelpers.export(exports, "drawImageOrLabel", ()=>drawImageOrLabel);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _hasJs = require("../has.js");
var _objJs = require("../obj.js");
var _domJs = require("../dom.js");
var _cssJs = require("../css.js");
const defaultFont = '10px sans-serif';
const defaultFillStyle = '#000';
const defaultLineCap = 'round';
const defaultLineDash = [];
const defaultLineDashOffset = 0;
const defaultLineJoin = 'round';
const defaultMiterLimit = 10;
const defaultStrokeStyle = '#000';
const defaultTextAlign = 'center';
const defaultTextBaseline = 'middle';
const defaultPadding = [
    0,
    0,
    0,
    0
];
const defaultLineWidth = 1;
const checkedFonts = new (0, _objectJsDefault.default)();
/**
 * @type {CanvasRenderingContext2D}
 */ let measureContext = null;
/**
 * @type {string}
 */ let measureFont;
const textHeights = {};
const registerFont = function() {
    const retries = 100;
    const size = '32px ';
    const referenceFonts = [
        'monospace',
        'serif'
    ];
    const len = referenceFonts.length;
    const text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
    let interval, referenceWidth;
    /**
   * @param {string} fontStyle Css font-style
   * @param {string} fontWeight Css font-weight
   * @param {*} fontFamily Css font-family
   * @return {boolean} Font with style and weight is available
   */ function isAvailable(fontStyle, fontWeight, fontFamily) {
        let available = true;
        for(let i = 0; i < len; ++i){
            const referenceFont = referenceFonts[i];
            referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);
            if (fontFamily != referenceFont) {
                const width = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + fontFamily + ',' + referenceFont, text);
                // If width and referenceWidth are the same, then the fallback was used
                // instead of the font we wanted, so the font is not available.
                available = available && width != referenceWidth;
            }
        }
        if (available) return true;
        return false;
    }
    function check() {
        let done = true;
        const fonts = checkedFonts.getKeys();
        for(let i = 0, ii = fonts.length; i < ii; ++i){
            const font = fonts[i];
            if (checkedFonts.get(font) < retries) {
                if (isAvailable.apply(this, font.split('\n'))) {
                    (0, _objJs.clear)(textHeights);
                    // Make sure that loaded fonts are picked up by Safari
                    measureContext = null;
                    measureFont = undefined;
                    checkedFonts.set(font, retries);
                } else {
                    checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                    done = false;
                }
            }
        }
        if (done) {
            clearInterval(interval);
            interval = undefined;
        }
    }
    return function(fontSpec) {
        const font = (0, _cssJs.getFontParameters)(fontSpec);
        if (!font) return;
        const families = font.families;
        for(let i = 0, ii = families.length; i < ii; ++i){
            const family = families[i];
            const key = font.style + '\n' + font.weight + '\n' + family;
            if (checkedFonts.get(key) === undefined) {
                checkedFonts.set(key, retries, true);
                if (!isAvailable(font.style, font.weight, family)) {
                    checkedFonts.set(key, 0, true);
                    if (interval === undefined) interval = setInterval(check, 32);
                }
            }
        }
    };
}();
const measureTextHeight = function() {
    /**
   * @type {HTMLDivElement}
   */ let measureElement;
    return function(fontSpec) {
        let height = textHeights[fontSpec];
        if (height == undefined) {
            if (0, _hasJs.WORKER_OFFSCREEN_CANVAS) {
                const font = (0, _cssJs.getFontParameters)(fontSpec);
                const metrics = measureText(fontSpec, "\u017Dg");
                const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
                height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
            } else {
                if (!measureElement) {
                    measureElement = document.createElement('div');
                    measureElement.innerHTML = 'M';
                    measureElement.style.minHeight = '0';
                    measureElement.style.maxHeight = 'none';
                    measureElement.style.height = 'auto';
                    measureElement.style.padding = '0';
                    measureElement.style.border = 'none';
                    measureElement.style.position = 'absolute';
                    measureElement.style.display = 'block';
                    measureElement.style.left = '-99999px';
                }
                measureElement.style.font = fontSpec;
                document.body.appendChild(measureElement);
                height = measureElement.offsetHeight;
                document.body.removeChild(measureElement);
            }
            textHeights[fontSpec] = height;
        }
        return height;
    };
}();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */ function measureText(font, text) {
    if (!measureContext) measureContext = (0, _domJs.createCanvasContext2D)(1, 1);
    if (font != measureFont) {
        measureContext.font = font;
        measureFont = measureContext.font;
    }
    return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
    return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache) {
    if (text in cache) return cache[text];
    const width = text.split('\n').reduce((prev, curr)=>Math.max(prev, measureTextWidth(font, curr)), 0);
    cache[text] = width;
    return width;
}
function getTextDimensions(baseStyle, chunks) {
    const widths = [];
    const heights = [];
    const lineWidths = [];
    let width = 0;
    let lineWidth = 0;
    let height = 0;
    let lineHeight = 0;
    for(let i = 0, ii = chunks.length; i <= ii; i += 2){
        const text = chunks[i];
        if (text === '\n' || i === ii) {
            width = Math.max(width, lineWidth);
            lineWidths.push(lineWidth);
            lineWidth = 0;
            height += lineHeight;
            continue;
        }
        const font = chunks[i + 1] || baseStyle.font;
        const currentWidth = measureTextWidth(font, text);
        widths.push(currentWidth);
        lineWidth += currentWidth;
        const currentHeight = measureTextHeight(font);
        heights.push(currentHeight);
        lineHeight = Math.max(lineHeight, currentHeight);
    }
    return {
        width,
        height,
        widths,
        heights,
        lineWidths
    };
}
function rotateAtOffset(context, rotation, offsetX, offsetY) {
    if (rotation !== 0) {
        context.translate(offsetX, offsetY);
        context.rotate(rotation);
        context.translate(-offsetX, -offsetY);
    }
}
function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
    context.save();
    if (opacity !== 1) context.globalAlpha *= opacity;
    if (transform) context.transform.apply(context, transform);
    if (/** @type {*} */ labelOrImage.contextInstructions) {
        // label
        context.translate(x, y);
        context.scale(scale[0], scale[1]);
        executeLabelInstructions(/** @type {Label} */ labelOrImage, context);
    } else if (scale[0] < 0 || scale[1] < 0) {
        // flipped image
        context.translate(x, y);
        context.scale(scale[0], scale[1]);
        context.drawImage(/** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ labelOrImage, originX, originY, w, h, 0, 0, w, h);
    } else // if image not flipped translate and scale can be avoided
    context.drawImage(/** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ labelOrImage, originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
    context.restore();
}
/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */ function executeLabelInstructions(label, context) {
    const contextInstructions = label.contextInstructions;
    for(let i = 0, ii = contextInstructions.length; i < ii; i += 2)if (Array.isArray(contextInstructions[i + 1])) context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    else context[contextInstructions[i]] = contextInstructions[i + 1];
}

},{"../Object.js":"1zG8z","../has.js":"6BDNi","../obj.js":"3ssAG","../dom.js":"84QzQ","../css.js":"lDlNi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lDlNi":[function(require,module,exports,__globalThis) {
/**
 * @module ol/css
 */ /**
 * @typedef {Object} FontParameters
 * @property {string} style Style.
 * @property {string} variant Variant.
 * @property {string} weight Weight.
 * @property {string} size Size.
 * @property {string} lineHeight LineHeight.
 * @property {string} family Family.
 * @property {Array<string>} families Families.
 */ /**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CLASS_HIDDEN", ()=>CLASS_HIDDEN);
parcelHelpers.export(exports, "CLASS_SELECTABLE", ()=>CLASS_SELECTABLE);
parcelHelpers.export(exports, "CLASS_UNSELECTABLE", ()=>CLASS_UNSELECTABLE);
parcelHelpers.export(exports, "CLASS_UNSUPPORTED", ()=>CLASS_UNSUPPORTED);
parcelHelpers.export(exports, "CLASS_CONTROL", ()=>CLASS_CONTROL);
parcelHelpers.export(exports, "CLASS_COLLAPSED", ()=>CLASS_COLLAPSED);
parcelHelpers.export(exports, "getFontParameters", ()=>getFontParameters);
const CLASS_HIDDEN = 'ol-hidden';
const CLASS_SELECTABLE = 'ol-selectable';
const CLASS_UNSELECTABLE = 'ol-unselectable';
const CLASS_UNSUPPORTED = 'ol-unsupported';
const CLASS_CONTROL = 'ol-control';
const CLASS_COLLAPSED = 'ol-collapsed';
/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */ const fontRegEx = new RegExp([
    '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
    '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
    '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
    '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
    '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$'
].join(''), 'i');
/** @type {Array<'style'|'variant'|'weight'|'size'|'lineHeight'|'family'>} */ const fontRegExMatchIndex = [
    'style',
    'variant',
    'weight',
    'size',
    'lineHeight',
    'family'
];
const getFontParameters = function(fontSpec) {
    const match = fontSpec.match(fontRegEx);
    if (!match) return null;
    const style = /** @type {FontParameters} */ {
        lineHeight: 'normal',
        size: '1.2em',
        style: 'normal',
        weight: 'normal',
        variant: 'normal'
    };
    for(let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i){
        const value = match[i + 1];
        if (value !== undefined) style[fontRegExMatchIndex[i]] = value;
    }
    style.families = style.family.split(/,\s?/);
    return style;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4fB56":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Fill
 */ /**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike|null} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */ /**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Fill {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike|null}
     */ this.color_ = options.color !== undefined ? options.color : null;
    }
    /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */ clone() {
        const color = this.getColor();
        return new Fill({
            color: Array.isArray(color) ? color.slice() : color || undefined
        });
    }
    /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
   * @api
   */ getColor() {
        return this.color_;
    }
    /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
   * @api
   */ setColor(color) {
        this.color_ = color;
    }
}
exports.default = Fill;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Cq04":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Stroke
 */ /**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */ /**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Stroke {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */ this.color_ = options.color !== undefined ? options.color : null;
        /**
     * @private
     * @type {CanvasLineCap|undefined}
     */ this.lineCap_ = options.lineCap;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
        /**
     * @private
     * @type {number|undefined}
     */ this.lineDashOffset_ = options.lineDashOffset;
        /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */ this.lineJoin_ = options.lineJoin;
        /**
     * @private
     * @type {number|undefined}
     */ this.miterLimit_ = options.miterLimit;
        /**
     * @private
     * @type {number|undefined}
     */ this.width_ = options.width;
    }
    /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */ clone() {
        const color = this.getColor();
        return new Stroke({
            color: Array.isArray(color) ? color.slice() : color || undefined,
            lineCap: this.getLineCap(),
            lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
            lineDashOffset: this.getLineDashOffset(),
            lineJoin: this.getLineJoin(),
            miterLimit: this.getMiterLimit(),
            width: this.getWidth()
        });
    }
    /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */ getColor() {
        return this.color_;
    }
    /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */ getLineCap() {
        return this.lineCap_;
    }
    /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */ getLineDash() {
        return this.lineDash_;
    }
    /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */ getLineDashOffset() {
        return this.lineDashOffset_;
    }
    /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */ getLineJoin() {
        return this.lineJoin_;
    }
    /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */ getMiterLimit() {
        return this.miterLimit_;
    }
    /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */ getWidth() {
        return this.width_;
    }
    /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */ setColor(color) {
        this.color_ = color;
    }
    /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */ setLineCap(lineCap) {
        this.lineCap_ = lineCap;
    }
    /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */ setLineDash(lineDash) {
        this.lineDash_ = lineDash;
    }
    /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */ setLineDashOffset(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
    }
    /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */ setLineJoin(lineJoin) {
        this.lineJoin_ = lineJoin;
    }
    /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */ setMiterLimit(miterLimit) {
        this.miterLimit_ = miterLimit;
    }
    /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */ setWidth(width) {
        this.width_ = width;
    }
}
exports.default = Stroke;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"grY67":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/style
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This function adapts a rule evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */ parcelHelpers.export(exports, "rulesToStyleFunction", ()=>rulesToStyleFunction);
/**
 * This function adapts a style evaluator to the existing style function interface.
 * After we have deprecated the style function, we can use the compiled rules directly
 * and pass a more complete evaluation context (variables, zoom, time, etc.).
 *
 * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.
 * @return {import('../../style/Style.js').StyleFunction} A style function.
 */ parcelHelpers.export(exports, "flatStylesToStyleFunction", ()=>flatStylesToStyleFunction);
/**
 * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator
 */ /**
 * @typedef {Object} CompiledRule
 * @property {ExpressionEvaluator} filter The compiled filter evaluator.
 * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.
 */ /**
 * @param {Array<import('../../style/flat.js').Rule>} rules The rules.
 * @param {ParsingContext} context The parsing context.
 * @return {RuleSetEvaluator} The evaluator function.
 */ parcelHelpers.export(exports, "buildRuleSet", ()=>buildRuleSet);
/**
 * @typedef {function(EvaluationContext):Style|null} StyleEvaluator
 */ /**
 * @param {FlatStyle} flatStyle A flat style literal.
 * @param {ParsingContext} context The parsing context.
 * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by
 * this function will be reused between invocations.
 */ parcelHelpers.export(exports, "buildStyle", ()=>buildStyle);
var _circleJs = require("../../style/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("../../style/Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _iconJs = require("../../style/Icon.js");
var _iconJsDefault = parcelHelpers.interopDefault(_iconJs);
var _regularShapeJs = require("../../style/RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
var _strokeJs = require("../../style/Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _styleJs = require("../../style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _textJs = require("../../style/Text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);
var _expressionJs = require("../../expr/expression.js");
var _cpuJs = require("../../expr/cpu.js");
var _objJs = require("../../obj.js");
var _sizeJs = require("../../size.js");
/**
 * @fileoverview This module includes functions to build styles for the canvas renderer.  Building
 * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression
 * and returns an instance of one of the expression classes.  The compiling step takes the
 * expression instance and returns a function that can be evaluated to return a literal value.  The
 * evaluator function should do as little allocation and work as possible.
 */ /**
 * @typedef {import("../../style/flat.js").FlatStyle} FlatStyle
 */ /**
 * @typedef {import("../../expr/expression.js").EncodedExpression} EncodedExpression
 */ /**
 * @typedef {import("../../expr/expression.js").ParsingContext} ParsingContext
 */ /**
 * @typedef {import("../../expr/expression.js").CallExpression} CallExpression
 */ /**
 * @typedef {import("../../expr/cpu.js").EvaluationContext} EvaluationContext
 */ /**
 * @typedef {import("../../expr/cpu.js").ExpressionEvaluator} ExpressionEvaluator
 */ /**
 * @param {EvaluationContext} context The evaluation context.
 * @return {boolean} Always true.
 */ function always(context) {
    return true;
}
function rulesToStyleFunction(rules) {
    const parsingContext = (0, _expressionJs.newParsingContext)();
    const evaluator = buildRuleSet(rules, parsingContext);
    const evaluationContext = (0, _cpuJs.newEvaluationContext)();
    return function(feature, resolution) {
        evaluationContext.properties = feature.getPropertiesInternal();
        evaluationContext.resolution = resolution;
        if (parsingContext.featureId) {
            const id = feature.getId();
            if (id !== undefined) evaluationContext.featureId = id;
            else evaluationContext.featureId = null;
        }
        return evaluator(evaluationContext);
    };
}
function flatStylesToStyleFunction(flatStyles) {
    const parsingContext = (0, _expressionJs.newParsingContext)();
    const length = flatStyles.length;
    /**
   * @type {Array<StyleEvaluator>}
   */ const evaluators = new Array(length);
    for(let i = 0; i < length; ++i)evaluators[i] = buildStyle(flatStyles[i], parsingContext);
    const evaluationContext = (0, _cpuJs.newEvaluationContext)();
    /**
   * @type {Array<Style>}
   */ const styles = new Array(length);
    return function(feature, resolution) {
        evaluationContext.properties = feature.getPropertiesInternal();
        evaluationContext.resolution = resolution;
        if (parsingContext.featureId) {
            const id = feature.getId();
            if (id !== undefined) evaluationContext.featureId = id;
            else evaluationContext.featureId = null;
        }
        let nonNullCount = 0;
        for(let i = 0; i < length; ++i){
            const style = evaluators[i](evaluationContext);
            if (style) {
                styles[nonNullCount] = style;
                nonNullCount += 1;
            }
        }
        styles.length = nonNullCount;
        return styles;
    };
}
function buildRuleSet(rules, context) {
    const length = rules.length;
    /**
   * @type {Array<CompiledRule>}
   */ const compiledRules = new Array(length);
    for(let i = 0; i < length; ++i){
        const rule = rules[i];
        const filter = 'filter' in rule ? (0, _cpuJs.buildExpression)(rule.filter, (0, _expressionJs.BooleanType), context) : always;
        /**
     * @type {Array<StyleEvaluator>}
     */ let styles;
        if (Array.isArray(rule.style)) {
            const styleLength = rule.style.length;
            styles = new Array(styleLength);
            for(let j = 0; j < styleLength; ++j)styles[j] = buildStyle(rule.style[j], context);
        } else styles = [
            buildStyle(rule.style, context)
        ];
        compiledRules[i] = {
            filter,
            styles
        };
    }
    return function(context) {
        /**
     * @type {Array<Style>}
     */ const styles = [];
        let someMatched = false;
        for(let i = 0; i < length; ++i){
            const filterEvaluator = compiledRules[i].filter;
            if (!filterEvaluator(context)) continue;
            if (rules[i].else && someMatched) continue;
            someMatched = true;
            for (const styleEvaluator of compiledRules[i].styles){
                const style = styleEvaluator(context);
                if (!style) continue;
                styles.push(style);
            }
        }
        return styles;
    };
}
function buildStyle(flatStyle, context) {
    const evaluateFill = buildFill(flatStyle, '', context);
    const evaluateStroke = buildStroke(flatStyle, '', context);
    const evaluateText = buildText(flatStyle, context);
    const evaluateImage = buildImage(flatStyle, context);
    const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);
    if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !(0, _objJs.isEmpty)(flatStyle)) // assume this is a user error
    // would be nice to check the properties and suggest "did you mean..."
    throw new Error('No fill, stroke, point, or text symbolizer properties in style: ' + JSON.stringify(flatStyle));
    const style = new (0, _styleJsDefault.default)();
    return function(context) {
        let empty = true;
        if (evaluateFill) {
            const fill = evaluateFill(context);
            if (fill) empty = false;
            style.setFill(fill);
        }
        if (evaluateStroke) {
            const stroke = evaluateStroke(context);
            if (stroke) empty = false;
            style.setStroke(stroke);
        }
        if (evaluateText) {
            const text = evaluateText(context);
            if (text) empty = false;
            style.setText(text);
        }
        if (evaluateImage) {
            const image = evaluateImage(context);
            if (image) empty = false;
            style.setImage(image);
        }
        if (evaluateZIndex) style.setZIndex(evaluateZIndex(context));
        if (empty) return null;
        return style;
    };
}
/**
 * @typedef {function(EvaluationContext):Fill|null} FillEvaluator
 */ /**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @param {ParsingContext} context The parsing context.
 * @return {FillEvaluator?} A function that evaluates to a fill.
 */ function buildFill(flatStyle, prefix, context) {
    const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'fill-color', context);
    if (!evaluateColor) return null;
    const fill = new (0, _fillJsDefault.default)();
    return function(context) {
        const color = evaluateColor(context);
        if (color === 'none') return null;
        fill.setColor(color);
        return fill;
    };
}
/**
 * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator
 */ /**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} prefix The property prefix.
 * @param {ParsingContext} context The parsing context.
 * @return {StrokeEvaluator?} A function the evaluates to a stroke.
 */ function buildStroke(flatStyle, prefix, context) {
    const evaluateWidth = numberEvaluator(flatStyle, prefix + 'stroke-width', context);
    const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'stroke-color', context);
    if (!evaluateWidth && !evaluateColor) return null;
    const evaluateLineCap = stringEvaluator(flatStyle, prefix + 'stroke-line-cap', context);
    const evaluateLineJoin = stringEvaluator(flatStyle, prefix + 'stroke-line-join', context);
    const evaluateLineDash = numberArrayEvaluator(flatStyle, prefix + 'stroke-line-dash', context);
    const evaluateLineDashOffset = numberEvaluator(flatStyle, prefix + 'stroke-line-dash-offset', context);
    const evaluateMiterLimit = numberEvaluator(flatStyle, prefix + 'stroke-miter-limit', context);
    const stroke = new (0, _strokeJsDefault.default)();
    return function(context) {
        if (evaluateColor) {
            const color = evaluateColor(context);
            if (color === 'none') return null;
            stroke.setColor(color);
        }
        if (evaluateWidth) stroke.setWidth(evaluateWidth(context));
        if (evaluateLineCap) {
            const lineCap = evaluateLineCap(context);
            if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') throw new Error('Expected butt, round, or square line cap');
            stroke.setLineCap(lineCap);
        }
        if (evaluateLineJoin) {
            const lineJoin = evaluateLineJoin(context);
            if (lineJoin !== 'bevel' && lineJoin !== 'round' && lineJoin !== 'miter') throw new Error('Expected bevel, round, or miter line join');
            stroke.setLineJoin(lineJoin);
        }
        if (evaluateLineDash) stroke.setLineDash(evaluateLineDash(context));
        if (evaluateLineDashOffset) stroke.setLineDashOffset(evaluateLineDashOffset(context));
        if (evaluateMiterLimit) stroke.setMiterLimit(evaluateMiterLimit(context));
        return stroke;
    };
}
/**
 * @typedef {function(EvaluationContext):Text} TextEvaluator
 */ /**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {TextEvaluator?} A function that evaluates to a text symbolizer.
 */ function buildText(flatStyle, context) {
    const prefix = 'text-';
    // Currently, an Array<string> may be used for rich text support.  This doesn't
    // work with our expression syntax where arrays of strings are interpreted as
    // call expressions.  To support rich text, we could add a 'strings' operator
    // where all the following arguments would be string values.
    const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);
    if (!evaluateValue) return null;
    const evaluateFill = buildFill(flatStyle, prefix, context);
    const evaluateBackgroundFill = buildFill(flatStyle, prefix + 'background-', context);
    const evaluateStroke = buildStroke(flatStyle, prefix, context);
    const evaluateBackgroundStroke = buildStroke(flatStyle, prefix + 'background-', context);
    const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);
    const evaluateMaxAngle = numberEvaluator(flatStyle, prefix + 'max-angle', context);
    const evaluateOffsetX = numberEvaluator(flatStyle, prefix + 'offset-x', context);
    const evaluateOffsetY = numberEvaluator(flatStyle, prefix + 'offset-y', context);
    const evaluateOverflow = booleanEvaluator(flatStyle, prefix + 'overflow', context);
    const evaluatePlacement = stringEvaluator(flatStyle, prefix + 'placement', context);
    const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
    const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);
    const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
    const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);
    const evaluateJustify = stringEvaluator(flatStyle, prefix + 'justify', context);
    const evaluateBaseline = stringEvaluator(flatStyle, prefix + 'baseline', context);
    const evaluatePadding = numberArrayEvaluator(flatStyle, prefix + 'padding', context);
    const text = new (0, _textJsDefault.default)({});
    return function(context) {
        text.setText(evaluateValue(context));
        if (evaluateFill) text.setFill(evaluateFill(context));
        if (evaluateBackgroundFill) text.setBackgroundFill(evaluateBackgroundFill(context));
        if (evaluateStroke) text.setStroke(evaluateStroke(context));
        if (evaluateBackgroundStroke) text.setBackgroundStroke(evaluateBackgroundStroke(context));
        if (evaluateFont) text.setFont(evaluateFont(context));
        if (evaluateMaxAngle) text.setMaxAngle(evaluateMaxAngle(context));
        if (evaluateOffsetX) text.setOffsetX(evaluateOffsetX(context));
        if (evaluateOffsetY) text.setOffsetY(evaluateOffsetY(context));
        if (evaluateOverflow) text.setOverflow(evaluateOverflow(context));
        if (evaluatePlacement) {
            const placement = evaluatePlacement(context);
            if (placement !== 'point' && placement !== 'line') throw new Error('Expected point or line for text-placement');
            text.setPlacement(placement);
        }
        if (evaluateRepeat) text.setRepeat(evaluateRepeat(context));
        if (evaluateScale) text.setScale(evaluateScale(context));
        if (evaluateRotateWithView) text.setRotateWithView(evaluateRotateWithView(context));
        if (evaluateRotation) text.setRotation(evaluateRotation(context));
        if (evaluateAlign) {
            const textAlign = evaluateAlign(context);
            if (textAlign !== 'left' && textAlign !== 'center' && textAlign !== 'right' && textAlign !== 'end' && textAlign !== 'start') throw new Error('Expected left, right, center, start, or end for text-align');
            text.setTextAlign(textAlign);
        }
        if (evaluateJustify) {
            const justify = evaluateJustify(context);
            if (justify !== 'left' && justify !== 'right' && justify !== 'center') throw new Error('Expected left, right, or center for text-justify');
            text.setJustify(justify);
        }
        if (evaluateBaseline) {
            const textBaseline = evaluateBaseline(context);
            if (textBaseline !== 'bottom' && textBaseline !== 'top' && textBaseline !== 'middle' && textBaseline !== 'alphabetic' && textBaseline !== 'hanging') throw new Error('Expected bottom, top, middle, alphabetic, or hanging for text-baseline');
            text.setTextBaseline(textBaseline);
        }
        if (evaluatePadding) text.setPadding(evaluatePadding(context));
        return text;
    };
}
/**
 * @typedef {function(EvaluationContext):import("../../style/Image.js").default} ImageEvaluator
 */ /**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.
 */ function buildImage(flatStyle, context) {
    if ('icon-src' in flatStyle) return buildIcon(flatStyle, context);
    if ('shape-points' in flatStyle) return buildShape(flatStyle, context);
    if ('circle-radius' in flatStyle) return buildCircle(flatStyle, context);
    return null;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to an image symbolizer.
 */ function buildIcon(flatStyle, context) {
    const prefix = 'icon-';
    // required property
    const srcName = prefix + 'src';
    const src = requireString(flatStyle[srcName], srcName);
    // settable properties
    const evaluateAnchor = coordinateEvaluator(flatStyle, prefix + 'anchor', context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
    const evaluateOpacity = numberEvaluator(flatStyle, prefix + 'opacity', context);
    const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);
    const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
    const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);
    // the remaining symbolizer properties are not currently settable
    const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');
    const anchorXUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-x-units');
    const anchorYUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-y-units');
    const color = optionalColorLike(flatStyle, prefix + 'color');
    const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');
    const offset = optionalNumberArray(flatStyle, prefix + 'offset');
    const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');
    const width = optionalNumber(flatStyle, prefix + 'width');
    const height = optionalNumber(flatStyle, prefix + 'height');
    const size = optionalSize(flatStyle, prefix + 'size');
    const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter');
    const icon = new (0, _iconJsDefault.default)({
        src,
        anchorOrigin,
        anchorXUnits,
        anchorYUnits,
        color,
        crossOrigin,
        offset,
        offsetOrigin,
        height,
        width,
        size,
        declutterMode
    });
    return function(context) {
        if (evaluateOpacity) icon.setOpacity(evaluateOpacity(context));
        if (evaluateDisplacement) icon.setDisplacement(evaluateDisplacement(context));
        if (evaluateRotation) icon.setRotation(evaluateRotation(context));
        if (evaluateRotateWithView) icon.setRotateWithView(evaluateRotateWithView(context));
        if (evaluateScale) icon.setScale(evaluateScale(context));
        if (evaluateAnchor) icon.setAnchor(evaluateAnchor(context));
        return icon;
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.
 */ function buildShape(flatStyle, context) {
    const prefix = 'shape-';
    // required property
    const pointsName = prefix + 'points';
    const points = requireNumber(flatStyle[pointsName], pointsName);
    // settable properties
    const evaluateFill = buildFill(flatStyle, prefix, context);
    const evaluateStroke = buildStroke(flatStyle, prefix, context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
    const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);
    const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
    const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);
    // the remaining properties are not currently settable
    const radius = optionalNumber(flatStyle, prefix + 'radius');
    const radius1 = optionalNumber(flatStyle, prefix + 'radius1');
    const radius2 = optionalNumber(flatStyle, prefix + 'radius2');
    const angle = optionalNumber(flatStyle, prefix + 'angle');
    const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');
    const shape = new (0, _regularShapeJsDefault.default)({
        points,
        radius,
        radius1,
        radius2,
        angle,
        declutterMode
    });
    return function(context) {
        if (evaluateFill) shape.setFill(evaluateFill(context));
        if (evaluateStroke) shape.setStroke(evaluateStroke(context));
        if (evaluateDisplacement) shape.setDisplacement(evaluateDisplacement(context));
        if (evaluateRotation) shape.setRotation(evaluateRotation(context));
        if (evaluateRotateWithView) shape.setRotateWithView(evaluateRotateWithView(context));
        if (evaluateScale) shape.setScale(evaluateScale(context));
        return shape;
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {ParsingContext} context The parsing context.
 * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.
 */ function buildCircle(flatStyle, context) {
    const prefix = 'circle-';
    // settable properties
    const evaluateFill = buildFill(flatStyle, prefix, context);
    const evaluateStroke = buildStroke(flatStyle, prefix, context);
    const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);
    const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);
    const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);
    const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);
    // the remaining properties are not currently settable
    const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');
    const circle = new (0, _circleJsDefault.default)({
        radius: 5,
        declutterMode
    });
    return function(context) {
        if (evaluateRadius) circle.setRadius(evaluateRadius(context));
        if (evaluateFill) circle.setFill(evaluateFill(context));
        if (evaluateStroke) circle.setStroke(evaluateStroke(context));
        if (evaluateDisplacement) circle.setDisplacement(evaluateDisplacement(context));
        if (evaluateRotation) circle.setRotation(evaluateRotation(context));
        if (evaluateRotateWithView) circle.setRotateWithView(evaluateRotateWithView(context));
        if (evaluateScale) circle.setScale(evaluateScale(context));
        return circle;
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.
 */ function numberEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return undefined;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.NumberType), context);
    return function(context) {
        return requireNumber(evaluator(context), name);
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.
 */ function stringEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.StringType), context);
    return function(context) {
        return requireString(evaluator(context), name);
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.
 */ function booleanEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.BooleanType), context);
    return function(context) {
        const value = evaluator(context);
        if (typeof value !== 'boolean') throw new Error(`Expected a boolean for ${name}`);
        return value;
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.
 */ function colorLikeEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.ColorType) | (0, _expressionJs.StringType), context);
    return function(context) {
        return requireColorLike(evaluator(context), name);
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.
 */ function numberArrayEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.NumberArrayType), context);
    return function(context) {
        return requireNumberArray(evaluator(context), name);
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.
 */ function coordinateEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.NumberArrayType), context);
    return function(context) {
        const array = requireNumberArray(evaluator(context), name);
        if (array.length !== 2) throw new Error(`Expected two numbers for ${name}`);
        return array;
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} name The property name.
 * @param {ParsingContext} context The parsing context.
 * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.
 */ function sizeLikeEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) return null;
    const evaluator = (0, _cpuJs.buildExpression)(flatStyle[name], (0, _expressionJs.NumberArrayType) | (0, _expressionJs.NumberType), context);
    return function(context) {
        return requireSizeLike(evaluator(context), name);
    };
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {number|undefined} A number or undefined.
 */ function optionalNumber(flatStyle, property) {
    const value = flatStyle[property];
    if (value === undefined) return undefined;
    if (typeof value !== 'number') throw new Error(`Expected a number for ${property}`);
    return value;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../size.js").Size|undefined} A size or undefined.
 */ function optionalSize(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    if (typeof encoded === 'number') return (0, _sizeJs.toSize)(encoded);
    if (!Array.isArray(encoded)) throw new Error(`Expected a number or size array for ${property}`);
    if (encoded.length !== 2 || typeof encoded[0] !== 'number' || typeof encoded[1] !== 'number') throw new Error(`Expected a number or size array for ${property}`);
    return encoded;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {string|undefined} A string or undefined.
 */ function optionalString(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    if (typeof encoded !== 'string') throw new Error(`Expected a string for ${property}`);
    return encoded;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../style/Icon.js").IconOrigin|undefined} An icon origin or undefined.
 */ function optionalIconOrigin(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    if (encoded !== 'bottom-left' && encoded !== 'bottom-right' && encoded !== 'top-left' && encoded !== 'top-right') throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${property}`);
    return encoded;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {import("../../style/Icon.js").IconAnchorUnits|undefined} Icon anchor units or undefined.
 */ function optionalIconAnchorUnits(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    if (encoded !== 'pixels' && encoded !== 'fraction') throw new Error(`Expected pixels or fraction for ${property}`);
    return encoded;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {Array<number>|undefined} An array of numbers or undefined.
 */ function optionalNumberArray(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    return requireNumberArray(encoded, property);
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {"declutter"|"obstacle"|"none"|undefined} Icon declutter mode.
 */ function optionalDeclutterMode(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    if (typeof encoded !== 'string') throw new Error(`Expected a string for ${property}`);
    if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') throw new Error(`Expected declutter, obstacle, or none for ${property}`);
    return encoded;
}
/**
 * @param {FlatStyle} flatStyle The flat style.
 * @param {string} property The symbolizer property.
 * @return {string|Array<number>|undefined} A string or an array of color values or undefined.
 */ function optionalColorLike(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === undefined) return undefined;
    return requireColorLike(encoded, property);
}
/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>} An array of numbers.
 */ function requireNumberArray(value, property) {
    if (!Array.isArray(value)) throw new Error(`Expected an array for ${property}`);
    const length = value.length;
    for(let i = 0; i < length; ++i){
        if (typeof value[i] !== 'number') throw new Error(`Expected an array of numbers for ${property}`);
    }
    return value;
}
/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {string} A string.
 */ function requireString(value, property) {
    if (typeof value !== 'string') throw new Error(`Expected a string for ${property}`);
    return value;
}
/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {number} A number.
 */ function requireNumber(value, property) {
    if (typeof value !== 'number') throw new Error(`Expected a number for ${property}`);
    return value;
}
/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {Array<number>|string} A color.
 */ function requireColorLike(value, property) {
    if (typeof value === 'string') return value;
    const array = requireNumberArray(value, property);
    const length = array.length;
    if (length < 3 || length > 4) throw new Error(`Expected a color with 3 or 4 values for ${property}`);
    return array;
}
/**
 * @param {any} value The value.
 * @param {string} property The property.
 * @return {number|Array<number>} A number or an array of two numbers.
 */ function requireSizeLike(value, property) {
    if (typeof value === 'number') return value;
    const size = requireNumberArray(value, property);
    if (size.length !== 2) throw new Error(`Expected an array of two numbers for ${property}`);
    return size;
}

},{"../../style/Circle.js":"cSS3Y","../../style/Fill.js":"4fB56","../../style/Icon.js":"dJiIs","../../style/RegularShape.js":"44xDg","../../style/Stroke.js":"5Cq04","../../style/Style.js":"fW7vC","../../style/Text.js":"dwGM6","../../expr/expression.js":"7wOmt","../../expr/cpu.js":"l7qGi","../../obj.js":"3ssAG","../../size.js":"lKEPe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dJiIs":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Icon
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("./Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _colorJs = require("../color.js");
var _assertsJs = require("../asserts.js");
var _iconImageJs = require("./IconImage.js");
var _utilJs = require("../util.js");
/**
 * @typedef {'fraction' | 'pixels'} IconAnchorUnits
 * Anchor unit can be either a fraction of the icon size or in pixels.
 */ /**
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} IconOrigin
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 */ /**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {IconOrigin} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {IconAnchorUnits} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {IconAnchorUnits} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement|ImageBitmap} [img] Image object for the icon.
 * @property {Array<number>} [displacement=[0, 0]] Displacement of the icon in pixels.
 * Positive values will shift the icon right and up.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number} [width] The width of the icon in pixels. This can't be used together with `scale`.
 * @property {number} [height] The height of the icon in pixels. This can't be used together with `scale`.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {Array<number>} [offset=[0, 0]] Offset which, together with `size` and `offsetOrigin`, defines the
 * sub-rectangle to use from the original (sprite) image.
 * @property {IconOrigin} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("../size.js").Size} [size] Icon size in pixels. Used together with `offset` to define the
 * sub-rectangle to use from the original (sprite) image.
 * @property {string} [src] Image source URI.
 * @property {"declutter"|"obstacle"|"none"|undefined} [declutterMode] Declutter mode.
 */ /**
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {number|undefined} wantedWidth The wanted width.
 * @param {number|undefined} wantedHeight The wanted height.
 * @return {number|Array<number>} The scale.
 */ function calculateScale(width, height, wantedWidth, wantedHeight) {
    if (wantedWidth !== undefined && wantedHeight !== undefined) return [
        wantedWidth / width,
        wantedHeight / height
    ];
    if (wantedWidth !== undefined) return wantedWidth / width;
    if (wantedHeight !== undefined) return wantedHeight / height;
    return 1;
}
/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */ class Icon extends (0, _imageJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @type {number}
     */ const opacity = options.opacity !== undefined ? options.opacity : 1;
        /**
     * @type {number}
     */ const rotation = options.rotation !== undefined ? options.rotation : 0;
        /**
     * @type {number|import("../size.js").Size}
     */ const scale = options.scale !== undefined ? options.scale : 1;
        /**
     * @type {boolean}
     */ const rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
        super({
            opacity: opacity,
            rotation: rotation,
            scale: scale,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ],
            rotateWithView: rotateWithView,
            declutterMode: options.declutterMode
        });
        /**
     * @private
     * @type {Array<number>}
     */ this.anchor_ = options.anchor !== undefined ? options.anchor : [
            0.5,
            0.5
        ];
        /**
     * @private
     * @type {Array<number>}
     */ this.normalizedAnchor_ = null;
        /**
     * @private
     * @type {IconOrigin}
     */ this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : 'top-left';
        /**
     * @private
     * @type {IconAnchorUnits}
     */ this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : 'fraction';
        /**
     * @private
     * @type {IconAnchorUnits}
     */ this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : 'fraction';
        /**
     * @private
     * @type {?string}
     */ this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
        const image = options.img !== undefined ? options.img : null;
        let cacheKey = options.src;
        (0, _assertsJs.assert)(!(cacheKey !== undefined && image), '`image` and `src` cannot be provided at the same time');
        if ((cacheKey === undefined || cacheKey.length === 0) && image) cacheKey = /** @type {HTMLImageElement} */ image.src || (0, _utilJs.getUid)(image);
        (0, _assertsJs.assert)(cacheKey !== undefined && cacheKey.length > 0, 'A defined and non-empty `src` or `image` must be provided');
        (0, _assertsJs.assert)(!((options.width !== undefined || options.height !== undefined) && options.scale !== undefined), '`width` or `height` cannot be provided together with `scale`');
        let imageState;
        if (options.src !== undefined) imageState = (0, _imageStateJsDefault.default).IDLE;
        else if (image !== undefined) {
            if (image instanceof HTMLImageElement) {
                if (image.complete) imageState = image.src ? (0, _imageStateJsDefault.default).LOADED : (0, _imageStateJsDefault.default).IDLE;
                else imageState = (0, _imageStateJsDefault.default).LOADING;
            } else imageState = (0, _imageStateJsDefault.default).LOADED;
        }
        /**
     * @private
     * @type {import("../color.js").Color}
     */ this.color_ = options.color !== undefined ? (0, _colorJs.asArray)(options.color) : null;
        /**
     * @private
     * @type {import("./IconImage.js").default}
     */ this.iconImage_ = (0, _iconImageJs.get)(image, /** @type {string} */ cacheKey, this.crossOrigin_, imageState, this.color_);
        /**
     * @private
     * @type {Array<number>}
     */ this.offset_ = options.offset !== undefined ? options.offset : [
            0,
            0
        ];
        /**
     * @private
     * @type {IconOrigin}
     */ this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : 'top-left';
        /**
     * @private
     * @type {Array<number>}
     */ this.origin_ = null;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.size_ = options.size !== undefined ? options.size : null;
        /**
     * Calculate the scale if width or height were given.
     */ if (options.width !== undefined || options.height !== undefined) {
            let width, height;
            if (options.size) [width, height] = options.size;
            else {
                const image = this.getImage(1);
                if (image.width && image.height) {
                    width = image.width;
                    height = image.height;
                } else if (image instanceof HTMLImageElement) {
                    this.initialOptions_ = options;
                    const onload = ()=>{
                        this.unlistenImageChange(onload);
                        if (!this.initialOptions_) return;
                        const imageSize = this.iconImage_.getSize();
                        this.setScale(calculateScale(imageSize[0], imageSize[1], options.width, options.height));
                    };
                    this.listenImageChange(onload);
                    return;
                }
            }
            if (width !== undefined) this.setScale(calculateScale(width, height, options.width, options.height));
        }
    }
    /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */ clone() {
        let scale, width, height;
        if (this.initialOptions_) {
            width = this.initialOptions_.width;
            height = this.initialOptions_.height;
        } else {
            scale = this.getScale();
            scale = Array.isArray(scale) ? scale.slice() : scale;
        }
        return new Icon({
            anchor: this.anchor_.slice(),
            anchorOrigin: this.anchorOrigin_,
            anchorXUnits: this.anchorXUnits_,
            anchorYUnits: this.anchorYUnits_,
            color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
            crossOrigin: this.crossOrigin_,
            offset: this.offset_.slice(),
            offsetOrigin: this.offsetOrigin_,
            opacity: this.getOpacity(),
            rotateWithView: this.getRotateWithView(),
            rotation: this.getRotation(),
            scale,
            width,
            height,
            size: this.size_ !== null ? this.size_.slice() : undefined,
            src: this.getSrc(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
    }
    /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */ getAnchor() {
        let anchor = this.normalizedAnchor_;
        if (!anchor) {
            anchor = this.anchor_;
            const size = this.getSize();
            if (this.anchorXUnits_ == 'fraction' || this.anchorYUnits_ == 'fraction') {
                if (!size) return null;
                anchor = this.anchor_.slice();
                if (this.anchorXUnits_ == 'fraction') anchor[0] *= size[0];
                if (this.anchorYUnits_ == 'fraction') anchor[1] *= size[1];
            }
            if (this.anchorOrigin_ != 'top-left') {
                if (!size) return null;
                if (anchor === this.anchor_) anchor = this.anchor_.slice();
                if (this.anchorOrigin_ == 'top-right' || this.anchorOrigin_ == 'bottom-right') anchor[0] = -anchor[0] + size[0];
                if (this.anchorOrigin_ == 'bottom-left' || this.anchorOrigin_ == 'bottom-right') anchor[1] = -anchor[1] + size[1];
            }
            this.normalizedAnchor_ = anchor;
        }
        const displacement = this.getDisplacement();
        const scale = this.getScaleArray();
        // anchor is scaled by renderer but displacement should not be scaled
        // so divide by scale here
        return [
            anchor[0] - displacement[0] / scale[0],
            anchor[1] + displacement[1] / scale[1]
        ];
    }
    /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */ setAnchor(anchor) {
        this.anchor_ = anchor;
        this.normalizedAnchor_ = null;
    }
    /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */ getColor() {
        return this.color_;
    }
    /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   */ getImage(pixelRatio) {
        return this.iconImage_.getImage(pixelRatio);
    }
    /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */ getPixelRatio(pixelRatio) {
        return this.iconImage_.getPixelRatio(pixelRatio);
    }
    /**
   * @return {import("../size.js").Size} Image size.
   */ getImageSize() {
        return this.iconImage_.getSize();
    }
    /**
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return this.iconImage_.getImageState();
    }
    /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */ getHitDetectionImage() {
        return this.iconImage_.getHitDetectionImage();
    }
    /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */ getOrigin() {
        if (this.origin_) return this.origin_;
        let offset = this.offset_;
        if (this.offsetOrigin_ != 'top-left') {
            const size = this.getSize();
            const iconImageSize = this.iconImage_.getSize();
            if (!size || !iconImageSize) return null;
            offset = offset.slice();
            if (this.offsetOrigin_ == 'top-right' || this.offsetOrigin_ == 'bottom-right') offset[0] = iconImageSize[0] - size[0] - offset[0];
            if (this.offsetOrigin_ == 'bottom-left' || this.offsetOrigin_ == 'bottom-right') offset[1] = iconImageSize[1] - size[1] - offset[1];
        }
        this.origin_ = offset;
        return this.origin_;
    }
    /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */ getSrc() {
        return this.iconImage_.getSrc();
    }
    /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */ getSize() {
        return !this.size_ ? this.iconImage_.getSize() : this.size_;
    }
    /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */ getWidth() {
        const scale = this.getScaleArray();
        if (this.size_) return this.size_[0] * scale[0];
        if (this.iconImage_.getImageState() == (0, _imageStateJsDefault.default).LOADED) return this.iconImage_.getSize()[0] * scale[0];
        return undefined;
    }
    /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */ getHeight() {
        const scale = this.getScaleArray();
        if (this.size_) return this.size_[1] * scale[1];
        if (this.iconImage_.getImageState() == (0, _imageStateJsDefault.default).LOADED) return this.iconImage_.getSize()[1] * scale[1];
        return undefined;
    }
    /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */ setScale(scale) {
        delete this.initialOptions_;
        super.setScale(scale);
    }
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ listenImageChange(listener) {
        this.iconImage_.addEventListener((0, _eventTypeJsDefault.default).CHANGE, listener);
    }
    /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */ load() {
        this.iconImage_.load();
    }
    /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */ unlistenImageChange(listener) {
        this.iconImage_.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, listener);
    }
}
exports.default = Icon;

},{"../events/EventType.js":"hrQJ6","../ImageState.js":"c4jJS","./Image.js":"eyoR9","../color.js":"4tahz","../asserts.js":"e4TiF","./IconImage.js":"8WrYM","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8WrYM":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/IconImage
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
 * @param {string} cacheKey Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */ parcelHelpers.export(exports, "get", ()=>get);
var _targetJs = require("../events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _colorJs = require("../color.js");
var _domJs = require("../dom.js");
var _imageJs = require("../Image.js");
var _iconImageCacheJs = require("./IconImageCache.js");
/**
 * @type {CanvasRenderingContext2D}
 */ let taintedTestContext = null;
class IconImage extends (0, _targetJsDefault.default) {
    /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */ constructor(image, src, crossOrigin, imageState, color){
        super();
        /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap}
     */ this.hitDetectionImage_ = null;
        /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement|ImageBitmap}
     */ this.image_ = image;
        /**
     * @private
     * @type {string|null}
     */ this.crossOrigin_ = crossOrigin;
        /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */ this.canvas_ = {};
        /**
     * @private
     * @type {import("../color.js").Color}
     */ this.color_ = color;
        /**
     * @private
     * @type {import("../ImageState.js").default}
     */ this.imageState_ = imageState === undefined ? (0, _imageStateJsDefault.default).IDLE : imageState;
        /**
     * @private
     * @type {import("../size.js").Size|null}
     */ this.size_ = image && image.width && image.height ? [
            image.width,
            image.height
        ] : null;
        /**
     * @private
     * @type {string|undefined}
     */ this.src_ = src;
        /**
     * @private
     */ this.tainted_;
    }
    /**
   * @private
   */ initializeImage_() {
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) this.image_.crossOrigin = this.crossOrigin_;
    }
    /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */ isTainted_() {
        if (this.tainted_ === undefined && this.imageState_ === (0, _imageStateJsDefault.default).LOADED) {
            if (!taintedTestContext) taintedTestContext = (0, _domJs.createCanvasContext2D)(1, 1, undefined, {
                willReadFrequently: true
            });
            taintedTestContext.drawImage(this.image_, 0, 0);
            try {
                taintedTestContext.getImageData(0, 0, 1, 1);
                this.tainted_ = false;
            } catch (e) {
                taintedTestContext = null;
                this.tainted_ = true;
            }
        }
        return this.tainted_ === true;
    }
    /**
   * @private
   */ dispatchChangeEvent_() {
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * @private
   */ handleImageError_() {
        this.imageState_ = (0, _imageStateJsDefault.default).ERROR;
        this.dispatchChangeEvent_();
    }
    /**
   * @private
   */ handleImageLoad_() {
        this.imageState_ = (0, _imageStateJsDefault.default).LOADED;
        this.size_ = [
            this.image_.width,
            this.image_.height
        ];
        this.dispatchChangeEvent_();
    }
    /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */ getImage(pixelRatio) {
        if (!this.image_) this.initializeImage_();
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
    }
    /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */ getPixelRatio(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
    }
    /**
   * @return {import("../ImageState.js").default} Image state.
   */ getImageState() {
        return this.imageState_;
    }
    /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */ getHitDetectionImage() {
        if (!this.image_) this.initializeImage_();
        if (!this.hitDetectionImage_) {
            if (this.isTainted_()) {
                const width = this.size_[0];
                const height = this.size_[1];
                const context = (0, _domJs.createCanvasContext2D)(width, height);
                context.fillRect(0, 0, width, height);
                this.hitDetectionImage_ = context.canvas;
            } else this.hitDetectionImage_ = this.image_;
        }
        return this.hitDetectionImage_;
    }
    /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */ getSize() {
        return this.size_;
    }
    /**
   * @return {string|undefined} Image src.
   */ getSrc() {
        return this.src_;
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.imageState_ !== (0, _imageStateJsDefault.default).IDLE) return;
        if (!this.image_) this.initializeImage_();
        this.imageState_ = (0, _imageStateJsDefault.default).LOADING;
        try {
            if (this.src_ !== undefined) /** @type {HTMLImageElement} */ this.image_.src = this.src_;
        } catch (e) {
            this.handleImageError_();
        }
        if (this.image_ instanceof HTMLImageElement) (0, _imageJs.decodeFallback)(this.image_, this.src_).then((image)=>{
            this.image_ = image;
            this.handleImageLoad_();
        }).catch(this.handleImageError_.bind(this));
    }
    /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */ replaceColor_(pixelRatio) {
        if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== (0, _imageStateJsDefault.default).LOADED) return;
        const image = this.image_;
        const canvas = document.createElement('canvas');
        canvas.width = Math.ceil(image.width * pixelRatio);
        canvas.height = Math.ceil(image.height * pixelRatio);
        const ctx = canvas.getContext('2d');
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(image, 0, 0);
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = (0, _colorJs.asString)(this.color_);
        ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
        ctx.globalCompositeOperation = 'destination-in';
        ctx.drawImage(image, 0, 0);
        this.canvas_[pixelRatio] = canvas;
    }
}
function get(image, cacheKey, crossOrigin, imageState, color) {
    let iconImage = cacheKey === undefined ? undefined : (0, _iconImageCacheJs.shared).get(cacheKey, crossOrigin, color);
    if (!iconImage) {
        iconImage = new IconImage(image, image instanceof HTMLImageElement ? image.src || undefined : cacheKey, crossOrigin, imageState, color);
        (0, _iconImageCacheJs.shared).set(cacheKey, crossOrigin, color, iconImage);
    }
    return iconImage;
}
exports.default = IconImage;

},{"../events/Target.js":"7T5Yi","../events/EventType.js":"hrQJ6","../ImageState.js":"c4jJS","../color.js":"4tahz","../dom.js":"84QzQ","../Image.js":"c0Egp","./IconImageCache.js":"2uEpE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c0Egp":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Image
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import('./DataTile.js').ImageLike} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */ parcelHelpers.export(exports, "listenImage", ()=>listenImage);
/**
 * Loads an image.
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.
 * @api
 */ parcelHelpers.export(exports, "load", ()=>load);
/**
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<HTMLImageElement>} Promise resolving to an `HTMLImageElement`.
 */ parcelHelpers.export(exports, "decodeFallback", ()=>decodeFallback);
/**
 * Loads an image and decodes it to an `ImageBitmap` if `createImageBitmap()` is supported. Returns
 * the loaded image otherwise.
 * @param {HTMLImageElement} image Image, not yet loaded.
 * @param {string} [src] `src` attribute of the image. Optional, not required if already present.
 * @return {Promise<ImageBitmap|HTMLImageElement>} Promise resolving to an `ImageBitmap` or an
 * `HTMLImageElement` if `createImageBitmap()` is not supported.
 * @api
 */ parcelHelpers.export(exports, "decode", ()=>decode);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("./ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _hasJs = require("./has.js");
var _eventsJs = require("./events.js");
var _functionsJs = require("./functions.js");
/**
 * A function that takes an {@link module:ol/Image~ImageWrapper} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~ImageWrapper#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(import("./Image.js").default, string): void} LoadFunction
 * @api
 */ /**
 * @typedef {Object} ImageObject
 * @property {import("./extent.js").Extent} [extent] Extent, if different from the requested one.
 * @property {import("./resolution.js").ResolutionLike} [resolution] Resolution, if different from the requested one.
 * When x and y resolution are different, use the array type (`[xResolution, yResolution]`).
 * @property {number} [pixelRatio] Pixel ratio, if different from the requested one.
 * @property {import('./DataTile.js').ImageLike} image Image.
 */ /**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * For images that cover any extent and resolution (static images), the loader function should not accept
 * any arguments. The function returns an {@link import("./DataTile.js").ImageLike image}, an
 * {@link import("./Image.js").ImageObject image object}, or a promise for the same.
 * For loaders that generate images, the promise should not resolve until the image is loaded.
 * If the returned image does not match the extent, resolution or pixel ratio passed to the loader,
 * it has to return an {@link import("./Image.js").ImageObject image object} with the `image` and the
 * correct `extent`, `resolution` and `pixelRatio`.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} Loader
 * @api
 */ /**
 * Loader function used for image sources. Receives extent, resolution and pixel ratio as arguments.
 * The function returns a promise for an  {@link import("./Image.js").ImageObject image object}.
 *
 * @typedef {function(import("./extent.js").Extent, number, number, (function(HTMLImageElement, string): void)=): import("./DataTile.js").ImageLike|ImageObject|Promise<import("./DataTile.js").ImageLike|ImageObject>} ImageObjectPromiseLoader
 */ class ImageWrapper extends (0, _targetJsDefault.default) {
    /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
   */ constructor(extent, resolution, pixelRatio, stateOrLoader){
        super();
        /**
     * @protected
     * @type {import("./extent.js").Extent}
     */ this.extent = extent;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @protected
     * @type {number|Array<number>|undefined}
     */ this.resolution = resolution;
        /**
     * @protected
     * @type {import("./ImageState.js").default}
     */ this.state = typeof stateOrLoader === 'function' ? (0, _imageStateJsDefault.default).IDLE : stateOrLoader;
        /**
     * @private
     * @type {import('./DataTile.js').ImageLike|null}
     */ this.image_ = null;
        /**
     * @protected
     * @type {import("./Image.js").Loader}
     */ this.loader = typeof stateOrLoader === 'function' ? stateOrLoader : null;
    }
    /**
   * @protected
   */ changed() {
        this.dispatchEvent((0, _eventTypeJsDefault.default).CHANGE);
    }
    /**
   * @return {import("./extent.js").Extent} Extent.
   */ getExtent() {
        return this.extent;
    }
    /**
   * @return {import('./DataTile.js').ImageLike} Image.
   */ getImage() {
        return this.image_;
    }
    /**
   * @return {number} PixelRatio.
   */ getPixelRatio() {
        return this.pixelRatio_;
    }
    /**
   * @return {number|Array<number>} Resolution.
   */ getResolution() {
        return /** @type {number} */ this.resolution;
    }
    /**
   * @return {import("./ImageState.js").default} State.
   */ getState() {
        return this.state;
    }
    /**
   * Load not yet loaded URI.
   */ load() {
        if (this.state == (0, _imageStateJsDefault.default).IDLE) {
            if (this.loader) {
                this.state = (0, _imageStateJsDefault.default).LOADING;
                this.changed();
                const resolution = this.getResolution();
                const requestResolution = Array.isArray(resolution) ? resolution[0] : resolution;
                (0, _functionsJs.toPromise)(()=>this.loader(this.getExtent(), requestResolution, this.getPixelRatio())).then((image)=>{
                    if ('image' in image) this.image_ = image.image;
                    if ('extent' in image) this.extent = image.extent;
                    if ('resolution' in image) this.resolution = image.resolution;
                    if ('pixelRatio' in image) this.pixelRatio_ = image.pixelRatio;
                    if (image instanceof HTMLImageElement || image instanceof ImageBitmap || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement) this.image_ = image;
                    this.state = (0, _imageStateJsDefault.default).LOADED;
                }).catch((error)=>{
                    this.state = (0, _imageStateJsDefault.default).ERROR;
                    console.error(error); // eslint-disable-line no-console
                }).finally(()=>this.changed());
            }
        }
    }
    /**
   * @param {import('./DataTile.js').ImageLike} image The image.
   */ setImage(image) {
        this.image_ = image;
    }
    /**
   * @param {number|Array<number>} resolution Resolution.
   */ setResolution(resolution) {
        this.resolution = resolution;
    }
}
function listenImage(image, loadHandler, errorHandler) {
    const img = /** @type {HTMLImageElement} */ image;
    let listening = true;
    let decoding = false;
    let loaded = false;
    const listenerKeys = [
        (0, _eventsJs.listenOnce)(img, (0, _eventTypeJsDefault.default).LOAD, function() {
            loaded = true;
            if (!decoding) loadHandler();
        })
    ];
    if (img.src && (0, _hasJs.IMAGE_DECODE)) {
        decoding = true;
        img.decode().then(function() {
            if (listening) loadHandler();
        }).catch(function(error) {
            if (listening) {
                if (loaded) loadHandler();
                else errorHandler();
            }
        });
    } else listenerKeys.push((0, _eventsJs.listenOnce)(img, (0, _eventTypeJsDefault.default).ERROR, errorHandler));
    return function unlisten() {
        listening = false;
        listenerKeys.forEach((0, _eventsJs.unlistenByKey));
    };
}
function load(image, src) {
    return new Promise((resolve, reject)=>{
        function handleLoad() {
            unlisten();
            resolve(image);
        }
        function handleError() {
            unlisten();
            reject(new Error('Image load error'));
        }
        function unlisten() {
            image.removeEventListener('load', handleLoad);
            image.removeEventListener('error', handleError);
        }
        image.addEventListener('load', handleLoad);
        image.addEventListener('error', handleError);
        if (src) image.src = src;
    });
}
function decodeFallback(image, src) {
    if (src) image.src = src;
    return image.src && (0, _hasJs.IMAGE_DECODE) ? new Promise((resolve, reject)=>image.decode().then(()=>resolve(image)).catch((e)=>image.complete && image.width ? resolve(image) : reject(e))) : load(image);
}
function decode(image, src) {
    if (src) image.src = src;
    return image.src && (0, _hasJs.IMAGE_DECODE) && (0, _hasJs.CREATE_IMAGE_BITMAP) ? image.decode().then(()=>createImageBitmap(image)).catch((e)=>{
        if (image.complete && image.width) return image;
        throw e;
    }) : decodeFallback(image);
}
exports.default = ImageWrapper;

},{"./events/Target.js":"7T5Yi","./events/EventType.js":"hrQJ6","./ImageState.js":"c4jJS","./has.js":"6BDNi","./events.js":"dcspA","./functions.js":"iqv8I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2uEpE":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/IconImageCache
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shared", ()=>shared);
var _colorJs = require("../color.js");
/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.
 */ class IconImageCache {
    constructor(){
        /**
     * @type {!Object<string, import("./IconImage.js").default>}
     * @private
     */ this.cache_ = {};
        /**
     * @type {number}
     * @private
     */ this.cacheSize_ = 0;
        /**
     * @type {number}
     * @private
     */ this.maxCacheSize_ = 32;
    }
    /**
   * FIXME empty description for jsdoc
   */ clear() {
        this.cache_ = {};
        this.cacheSize_ = 0;
    }
    /**
   * @return {boolean} Can expire cache.
   */ canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_;
    }
    /**
   * FIXME empty description for jsdoc
   */ expire() {
        if (this.canExpireCache()) {
            let i = 0;
            for(const key in this.cache_){
                const iconImage = this.cache_[key];
                if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                    delete this.cache_[key];
                    --this.cacheSize_;
                }
            }
        }
    }
    /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */ get(src, crossOrigin, color) {
        const key = getKey(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
    }
    /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @param {import("./IconImage.js").default} iconImage Icon image.
   */ set(src, crossOrigin, color, iconImage) {
        const key = getKey(src, crossOrigin, color);
        this.cache_[key] = iconImage;
        ++this.cacheSize_;
    }
    /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */ setSize(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
    }
}
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */ function getKey(src, crossOrigin, color) {
    const colorString = color ? (0, _colorJs.asString)(color) : 'null';
    return crossOrigin + ':' + src + ':' + colorString;
}
exports.default = IconImageCache;
const shared = new IconImageCache();

},{"../color.js":"4tahz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dwGM6":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style/Text
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fillJs = require("./Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _sizeJs = require("../size.js");
/**
 * @typedef {'point' | 'line'} TextPlacement
 * Default text placement is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 */ /**
 * @typedef {'left' | 'center' | 'right'} TextJustify
 */ /**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */ const DEFAULT_FILL_COLOR = '#333';
/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS `font` value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is `'10px sans-serif'`
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {TextPlacement} [placement='point'] Text placement.
 * @property {number} [repeat] Repeat interval. When set, the text will be repeated at this interval, which specifies
 * the distance between two text anchors in pixels. Only available when `placement` is set to `'line'`. Overrides 'textAlign'.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string|Array<string>} [text] Text content or rich text content. For plain text provide a string, which can
 * contain line breaks (`\n`). For rich text provide an array of text/font tuples. A tuple consists of the text to
 * render and the font to use (or `''` to use the text style's font). A line break has to be a separate tuple (i.e. `'\n', ''`).
 * **Example:** `['foo', 'bold 10px sans-serif', ' bar', 'italic 10px sans-serif', ' baz', '']` will yield "**foo** *bar* baz".
 * **Note:** Rich text is not supported for `placement: 'line'` or the immediate rendering API.
 * @property {CanvasTextAlign} [textAlign] Text alignment. Possible values: `'left'`, `'right'`, `'center'`, `'end'` or `'start'`.
 * Default is `'center'` for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {TextJustify} [justify] Text justification within the text box.
 * If not set, text is justified towards the `textAlign` anchor.
 * Otherwise, use options `'left'`, `'center'`, or `'right'` to justify the text within the text box.
 * **Note:** `justify` is ignored for immediate rendering and also for `placement: 'line'`.
 * @property {CanvasTextBaseline} [textBaseline='middle'] Text base line. Possible values: `'bottom'`, `'top'`, `'middle'`, `'alphabetic'`,
 * `'hanging'`, `'ideographic'`.
 * @property {import("./Fill.js").default|null} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333). Specify `null` for no fill.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */ /**
 * @classdesc
 * Set text style for vector features.
 * @api
 */ class Text {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options || {};
        /**
     * @private
     * @type {string|undefined}
     */ this.font_ = options.font;
        /**
     * @private
     * @type {number|undefined}
     */ this.rotation_ = options.rotation;
        /**
     * @private
     * @type {boolean|undefined}
     */ this.rotateWithView_ = options.rotateWithView;
        /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */ this.scale_ = options.scale;
        /**
     * @private
     * @type {import("../size.js").Size}
     */ this.scaleArray_ = (0, _sizeJs.toSize)(options.scale !== undefined ? options.scale : 1);
        /**
     * @private
     * @type {string|Array<string>|undefined}
     */ this.text_ = options.text;
        /**
     * @private
     * @type {CanvasTextAlign|undefined}
     */ this.textAlign_ = options.textAlign;
        /**
     * @private
     * @type {TextJustify|undefined}
     */ this.justify_ = options.justify;
        /**
     * @private
     * @type {number|undefined}
     */ this.repeat_ = options.repeat;
        /**
     * @private
     * @type {CanvasTextBaseline|undefined}
     */ this.textBaseline_ = options.textBaseline;
        /**
     * @private
     * @type {import("./Fill.js").default|null}
     */ this.fill_ = options.fill !== undefined ? options.fill : new (0, _fillJsDefault.default)({
            color: DEFAULT_FILL_COLOR
        });
        /**
     * @private
     * @type {number}
     */ this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
        /**
     * @private
     * @type {TextPlacement}
     */ this.placement_ = options.placement !== undefined ? options.placement : 'point';
        /**
     * @private
     * @type {boolean}
     */ this.overflow_ = !!options.overflow;
        /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
     * @private
     * @type {number}
     */ this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
        /**
     * @private
     * @type {number}
     */ this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
        /**
     * @private
     * @type {import("./Fill.js").default|null}
     */ this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
        /**
     * @private
     * @type {import("./Stroke.js").default|null}
     */ this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
        /**
     * @private
     * @type {Array<number>|null}
     */ this.padding_ = options.padding === undefined ? null : options.padding;
    }
    /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */ clone() {
        const scale = this.getScale();
        return new Text({
            font: this.getFont(),
            placement: this.getPlacement(),
            repeat: this.getRepeat(),
            maxAngle: this.getMaxAngle(),
            overflow: this.getOverflow(),
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            text: this.getText(),
            textAlign: this.getTextAlign(),
            justify: this.getJustify(),
            textBaseline: this.getTextBaseline(),
            fill: this.getFill() ? this.getFill().clone() : undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            offsetX: this.getOffsetX(),
            offsetY: this.getOffsetY(),
            backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,
            backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined,
            padding: this.getPadding() || undefined
        });
    }
    /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */ getOverflow() {
        return this.overflow_;
    }
    /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */ getFont() {
        return this.font_;
    }
    /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */ getMaxAngle() {
        return this.maxAngle_;
    }
    /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */ getPlacement() {
        return this.placement_;
    }
    /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */ getRepeat() {
        return this.repeat_;
    }
    /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */ getOffsetX() {
        return this.offsetX_;
    }
    /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */ getOffsetY() {
        return this.offsetY_;
    }
    /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */ getFill() {
        return this.fill_;
    }
    /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */ getRotateWithView() {
        return this.rotateWithView_;
    }
    /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */ getRotation() {
        return this.rotation_;
    }
    /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */ getScale() {
        return this.scale_;
    }
    /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */ getScaleArray() {
        return this.scaleArray_;
    }
    /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */ getStroke() {
        return this.stroke_;
    }
    /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */ getText() {
        return this.text_;
    }
    /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */ getTextAlign() {
        return this.textAlign_;
    }
    /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */ getJustify() {
        return this.justify_;
    }
    /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */ getTextBaseline() {
        return this.textBaseline_;
    }
    /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */ getBackgroundFill() {
        return this.backgroundFill_;
    }
    /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */ getBackgroundStroke() {
        return this.backgroundStroke_;
    }
    /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */ getPadding() {
        return this.padding_;
    }
    /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */ setOverflow(overflow) {
        this.overflow_ = overflow;
    }
    /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */ setFont(font) {
        this.font_ = font;
    }
    /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */ setMaxAngle(maxAngle) {
        this.maxAngle_ = maxAngle;
    }
    /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */ setOffsetX(offsetX) {
        this.offsetX_ = offsetX;
    }
    /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */ setOffsetY(offsetY) {
        this.offsetY_ = offsetY;
    }
    /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */ setPlacement(placement) {
        this.placement_ = placement;
    }
    /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */ setRepeat(repeat) {
        this.repeat_ = repeat;
    }
    /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */ setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
    }
    /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */ setFill(fill) {
        this.fill_ = fill;
    }
    /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */ setRotation(rotation) {
        this.rotation_ = rotation;
    }
    /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */ setScale(scale) {
        this.scale_ = scale;
        this.scaleArray_ = (0, _sizeJs.toSize)(scale !== undefined ? scale : 1);
    }
    /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */ setStroke(stroke) {
        this.stroke_ = stroke;
    }
    /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */ setText(text) {
        this.text_ = text;
    }
    /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */ setTextAlign(textAlign) {
        this.textAlign_ = textAlign;
    }
    /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */ setJustify(justify) {
        this.justify_ = justify;
    }
    /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */ setTextBaseline(textBaseline) {
        this.textBaseline_ = textBaseline;
    }
    /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */ setBackgroundFill(fill) {
        this.backgroundFill_ = fill;
    }
    /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */ setBackgroundStroke(stroke) {
        this.backgroundStroke_ = stroke;
    }
    /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */ setPadding(padding) {
        this.padding_ = padding;
    }
}
exports.default = Text;

},{"./Fill.js":"4fB56","../size.js":"lKEPe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7wOmt":[function(require,module,exports,__globalThis) {
/**
 * @module ol/expr/expression
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoneType", ()=>NoneType);
parcelHelpers.export(exports, "BooleanType", ()=>BooleanType);
parcelHelpers.export(exports, "NumberType", ()=>NumberType);
parcelHelpers.export(exports, "StringType", ()=>StringType);
parcelHelpers.export(exports, "ColorType", ()=>ColorType);
parcelHelpers.export(exports, "NumberArrayType", ()=>NumberArrayType);
parcelHelpers.export(exports, "AnyType", ()=>AnyType);
/**
 * Get a string representation for a type.
 * @param {number} type The type.
 * @return {string} The type name.
 */ parcelHelpers.export(exports, "typeName", ()=>typeName);
/**
 * @param {number} broad The broad type.
 * @param {number} specific The specific type.
 * @return {boolean} The broad type includes the specific type.
 */ parcelHelpers.export(exports, "includesType", ()=>includesType);
/**
 * @param {number} oneType One type.
 * @param {number} otherType Another type.
 * @return {boolean} The set of types overlap (share a common specific type)
 */ parcelHelpers.export(exports, "overlapsType", ()=>overlapsType);
/**
 * @param {number} type The type.
 * @param {number} expected The expected type.
 * @return {boolean} The given type is exactly the expected type.
 */ parcelHelpers.export(exports, "isType", ()=>isType);
/**
 * @typedef {boolean|number|string|Array<number>} LiteralValue
 */ parcelHelpers.export(exports, "LiteralExpression", ()=>LiteralExpression);
parcelHelpers.export(exports, "CallExpression", ()=>CallExpression);
/**
 * @typedef {LiteralExpression|CallExpression} Expression
 */ /**
 * @typedef {Object} ParsingContext
 * @property {Set<string>} variables Variables referenced with the 'var' operator.
 * @property {Set<string>} properties Properties referenced with the 'get' operator.
 * @property {boolean} featureId The style uses the feature id.
 * @property {import("../style/flat.js").FlatStyle|import("../style/webgl.js").WebGLStyle} style The style being parsed
 */ /**
 * @return {ParsingContext} A new parsing context.
 */ parcelHelpers.export(exports, "newParsingContext", ()=>newParsingContext);
/**
 * @typedef {LiteralValue|Array} EncodedExpression
 */ /**
 * @param {EncodedExpression} encoded The encoded expression.
 * @param {ParsingContext} context The parsing context.
 * @param {number} [typeHint] Optional type hint
 * @return {Expression} The parsed expression result.
 */ parcelHelpers.export(exports, "parse", ()=>parse);
parcelHelpers.export(exports, "Ops", ()=>Ops);
var _arrayJs = require("../array.js");
var _colorJs = require("../color.js");
/**
 * @fileoverview This module includes types and functions for parsing array encoded expressions.
 * The result of parsing an encoded expression is one of the specific expression classes.
 * During parsing, information is added to the parsing context about the data accessed by the
 * expression.
 */ /**
 * Base type used for literal style parameters; can be a number literal or the output of an operator,
 * which in turns takes {@link import("./expression.js").ExpressionValue} arguments.
 *
 * The following operators can be used:
 *
 * * Reading operators:
 *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band
 *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values
 *     are in the 0..1 range. {@link import("../source/TileImage.js").default} sources have 4 bands: red,
 *     green, blue and alpha. {@link import("../source/DataTile.js").default} sources can have any number
 *     of bands, depending on the underlying data source and
 *     {@link import("../source/GeoTIFF.js").Options configuration}. `xOffset` and `yOffset` are optional
 *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.
 *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`
 *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which
 *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'
 *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'
 *     `Multi*` values are returned as their singular equivalent
 *     `Circle` geometries are returned as 'Polygon'
 *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection
 *   * `['resolution']` returns the current resolution
 *   * `['time']` returns the time in seconds since the creation of the layer
 *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined
 *   * `['zoom']` returns the current zoom level
 *
 * * Math operators:
 *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)
 *   * `['/', value1, value2]` divides `value1` by `value2`
 *   * `['+', value1, value2, ...]` adds the values
 *   * `['-', value1, value2]` subtracts `value2` from `value1`
 *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`
 *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)
 *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power
 *   * `['abs', value1]` returns the absolute value of `value1`
 *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`
 *   * `['round', value1]` returns the nearest integer to `value1`
 *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`
 *   * `['sin', value1]` returns the sine of `value1`
 *   * `['cos', value1]` returns the cosine of `value1`
 *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`
 *   * `['sqrt', value1]` returns the square root of `value1`
 *
 * * Transform operators:
 *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding
 *     condition evaluates to `true`. If no match is found, returns the `fallback` value.
 *     All conditions should be `boolean`, output and fallback can be any kind.
 *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all
 *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,
 *     returns the `fallback` value.
 *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and
 *     `fallback` values must be of the same type, and can be of any kind.
 *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between
 *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is
 *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value
 *     of 1 is equivalent to `['linear']`.
 *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.
 *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised
 *     between `output1` and `outputN`.
 *
 * * Logical operators:
 *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.
 *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.
 *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.
 *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.
 *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.
 *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.
 *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.
 *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.
 *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.
 *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`
 *     (inclusively), or `false` otherwise.
 *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and
 *     `false` otherwise.
 *     This operator has the following limitations:
 *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)
 *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an
 *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:
 *     `['literal', ['abc', 'def', 'ghi']]`
 *
 * * Conversion operators:
 *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of
 *     values can currently only be 2, 3 or 4.
 *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is
 *     optional; if not specified, it will be set to 1.
 *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.
 *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`
 *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors
 *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),
 *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b
 *     in the 0-255 range and a in the 0-1 range).
 *
 * Values can either be literals or another operator, as they will be evaluated recursively.
 * Literal values can be of the following types:
 * * `boolean`
 * * `number`
 * * `number[]` (number arrays can only have a length of 2, 3 or 4)
 * * `string`
 * * {@link module:ol/color~Color}
 *
 * @typedef {Array<*>|import("../color.js").Color|string|number|boolean} ExpressionValue
 * @api
 */ let numTypes = 0;
const NoneType = 0;
const BooleanType = 1 << numTypes++;
const NumberType = 1 << numTypes++;
const StringType = 1 << numTypes++;
const ColorType = 1 << numTypes++;
const NumberArrayType = 1 << numTypes++;
const AnyType = Math.pow(2, numTypes) - 1;
const typeNames = {
    [BooleanType]: 'boolean',
    [NumberType]: 'number',
    [StringType]: 'string',
    [ColorType]: 'color',
    [NumberArrayType]: 'number[]'
};
const namedTypes = Object.keys(typeNames).map(Number).sort((0, _arrayJs.ascending));
function typeName(type) {
    const names = [];
    for (const namedType of namedTypes)if (includesType(type, namedType)) names.push(typeNames[namedType]);
    if (names.length === 0) return 'untyped';
    if (names.length < 3) return names.join(' or ');
    return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];
}
function includesType(broad, specific) {
    return (broad & specific) === specific;
}
function overlapsType(oneType, otherType) {
    return !!(oneType & otherType);
}
function isType(type, expected) {
    return type === expected;
}
class LiteralExpression {
    /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */ constructor(type, value){
        this.type = type;
        this.value = value;
    }
}
class CallExpression {
    /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */ constructor(type, operator, ...args){
        this.type = type;
        this.operator = operator;
        this.args = args;
    }
}
function newParsingContext() {
    return {
        variables: new Set(),
        properties: new Set(),
        featureId: false,
        style: {}
    };
}
/**
 * @param {string} typeHint Type hint
 * @return {number} Resulting value type (will be a single type)
 */ function getTypeFromHint(typeHint) {
    switch(typeHint){
        case 'string':
            return StringType;
        case 'color':
            return ColorType;
        case 'number':
            return NumberType;
        case 'boolean':
            return BooleanType;
        case 'number[]':
            return NumberArrayType;
        default:
            throw new Error(`Unrecognized type hint: ${typeHint}`);
    }
}
function parse(encoded, context, typeHint) {
    switch(typeof encoded){
        case 'boolean':
            return new LiteralExpression(BooleanType, encoded);
        case 'number':
            return new LiteralExpression(NumberType, encoded);
        case 'string':
            {
                let type = StringType;
                if ((0, _colorJs.isStringColor)(encoded)) type |= ColorType;
                // apply the given type hint only if it won't result in an empty type
                if (!isType(type & typeHint, NoneType)) type &= typeHint;
                return new LiteralExpression(type, encoded);
            }
        default:
    }
    if (!Array.isArray(encoded)) throw new Error('Expression must be an array or a primitive value');
    if (encoded.length === 0) throw new Error('Empty expression');
    if (typeof encoded[0] === 'string') return parseCallExpression(encoded, context, typeHint);
    for (const item of encoded){
        if (typeof item !== 'number') throw new Error('Expected an array of numbers');
    }
    let type = NumberArrayType;
    if (encoded.length === 3 || encoded.length === 4) type |= ColorType;
    if (typeHint) type &= typeHint;
    return new LiteralExpression(type, encoded);
}
const Ops = {
    Get: 'get',
    Var: 'var',
    Concat: 'concat',
    GeometryType: 'geometry-type',
    Any: 'any',
    All: 'all',
    Not: '!',
    Resolution: 'resolution',
    Zoom: 'zoom',
    Time: 'time',
    Equal: '==',
    NotEqual: '!=',
    GreaterThan: '>',
    GreaterThanOrEqualTo: '>=',
    LessThan: '<',
    LessThanOrEqualTo: '<=',
    Multiply: '*',
    Divide: '/',
    Add: '+',
    Subtract: '-',
    Clamp: 'clamp',
    Mod: '%',
    Pow: '^',
    Abs: 'abs',
    Floor: 'floor',
    Ceil: 'ceil',
    Round: 'round',
    Sin: 'sin',
    Cos: 'cos',
    Atan: 'atan',
    Sqrt: 'sqrt',
    Match: 'match',
    Between: 'between',
    Interpolate: 'interpolate',
    Case: 'case',
    In: 'in',
    Number: 'number',
    String: 'string',
    Array: 'array',
    Color: 'color',
    Id: 'id',
    Band: 'band',
    Palette: 'palette'
};
/**
 * @typedef {function(Array, ParsingContext, number):Expression} Parser
 * Third argument is a type hint
 */ /**
 * @type {Object<string, Parser>}
 */ const parsers = {
    [Ops.Get]: createParser(([_, typeHint])=>{
        if (typeHint !== undefined) return getTypeFromHint(/** @type {string} */ /** @type {LiteralExpression} */ typeHint.value);
        return AnyType;
    }, withArgsCount(1, 2), withGetArgs),
    [Ops.Var]: createParser(([firstArg])=>firstArg.type, withArgsCount(1, 1), withVarArgs),
    [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),
    [Ops.Concat]: createParser(StringType, withArgsCount(2, Infinity), parseArgsOfType(AnyType)),
    [Ops.GeometryType]: createParser(StringType, withNoArgs),
    [Ops.Resolution]: createParser(NumberType, withNoArgs),
    [Ops.Zoom]: createParser(NumberType, withNoArgs),
    [Ops.Time]: createParser(NumberType, withNoArgs),
    [Ops.Any]: createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType)),
    [Ops.All]: createParser(BooleanType, withArgsCount(2, Infinity), parseArgsOfType(BooleanType)),
    [Ops.Not]: createParser(BooleanType, withArgsCount(1, 1), parseArgsOfType(BooleanType)),
    [Ops.Equal]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.NotEqual]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.GreaterThan]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.GreaterThanOrEqualTo]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.LessThan]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.LessThanOrEqualTo]: createParser(BooleanType, withArgsCount(2, 2), parseArgsOfType(AnyType), narrowArgsType),
    [Ops.Multiply]: createParser((parsedArgs)=>{
        let outputType = NumberType | ColorType;
        for(let i = 0; i < parsedArgs.length; i++)outputType &= parsedArgs[i].type;
        return outputType;
    }, withArgsCount(2, Infinity), parseArgsOfType(NumberType | ColorType), narrowArgsType),
    [Ops.Divide]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),
    [Ops.Add]: createParser(NumberType, withArgsCount(2, Infinity), parseArgsOfType(NumberType)),
    [Ops.Subtract]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),
    [Ops.Clamp]: createParser(NumberType, withArgsCount(3, 3), parseArgsOfType(NumberType)),
    [Ops.Mod]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),
    [Ops.Pow]: createParser(NumberType, withArgsCount(2, 2), parseArgsOfType(NumberType)),
    [Ops.Abs]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Floor]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Ceil]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Round]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Sin]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Cos]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Atan]: createParser(NumberType, withArgsCount(1, 2), parseArgsOfType(NumberType)),
    [Ops.Sqrt]: createParser(NumberType, withArgsCount(1, 1), parseArgsOfType(NumberType)),
    [Ops.Match]: createParser((parsedArgs)=>{
        let type = AnyType;
        for(let i = 2; i < parsedArgs.length; i += 2)type &= parsedArgs[i].type;
        type &= parsedArgs[parsedArgs.length - 1].type;
        return type;
    }, withArgsCount(4, Infinity), withEvenArgs, parseMatchArgs),
    [Ops.Between]: createParser(BooleanType, withArgsCount(3, 3), parseArgsOfType(NumberType)),
    [Ops.Interpolate]: createParser((parsedArgs)=>{
        let type = ColorType | NumberType;
        for(let i = 3; i < parsedArgs.length; i += 2)type &= parsedArgs[i].type;
        return type;
    }, withArgsCount(6, Infinity), withEvenArgs, parseInterpolateArgs),
    [Ops.Case]: createParser((parsedArgs)=>{
        let type = AnyType;
        for(let i = 1; i < parsedArgs.length; i += 2)type &= parsedArgs[i].type;
        type &= parsedArgs[parsedArgs.length - 1].type;
        return type;
    }, withArgsCount(3, Infinity), withOddArgs, parseCaseArgs),
    [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),
    [Ops.Number]: createParser(NumberType, withArgsCount(1, Infinity), parseArgsOfType(AnyType)),
    [Ops.String]: createParser(StringType, withArgsCount(1, Infinity), parseArgsOfType(AnyType)),
    [Ops.Array]: createParser((parsedArgs)=>{
        return parsedArgs.length === 3 || parsedArgs.length === 4 ? NumberArrayType | ColorType : NumberArrayType;
    }, withArgsCount(1, Infinity), parseArgsOfType(NumberType)),
    [Ops.Color]: createParser(ColorType, withArgsCount(3, 4), parseArgsOfType(NumberType)),
    [Ops.Band]: createParser(NumberType, withArgsCount(1, 3), parseArgsOfType(NumberType)),
    [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs)
};
/**
 * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator
 * An argument validator applies various checks to an encoded expression arguments
 * Returns the parsed arguments if any.
 * Third argument is the array of parsed arguments from previous validators
 * Fourth argument is an optional type hint
 */ /**
 * @type ArgValidator
 */ function withGetArgs(encoded, context) {
    const arg = parse(encoded[1], context);
    if (!(arg instanceof LiteralExpression)) throw new Error('Expected a literal argument for get operation');
    if (typeof arg.value !== 'string') throw new Error('Expected a string argument for get operation');
    context.properties.add(arg.value);
    if (encoded.length === 3) {
        const hint = parse(encoded[2], context);
        return [
            arg,
            hint
        ];
    }
    return [
        arg
    ];
}
/**
 * @type ArgValidator
 */ function withVarArgs(encoded, context, parsedArgs, typeHint) {
    const varName = encoded[1];
    if (typeof varName !== 'string') throw new Error('Expected a string argument for var operation');
    context.variables.add(varName);
    if (!('variables' in context.style) || context.style.variables[varName] === undefined) return [
        new LiteralExpression(AnyType, varName)
    ];
    const initialValue = context.style.variables[varName];
    const arg = /** @type {LiteralExpression} */ parse(initialValue, context);
    arg.value = varName;
    if (typeHint && !overlapsType(typeHint, arg.type)) throw new Error(`The variable ${varName} has type ${typeName(arg.type)} but the following type was expected: ${typeName(typeHint)}`);
    return [
        arg
    ];
}
/**
 * @type ArgValidator
 */ function usesFeatureId(encoded, context) {
    context.featureId = true;
}
/**
 * @type ArgValidator
 */ function withNoArgs(encoded, context) {
    const operation = encoded[0];
    if (encoded.length !== 1) throw new Error(`Expected no arguments for ${operation} operation`);
    return [];
}
/**
 * @param {number} minArgs The minimum number of arguments.
 * @param {number} maxArgs The maximum number of arguments.
 * @return {ArgValidator} The argument validator
 */ function withArgsCount(minArgs, maxArgs) {
    return function(encoded, context) {
        const operation = encoded[0];
        const argCount = encoded.length - 1;
        if (minArgs === maxArgs) {
            if (argCount !== minArgs) {
                const plural = minArgs === 1 ? '' : 's';
                throw new Error(`Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`);
            }
        } else if (argCount < minArgs || argCount > maxArgs) {
            const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;
            throw new Error(`Expected ${range} arguments for ${operation}, got ${argCount}`);
        }
    };
}
/**
 * @param {number} argType The argument type.
 * @return {ArgValidator} The argument validator
 */ function parseArgsOfType(argType) {
    return function(encoded, context) {
        const operation = encoded[0];
        const argCount = encoded.length - 1;
        /**
     * @type {Array<Expression>}
     */ const args = new Array(argCount);
        for(let i = 0; i < argCount; ++i){
            const expression = parse(encoded[i + 1], context);
            if (!overlapsType(argType, expression.type)) {
                const gotType = typeName(argType);
                const expectedType = typeName(expression.type);
                throw new Error(`Unexpected type for argument ${i} of ${operation} operation` + `, got ${gotType} but expected ${expectedType}`);
            }
            expression.type &= argType;
            args[i] = expression;
        }
        return args;
    };
}
/**
 * @type {ArgValidator}
 */ function narrowArgsType(encoded, context, parsedArgs) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    // first pass to determine a narrowed down type
    let sameType = AnyType;
    for(let i = 0; i < parsedArgs.length; ++i)sameType &= parsedArgs[i].type;
    if (sameType === NoneType) throw new Error(`No common type could be found for arguments of ${operation} operation`);
    // re-parse args
    const args = new Array(argCount);
    for(let i = 0; i < argCount; ++i)args[i] = parse(encoded[i + 1], context, sameType);
    return args;
}
/**
 * @type {ArgValidator}
 */ function withOddArgs(encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (argCount % 2 === 0) throw new Error(`An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(argCount)} instead`);
}
/**
 * @type {ArgValidator}
 */ function withEvenArgs(encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (argCount % 2 === 1) throw new Error(`An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(argCount)} instead`);
}
/**
 * @type ArgValidator
 */ function parseMatchArgs(encoded, context, parsedArgs, typeHint) {
    const argsCount = encoded.length - 1;
    const input = parse(encoded[1], context);
    let inputType = input.type;
    const fallback = parse(encoded[encoded.length - 1], context);
    let outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;
    // first parse args to figure out possible types
    const args = new Array(argsCount - 2);
    for(let i = 0; i < argsCount - 2; i += 2){
        const match = parse(encoded[i + 2], context);
        const output = parse(encoded[i + 3], context);
        inputType &= match.type;
        outputType &= output.type;
        args[i] = match;
        args[i + 1] = output;
    }
    // check input and output types validity
    const expectedInputType = StringType | NumberType | BooleanType;
    if (!overlapsType(expectedInputType, inputType)) throw new Error(`Expected an input of type ${typeName(expectedInputType)} for the interpolate operation` + `, got ${typeName(inputType)} instead`);
    if (isType(outputType, NoneType)) throw new Error(`Could not find a common output type for the following match operation: ` + JSON.stringify(encoded));
    // parse again inputs and outputs with common type
    for(let i = 0; i < argsCount - 2; i += 2){
        const match = parse(encoded[i + 2], context, inputType);
        const output = parse(encoded[i + 3], context, outputType);
        args[i] = match;
        args[i + 1] = output;
    }
    return [
        parse(encoded[1], context, inputType),
        ...args,
        parse(encoded[encoded.length - 1], context, outputType)
    ];
}
/**
 * @type ArgValidator
 */ function parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {
    const interpolationType = encoded[1];
    let interpolation;
    switch(interpolationType[0]){
        case 'linear':
            interpolation = 1;
            break;
        case 'exponential':
            interpolation = interpolationType[1];
            if (typeof interpolation !== 'number') throw new Error(`Expected a number base for exponential interpolation` + `, got ${JSON.stringify(interpolation)} instead`);
            break;
        default:
            interpolation = null;
    }
    if (!interpolation) throw new Error(`Invalid interpolation type: ${JSON.stringify(interpolationType)}`);
    interpolation = parse(interpolation, context);
    // check input types
    let input = parse(encoded[2], context);
    if (!overlapsType(NumberType, input.type)) throw new Error(`Expected an input of type number for the interpolate operation` + `, got ${typeName(input.type)} instead`);
    input = parse(encoded[2], context, NumberType); // parse again with narrower output
    const args = new Array(encoded.length - 3);
    for(let i = 0; i < args.length; i += 2){
        let stop = parse(encoded[i + 3], context);
        if (!overlapsType(NumberType, stop.type)) throw new Error(`Expected all stop input values in the interpolate operation to be of type number` + `, got ${typeName(stop.type)} at position ${i + 2} instead`);
        let output = parse(encoded[i + 4], context);
        if (!overlapsType(NumberType | ColorType, output.type)) throw new Error(`Expected all stop output values in the interpolate operation to be a number or color` + `, got ${typeName(output.type)} at position ${i + 3} instead`);
        // parse again with narrower types
        stop = parse(encoded[i + 3], context, NumberType);
        output = parse(encoded[i + 4], context, NumberType | ColorType);
        args[i] = stop;
        args[i + 1] = output;
    }
    return [
        interpolation,
        input,
        ...args
    ];
}
/**
 * @type ArgValidator
 */ function parseCaseArgs(encoded, context, parsedArgs, typeHint) {
    const fallback = parse(encoded[encoded.length - 1], context);
    let outputType = typeHint !== undefined ? typeHint & fallback.type : fallback.type;
    // first parse args to figure out possible types
    const args = new Array(encoded.length - 1);
    for(let i = 0; i < args.length - 1; i += 2){
        const condition = parse(encoded[i + 1], context);
        const output = parse(encoded[i + 2], context);
        if (!overlapsType(BooleanType, condition.type)) throw new Error(`Expected all conditions in the case operation to be of type boolean` + `, got ${typeName(condition.type)} at position ${i} instead`);
        outputType &= output.type;
        args[i] = condition;
        args[i + 1] = output;
    }
    if (isType(outputType, NoneType)) throw new Error(`Could not find a common output type for the following case operation: ` + JSON.stringify(encoded));
    // parse again args with common output type
    for(let i = 0; i < args.length - 1; i += 2)args[i + 1] = parse(encoded[i + 2], context, outputType);
    args[args.length - 1] = parse(encoded[encoded.length - 1], context, outputType);
    return args;
}
/**
 * @type ArgValidator
 */ function parseInArgs(encoded, context) {
    /** @type {Array<number|string>} */ let haystack = /** @type {any} */ encoded[2];
    if (!Array.isArray(haystack)) throw new Error(`The "in" operator was provided a literal value which was not an array as second argument.`);
    if (typeof haystack[0] === 'string') {
        if (haystack[0] !== 'literal') throw new Error(`For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.`);
        if (!Array.isArray(haystack[1])) throw new Error(`The "in" operator was provided a literal value which was not an array as second argument.`);
        haystack = haystack[1];
    }
    let needleType = StringType | NumberType;
    const args = new Array(haystack.length);
    for(let i = 0; i < args.length; i++){
        const arg = parse(haystack[i], context);
        needleType &= arg.type;
        args[i] = arg;
    }
    if (isType(needleType, NoneType)) throw new Error(`Could not find a common type for the following in operation: ` + JSON.stringify(encoded));
    const needle = parse(encoded[1], context, needleType);
    return [
        needle,
        ...args
    ];
}
/**
 * @type ArgValidator
 */ function parsePaletteArgs(encoded, context) {
    const index = parse(encoded[1], context, NumberType);
    if (index.type !== NumberType) throw new Error(`The first argument of palette must be an number, got ${typeName(index.type)} instead`);
    const colors = encoded[2];
    if (!Array.isArray(colors)) throw new Error('The second argument of palette must be an array');
    const parsedColors = new Array(colors.length);
    for(let i = 0; i < parsedColors.length; i++){
        const color = parse(colors[i], context, ColorType);
        if (!(color instanceof LiteralExpression)) throw new Error(`The palette color at index ${i} must be a literal value`);
        if (!overlapsType(color.type, ColorType)) throw new Error(`The palette color at index ${i} should be of type color, got ${typeName(color.type)} instead`);
        parsedColors[i] = color;
    }
    return [
        index,
        ...parsedColors
    ];
}
/**
 * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed
 * arguments
 * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator
 * will be used as parsed arguments
 * @return {Parser} The parser.
 */ function createParser(returnType, ...argValidators) {
    return function(encoded, context, typeHint) {
        const operator = encoded[0];
        let parsedArgs = [];
        for(let i = 0; i < argValidators.length; i++)parsedArgs = argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;
        let actualType = typeof returnType === 'function' ? returnType(parsedArgs) : returnType;
        if (typeHint !== undefined) {
            if (!overlapsType(actualType, typeHint)) throw new Error(`The following expression was expected to return ${typeName(typeHint)}, but returns ${typeName(actualType)} instead: ${JSON.stringify(encoded)}`);
            actualType &= typeHint;
        }
        if (actualType === NoneType) throw new Error(`No matching type was found for the following expression: ${JSON.stringify(encoded)}`);
        return new CallExpression(actualType, operator, ...parsedArgs);
    };
}
/**
 * @param {Array} encoded The encoded expression.
 * @param {ParsingContext} context The parsing context.
 * @param {number} [typeHint] Optional type hint
 * @return {Expression} The parsed expression.
 */ function parseCallExpression(encoded, context, typeHint) {
    const operator = encoded[0];
    const parser = parsers[operator];
    if (!parser) throw new Error(`Unknown operator: ${operator}`);
    return parser(encoded, context, typeHint);
}

},{"../array.js":"1Fbic","../color.js":"4tahz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l7qGi":[function(require,module,exports,__globalThis) {
/**
 * @module ol/expr/cpu
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @fileoverview This module includes functions to build expressions for evaluation on the CPU.
 * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded
 * expression and returns an instance of one of the expression classes.  The compiling step takes
 * the expression instance and returns a function that can be evaluated in to return a literal
 * value.  The evaluator function should do as little allocation and work as possible.
 */ /**
 * @typedef {Object} EvaluationContext
 * @property {Object} properties The values for properties used in 'get' expressions.
 * @property {Object} variables The values for variables used in 'var' expressions.
 * @property {number} resolution The map resolution.
 * @property {string|number|null} featureId The feature id.
 */ /**
 * @return {EvaluationContext} A new evaluation context.
 */ parcelHelpers.export(exports, "newEvaluationContext", ()=>newEvaluationContext);
/**
 * @typedef {function(EvaluationContext):import("./expression.js").LiteralValue} ExpressionEvaluator
 */ /**
 * @typedef {function(EvaluationContext):boolean} BooleanEvaluator
 */ /**
 * @typedef {function(EvaluationContext):number} NumberEvaluator
 */ /**
 * @typedef {function(EvaluationContext):string} StringEvaluator
 */ /**
 * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator
 */ /**
 * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator
 */ /**
 * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator
 */ /**
 * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator
 */ /**
 * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.
 * @param {number} type The expected type.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The expression evaluator.
 */ parcelHelpers.export(exports, "buildExpression", ()=>buildExpression);
var _expressionJs = require("./expression.js");
var _colorJs = require("../color.js");
function newEvaluationContext() {
    return {
        variables: {},
        properties: {},
        resolution: NaN,
        featureId: null
    };
}
function buildExpression(encoded, type, context) {
    const expression = (0, _expressionJs.parse)(encoded, context);
    if (!(0, _expressionJs.overlapsType)(type, expression.type)) {
        const expected = (0, _expressionJs.typeName)(type);
        const actual = (0, _expressionJs.typeName)(expression.type);
        throw new Error(`Expected expression to be of type ${expected}, got ${actual}`);
    }
    return compileExpression(expression, context);
}
/**
 * @param {import("./expression.js").Expression} expression The expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileExpression(expression, context) {
    if (expression instanceof (0, _expressionJs.LiteralExpression)) {
        // convert colors to array if possible
        if (expression.type === (0, _expressionJs.ColorType) && typeof expression.value === 'string') {
            const colorValue = (0, _colorJs.fromString)(expression.value);
            return function() {
                return colorValue;
            };
        }
        return function() {
            return expression.value;
        };
    }
    const operator = expression.operator;
    switch(operator){
        case (0, _expressionJs.Ops).Number:
        case (0, _expressionJs.Ops).String:
            return compileAssertionExpression(expression, context);
        case (0, _expressionJs.Ops).Get:
        case (0, _expressionJs.Ops).Var:
            return compileAccessorExpression(expression, context);
        case (0, _expressionJs.Ops).Id:
            return (expression)=>expression.featureId;
        case (0, _expressionJs.Ops).Concat:
            {
                const args = expression.args.map((e)=>compileExpression(e, context));
                return (context)=>''.concat(...args.map((arg)=>arg(context).toString()));
            }
        case (0, _expressionJs.Ops).Resolution:
            return (context)=>context.resolution;
        case (0, _expressionJs.Ops).Any:
        case (0, _expressionJs.Ops).All:
        case (0, _expressionJs.Ops).Not:
            return compileLogicalExpression(expression, context);
        case (0, _expressionJs.Ops).Equal:
        case (0, _expressionJs.Ops).NotEqual:
        case (0, _expressionJs.Ops).LessThan:
        case (0, _expressionJs.Ops).LessThanOrEqualTo:
        case (0, _expressionJs.Ops).GreaterThan:
        case (0, _expressionJs.Ops).GreaterThanOrEqualTo:
            return compileComparisonExpression(expression, context);
        case (0, _expressionJs.Ops).Multiply:
        case (0, _expressionJs.Ops).Divide:
        case (0, _expressionJs.Ops).Add:
        case (0, _expressionJs.Ops).Subtract:
        case (0, _expressionJs.Ops).Clamp:
        case (0, _expressionJs.Ops).Mod:
        case (0, _expressionJs.Ops).Pow:
        case (0, _expressionJs.Ops).Abs:
        case (0, _expressionJs.Ops).Floor:
        case (0, _expressionJs.Ops).Ceil:
        case (0, _expressionJs.Ops).Round:
        case (0, _expressionJs.Ops).Sin:
        case (0, _expressionJs.Ops).Cos:
        case (0, _expressionJs.Ops).Atan:
        case (0, _expressionJs.Ops).Sqrt:
            return compileNumericExpression(expression, context);
        case (0, _expressionJs.Ops).Match:
            return compileMatchExpression(expression, context);
        case (0, _expressionJs.Ops).Interpolate:
            return compileInterpolateExpression(expression, context);
        default:
            throw new Error(`Unsupported operator ${operator}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileAssertionExpression(expression, context) {
    const type = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i)args[i] = compileExpression(expression.args[i], context);
    switch(type){
        case (0, _expressionJs.Ops).Number:
        case (0, _expressionJs.Ops).String:
            return (context)=>{
                for(let i = 0; i < length; ++i){
                    const value = args[i](context);
                    if (typeof value === type) return value;
                }
                throw new Error(`Expected one of the values to be a ${type}`);
            };
        default:
            throw new Error(`Unsupported assertion operator ${type}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileAccessorExpression(expression, context) {
    const nameExpression = /** @type {LiteralExpression} */ expression.args[0];
    const name = /** @type {string} */ nameExpression.value;
    switch(expression.operator){
        case (0, _expressionJs.Ops).Get:
            return (context)=>context.properties[name];
        case (0, _expressionJs.Ops).Var:
            return (context)=>context.variables[name];
        default:
            throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */ function compileComparisonExpression(expression, context) {
    const op = expression.operator;
    const left = compileExpression(expression.args[0], context);
    const right = compileExpression(expression.args[1], context);
    switch(op){
        case (0, _expressionJs.Ops).Equal:
            return (context)=>left(context) === right(context);
        case (0, _expressionJs.Ops).NotEqual:
            return (context)=>left(context) !== right(context);
        case (0, _expressionJs.Ops).LessThan:
            return (context)=>left(context) < right(context);
        case (0, _expressionJs.Ops).LessThanOrEqualTo:
            return (context)=>left(context) <= right(context);
        case (0, _expressionJs.Ops).GreaterThan:
            return (context)=>left(context) > right(context);
        case (0, _expressionJs.Ops).GreaterThanOrEqualTo:
            return (context)=>left(context) >= right(context);
        default:
            throw new Error(`Unsupported comparison operator ${op}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {BooleanEvaluator} The evaluator function.
 */ function compileLogicalExpression(expression, context) {
    const op = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i)args[i] = compileExpression(expression.args[i], context);
    switch(op){
        case (0, _expressionJs.Ops).Any:
            return (context)=>{
                for(let i = 0; i < length; ++i){
                    if (args[i](context)) return true;
                }
                return false;
            };
        case (0, _expressionJs.Ops).All:
            return (context)=>{
                for(let i = 0; i < length; ++i){
                    if (!args[i](context)) return false;
                }
                return true;
            };
        case (0, _expressionJs.Ops).Not:
            return (context)=>!args[0](context);
        default:
            throw new Error(`Unsupported logical operator ${op}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {NumberEvaluator} The evaluator function.
 */ function compileNumericExpression(expression, context) {
    const op = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i)args[i] = compileExpression(expression.args[i], context);
    switch(op){
        case (0, _expressionJs.Ops).Multiply:
            return (context)=>{
                let value = 1;
                for(let i = 0; i < length; ++i)value *= args[i](context);
                return value;
            };
        case (0, _expressionJs.Ops).Divide:
            return (context)=>args[0](context) / args[1](context);
        case (0, _expressionJs.Ops).Add:
            return (context)=>{
                let value = 0;
                for(let i = 0; i < length; ++i)value += args[i](context);
                return value;
            };
        case (0, _expressionJs.Ops).Subtract:
            return (context)=>args[0](context) - args[1](context);
        case (0, _expressionJs.Ops).Clamp:
            return (context)=>{
                const value = args[0](context);
                const min = args[1](context);
                if (value < min) return min;
                const max = args[2](context);
                if (value > max) return max;
                return value;
            };
        case (0, _expressionJs.Ops).Mod:
            return (context)=>args[0](context) % args[1](context);
        case (0, _expressionJs.Ops).Pow:
            return (context)=>Math.pow(args[0](context), args[1](context));
        case (0, _expressionJs.Ops).Abs:
            return (context)=>Math.abs(args[0](context));
        case (0, _expressionJs.Ops).Floor:
            return (context)=>Math.floor(args[0](context));
        case (0, _expressionJs.Ops).Ceil:
            return (context)=>Math.ceil(args[0](context));
        case (0, _expressionJs.Ops).Round:
            return (context)=>Math.round(args[0](context));
        case (0, _expressionJs.Ops).Sin:
            return (context)=>Math.sin(args[0](context));
        case (0, _expressionJs.Ops).Cos:
            return (context)=>Math.cos(args[0](context));
        case (0, _expressionJs.Ops).Atan:
            if (length === 2) return (context)=>Math.atan2(args[0](context), args[1](context));
            return (context)=>Math.atan(args[0](context));
        case (0, _expressionJs.Ops).Sqrt:
            return (context)=>Math.sqrt(args[0](context));
        default:
            throw new Error(`Unsupported numeric operator ${op}`);
    }
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileMatchExpression(expression, context) {
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i)args[i] = compileExpression(expression.args[i], context);
    return (context)=>{
        const value = args[0](context);
        for(let i = 1; i < length; i += 2){
            if (value === args[i](context)) return args[i + 1](context);
        }
        return args[length - 1](context);
    };
}
/**
 * @param {import('./expression.js').CallExpression} expression The call expression.
 * @param {import('./expression.js').ParsingContext} context The parsing context.
 * @return {ExpressionEvaluator} The evaluator function.
 */ function compileInterpolateExpression(expression, context) {
    const length = expression.args.length;
    const args = new Array(length);
    for(let i = 0; i < length; ++i)args[i] = compileExpression(expression.args[i], context);
    return (context)=>{
        const base = args[0](context);
        const value = args[1](context);
        let previousInput;
        let previousOutput;
        for(let i = 2; i < length; i += 2){
            const input = args[i](context);
            let output = args[i + 1](context);
            const isColor = Array.isArray(output);
            if (isColor) output = (0, _colorJs.withAlpha)(output);
            if (input >= value) {
                if (i === 2) return output;
                if (isColor) return interpolateColor(base, value, previousInput, previousOutput, input, output);
                return interpolateNumber(base, value, previousInput, previousOutput, input, output);
            }
            previousInput = input;
            previousOutput = output;
        }
        return previousOutput;
    };
}
/**
 * @param {number} base The base.
 * @param {number} value The value.
 * @param {number} input1 The first input value.
 * @param {number} output1 The first output value.
 * @param {number} input2 The second input value.
 * @param {number} output2 The second output value.
 * @return {number} The interpolated value.
 */ function interpolateNumber(base, value, input1, output1, input2, output2) {
    const delta = input2 - input1;
    if (delta === 0) return output1;
    const along = value - input1;
    const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
    return output1 + factor * (output2 - output1);
}
/**
 * @param {number} base The base.
 * @param {number} value The value.
 * @param {number} input1 The first input value.
 * @param {import('../color.js').Color} rgba1 The first output value.
 * @param {number} input2 The second input value.
 * @param {import('../color.js').Color} rgba2 The second output value.
 * @return {import('../color.js').Color} The interpolated color.
 */ function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
    const delta = input2 - input1;
    if (delta === 0) return rgba1;
    const lcha1 = (0, _colorJs.rgbaToLcha)(rgba1);
    const lcha2 = (0, _colorJs.rgbaToLcha)(rgba2);
    let deltaHue = lcha2[2] - lcha1[2];
    if (deltaHue > 180) deltaHue -= 360;
    else if (deltaHue < -180) deltaHue += 360;
    const lcha = [
        interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
        interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
        lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
        interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])
    ];
    return (0, _colorJs.normalize)((0, _colorJs.lchaToRgba)(lcha));
}

},{"./expression.js":"7wOmt","../color.js":"4tahz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kTTmt":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/canvas/VectorLayer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderGroupJs = require("../../render/canvas/BuilderGroup.js");
var _builderGroupJsDefault = parcelHelpers.interopDefault(_builderGroupJs);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _executorGroupJs = require("../../render/canvas/ExecutorGroup.js");
var _executorGroupJsDefault = parcelHelpers.interopDefault(_executorGroupJs);
var _eventTypeJs = require("../../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _viewHintJs = require("../../ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _hitdetectJs = require("../../render/canvas/hitdetect.js");
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _domJs = require("../../dom.js");
var _vectorJs = require("../vector.js");
var _arrayJs = require("../../array.js");
var _projJs = require("../../proj.js");
var _utilJs = require("../../util.js");
var _coordinateJs = require("../../coordinate.js");
/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */ class CanvasVectorLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */ constructor(vectorLayer){
        super(vectorLayer);
        /** @private */ this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
        /**
     * @type {boolean}
     */ this.animatingOrInteracting_;
        /**
     * @type {ImageData|null}
     */ this.hitDetectionImageData_ = null;
        /**
     * @type {Array<import("../../Feature.js").default>}
     */ this.renderedFeatures_ = null;
        /**
     * @private
     * @type {number}
     */ this.renderedRevision_ = -1;
        /**
     * @private
     * @type {number}
     */ this.renderedResolution_ = NaN;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.renderedExtent_ = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.wrappedRenderedExtent_ = (0, _extentJs.createEmpty)();
        /**
     * @private
     * @type {number}
     */ this.renderedRotation_;
        /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */ this.renderedCenter_ = null;
        /**
     * @private
     * @type {import("../../proj/Projection").default}
     */ this.renderedProjection_ = null;
        /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */ this.renderedRenderOrder_ = null;
        /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */ this.replayGroup_ = null;
        /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */ this.replayGroupChanged = true;
        /**
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */ this.declutterExecutorGroup = null;
        /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */ this.clipping = true;
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.compositionContext_ = null;
        /**
     * @private
     * @type {number}
     */ this.opacity_ = 1;
    }
    /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */ renderWorlds(executorGroup, frameState, declutterTree) {
        const extent = frameState.extent;
        const viewState = frameState.viewState;
        const center = viewState.center;
        const resolution = viewState.resolution;
        const projection = viewState.projection;
        const rotation = viewState.rotation;
        const projectionExtent = projection.getExtent();
        const vectorSource = this.getLayer().getSource();
        const pixelRatio = frameState.pixelRatio;
        const viewHints = frameState.viewHints;
        const snapToPixel = !(viewHints[(0, _viewHintJsDefault.default).ANIMATING] || viewHints[(0, _viewHintJsDefault.default).INTERACTING]);
        const context = this.compositionContext_;
        const width = Math.round(frameState.size[0] * pixelRatio);
        const height = Math.round(frameState.size[1] * pixelRatio);
        const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
        const worldWidth = multiWorld ? (0, _extentJs.getWidth)(projectionExtent) : null;
        const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
        let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
        do {
            const transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
            executorGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, declutterTree);
        }while (++world < endWorld);
    }
    setupCompositionContext_() {
        if (this.opacity_ !== 1) {
            const compositionContext = (0, _domJs.createCanvasContext2D)(this.context.canvas.width, this.context.canvas.height, (0, _layerJs.canvasPool));
            this.compositionContext_ = compositionContext;
        } else this.compositionContext_ = this.context;
    }
    releaseCompositionContext_() {
        if (this.opacity_ !== 1) {
            const alpha = this.context.globalAlpha;
            this.context.globalAlpha = this.opacity_;
            this.context.drawImage(this.compositionContext_.canvas, 0, 0);
            this.context.globalAlpha = alpha;
            (0, _domJs.releaseCanvas)(this.compositionContext_);
            (0, _layerJs.canvasPool).push(this.compositionContext_.canvas);
            this.compositionContext_ = null;
        }
    }
    /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */ renderDeclutter(frameState) {
        if (this.declutterExecutorGroup) {
            this.setupCompositionContext_();
            this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
            this.releaseCompositionContext_();
        }
    }
    /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */ renderFrame(frameState, target) {
        const pixelRatio = frameState.pixelRatio;
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        // set forward and inverse pixel transforms
        (0, _transformJs.makeScale)(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
        (0, _transformJs.makeInverse)(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = (0, _transformJs.toString)(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        const context = this.context;
        const canvas = context.canvas;
        const replayGroup = this.replayGroup_;
        const declutterExecutorGroup = this.declutterExecutorGroup;
        let render = replayGroup && !replayGroup.isEmpty() || declutterExecutorGroup && !declutterExecutorGroup.isEmpty();
        if (!render) {
            const hasRenderListeners = this.getLayer().hasListener((0, _eventTypeJsDefault.default).PRERENDER) || this.getLayer().hasListener((0, _eventTypeJsDefault.default).POSTRENDER);
            if (!hasRenderListeners) return null;
        }
        // resize and clear
        const width = Math.round(frameState.size[0] * pixelRatio);
        const height = Math.round(frameState.size[1] * pixelRatio);
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
            if (canvas.style.transform !== canvasTransform) canvas.style.transform = canvasTransform;
        } else if (!this.containerReused) context.clearRect(0, 0, width, height);
        this.preRender(context, frameState);
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        this.opacity_ = layerState.opacity;
        this.setupCompositionContext_();
        // clipped rendering if layer extent is set
        let clipped = false;
        if (render && layerState.extent && this.clipping) {
            const layerExtent = (0, _projJs.fromUserExtent)(layerState.extent, projection);
            render = (0, _extentJs.intersects)(layerExtent, frameState.extent);
            clipped = render && !(0, _extentJs.containsExtent)(layerExtent, frameState.extent);
            if (clipped) this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
        }
        if (render) this.renderWorlds(replayGroup, frameState);
        if (clipped) this.compositionContext_.restore();
        this.releaseCompositionContext_();
        this.postRender(context, frameState);
        if (this.renderedRotation_ !== viewState.rotation) {
            this.renderedRotation_ = viewState.rotation;
            this.hitDetectionImageData_ = null;
        }
        return this.container;
    }
    /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */ getFeatures(pixel) {
        return new Promise((resolve)=>{
            if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                const size = [
                    this.context.canvas.width,
                    this.context.canvas.height
                ];
                (0, _transformJs.apply)(this.pixelTransform, size);
                const center = this.renderedCenter_;
                const resolution = this.renderedResolution_;
                const rotation = this.renderedRotation_;
                const projection = this.renderedProjection_;
                const extent = this.wrappedRenderedExtent_;
                const layer = this.getLayer();
                const transforms = [];
                const width = size[0] * (0, _hitdetectJs.HIT_DETECT_RESOLUTION);
                const height = size[1] * (0, _hitdetectJs.HIT_DETECT_RESOLUTION);
                transforms.push(this.getRenderTransform(center, resolution, rotation, (0, _hitdetectJs.HIT_DETECT_RESOLUTION), width, height, 0).slice());
                const source = layer.getSource();
                const projectionExtent = projection.getExtent();
                if (source.getWrapX() && projection.canWrapX() && !(0, _extentJs.containsExtent)(projectionExtent, extent)) {
                    let startX = extent[0];
                    const worldWidth = (0, _extentJs.getWidth)(projectionExtent);
                    let world = 0;
                    let offsetX;
                    while(startX < projectionExtent[0]){
                        --world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, (0, _hitdetectJs.HIT_DETECT_RESOLUTION), width, height, offsetX).slice());
                        startX += worldWidth;
                    }
                    world = 0;
                    startX = extent[2];
                    while(startX > projectionExtent[2]){
                        ++world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, (0, _hitdetectJs.HIT_DETECT_RESOLUTION), width, height, offsetX).slice());
                        startX -= worldWidth;
                    }
                }
                this.hitDetectionImageData_ = (0, _hitdetectJs.createHitDetectionImageData)(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
            }
            resolve((0, _hitdetectJs.hitDetect)(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
        });
    }
    /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        if (!this.replayGroup_) return undefined;
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const layer = this.getLayer();
        /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */ const features = {};
        /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position
     * @return {T|undefined} Callback result.
     */ const featureCallback = function(feature, geometry, distanceSq) {
            const key = (0, _utilJs.getUid)(feature);
            const match = features[key];
            if (!match) {
                if (distanceSq === 0) {
                    features[key] = true;
                    return callback(feature, layer, geometry);
                }
                matches.push(features[key] = {
                    feature: feature,
                    layer: layer,
                    geometry: geometry,
                    distanceSq: distanceSq,
                    callback: callback
                });
            } else if (match !== true && distanceSq < match.distanceSq) {
                if (distanceSq === 0) {
                    features[key] = true;
                    matches.splice(matches.lastIndexOf(match), 1);
                    return callback(feature, layer, geometry);
                }
                match.geometry = geometry;
                match.distanceSq = distanceSq;
            }
            return undefined;
        };
        let result;
        const executorGroups = [
            this.replayGroup_
        ];
        if (this.declutterExecutorGroup) executorGroups.push(this.declutterExecutorGroup);
        executorGroups.some((executorGroup)=>{
            return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map((item)=>item.value) : null);
        });
        return result;
    }
    /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */ handleFontsChanged() {
        const layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) layer.changed();
    }
    /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */ handleStyleImageChange_(event) {
        this.renderIfReadyAndVisible();
    }
    /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        const vectorLayer = this.getLayer();
        const vectorSource = vectorLayer.getSource();
        if (!vectorSource) return false;
        const animating = frameState.viewHints[(0, _viewHintJsDefault.default).ANIMATING];
        const interacting = frameState.viewHints[(0, _viewHintJsDefault.default).INTERACTING];
        const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
        if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
            this.animatingOrInteracting_ = true;
            return true;
        }
        this.animatingOrInteracting_ = false;
        const frameStateExtent = frameState.extent;
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const resolution = viewState.resolution;
        const pixelRatio = frameState.pixelRatio;
        const vectorLayerRevision = vectorLayer.getRevision();
        const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
        if (vectorLayerRenderOrder === undefined) vectorLayerRenderOrder = (0, _vectorJs.defaultOrder);
        const center = viewState.center.slice();
        const extent = (0, _extentJs.buffer)(frameStateExtent, vectorLayerRenderBuffer * resolution);
        const renderedExtent = extent.slice();
        const loadExtents = [
            extent.slice()
        ];
        const projectionExtent = projection.getExtent();
        if (vectorSource.getWrapX() && projection.canWrapX() && !(0, _extentJs.containsExtent)(projectionExtent, frameState.extent)) {
            // For the replay group, we need an extent that intersects the real world
            // (-180° to +180°). To support geometries in a coordinate range from -540°
            // to +540°, we add at least 1 world width on each side of the projection
            // extent. If the viewport is wider than the world, we need to add half of
            // the viewport width to make sure we cover the whole viewport.
            const worldWidth = (0, _extentJs.getWidth)(projectionExtent);
            const gutter = Math.max((0, _extentJs.getWidth)(extent) / 2, worldWidth);
            extent[0] = projectionExtent[0] - gutter;
            extent[2] = projectionExtent[2] + gutter;
            (0, _coordinateJs.wrapX)(center, projection);
            const loadExtent = (0, _extentJs.wrapX)(loadExtents[0], projection);
            // If the extent crosses the date line, we load data for both edges of the worlds
            if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) loadExtents.push([
                loadExtent[0] + worldWidth,
                loadExtent[1],
                loadExtent[2] + worldWidth,
                loadExtent[3]
            ]);
            else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) loadExtents.push([
                loadExtent[0] - worldWidth,
                loadExtent[1],
                loadExtent[2] - worldWidth,
                loadExtent[3]
            ]);
        }
        if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && (0, _extentJs.containsExtent)(this.wrappedRenderedExtent_, extent)) {
            if (!(0, _arrayJs.equals)(this.renderedExtent_, renderedExtent)) {
                this.hitDetectionImageData_ = null;
                this.renderedExtent_ = renderedExtent;
            }
            this.renderedCenter_ = center;
            this.replayGroupChanged = false;
            return true;
        }
        this.replayGroup_ = null;
        const replayGroup = new (0, _builderGroupJsDefault.default)((0, _vectorJs.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
        let declutterBuilderGroup;
        if (this.getLayer().getDeclutter()) declutterBuilderGroup = new (0, _builderGroupJsDefault.default)((0, _vectorJs.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
        const userProjection = (0, _projJs.getUserProjection)();
        let userTransform;
        if (userProjection) {
            for(let i = 0, ii = loadExtents.length; i < ii; ++i){
                const extent = loadExtents[i];
                const userExtent = (0, _projJs.toUserExtent)(extent, projection);
                vectorSource.loadFeatures(userExtent, (0, _projJs.toUserResolution)(resolution, projection), userProjection);
            }
            userTransform = (0, _projJs.getTransformFromProjections)(userProjection, projection);
        } else for(let i = 0, ii = loadExtents.length; i < ii; ++i)vectorSource.loadFeatures(loadExtents[i], resolution, projection);
        const squaredTolerance = (0, _vectorJs.getSquaredTolerance)(resolution, pixelRatio);
        let ready = true;
        const render = /**
       * @param {import("../../Feature.js").default} feature Feature.
       */ (feature)=>{
            let styles;
            const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
            if (styleFunction) styles = styleFunction(feature, resolution);
            if (styles) {
                const dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
                ready = ready && !dirty;
            }
        };
        const userExtent = (0, _projJs.toUserExtent)(extent, projection);
        /** @type {Array<import("../../Feature.js").default>} */ const features = vectorSource.getFeaturesInExtent(userExtent);
        if (vectorLayerRenderOrder) features.sort(vectorLayerRenderOrder);
        for(let i = 0, ii = features.length; i < ii; ++i)render(features[i]);
        this.renderedFeatures_ = features;
        this.ready = ready;
        const replayGroupInstructions = replayGroup.finish();
        const executorGroup = new (0, _executorGroupJsDefault.default)(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
        if (declutterBuilderGroup) this.declutterExecutorGroup = new (0, _executorGroupJsDefault.default)(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedExtent_ = renderedExtent;
        this.wrappedRenderedExtent_ = extent;
        this.renderedCenter_ = center;
        this.renderedProjection_ = projection;
        this.replayGroup_ = executorGroup;
        this.hitDetectionImageData_ = null;
        this.replayGroupChanged = true;
        return true;
    }
    /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */ renderFeature(feature, squaredTolerance, styles, builderGroup, transform, declutterBuilderGroup) {
        if (!styles) return false;
        let loading = false;
        if (Array.isArray(styles)) for(let i = 0, ii = styles.length; i < ii; ++i)loading = (0, _vectorJs.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, transform, declutterBuilderGroup) || loading;
        else loading = (0, _vectorJs.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, transform, declutterBuilderGroup);
        return loading;
    }
}
exports.default = CanvasVectorLayerRenderer;

},{"../../render/canvas/BuilderGroup.js":"kQbDd","./Layer.js":"fY3ny","../../render/canvas/ExecutorGroup.js":"eUidV","../../render/EventType.js":"5G9JA","../../ViewHint.js":"6THmF","../../render/canvas/hitdetect.js":"hriIE","../../transform.js":"1BqUf","../../extent.js":"6YrVc","../../dom.js":"84QzQ","../vector.js":"liv8a","../../array.js":"1Fbic","../../proj.js":"SznqC","../../util.js":"pLBjQ","../../coordinate.js":"85Vu7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kQbDd":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/BuilderGroup
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _imageBuilderJs = require("./ImageBuilder.js");
var _imageBuilderJsDefault = parcelHelpers.interopDefault(_imageBuilderJs);
var _lineStringBuilderJs = require("./LineStringBuilder.js");
var _lineStringBuilderJsDefault = parcelHelpers.interopDefault(_lineStringBuilderJs);
var _polygonBuilderJs = require("./PolygonBuilder.js");
var _polygonBuilderJsDefault = parcelHelpers.interopDefault(_polygonBuilderJs);
var _textBuilderJs = require("./TextBuilder.js");
var _textBuilderJsDefault = parcelHelpers.interopDefault(_textBuilderJs);
/**
 * @type {Object<import("../canvas.js").BuilderType, typeof Builder>}
 */ const BATCH_CONSTRUCTORS = {
    'Circle': (0, _polygonBuilderJsDefault.default),
    'Default': (0, _builderJsDefault.default),
    'Image': (0, _imageBuilderJsDefault.default),
    'LineString': (0, _lineStringBuilderJsDefault.default),
    'Polygon': (0, _polygonBuilderJsDefault.default),
    'Text': (0, _textBuilderJsDefault.default)
};
class BuilderGroup {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        /**
     * @private
     * @type {number}
     */ this.tolerance_ = tolerance;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.maxExtent_ = maxExtent;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {number}
     */ this.resolution_ = resolution;
        /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, Builder>>}
     */ this.buildersByZIndex_ = {};
    }
    /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */ finish() {
        const builderInstructions = {};
        for(const zKey in this.buildersByZIndex_){
            builderInstructions[zKey] = builderInstructions[zKey] || {};
            const builders = this.buildersByZIndex_[zKey];
            for(const builderKey in builders){
                const builderInstruction = builders[builderKey].finish();
                builderInstructions[zKey][builderKey] = builderInstruction;
            }
        }
        return builderInstructions;
    }
    /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */ getBuilder(zIndex, builderType) {
        const zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
        let replays = this.buildersByZIndex_[zIndexKey];
        if (replays === undefined) {
            replays = {};
            this.buildersByZIndex_[zIndexKey] = replays;
        }
        let replay = replays[builderType];
        if (replay === undefined) {
            const Constructor = BATCH_CONSTRUCTORS[builderType];
            replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
            replays[builderType] = replay;
        }
        return replay;
    }
}
exports.default = BuilderGroup;

},{"./Builder.js":"aCopB","./ImageBuilder.js":"jkri9","./LineStringBuilder.js":"cuNSN","./PolygonBuilder.js":"992jH","./TextBuilder.js":"6mvke","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aCopB":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/Builder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _relationshipJs = require("../../extent/Relationship.js");
var _relationshipJsDefault = parcelHelpers.interopDefault(_relationshipJs);
var _vectorContextJs = require("../VectorContext.js");
var _vectorContextJsDefault = parcelHelpers.interopDefault(_vectorContextJs);
var _colorlikeJs = require("../../colorlike.js");
var _extentJs = require("../../extent.js");
var _canvasJs = require("../canvas.js");
var _arrayJs = require("../../array.js");
var _inflateJs = require("../../geom/flat/inflate.js");
class CanvasBuilder extends (0, _vectorContextJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super();
        /**
     * @protected
     * @type {number}
     */ this.tolerance = tolerance;
        /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */ this.maxExtent = maxExtent;
        /**
     * @protected
     * @type {number}
     */ this.pixelRatio = pixelRatio;
        /**
     * @protected
     * @type {number}
     */ this.maxLineWidth = 0;
        /**
     * @protected
     * @const
     * @type {number}
     */ this.resolution = resolution;
        /**
     * @private
     * @type {Array<*>}
     */ this.beginGeometryInstruction1_ = null;
        /**
     * @private
     * @type {Array<*>}
     */ this.beginGeometryInstruction2_ = null;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.bufferedMaxExtent_ = null;
        /**
     * @protected
     * @type {Array<*>}
     */ this.instructions = [];
        /**
     * @protected
     * @type {Array<number>}
     */ this.coordinates = [];
        /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */ this.tmpCoordinate_ = [];
        /**
     * @protected
     * @type {Array<*>}
     */ this.hitDetectionInstructions = [];
        /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */ this.state = /** @type {import("../canvas.js").FillStrokeState} */ {};
    }
    /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */ applyPixelRatio(dashArray) {
        const pixelRatio = this.pixelRatio;
        return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
            return dash * pixelRatio;
        });
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */ appendFlatPointCoordinates(flatCoordinates, stride) {
        const extent = this.getBufferedMaxExtent();
        const tmpCoord = this.tmpCoordinate_;
        const coordinates = this.coordinates;
        let myEnd = coordinates.length;
        for(let i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            tmpCoord[0] = flatCoordinates[i];
            tmpCoord[1] = flatCoordinates[i + 1];
            if ((0, _extentJs.containsCoordinate)(extent, tmpCoord)) {
                coordinates[myEnd++] = tmpCoord[0];
                coordinates[myEnd++] = tmpCoord[1];
            }
        }
        return myEnd;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */ appendFlatLineCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {
        const coordinates = this.coordinates;
        let myEnd = coordinates.length;
        const extent = this.getBufferedMaxExtent();
        if (skipFirst) offset += stride;
        let lastXCoord = flatCoordinates[offset];
        let lastYCoord = flatCoordinates[offset + 1];
        const nextCoord = this.tmpCoordinate_;
        let skipped = true;
        let i, lastRel, nextRel;
        for(i = offset + stride; i < end; i += stride){
            nextCoord[0] = flatCoordinates[i];
            nextCoord[1] = flatCoordinates[i + 1];
            nextRel = (0, _extentJs.coordinateRelationship)(extent, nextCoord);
            if (nextRel !== lastRel) {
                if (skipped) {
                    coordinates[myEnd++] = lastXCoord;
                    coordinates[myEnd++] = lastYCoord;
                    skipped = false;
                }
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
            } else if (nextRel === (0, _relationshipJsDefault.default).INTERSECTING) {
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
                skipped = false;
            } else skipped = true;
            lastXCoord = nextCoord[0];
            lastYCoord = nextCoord[1];
            lastRel = nextRel;
        }
        // Last coordinate equals first or only one point to append:
        if (closed && skipped || i === offset + stride) {
            coordinates[myEnd++] = lastXCoord;
            coordinates[myEnd++] = lastYCoord;
        }
        return myEnd;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */ drawCustomCoordinates_(flatCoordinates, offset, ends, stride, builderEnds) {
        for(let i = 0, ii = ends.length; i < ii; ++i){
            const end = ends[i];
            const builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
            builderEnds.push(builderEnd);
            offset = end;
        }
        return offset;
    }
    /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */ drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
        this.beginGeometry(geometry, feature);
        const type = geometry.getType();
        const stride = geometry.getStride();
        const builderBegin = this.coordinates.length;
        let flatCoordinates, builderEnd, builderEnds, builderEndss;
        let offset;
        switch(type){
            case 'MultiPolygon':
                flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getOrientedFlatCoordinates();
                builderEndss = [];
                const endss = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getEndss();
                offset = 0;
                for(let i = 0, ii = endss.length; i < ii; ++i){
                    const myEnds = [];
                    offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                    builderEndss.push(myEnds);
                }
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEndss,
                    geometry,
                    renderer,
                    (0, _inflateJs.inflateMultiCoordinatesArray)
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEndss,
                    geometry,
                    hitDetectionRenderer || renderer,
                    (0, _inflateJs.inflateMultiCoordinatesArray)
                ]);
                break;
            case 'Polygon':
            case 'MultiLineString':
                builderEnds = [];
                flatCoordinates = type == 'Polygon' ? /** @type {import("../../geom/Polygon.js").default} */ geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
                offset = this.drawCustomCoordinates_(flatCoordinates, 0, /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ geometry.getEnds(), stride, builderEnds);
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnds,
                    geometry,
                    renderer,
                    (0, _inflateJs.inflateCoordinatesArray)
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnds,
                    geometry,
                    hitDetectionRenderer || renderer,
                    (0, _inflateJs.inflateCoordinatesArray)
                ]);
                break;
            case 'LineString':
            case 'Circle':
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer,
                    (0, _inflateJs.inflateCoordinates)
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    hitDetectionRenderer || renderer,
                    (0, _inflateJs.inflateCoordinates)
                ]);
                break;
            case 'MultiPoint':
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
                if (builderEnd > builderBegin) {
                    this.instructions.push([
                        (0, _instructionJsDefault.default).CUSTOM,
                        builderBegin,
                        builderEnd,
                        geometry,
                        renderer,
                        (0, _inflateJs.inflateCoordinates)
                    ]);
                    this.hitDetectionInstructions.push([
                        (0, _instructionJsDefault.default).CUSTOM,
                        builderBegin,
                        builderEnd,
                        geometry,
                        hitDetectionRenderer || renderer,
                        (0, _inflateJs.inflateCoordinates)
                    ]);
                }
                break;
            case 'Point':
                flatCoordinates = geometry.getFlatCoordinates();
                this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
                builderEnd = this.coordinates.length;
                this.instructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer
                ]);
                this.hitDetectionInstructions.push([
                    (0, _instructionJsDefault.default).CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    hitDetectionRenderer || renderer
                ]);
                break;
            default:
        }
        this.endGeometry(feature);
    }
    /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ beginGeometry(geometry, feature) {
        this.beginGeometryInstruction1_ = [
            (0, _instructionJsDefault.default).BEGIN_GEOMETRY,
            feature,
            0,
            geometry
        ];
        this.instructions.push(this.beginGeometryInstruction1_);
        this.beginGeometryInstruction2_ = [
            (0, _instructionJsDefault.default).BEGIN_GEOMETRY,
            feature,
            0,
            geometry
        ];
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        return {
            instructions: this.instructions,
            hitDetectionInstructions: this.hitDetectionInstructions,
            coordinates: this.coordinates
        };
    }
    /**
   * Reverse the hit detection instructions.
   */ reverseHitDetectionInstructions() {
        const hitDetectionInstructions = this.hitDetectionInstructions;
        // step 1 - reverse array
        hitDetectionInstructions.reverse();
        // step 2 - reverse instructions within geometry blocks
        let i;
        const n = hitDetectionInstructions.length;
        let instruction;
        let type;
        let begin = -1;
        for(i = 0; i < n; ++i){
            instruction = hitDetectionInstructions[i];
            type = /** @type {import("./Instruction.js").default} */ instruction[0];
            if (type == (0, _instructionJsDefault.default).END_GEOMETRY) begin = i;
            else if (type == (0, _instructionJsDefault.default).BEGIN_GEOMETRY) {
                instruction[2] = i;
                (0, _arrayJs.reverseSubArray)(this.hitDetectionInstructions, begin, i);
                begin = -1;
            }
        }
    }
    /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */ setFillStrokeStyle(fillStyle, strokeStyle) {
        const state = this.state;
        if (fillStyle) {
            const fillStyleColor = fillStyle.getColor();
            state.fillStyle = (0, _colorlikeJs.asColorLike)(fillStyleColor ? fillStyleColor : (0, _canvasJs.defaultFillStyle));
        } else state.fillStyle = undefined;
        if (strokeStyle) {
            const strokeStyleColor = strokeStyle.getColor();
            state.strokeStyle = (0, _colorlikeJs.asColorLike)(strokeStyleColor ? strokeStyleColor : (0, _canvasJs.defaultStrokeStyle));
            const strokeStyleLineCap = strokeStyle.getLineCap();
            state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : (0, _canvasJs.defaultLineCap);
            const strokeStyleLineDash = strokeStyle.getLineDash();
            state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : (0, _canvasJs.defaultLineDash);
            const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
            state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : (0, _canvasJs.defaultLineDashOffset);
            const strokeStyleLineJoin = strokeStyle.getLineJoin();
            state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : (0, _canvasJs.defaultLineJoin);
            const strokeStyleWidth = strokeStyle.getWidth();
            state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : (0, _canvasJs.defaultLineWidth);
            const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : (0, _canvasJs.defaultMiterLimit);
            if (state.lineWidth > this.maxLineWidth) {
                this.maxLineWidth = state.lineWidth;
                // invalidate the buffered max extent cache
                this.bufferedMaxExtent_ = null;
            }
        } else {
            state.strokeStyle = undefined;
            state.lineCap = undefined;
            state.lineDash = null;
            state.lineDashOffset = undefined;
            state.lineJoin = undefined;
            state.lineWidth = undefined;
            state.miterLimit = undefined;
        }
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */ createFill(state) {
        const fillStyle = state.fillStyle;
        /** @type {Array<*>} */ const fillInstruction = [
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            fillStyle
        ];
        if (typeof fillStyle !== 'string') // Fill is a pattern or gradient - align it!
        fillInstruction.push(true);
        return fillInstruction;
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */ applyStroke(state) {
        this.instructions.push(this.createStroke(state));
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */ createStroke(state) {
        return [
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth * this.pixelRatio,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            this.applyPixelRatio(state.lineDash),
            state.lineDashOffset * this.pixelRatio
        ];
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */ updateFillStyle(state, createFill) {
        const fillStyle = state.fillStyle;
        if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
            if (fillStyle !== undefined) this.instructions.push(createFill.call(this, state));
            state.currentFillStyle = fillStyle;
        }
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */ updateStrokeStyle(state, applyStroke) {
        const strokeStyle = state.strokeStyle;
        const lineCap = state.lineCap;
        const lineDash = state.lineDash;
        const lineDashOffset = state.lineDashOffset;
        const lineJoin = state.lineJoin;
        const lineWidth = state.lineWidth;
        const miterLimit = state.miterLimit;
        if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !(0, _arrayJs.equals)(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
            if (strokeStyle !== undefined) applyStroke.call(this, state);
            state.currentStrokeStyle = strokeStyle;
            state.currentLineCap = lineCap;
            state.currentLineDash = lineDash;
            state.currentLineDashOffset = lineDashOffset;
            state.currentLineJoin = lineJoin;
            state.currentLineWidth = lineWidth;
            state.currentMiterLimit = miterLimit;
        }
    }
    /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ endGeometry(feature) {
        this.beginGeometryInstruction1_[2] = this.instructions.length;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
        this.beginGeometryInstruction2_ = null;
        const endGeometryInstruction = [
            (0, _instructionJsDefault.default).END_GEOMETRY,
            feature
        ];
        this.instructions.push(endGeometryInstruction);
        this.hitDetectionInstructions.push(endGeometryInstruction);
    }
    /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */ getBufferedMaxExtent() {
        if (!this.bufferedMaxExtent_) {
            this.bufferedMaxExtent_ = (0, _extentJs.clone)(this.maxExtent);
            if (this.maxLineWidth > 0) {
                const width = this.resolution * (this.maxLineWidth + 1) / 2;
                (0, _extentJs.buffer)(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
            }
        }
        return this.bufferedMaxExtent_;
    }
}
exports.default = CanvasBuilder;

},{"./Instruction.js":"9nhw8","../../extent/Relationship.js":"9q0e7","../VectorContext.js":"ezpza","../../colorlike.js":"ftcFo","../../extent.js":"6YrVc","../canvas.js":"e85iQ","../../array.js":"1Fbic","../../geom/flat/inflate.js":"4Rpju","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9nhw8":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/Instruction
 */ /**
 * @enum {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fillInstruction", ()=>fillInstruction);
parcelHelpers.export(exports, "strokeInstruction", ()=>strokeInstruction);
parcelHelpers.export(exports, "beginPathInstruction", ()=>beginPathInstruction);
parcelHelpers.export(exports, "closePathInstruction", ()=>closePathInstruction);
const Instruction = {
    BEGIN_GEOMETRY: 0,
    BEGIN_PATH: 1,
    CIRCLE: 2,
    CLOSE_PATH: 3,
    CUSTOM: 4,
    DRAW_CHARS: 5,
    DRAW_IMAGE: 6,
    END_GEOMETRY: 7,
    FILL: 8,
    MOVE_TO_LINE_TO: 9,
    SET_FILL_STYLE: 10,
    SET_STROKE_STYLE: 11,
    STROKE: 12
};
const fillInstruction = [
    Instruction.FILL
];
const strokeInstruction = [
    Instruction.STROKE
];
const beginPathInstruction = [
    Instruction.BEGIN_PATH
];
const closePathInstruction = [
    Instruction.CLOSE_PATH
];
exports.default = Instruction;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ezpza":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/VectorContext
 */ /**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class VectorContext {
    /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   */ drawCustom(geometry, feature, renderer, hitDetectionRenderer) {}
    /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */ drawGeometry(geometry) {}
    /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */ setStyle(style) {}
    /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */ drawCircle(circleGeometry, feature) {}
    /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */ drawFeature(feature, style) {}
    /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */ drawGeometryCollection(geometryCollectionGeometry, feature) {}
    /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawLineString(lineStringGeometry, feature) {}
    /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawMultiLineString(multiLineStringGeometry, feature) {}
    /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPoint(multiPointGeometry, feature) {}
    /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPolygon(multiPolygonGeometry, feature) {}
    /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawPoint(pointGeometry, feature) {}
    /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawPolygon(polygonGeometry, feature) {}
    /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */ drawText(geometry, feature) {}
    /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */ setFillStrokeStyle(fillStyle, strokeStyle) {}
    /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */ setImageStyle(imageStyle, declutterImageWithText) {}
    /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */ setTextStyle(textStyle, declutterImageWithText) {}
}
exports.default = VectorContext;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jkri9":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/ImageBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
class CanvasImageBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
        /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */ this.hitDetectionImage_ = null;
        /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */ this.image_ = null;
        /**
     * @private
     * @type {number|undefined}
     */ this.imagePixelRatio_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.anchorX_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.anchorY_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.height_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.opacity_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.originX_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.originY_ = undefined;
        /**
     * @private
     * @type {boolean|undefined}
     */ this.rotateWithView_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.rotation_ = undefined;
        /**
     * @private
     * @type {import("../../size.js").Size|undefined}
     */ this.scale_ = undefined;
        /**
     * @private
     * @type {number|undefined}
     */ this.width_ = undefined;
        /**
     * @private
     * @type {"declutter"|"obstacle"|"none"|undefined}
     */ this.declutterMode_ = undefined;
        /**
     * Data shared with a text builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */ this.declutterImageWithText_ = undefined;
    }
    /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawPoint(pointGeometry, feature) {
        if (!this.image_) return;
        this.beginGeometry(pointGeometry, feature);
        const flatCoordinates = pointGeometry.getFlatCoordinates();
        const stride = pointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_ * this.imagePixelRatio_,
            this.anchorY_ * this.imagePixelRatio_,
            Math.ceil(this.height_ * this.imagePixelRatio_),
            this.opacity_,
            this.originX_ * this.imagePixelRatio_,
            this.originY_ * this.imagePixelRatio_,
            this.rotateWithView_,
            this.rotation_,
            [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
            ],
            Math.ceil(this.width_ * this.imagePixelRatio_),
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_,
            this.anchorY_,
            this.height_,
            1,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            this.scale_,
            this.width_,
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPoint(multiPointGeometry, feature) {
        if (!this.image_) return;
        this.beginGeometry(multiPointGeometry, feature);
        const flatCoordinates = multiPointGeometry.getFlatCoordinates();
        const stride = multiPointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_ * this.imagePixelRatio_,
            this.anchorY_ * this.imagePixelRatio_,
            Math.ceil(this.height_ * this.imagePixelRatio_),
            this.opacity_,
            this.originX_ * this.imagePixelRatio_,
            this.originY_ * this.imagePixelRatio_,
            this.rotateWithView_,
            this.rotation_,
            [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
            ],
            Math.ceil(this.width_ * this.imagePixelRatio_),
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).DRAW_IMAGE,
            myBegin,
            myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_,
            this.anchorY_,
            this.height_,
            1,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            this.scale_,
            this.width_,
            this.declutterMode_,
            this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        this.reverseHitDetectionInstructions();
        // FIXME this doesn't really protect us against further calls to draw*Geometry
        this.anchorX_ = undefined;
        this.anchorY_ = undefined;
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = undefined;
        this.height_ = undefined;
        this.scale_ = undefined;
        this.opacity_ = undefined;
        this.originX_ = undefined;
        this.originY_ = undefined;
        this.rotateWithView_ = undefined;
        this.rotation_ = undefined;
        this.width_ = undefined;
        return super.finish();
    }
    /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */ setImageStyle(imageStyle, sharedData) {
        const anchor = imageStyle.getAnchor();
        const size = imageStyle.getSize();
        const origin = imageStyle.getOrigin();
        this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
        this.anchorX_ = anchor[0];
        this.anchorY_ = anchor[1];
        this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
        this.image_ = imageStyle.getImage(this.pixelRatio);
        this.height_ = size[1];
        this.opacity_ = imageStyle.getOpacity();
        this.originX_ = origin[0];
        this.originY_ = origin[1];
        this.rotateWithView_ = imageStyle.getRotateWithView();
        this.rotation_ = imageStyle.getRotation();
        this.scale_ = imageStyle.getScaleArray();
        this.width_ = size[0];
        this.declutterMode_ = imageStyle.getDeclutterMode();
        this.declutterImageWithText_ = sharedData;
    }
}
exports.default = CanvasImageBuilder;

},{"./Builder.js":"aCopB","./Instruction.js":"9nhw8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cuNSN":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/LineStringBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _canvasJs = require("../canvas.js");
class CanvasLineStringBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */ drawFlatCoordinates_(flatCoordinates, offset, end, stride) {
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
        const moveToLineToInstruction = [
            (0, _instructionJsDefault.default).MOVE_TO_LINE_TO,
            myBegin,
            myEnd
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
    }
    /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawLineString(lineStringGeometry, feature) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) return;
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(lineStringGeometry, feature);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ], (0, _instructionJs.beginPathInstruction));
        const flatCoordinates = lineStringGeometry.getFlatCoordinates();
        const stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
        this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawMultiLineString(multiLineStringGeometry, feature) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) return;
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(multiLineStringGeometry, feature);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ], (0, _instructionJs.beginPathInstruction));
        const ends = multiLineStringGeometry.getEnds();
        const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        const stride = multiLineStringGeometry.getStride();
        let offset = 0;
        for(let i = 0, ii = ends.length; i < ii; ++i)offset = this.drawFlatCoordinates_(flatCoordinates, offset, /** @type {number} */ ends[i], stride);
        this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        this.endGeometry(feature);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        const state = this.state;
        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) this.instructions.push((0, _instructionJs.strokeInstruction));
        this.reverseHitDetectionInstructions();
        this.state = null;
        return super.finish();
    }
    /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */ applyStroke(state) {
        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
            this.instructions.push((0, _instructionJs.strokeInstruction));
            state.lastStroke = this.coordinates.length;
        }
        state.lastStroke = 0;
        super.applyStroke(state);
        this.instructions.push((0, _instructionJs.beginPathInstruction));
    }
}
exports.default = CanvasLineStringBuilder;

},{"./Builder.js":"aCopB","./Instruction.js":"9nhw8","../canvas.js":"e85iQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"992jH":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/PolygonBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _canvasJs = require("../canvas.js");
var _simplifyJs = require("../../geom/flat/simplify.js");
class CanvasPolygonBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */ drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {
        const state = this.state;
        const fill = state.fillStyle !== undefined;
        const stroke = state.strokeStyle !== undefined;
        const numEnds = ends.length;
        this.instructions.push((0, _instructionJs.beginPathInstruction));
        this.hitDetectionInstructions.push((0, _instructionJs.beginPathInstruction));
        for(let i = 0; i < numEnds; ++i){
            const end = ends[i];
            const myBegin = this.coordinates.length;
            const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
            const moveToLineToInstruction = [
                (0, _instructionJsDefault.default).MOVE_TO_LINE_TO,
                myBegin,
                myEnd
            ];
            this.instructions.push(moveToLineToInstruction);
            this.hitDetectionInstructions.push(moveToLineToInstruction);
            if (stroke) {
                // Performance optimization: only call closePath() when we have a stroke.
                // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
                this.instructions.push((0, _instructionJs.closePathInstruction));
                this.hitDetectionInstructions.push((0, _instructionJs.closePathInstruction));
            }
            offset = end;
        }
        if (fill) {
            this.instructions.push((0, _instructionJs.fillInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.fillInstruction));
        }
        if (stroke) {
            this.instructions.push((0, _instructionJs.strokeInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        }
        return offset;
    }
    /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */ drawCircle(circleGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(circleGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            (0, _canvasJs.defaultFillStyle)
        ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ]);
        const flatCoordinates = circleGeometry.getFlatCoordinates();
        const stride = circleGeometry.getStride();
        const myBegin = this.coordinates.length;
        this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
        const circleInstruction = [
            (0, _instructionJsDefault.default).CIRCLE,
            myBegin
        ];
        this.instructions.push((0, _instructionJs.beginPathInstruction), circleInstruction);
        this.hitDetectionInstructions.push((0, _instructionJs.beginPathInstruction), circleInstruction);
        if (state.fillStyle !== undefined) {
            this.instructions.push((0, _instructionJs.fillInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.fillInstruction));
        }
        if (state.strokeStyle !== undefined) {
            this.instructions.push((0, _instructionJs.strokeInstruction));
            this.hitDetectionInstructions.push((0, _instructionJs.strokeInstruction));
        }
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawPolygon(polygonGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(polygonGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            (0, _canvasJs.defaultFillStyle)
        ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ]);
        const ends = polygonGeometry.getEnds();
        const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        const stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(flatCoordinates, 0, /** @type {Array<number>} */ ends, stride);
        this.endGeometry(feature);
    }
    /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawMultiPolygon(multiPolygonGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_FILL_STYLE,
            (0, _canvasJs.defaultFillStyle)
        ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            (0, _canvasJs.defaultLineDash),
            (0, _canvasJs.defaultLineDashOffset)
        ]);
        const endss = multiPolygonGeometry.getEndss();
        const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        const stride = multiPolygonGeometry.getStride();
        let offset = 0;
        for(let i = 0, ii = endss.length; i < ii; ++i)offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
        this.endGeometry(feature);
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        this.reverseHitDetectionInstructions();
        this.state = null;
        // We want to preserve topology when drawing polygons.  Polygons are
        // simplified using quantization and point elimination. However, we might
        // have received a mix of quantized and non-quantized geometries, so ensure
        // that all are quantized by quantizing all coordinates in the batch.
        const tolerance = this.tolerance;
        if (tolerance !== 0) {
            const coordinates = this.coordinates;
            for(let i = 0, ii = coordinates.length; i < ii; ++i)coordinates[i] = (0, _simplifyJs.snap)(coordinates[i], tolerance);
        }
        return super.finish();
    }
    /**
   * @private
   */ setFillStrokeStyles_() {
        const state = this.state;
        const fillStyle = state.fillStyle;
        if (fillStyle !== undefined) this.updateFillStyle(state, this.createFill);
        if (state.strokeStyle !== undefined) this.updateStrokeStyle(state, this.applyStroke);
    }
}
exports.default = CanvasPolygonBuilder;

},{"./Builder.js":"aCopB","./Instruction.js":"9nhw8","../canvas.js":"e85iQ","../../geom/flat/simplify.js":"jsqc5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6mvke":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/TextBuilder
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TEXT_ALIGN", ()=>TEXT_ALIGN);
var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _colorlikeJs = require("../../colorlike.js");
var _canvasJs = require("../canvas.js");
var _utilJs = require("../../util.js");
var _extentJs = require("../../extent.js");
var _linechunkJs = require("../../geom/flat/linechunk.js");
var _straightchunkJs = require("../../geom/flat/straightchunk.js");
const TEXT_ALIGN = {
    'left': 0,
    'center': 0.5,
    'right': 1,
    'top': 0,
    'middle': 0.5,
    'hanging': 0.2,
    'alphabetic': 0.8,
    'ideographic': 0.8,
    'bottom': 1
};
class CanvasTextBuilder extends (0, _builderJsDefault.default) {
    /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */ constructor(tolerance, maxExtent, resolution, pixelRatio){
        super(tolerance, maxExtent, resolution, pixelRatio);
        /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */ this.labels_ = null;
        /**
     * @private
     * @type {string|Array<string>}
     */ this.text_ = '';
        /**
     * @private
     * @type {number}
     */ this.textOffsetX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.textOffsetY_ = 0;
        /**
     * @private
     * @type {boolean|undefined}
     */ this.textRotateWithView_ = undefined;
        /**
     * @private
     * @type {number}
     */ this.textRotation_ = 0;
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.textFillState_ = null;
        /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */ this.fillStates = {};
        this.fillStates[0, _canvasJs.defaultFillStyle] = {
            fillStyle: (0, _canvasJs.defaultFillStyle)
        };
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.textStrokeState_ = null;
        /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */ this.strokeStates = {};
        /**
     * @private
     * @type {import("../canvas.js").TextState}
     */ this.textState_ = /** @type {import("../canvas.js").TextState} */ {};
        /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */ this.textStates = {};
        /**
     * @private
     * @type {string}
     */ this.textKey_ = '';
        /**
     * @private
     * @type {string}
     */ this.fillKey_ = '';
        /**
     * @private
     * @type {string}
     */ this.strokeKey_ = '';
        /**
     * Data shared with an image builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */ this.declutterImageWithText_ = undefined;
    }
    /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */ finish() {
        const instructions = super.finish();
        instructions.textStates = this.textStates;
        instructions.fillStates = this.fillStates;
        instructions.strokeStates = this.strokeStates;
        return instructions;
    }
    /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */ drawText(geometry, feature) {
        const fillState = this.textFillState_;
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        if (this.text_ === '' || !textState || !fillState && !strokeState) return;
        const coordinates = this.coordinates;
        let begin = coordinates.length;
        const geometryType = geometry.getType();
        let flatCoordinates = null;
        let stride = geometry.getStride();
        if (textState.placement === 'line' && (geometryType == 'LineString' || geometryType == 'MultiLineString' || geometryType == 'Polygon' || geometryType == 'MultiPolygon')) {
            if (!(0, _extentJs.intersects)(this.getBufferedMaxExtent(), geometry.getExtent())) return;
            let ends;
            flatCoordinates = geometry.getFlatCoordinates();
            if (geometryType == 'LineString') ends = [
                flatCoordinates.length
            ];
            else if (geometryType == 'MultiLineString') ends = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.getEnds();
            else if (geometryType == 'Polygon') ends = /** @type {import("../../geom/Polygon.js").default} */ geometry.getEnds().slice(0, 1);
            else if (geometryType == 'MultiPolygon') {
                const endss = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getEndss();
                ends = [];
                for(let i = 0, ii = endss.length; i < ii; ++i)ends.push(endss[i][0]);
            }
            this.beginGeometry(geometry, feature);
            const repeat = textState.repeat;
            const textAlign = repeat ? undefined : textState.textAlign;
            // No `justify` support for line placement.
            let flatOffset = 0;
            for(let o = 0, oo = ends.length; o < oo; ++o){
                let chunks;
                if (repeat) chunks = (0, _linechunkJs.lineChunk)(repeat * this.resolution, flatCoordinates, flatOffset, ends[o], stride);
                else chunks = [
                    flatCoordinates.slice(flatOffset, ends[o])
                ];
                for(let c = 0, cc = chunks.length; c < cc; ++c){
                    const chunk = chunks[c];
                    let chunkBegin = 0;
                    let chunkEnd = chunk.length;
                    if (textAlign == undefined) {
                        const range = (0, _straightchunkJs.matchingChunk)(textState.maxAngle, chunk, 0, chunk.length, 2);
                        chunkBegin = range[0];
                        chunkEnd = range[1];
                    }
                    for(let i = chunkBegin; i < chunkEnd; i += stride)coordinates.push(chunk[i], chunk[i + 1]);
                    const end = coordinates.length;
                    flatOffset = ends[o];
                    this.drawChars_(begin, end);
                    begin = end;
                }
            }
            this.endGeometry(feature);
        } else {
            let geometryWidths = textState.overflow ? null : [];
            switch(geometryType){
                case 'Point':
                case 'MultiPoint':
                    flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */ geometry.getFlatCoordinates();
                    break;
                case 'LineString':
                    flatCoordinates = /** @type {import("../../geom/LineString.js").default} */ geometry.getFlatMidpoint();
                    break;
                case 'Circle':
                    flatCoordinates = /** @type {import("../../geom/Circle.js").default} */ geometry.getCenter();
                    break;
                case 'MultiLineString':
                    flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.getFlatMidpoints();
                    stride = 2;
                    break;
                case 'Polygon':
                    flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */ geometry.getFlatInteriorPoint();
                    if (!textState.overflow) geometryWidths.push(flatCoordinates[2] / this.resolution);
                    stride = 3;
                    break;
                case 'MultiPolygon':
                    const interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getFlatInteriorPoints();
                    flatCoordinates = [];
                    for(let i = 0, ii = interiorPoints.length; i < ii; i += 3){
                        if (!textState.overflow) geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                        flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                    }
                    if (flatCoordinates.length === 0) return;
                    stride = 2;
                    break;
                default:
            }
            const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
            if (end === begin) return;
            if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
                let beg = begin / 2;
                geometryWidths = geometryWidths.filter((w, i)=>{
                    const keep = coordinates[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
                    if (!keep) --beg;
                    return keep;
                });
            }
            this.saveTextStates_();
            if (textState.backgroundFill || textState.backgroundStroke) {
                this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                if (textState.backgroundFill) this.updateFillStyle(this.state, this.createFill);
                if (textState.backgroundStroke) {
                    this.updateStrokeStyle(this.state, this.applyStroke);
                    this.hitDetectionInstructions.push(this.createStroke(this.state));
                }
            }
            this.beginGeometry(geometry, feature);
            // adjust padding for negative scale
            let padding = textState.padding;
            if (padding != (0, _canvasJs.defaultPadding) && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                let p0 = textState.padding[0];
                let p1 = textState.padding[1];
                let p2 = textState.padding[2];
                let p3 = textState.padding[3];
                if (textState.scale[0] < 0) {
                    p1 = -p1;
                    p3 = -p3;
                }
                if (textState.scale[1] < 0) {
                    p0 = -p0;
                    p2 = -p2;
                }
                padding = [
                    p0,
                    p1,
                    p2,
                    p3
                ];
            }
            // The image is unknown at this stage so we pass null; it will be computed at render time.
            // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
            // render time.
            const pixelRatio = this.pixelRatio;
            this.instructions.push([
                (0, _instructionJsDefault.default).DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [
                    1,
                    1
                ],
                NaN,
                undefined,
                this.declutterImageWithText_,
                padding == (0, _canvasJs.defaultPadding) ? (0, _canvasJs.defaultPadding) : padding.map(function(p) {
                    return p * pixelRatio;
                }),
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths
            ]);
            const scale = 1 / pixelRatio;
            // Set default fill for hit detection background
            const currentFillStyle = this.state.fillStyle;
            if (textState.backgroundFill) {
                this.state.fillStyle = (0, _canvasJs.defaultFillStyle);
                this.hitDetectionInstructions.push(this.createFill(this.state));
            }
            this.hitDetectionInstructions.push([
                (0, _instructionJsDefault.default).DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [
                    scale,
                    scale
                ],
                NaN,
                undefined,
                this.declutterImageWithText_,
                padding,
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_ ? (0, _canvasJs.defaultFillStyle) : this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths
            ]);
            // Reset previous fill
            if (textState.backgroundFill) {
                this.state.fillStyle = currentFillStyle;
                this.hitDetectionInstructions.push(this.createFill(this.state));
            }
            this.endGeometry(feature);
        }
    }
    /**
   * @private
   */ saveTextStates_() {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const fillState = this.textFillState_;
        const strokeKey = this.strokeKey_;
        if (strokeState) {
            if (!(strokeKey in this.strokeStates)) this.strokeStates[strokeKey] = {
                strokeStyle: strokeState.strokeStyle,
                lineCap: strokeState.lineCap,
                lineDashOffset: strokeState.lineDashOffset,
                lineWidth: strokeState.lineWidth,
                lineJoin: strokeState.lineJoin,
                miterLimit: strokeState.miterLimit,
                lineDash: strokeState.lineDash
            };
        }
        const textKey = this.textKey_;
        if (!(textKey in this.textStates)) this.textStates[textKey] = {
            font: textState.font,
            textAlign: textState.textAlign || (0, _canvasJs.defaultTextAlign),
            justify: textState.justify,
            textBaseline: textState.textBaseline || (0, _canvasJs.defaultTextBaseline),
            scale: textState.scale
        };
        const fillKey = this.fillKey_;
        if (fillState) {
            if (!(fillKey in this.fillStates)) this.fillStates[fillKey] = {
                fillStyle: fillState.fillStyle
            };
        }
    }
    /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */ drawChars_(begin, end) {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const strokeKey = this.strokeKey_;
        const textKey = this.textKey_;
        const fillKey = this.fillKey_;
        this.saveTextStates_();
        const pixelRatio = this.pixelRatio;
        const baseline = TEXT_ALIGN[textState.textBaseline];
        const offsetY = this.textOffsetY_ * pixelRatio;
        const text = this.text_;
        const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
        this.instructions.push([
            (0, _instructionJsDefault.default).DRAW_CHARS,
            begin,
            end,
            baseline,
            textState.overflow,
            fillKey,
            textState.maxAngle,
            pixelRatio,
            offsetY,
            strokeKey,
            strokeWidth * pixelRatio,
            text,
            textKey,
            1
        ]);
        this.hitDetectionInstructions.push([
            (0, _instructionJsDefault.default).DRAW_CHARS,
            begin,
            end,
            baseline,
            textState.overflow,
            fillKey ? (0, _canvasJs.defaultFillStyle) : fillKey,
            textState.maxAngle,
            pixelRatio,
            offsetY,
            strokeKey,
            strokeWidth * pixelRatio,
            text,
            textKey,
            1 / pixelRatio
        ]);
    }
    /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */ setTextStyle(textStyle, sharedData) {
        let textState, fillState, strokeState;
        if (!textStyle) this.text_ = '';
        else {
            const textFillStyle = textStyle.getFill();
            if (!textFillStyle) {
                fillState = null;
                this.textFillState_ = fillState;
            } else {
                fillState = this.textFillState_;
                if (!fillState) {
                    fillState = /** @type {import("../canvas.js").FillState} */ {};
                    this.textFillState_ = fillState;
                }
                fillState.fillStyle = (0, _colorlikeJs.asColorLike)(textFillStyle.getColor() || (0, _canvasJs.defaultFillStyle));
            }
            const textStrokeStyle = textStyle.getStroke();
            if (!textStrokeStyle) {
                strokeState = null;
                this.textStrokeState_ = strokeState;
            } else {
                strokeState = this.textStrokeState_;
                if (!strokeState) {
                    strokeState = /** @type {import("../canvas.js").StrokeState} */ {};
                    this.textStrokeState_ = strokeState;
                }
                const lineDash = textStrokeStyle.getLineDash();
                const lineDashOffset = textStrokeStyle.getLineDashOffset();
                const lineWidth = textStrokeStyle.getWidth();
                const miterLimit = textStrokeStyle.getMiterLimit();
                strokeState.lineCap = textStrokeStyle.getLineCap() || (0, _canvasJs.defaultLineCap);
                strokeState.lineDash = lineDash ? lineDash.slice() : (0, _canvasJs.defaultLineDash);
                strokeState.lineDashOffset = lineDashOffset === undefined ? (0, _canvasJs.defaultLineDashOffset) : lineDashOffset;
                strokeState.lineJoin = textStrokeStyle.getLineJoin() || (0, _canvasJs.defaultLineJoin);
                strokeState.lineWidth = lineWidth === undefined ? (0, _canvasJs.defaultLineWidth) : lineWidth;
                strokeState.miterLimit = miterLimit === undefined ? (0, _canvasJs.defaultMiterLimit) : miterLimit;
                strokeState.strokeStyle = (0, _colorlikeJs.asColorLike)(textStrokeStyle.getColor() || (0, _canvasJs.defaultStrokeStyle));
            }
            textState = this.textState_;
            const font = textStyle.getFont() || (0, _canvasJs.defaultFont);
            (0, _canvasJs.registerFont)(font);
            const textScale = textStyle.getScaleArray();
            textState.overflow = textStyle.getOverflow();
            textState.font = font;
            textState.maxAngle = textStyle.getMaxAngle();
            textState.placement = textStyle.getPlacement();
            textState.textAlign = textStyle.getTextAlign();
            textState.repeat = textStyle.getRepeat();
            textState.justify = textStyle.getJustify();
            textState.textBaseline = textStyle.getTextBaseline() || (0, _canvasJs.defaultTextBaseline);
            textState.backgroundFill = textStyle.getBackgroundFill();
            textState.backgroundStroke = textStyle.getBackgroundStroke();
            textState.padding = textStyle.getPadding() || (0, _canvasJs.defaultPadding);
            textState.scale = textScale === undefined ? [
                1,
                1
            ] : textScale;
            const textOffsetX = textStyle.getOffsetX();
            const textOffsetY = textStyle.getOffsetY();
            const textRotateWithView = textStyle.getRotateWithView();
            const textRotation = textStyle.getRotation();
            this.text_ = textStyle.getText() || '';
            this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
            this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
            this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
            this.textRotation_ = textRotation === undefined ? 0 : textRotation;
            this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : (0, _utilJs.getUid)(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
            this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.repeat || '?') + (textState.justify || '?') + (textState.textBaseline || '?');
            this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + (0, _utilJs.getUid)(fillState.fillStyle) : '';
        }
        this.declutterImageWithText_ = sharedData;
    }
}
exports.default = CanvasTextBuilder;

},{"./Builder.js":"aCopB","./Instruction.js":"9nhw8","../../colorlike.js":"ftcFo","../canvas.js":"e85iQ","../../util.js":"pLBjQ","../../extent.js":"6YrVc","../../geom/flat/linechunk.js":"4PAOP","../../geom/flat/straightchunk.js":"eUhrS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4PAOP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates chunks of equal length from a linestring
 * @param {number} chunkLength Length of each chunk.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @return {Array<Array<number>>} Chunks of linestrings with stride 2.
 */ parcelHelpers.export(exports, "lineChunk", ()=>lineChunk);
var _mathJs = require("../../math.js");
function lineChunk(chunkLength, flatCoordinates, offset, end, stride) {
    const chunks = [];
    let cursor = offset;
    let chunkM = 0;
    let currentChunk = flatCoordinates.slice(offset, 2);
    while(chunkM < chunkLength && cursor + stride < end){
        const [x1, y1] = currentChunk.slice(-2);
        const x2 = flatCoordinates[cursor + stride];
        const y2 = flatCoordinates[cursor + stride + 1];
        const segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        chunkM += segmentLength;
        if (chunkM >= chunkLength) {
            const m = (chunkLength - chunkM + segmentLength) / segmentLength;
            const x = (0, _mathJs.lerp)(x1, x2, m);
            const y = (0, _mathJs.lerp)(y1, y2, m);
            currentChunk.push(x, y);
            chunks.push(currentChunk);
            currentChunk = [
                x,
                y
            ];
            if (chunkM == chunkLength) cursor += stride;
            chunkM = 0;
        } else if (chunkM < chunkLength) {
            currentChunk.push(flatCoordinates[cursor + stride], flatCoordinates[cursor + stride + 1]);
            cursor += stride;
        } else {
            const missing = segmentLength - chunkM;
            const x = (0, _mathJs.lerp)(x1, x2, missing / segmentLength);
            const y = (0, _mathJs.lerp)(y1, y2, missing / segmentLength);
            currentChunk.push(x, y);
            chunks.push(currentChunk);
            currentChunk = [
                x,
                y
            ];
            chunkM = 0;
            cursor += stride;
        }
    }
    if (chunkM > 0) chunks.push(currentChunk);
    return chunks;
}

},{"../../math.js":"5jEFr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eUhrS":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/straightchunk
 */ /**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "matchingChunk", ()=>matchingChunk);
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
    let chunkStart = offset;
    let chunkEnd = offset;
    let chunkM = 0;
    let m = 0;
    let start = offset;
    let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
    for(i = offset; i < end; i += stride){
        const x2 = flatCoordinates[i];
        const y2 = flatCoordinates[i + 1];
        if (x1 !== undefined) {
            x23 = x2 - x1;
            y23 = y2 - y1;
            m23 = Math.sqrt(x23 * x23 + y23 * y23);
            if (x12 !== undefined) {
                m += m12;
                acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                if (acos > maxAngle) {
                    if (m > chunkM) {
                        chunkM = m;
                        chunkStart = start;
                        chunkEnd = i;
                    }
                    m = 0;
                    start = i - stride;
                }
            }
            m12 = m23;
            x12 = x23;
            y12 = y23;
        }
        x1 = x2;
        y1 = y2;
    }
    m += m23;
    return m > chunkM ? [
        start,
        i
    ] : [
        chunkStart,
        chunkEnd
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fY3ny":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/canvas/Layer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "canvasPool", ()=>canvasPool);
var _layerJs = require("../Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _eventJs = require("../../render/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _transformJs = require("../../transform.js");
var _colorJs = require("../../color.js");
var _domJs = require("../../dom.js");
var _arrayJs = require("../../array.js");
var _extentJs = require("../../extent.js");
const canvasPool = [];
/**
 * @type {CanvasRenderingContext2D}
 */ let pixelContext = null;
function createPixelContext() {
    pixelContext = (0, _domJs.createCanvasContext2D)(1, 1, undefined, {
        willReadFrequently: true
    });
}
/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */ class CanvasLayerRenderer extends (0, _layerJsDefault.default) {
    /**
   * @param {LayerType} layer Layer.
   */ constructor(layer){
        super(layer);
        /**
     * @protected
     * @type {HTMLElement}
     */ this.container = null;
        /**
     * @protected
     * @type {number}
     */ this.renderedResolution;
        /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.tempTransform = (0, _transformJs.create)();
        /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.pixelTransform = (0, _transformJs.create)();
        /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */ this.inversePixelTransform = (0, _transformJs.create)();
        /**
     * @type {CanvasRenderingContext2D}
     */ this.context = null;
        /**
     * @type {boolean}
     */ this.containerReused = false;
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.pixelContext_ = null;
        /**
     * @protected
     * @type {import("../../Map.js").FrameState|null}
     */ this.frameState = null;
    }
    /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */ getImageData(image, col, row) {
        if (!pixelContext) createPixelContext();
        pixelContext.clearRect(0, 0, 1, 1);
        let data;
        try {
            pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
            data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch (err) {
            pixelContext = null;
            return null;
        }
        return data;
    }
    /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */ getBackground(frameState) {
        const layer = this.getLayer();
        let background = layer.getBackground();
        if (typeof background === 'function') background = background(frameState.viewState.resolution);
        return background || undefined;
    }
    /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */ useContainer(target, transform, backgroundColor) {
        const layerClassName = this.getLayer().getClassName();
        let container, context;
        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && (0, _arrayJs.equals)((0, _colorJs.asArray)(target.style.backgroundColor), (0, _colorJs.asArray)(backgroundColor)))) {
            const canvas = target.firstElementChild;
            if (canvas instanceof HTMLCanvasElement) context = canvas.getContext('2d');
        }
        if (context && context.canvas.style.transform === transform) {
            // Container of the previous layer renderer can be used.
            this.container = target;
            this.context = context;
            this.containerReused = true;
        } else if (this.containerReused) {
            // Previously reused container cannot be used any more.
            this.container = null;
            this.context = null;
            this.containerReused = false;
        } else if (this.container) this.container.style.backgroundColor = null;
        if (!this.container) {
            container = document.createElement('div');
            container.className = layerClassName;
            let style = container.style;
            style.position = 'absolute';
            style.width = '100%';
            style.height = '100%';
            context = (0, _domJs.createCanvasContext2D)();
            const canvas = context.canvas;
            container.appendChild(canvas);
            style = canvas.style;
            style.position = 'absolute';
            style.left = '0';
            style.transformOrigin = 'top left';
            this.container = container;
            this.context = context;
        }
        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) this.container.style.backgroundColor = backgroundColor;
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */ clipUnrotated(context, frameState, extent) {
        const topLeft = (0, _extentJs.getTopLeft)(extent);
        const topRight = (0, _extentJs.getTopRight)(extent);
        const bottomRight = (0, _extentJs.getBottomRight)(extent);
        const bottomLeft = (0, _extentJs.getBottomLeft)(extent);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, topLeft);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, topRight);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, bottomRight);
        (0, _transformJs.apply)(frameState.coordinateToPixelTransform, bottomLeft);
        const inverted = this.inversePixelTransform;
        (0, _transformJs.apply)(inverted, topLeft);
        (0, _transformJs.apply)(inverted, topRight);
        (0, _transformJs.apply)(inverted, bottomRight);
        (0, _transformJs.apply)(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
    }
    /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */ dispatchRenderEvent_(type, context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
            const event = new (0, _eventJsDefault.default)(type, this.inversePixelTransform, frameState, context);
            layer.dispatchEvent(event);
        }
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ preRender(context, frameState) {
        this.frameState = frameState;
        this.dispatchRenderEvent_((0, _eventTypeJsDefault.default).PRERENDER, context, frameState);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */ postRender(context, frameState) {
        this.dispatchRenderEvent_((0, _eventTypeJsDefault.default).POSTRENDER, context, frameState);
    }
    /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */ getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        const dx1 = width / 2;
        const dy1 = height / 2;
        const sx = pixelRatio / resolution;
        const sy = -sx;
        const dx2 = -center[0] + offsetX;
        const dy2 = -center[1];
        return (0, _transformJs.compose)(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
    }
    /**
   * Clean up.
   */ disposeInternal() {
        delete this.frameState;
        super.disposeInternal();
    }
}
exports.default = CanvasLayerRenderer;

},{"../Layer.js":"b6gGa","../../render/Event.js":"bpzid","../../render/EventType.js":"5G9JA","../../transform.js":"1BqUf","../../color.js":"4tahz","../../dom.js":"84QzQ","../../array.js":"1Fbic","../../extent.js":"6YrVc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b6gGa":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/Layer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _observableJs = require("../Observable.js");
var _observableJsDefault = parcelHelpers.interopDefault(_observableJs);
var _utilJs = require("../util.js");
/**
 * @template {import("../layer/Layer.js").default} LayerType
 */ class LayerRenderer extends (0, _observableJsDefault.default) {
    /**
   * @param {LayerType} layer Layer.
   */ constructor(layer){
        super();
        /**
     * The renderer is initialized and ready to render.
     * @type {boolean}
     */ this.ready = true;
        /** @private */ this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
        /**
     * @protected
     * @type {LayerType}
     */ this.layer_ = layer;
        /**
     * @type {import("../render/canvas/ExecutorGroup").default}
     */ this.declutterExecutorGroup = null;
    }
    /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */ getFeatures(pixel) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */ getData(pixel) {
        return null;
    }
    /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */ prepareFrame(frameState) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */ renderFrame(frameState, target) {
        return (0, _utilJs.abstract)();
    }
    /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */ loadedTileCallback(tiles, zoom, tile) {
        if (!tiles[zoom]) tiles[zoom] = {};
        tiles[zoom][tile.tileCoord.toString()] = tile;
        return undefined;
    }
    /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */ createLoadedTileFinder(source, projection, tiles) {
        return(/**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */ (zoom, tileRange)=>{
            const callback = this.loadedTileCallback.bind(this, tiles, zoom);
            return source.forEachLoadedTile(projection, zoom, tileRange, callback);
        });
    }
    /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return undefined;
    }
    /**
   * @return {LayerType} Layer.
   */ getLayer() {
        return this.layer_;
    }
    /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */ handleFontsChanged() {}
    /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */ handleImageChange_(event) {
        const image = /** @type {import("../Image.js").default} */ event.target;
        if (image.getState() === (0, _imageStateJsDefault.default).LOADED || image.getState() === (0, _imageStateJsDefault.default).ERROR) this.renderIfReadyAndVisible();
    }
    /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */ loadImage(image) {
        let imageState = image.getState();
        if (imageState != (0, _imageStateJsDefault.default).LOADED && imageState != (0, _imageStateJsDefault.default).ERROR) image.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleImageChange_);
        if (imageState == (0, _imageStateJsDefault.default).IDLE) {
            image.load();
            imageState = image.getState();
        }
        return imageState == (0, _imageStateJsDefault.default).LOADED;
    }
    /**
   * @protected
   */ renderIfReadyAndVisible() {
        const layer = this.getLayer();
        if (layer && layer.getVisible() && layer.getSourceState() === 'ready') layer.changed();
    }
    /**
   * Clean up.
   */ disposeInternal() {
        delete this.layer_;
        super.disposeInternal();
    }
}
exports.default = LayerRenderer;

},{"../events/EventType.js":"hrQJ6","../ImageState.js":"c4jJS","../Observable.js":"cQ2uI","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bpzid":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/Event
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
class RenderEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */ constructor(type, inversePixelTransform, frameState, context){
        super(type);
        /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */ this.inversePixelTransform = inversePixelTransform;
        /**
     * An object representing the current render frame state.
     * @type {import("../Map.js").FrameState|undefined}
     * @api
     */ this.frameState = frameState;
        /**
     * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
     * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
     * context.
     * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
     * @api
     */ this.context = context;
    }
}
exports.default = RenderEvent;

},{"../events/Event.js":"hwXQP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eUidV":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/ExecutorGroup
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @return {Array<number>} An array with indexes within a circle.
 */ parcelHelpers.export(exports, "getPixelIndexArray", ()=>getPixelIndexArray);
var _executorJs = require("./Executor.js");
var _executorJsDefault = parcelHelpers.interopDefault(_executorJs);
var _arrayJs = require("../../array.js");
var _extentJs = require("../../extent.js");
var _transformJs = require("../../transform.js");
var _domJs = require("../../dom.js");
var _objJs = require("../../obj.js");
var _transformJs1 = require("../../geom/flat/transform.js");
/**
 * @const
 * @type {Array<import("../canvas.js").BuilderType>}
 */ const ORDER = [
    'Polygon',
    'Circle',
    'LineString',
    'Image',
    'Text',
    'Default'
];
class ExecutorGroup {
    /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   */ constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer){
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.maxExtent_ = maxExtent;
        /**
     * @private
     * @type {boolean}
     */ this.overlaps_ = overlaps;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {number}
     */ this.resolution_ = resolution;
        /**
     * @private
     * @type {number|undefined}
     */ this.renderBuffer_ = renderBuffer;
        /**
     * @private
     * @type {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Executor").default>>}
     */ this.executorsByZIndex_ = {};
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.hitDetectionContext_ = null;
        /**
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.hitDetectionTransform_ = (0, _transformJs.create)();
        this.createExecutors_(allInstructions);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */ clip(context, transform) {
        const flatClipCoords = this.getClipCoords(transform);
        context.beginPath();
        context.moveTo(flatClipCoords[0], flatClipCoords[1]);
        context.lineTo(flatClipCoords[2], flatClipCoords[3]);
        context.lineTo(flatClipCoords[4], flatClipCoords[5]);
        context.lineTo(flatClipCoords[6], flatClipCoords[7]);
        context.clip();
    }
    /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */ createExecutors_(allInstructions) {
        for(const zIndex in allInstructions){
            let executors = this.executorsByZIndex_[zIndex];
            if (executors === undefined) {
                executors = {};
                this.executorsByZIndex_[zIndex] = executors;
            }
            const instructionByZindex = allInstructions[zIndex];
            for(const builderType in instructionByZindex){
                const instructions = instructionByZindex[builderType];
                executors[builderType] = new (0, _executorJsDefault.default)(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
            }
        }
    }
    /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */ hasExecutors(executors) {
        for(const zIndex in this.executorsByZIndex_){
            const candidates = this.executorsByZIndex_[zIndex];
            for(let i = 0, ii = executors.length; i < ii; ++i){
                if (executors[i] in candidates) return true;
            }
        }
        return false;
    }
    /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */ forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
        hitTolerance = Math.round(hitTolerance);
        const contextSize = hitTolerance * 2 + 1;
        const transform = (0, _transformJs.compose)(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
        const newContext = !this.hitDetectionContext_;
        if (newContext) this.hitDetectionContext_ = (0, _domJs.createCanvasContext2D)(contextSize, contextSize, undefined, {
            willReadFrequently: true
        });
        const context = this.hitDetectionContext_;
        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
            context.canvas.width = contextSize;
            context.canvas.height = contextSize;
        } else if (!newContext) context.clearRect(0, 0, contextSize, contextSize);
        /**
     * @type {import("../../extent.js").Extent}
     */ let hitExtent;
        if (this.renderBuffer_ !== undefined) {
            hitExtent = (0, _extentJs.createEmpty)();
            (0, _extentJs.extendCoordinate)(hitExtent, coordinate);
            (0, _extentJs.buffer)(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
        }
        const indexes = getPixelIndexArray(hitTolerance);
        let builderType;
        /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */ function featureCallback(feature, geometry) {
            const imageData = context.getImageData(0, 0, contextSize, contextSize).data;
            for(let i = 0, ii = indexes.length; i < ii; i++)if (imageData[indexes[i]] > 0) {
                if (!declutteredFeatures || builderType !== 'Image' && builderType !== 'Text' || declutteredFeatures.includes(feature)) {
                    const idx = (indexes[i] - 3) / 4;
                    const x = hitTolerance - idx % contextSize;
                    const y = hitTolerance - (idx / contextSize | 0);
                    const result = callback(feature, geometry, x * x + y * y);
                    if (result) return result;
                }
                context.clearRect(0, 0, contextSize, contextSize);
                break;
            }
            return undefined;
        }
        /** @type {Array<number>} */ const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort((0, _arrayJs.ascending));
        let i, j, executors, executor, result;
        for(i = zs.length - 1; i >= 0; --i){
            const zIndexKey = zs[i].toString();
            executors = this.executorsByZIndex_[zIndexKey];
            for(j = ORDER.length - 1; j >= 0; --j){
                builderType = ORDER[j];
                executor = executors[builderType];
                if (executor !== undefined) {
                    result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);
                    if (result) return result;
                }
            }
        }
        return undefined;
    }
    /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */ getClipCoords(transform) {
        const maxExtent = this.maxExtent_;
        if (!maxExtent) return null;
        const minX = maxExtent[0];
        const minY = maxExtent[1];
        const maxX = maxExtent[2];
        const maxY = maxExtent[3];
        const flatClipCoords = [
            minX,
            minY,
            minX,
            maxY,
            maxX,
            maxY,
            maxX,
            minY
        ];
        (0, _transformJs1.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
        return flatClipCoords;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return (0, _objJs.isEmpty)(this.executorsByZIndex_);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */ execute(context, contextScale, transform, viewRotation, snapToPixel, builderTypes, declutterTree) {
        /** @type {Array<number>} */ const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort((0, _arrayJs.ascending));
        // setup clipping so that the parts of over-simplified geometries are not
        // visible outside the current extent when panning
        if (this.maxExtent_) {
            context.save();
            this.clip(context, transform);
        }
        builderTypes = builderTypes ? builderTypes : ORDER;
        let i, ii, j, jj, replays, replay;
        if (declutterTree) zs.reverse();
        for(i = 0, ii = zs.length; i < ii; ++i){
            const zIndexKey = zs[i].toString();
            replays = this.executorsByZIndex_[zIndexKey];
            for(j = 0, jj = builderTypes.length; j < jj; ++j){
                const builderType = builderTypes[j];
                replay = replays[builderType];
                if (replay !== undefined) replay.execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree);
            }
        }
        if (this.maxExtent_) context.restore();
    }
}
/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */ const circlePixelIndexArrayCache = {};
function getPixelIndexArray(radius) {
    if (circlePixelIndexArrayCache[radius] !== undefined) return circlePixelIndexArrayCache[radius];
    const size = radius * 2 + 1;
    const maxDistanceSq = radius * radius;
    const distances = new Array(maxDistanceSq + 1);
    for(let i = 0; i <= radius; ++i)for(let j = 0; j <= radius; ++j){
        const distanceSq = i * i + j * j;
        if (distanceSq > maxDistanceSq) break;
        let distance = distances[distanceSq];
        if (!distance) {
            distance = [];
            distances[distanceSq] = distance;
        }
        distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
        if (i > 0) distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
        if (j > 0) {
            distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
            if (i > 0) distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
    }
    const pixelIndex = [];
    for(let i = 0, ii = distances.length; i < ii; ++i)if (distances[i]) pixelIndex.push(...distances[i]);
    circlePixelIndexArrayCache[radius] = pixelIndex;
    return pixelIndex;
}
exports.default = ExecutorGroup;

},{"./Executor.js":"5JJby","../../array.js":"1Fbic","../../extent.js":"6YrVc","../../transform.js":"1BqUf","../../dom.js":"84QzQ","../../obj.js":"3ssAG","../../geom/flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5JJby":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/Executor
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _textBuilderJs = require("./TextBuilder.js");
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _canvasJs = require("../canvas.js");
var _textpathJs = require("../../geom/flat/textpath.js");
var _arrayJs = require("../../array.js");
var _lengthJs = require("../../geom/flat/length.js");
var _transformJs1 = require("../../geom/flat/transform.js");
/**
 * @typedef {Object} BBox
 * @property {number} minX Minimal x.
 * @property {number} minY Minimal y.
 * @property {number} maxX Maximal x.
 * @property {number} maxY Maximal y
 * @property {*} value Value.
 */ /**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX DrawImageX.
 * @property {number} drawImageY DrawImageY.
 * @property {number} drawImageW DrawImageW.
 * @property {number} drawImageH DrawImageH.
 * @property {number} originX OriginX.
 * @property {number} originY OriginY.
 * @property {Array<number>} scale Scale.
 * @property {BBox} declutterBox DeclutterBox.
 * @property {import("../../transform.js").Transform} canvasTransform CanvasTransform.
 */ /**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */ /**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */ /**
 * @type {import("../../extent.js").Extent}
 */ const tmpExtent = (0, _extentJs.createEmpty)();
/** @type {import("../../coordinate.js").Coordinate} */ const p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */ const p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */ const p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */ const p4 = [];
/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */ function getDeclutterBox(replayImageOrLabelArgs) {
    return replayImageOrLabelArgs[3].declutterBox;
}
const rtlRegEx = new RegExp(/* eslint-disable prettier/prettier */ '[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']');
/**
 * @param {string} text Text.
 * @param {CanvasTextAlign} align Alignment.
 * @return {number} Text alignment.
 */ function horizontalTextAlign(text, align) {
    if (align === 'start') align = rtlRegEx.test(text) ? 'right' : 'left';
    else if (align === 'end') align = rtlRegEx.test(text) ? 'left' : 'right';
    return (0, _textBuilderJs.TEXT_ALIGN)[align];
}
/**
 * @param {Array<string>} acc Accumulator.
 * @param {string} line Line of text.
 * @param {number} i Index
 * @return {Array<string>} Accumulator.
 */ function createTextChunks(acc, line, i) {
    if (i > 0) acc.push('\n', '');
    acc.push(line, '');
    return acc;
}
class Executor {
    /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   */ constructor(resolution, pixelRatio, overlaps, instructions){
        /**
     * @protected
     * @type {boolean}
     */ this.overlaps = overlaps;
        /**
     * @protected
     * @type {number}
     */ this.pixelRatio = pixelRatio;
        /**
     * @protected
     * @const
     * @type {number}
     */ this.resolution = resolution;
        /**
     * @private
     * @type {boolean}
     */ this.alignFill_;
        /**
     * @protected
     * @type {Array<*>}
     */ this.instructions = instructions.instructions;
        /**
     * @protected
     * @type {Array<number>}
     */ this.coordinates = instructions.coordinates;
        /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */ this.coordinateCache_ = {};
        /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */ this.renderedTransform_ = (0, _transformJs.create)();
        /**
     * @protected
     * @type {Array<*>}
     */ this.hitDetectionInstructions = instructions.hitDetectionInstructions;
        /**
     * @private
     * @type {Array<number>}
     */ this.pixelCoordinates_ = null;
        /**
     * @private
     * @type {number}
     */ this.viewRotation_ = 0;
        /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */ this.fillStates = instructions.fillStates || {};
        /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */ this.strokeStates = instructions.strokeStates || {};
        /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */ this.textStates = instructions.textStates || {};
        /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */ this.widths_ = {};
        /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */ this.labels_ = {};
    }
    /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */ createLabel(text, textKey, fillKey, strokeKey) {
        const key = text + textKey + fillKey + strokeKey;
        if (this.labels_[key]) return this.labels_[key];
        const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
        const fillState = fillKey ? this.fillStates[fillKey] : null;
        const textState = this.textStates[textKey];
        const pixelRatio = this.pixelRatio;
        const scale = [
            textState.scale[0] * pixelRatio,
            textState.scale[1] * pixelRatio
        ];
        const textIsArray = Array.isArray(text);
        const align = textState.justify ? (0, _textBuilderJs.TEXT_ALIGN)[textState.justify] : horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || (0, _canvasJs.defaultTextAlign));
        const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const chunks = textIsArray ? text : text.split('\n').reduce(createTextChunks, []);
        const { width, height, widths, heights, lineWidths } = (0, _canvasJs.getTextDimensions)(textState, chunks);
        const renderWidth = width + strokeWidth;
        const contextInstructions = [];
        // make canvas 2 pixels wider to account for italic text width measurement errors
        const w = (renderWidth + 2) * scale[0];
        const h = (height + strokeWidth) * scale[1];
        /** @type {import("../canvas.js").Label} */ const label = {
            width: w < 0 ? Math.floor(w) : Math.ceil(w),
            height: h < 0 ? Math.floor(h) : Math.ceil(h),
            contextInstructions: contextInstructions
        };
        if (scale[0] != 1 || scale[1] != 1) contextInstructions.push('scale', scale);
        if (strokeKey) {
            contextInstructions.push('strokeStyle', strokeState.strokeStyle);
            contextInstructions.push('lineWidth', strokeWidth);
            contextInstructions.push('lineCap', strokeState.lineCap);
            contextInstructions.push('lineJoin', strokeState.lineJoin);
            contextInstructions.push('miterLimit', strokeState.miterLimit);
            contextInstructions.push('setLineDash', [
                strokeState.lineDash
            ]);
            contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
        }
        if (fillKey) contextInstructions.push('fillStyle', fillState.fillStyle);
        contextInstructions.push('textBaseline', 'middle');
        contextInstructions.push('textAlign', 'center');
        const leftRight = 0.5 - align;
        let x = align * renderWidth + leftRight * strokeWidth;
        const strokeInstructions = [];
        const fillInstructions = [];
        let lineHeight = 0;
        let lineOffset = 0;
        let widthHeightIndex = 0;
        let lineWidthIndex = 0;
        let previousFont;
        for(let i = 0, ii = chunks.length; i < ii; i += 2){
            const text = chunks[i];
            if (text === '\n') {
                lineOffset += lineHeight;
                lineHeight = 0;
                x = align * renderWidth + leftRight * strokeWidth;
                ++lineWidthIndex;
                continue;
            }
            const font = chunks[i + 1] || textState.font;
            if (font !== previousFont) {
                if (strokeKey) strokeInstructions.push('font', font);
                if (fillKey) fillInstructions.push('font', font);
                previousFont = font;
            }
            lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
            const fillStrokeArgs = [
                text,
                x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
                0.5 * (strokeWidth + lineHeight) + lineOffset
            ];
            x += widths[widthHeightIndex];
            if (strokeKey) strokeInstructions.push('strokeText', fillStrokeArgs);
            if (fillKey) fillInstructions.push('fillText', fillStrokeArgs);
            ++widthHeightIndex;
        }
        Array.prototype.push.apply(contextInstructions, strokeInstructions);
        Array.prototype.push.apply(contextInstructions, fillInstructions);
        this.labels_[key] = label;
        return label;
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */ replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
        context.beginPath();
        context.moveTo.apply(context, p1);
        context.lineTo.apply(context, p2);
        context.lineTo.apply(context, p3);
        context.lineTo.apply(context, p4);
        context.lineTo.apply(context, p1);
        if (fillInstruction) {
            this.alignFill_ = /** @type {boolean} */ fillInstruction[2];
            this.fill_(context);
        }
        if (strokeInstruction) {
            this.setStrokeStyle_(context, /** @type {Array<*>} */ strokeInstruction);
            context.stroke();
        }
    }
    /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */ calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
        anchorX *= scale[0];
        anchorY *= scale[1];
        let x = centerX - anchorX;
        let y = centerY - anchorY;
        const w = width + originX > sheetWidth ? sheetWidth - originX : width;
        const h = height + originY > sheetHeight ? sheetHeight - originY : height;
        const boxW = padding[3] + w * scale[0] + padding[1];
        const boxH = padding[0] + h * scale[1] + padding[2];
        const boxX = x - padding[3];
        const boxY = y - padding[0];
        if (fillStroke || rotation !== 0) {
            p1[0] = boxX;
            p4[0] = boxX;
            p1[1] = boxY;
            p2[1] = boxY;
            p2[0] = boxX + boxW;
            p3[0] = p2[0];
            p3[1] = boxY + boxH;
            p4[1] = p3[1];
        }
        let transform;
        if (rotation !== 0) {
            transform = (0, _transformJs.compose)((0, _transformJs.create)(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
            (0, _transformJs.apply)(transform, p1);
            (0, _transformJs.apply)(transform, p2);
            (0, _transformJs.apply)(transform, p3);
            (0, _transformJs.apply)(transform, p4);
            (0, _extentJs.createOrUpdate)(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
        } else (0, _extentJs.createOrUpdate)(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
        if (snapToPixel) {
            x = Math.round(x);
            y = Math.round(y);
        }
        return {
            drawImageX: x,
            drawImageY: y,
            drawImageW: w,
            drawImageH: h,
            originX: originX,
            originY: originY,
            declutterBox: {
                minX: tmpExtent[0],
                minY: tmpExtent[1],
                maxX: tmpExtent[2],
                maxY: tmpExtent[3],
                value: feature
            },
            canvasTransform: transform,
            scale: scale
        };
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */ replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
        const fillStroke = !!(fillInstruction || strokeInstruction);
        const box = dimensions.declutterBox;
        const canvas = context.canvas;
        const strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
        const intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
        if (intersects) {
            if (fillStroke) this.replayTextBackground_(context, p1, p2, p3, p4, /** @type {Array<*>} */ fillInstruction, /** @type {Array<*>} */ strokeInstruction);
            (0, _canvasJs.drawImageOrLabel)(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
        }
        return true;
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */ fill_(context) {
        if (this.alignFill_) {
            const origin = (0, _transformJs.apply)(this.renderedTransform_, [
                0,
                0
            ]);
            const repeatSize = 512 * this.pixelRatio;
            context.save();
            context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
            context.rotate(this.viewRotation_);
        }
        context.fill();
        if (this.alignFill_) context.restore();
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */ setStrokeStyle_(context, instruction) {
        context['strokeStyle'] = /** @type {import("../../colorlike.js").ColorLike} */ instruction[1];
        context.lineWidth = /** @type {number} */ instruction[2];
        context.lineCap = /** @type {CanvasLineCap} */ instruction[3];
        context.lineJoin = /** @type {CanvasLineJoin} */ instruction[4];
        context.miterLimit = /** @type {number} */ instruction[5];
        context.lineDashOffset = /** @type {number} */ instruction[7];
        context.setLineDash(/** @type {Array<number>} */ instruction[6]);
    }
    /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */ drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
        const textState = this.textStates[textKey];
        const label = this.createLabel(text, textKey, fillKey, strokeKey);
        const strokeState = this.strokeStates[strokeKey];
        const pixelRatio = this.pixelRatio;
        const align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || (0, _canvasJs.defaultTextAlign));
        const baseline = (0, _textBuilderJs.TEXT_ALIGN)[textState.textBaseline || (0, _canvasJs.defaultTextBaseline)];
        const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
        // Remove the 2 pixels we added in createLabel() for the anchor
        const width = label.width / pixelRatio - 2 * textState.scale[0];
        const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
        const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
        return {
            label: label,
            anchorX: anchorX,
            anchorY: anchorY
        };
    }
    /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */ execute_(context, contextScale, transform, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
        /** @type {Array<number>} */ let pixelCoordinates;
        if (this.pixelCoordinates_ && (0, _arrayJs.equals)(transform, this.renderedTransform_)) pixelCoordinates = this.pixelCoordinates_;
        else {
            if (!this.pixelCoordinates_) this.pixelCoordinates_ = [];
            pixelCoordinates = (0, _transformJs1.transform2D)(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
            (0, _transformJs.setFromArray)(this.renderedTransform_, transform);
        }
        let i = 0; // instruction index
        const ii = instructions.length; // end of instructions
        let d = 0; // data index
        let dd; // end of per-instruction data
        let anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
        let pendingFill = 0;
        let pendingStroke = 0;
        let lastFillInstruction = null;
        let lastStrokeInstruction = null;
        const coordinateCache = this.coordinateCache_;
        const viewRotation = this.viewRotation_;
        const viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
        const state = /** @type {import("../../render.js").State} */ {
            context: context,
            pixelRatio: this.pixelRatio,
            resolution: this.resolution,
            rotation: viewRotation
        };
        // When the batch size gets too big, performance decreases. 200 is a good
        // balance between batch size and number of fill/stroke instructions.
        const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
        let /** @type {import("../../Feature.js").FeatureLike} */ feature;
        let x, y, currentGeometry;
        while(i < ii){
            const instruction = instructions[i];
            const type = /** @type {import("./Instruction.js").default} */ instruction[0];
            switch(type){
                case (0, _instructionJsDefault.default).BEGIN_GEOMETRY:
                    feature = /** @type {import("../../Feature.js").FeatureLike} */ instruction[1];
                    currentGeometry = instruction[3];
                    if (!feature.getGeometry()) i = /** @type {number} */ instruction[2];
                    else if (hitExtent !== undefined && !(0, _extentJs.intersects)(hitExtent, currentGeometry.getExtent())) i = /** @type {number} */ instruction[2] + 1;
                    else ++i;
                    break;
                case (0, _instructionJsDefault.default).BEGIN_PATH:
                    if (pendingFill > batchSize) {
                        this.fill_(context);
                        pendingFill = 0;
                    }
                    if (pendingStroke > batchSize) {
                        context.stroke();
                        pendingStroke = 0;
                    }
                    if (!pendingFill && !pendingStroke) {
                        context.beginPath();
                        prevX = NaN;
                        prevY = NaN;
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).CIRCLE:
                    d = /** @type {number} */ instruction[1];
                    const x1 = pixelCoordinates[d];
                    const y1 = pixelCoordinates[d + 1];
                    const x2 = pixelCoordinates[d + 2];
                    const y2 = pixelCoordinates[d + 3];
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    context.moveTo(x1 + r, y1);
                    context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).CLOSE_PATH:
                    context.closePath();
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).CUSTOM:
                    d = /** @type {number} */ instruction[1];
                    dd = instruction[2];
                    const geometry = /** @type {import("../../geom/SimpleGeometry.js").default} */ instruction[3];
                    const renderer = instruction[4];
                    const fn = instruction.length == 6 ? instruction[5] : undefined;
                    state.geometry = geometry;
                    state.feature = feature;
                    if (!(i in coordinateCache)) coordinateCache[i] = [];
                    const coords = coordinateCache[i];
                    if (fn) fn(pixelCoordinates, d, dd, 2, coords);
                    else {
                        coords[0] = pixelCoordinates[d];
                        coords[1] = pixelCoordinates[d + 1];
                        coords.length = 2;
                    }
                    renderer(coords, state);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).DRAW_IMAGE:
                    d = /** @type {number} */ instruction[1];
                    dd = /** @type {number} */ instruction[2];
                    image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ instruction[3];
                    // Remaining arguments in DRAW_IMAGE are in alphabetical order
                    anchorX = /** @type {number} */ instruction[4];
                    anchorY = /** @type {number} */ instruction[5];
                    let height = /** @type {number} */ instruction[6];
                    const opacity = /** @type {number} */ instruction[7];
                    const originX = /** @type {number} */ instruction[8];
                    const originY = /** @type {number} */ instruction[9];
                    const rotateWithView = /** @type {boolean} */ instruction[10];
                    let rotation = /** @type {number} */ instruction[11];
                    const scale = /** @type {import("../../size.js").Size} */ instruction[12];
                    let width = /** @type {number} */ instruction[13];
                    const declutterMode = /** @type {"declutter"|"obstacle"|"none"|undefined} */ instruction[14];
                    const declutterImageWithText = /** @type {import("../canvas.js").DeclutterImageWithText} */ instruction[15];
                    if (!image && instruction.length >= 20) {
                        // create label images
                        text = /** @type {string} */ instruction[19];
                        textKey = /** @type {string} */ instruction[20];
                        strokeKey = /** @type {string} */ instruction[21];
                        fillKey = /** @type {string} */ instruction[22];
                        const labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                        image = labelWithAnchor.label;
                        instruction[3] = image;
                        const textOffsetX = /** @type {number} */ instruction[23];
                        anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                        instruction[4] = anchorX;
                        const textOffsetY = /** @type {number} */ instruction[24];
                        anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                        instruction[5] = anchorY;
                        height = image.height;
                        instruction[6] = height;
                        width = image.width;
                        instruction[13] = width;
                    }
                    let geometryWidths;
                    if (instruction.length > 25) geometryWidths = /** @type {number} */ instruction[25];
                    let padding, backgroundFill, backgroundStroke;
                    if (instruction.length > 17) {
                        padding = /** @type {Array<number>} */ instruction[16];
                        backgroundFill = /** @type {boolean} */ instruction[17];
                        backgroundStroke = /** @type {boolean} */ instruction[18];
                    } else {
                        padding = (0, _canvasJs.defaultPadding);
                        backgroundFill = false;
                        backgroundStroke = false;
                    }
                    if (rotateWithView && viewRotationFromTransform) // Canvas is expected to be rotated to reverse view rotation.
                    rotation += viewRotation;
                    else if (!rotateWithView && !viewRotationFromTransform) // Canvas is not rotated, images need to be rotated back to be north-up.
                    rotation -= viewRotation;
                    let widthIndex = 0;
                    for(; d < dd; d += 2){
                        if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) continue;
                        const dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
                        /** @type {ReplayImageOrLabelArgs} */ const args = [
                            context,
                            contextScale,
                            image,
                            dimensions,
                            opacity,
                            backgroundFill ? /** @type {Array<*>} */ lastFillInstruction : null,
                            backgroundStroke ? /** @type {Array<*>} */ lastStrokeInstruction : null
                        ];
                        if (declutterTree) {
                            if (declutterMode === 'none') continue;
                            else if (declutterMode === 'obstacle') {
                                // will always be drawn, thus no collision detection, but insert as obstacle
                                declutterTree.insert(dimensions.declutterBox);
                                continue;
                            } else {
                                let imageArgs;
                                let imageDeclutterBox;
                                if (declutterImageWithText) {
                                    const index = dd - d;
                                    if (!declutterImageWithText[index]) {
                                        // We now have the image for an image+text combination.
                                        declutterImageWithText[index] = args;
                                        continue;
                                    }
                                    imageArgs = declutterImageWithText[index];
                                    delete declutterImageWithText[index];
                                    imageDeclutterBox = getDeclutterBox(imageArgs);
                                    if (declutterTree.collides(imageDeclutterBox)) continue;
                                }
                                if (declutterTree.collides(dimensions.declutterBox)) continue;
                                if (imageArgs) {
                                    // We now have image and text for an image+text combination.
                                    declutterTree.insert(imageDeclutterBox);
                                    // Render the image before we render the text.
                                    this.replayImageOrLabel_.apply(this, imageArgs);
                                }
                                declutterTree.insert(dimensions.declutterBox);
                            }
                        }
                        this.replayImageOrLabel_.apply(this, args);
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).DRAW_CHARS:
                    const begin = /** @type {number} */ instruction[1];
                    const end = /** @type {number} */ instruction[2];
                    const baseline = /** @type {number} */ instruction[3];
                    const overflow = /** @type {number} */ instruction[4];
                    fillKey = /** @type {string} */ instruction[5];
                    const maxAngle = /** @type {number} */ instruction[6];
                    const measurePixelRatio = /** @type {number} */ instruction[7];
                    const offsetY = /** @type {number} */ instruction[8];
                    strokeKey = /** @type {string} */ instruction[9];
                    const strokeWidth = /** @type {number} */ instruction[10];
                    text = /** @type {string} */ instruction[11];
                    textKey = /** @type {string} */ instruction[12];
                    const pixelRatioScale = [
                        /** @type {number} */ instruction[13],
                        /** @type {number} */ instruction[13]
                    ];
                    const textState = this.textStates[textKey];
                    const font = textState.font;
                    const textScale = [
                        textState.scale[0] * measurePixelRatio,
                        textState.scale[1] * measurePixelRatio
                    ];
                    let cachedWidths;
                    if (font in this.widths_) cachedWidths = this.widths_[font];
                    else {
                        cachedWidths = {};
                        this.widths_[font] = cachedWidths;
                    }
                    const pathLength = (0, _lengthJs.lineStringLength)(pixelCoordinates, begin, end, 2);
                    const textLength = Math.abs(textScale[0]) * (0, _canvasJs.measureAndCacheTextWidth)(font, text, cachedWidths);
                    if (overflow || textLength <= pathLength) {
                        const textAlign = this.textStates[textKey].textAlign;
                        const startM = (pathLength - textLength) * horizontalTextAlign(text, textAlign);
                        const parts = (0, _textpathJs.drawTextOnPath)(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), (0, _canvasJs.measureAndCacheTextWidth), font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                        drawChars: if (parts) {
                            /** @type {Array<ReplayImageOrLabelArgs>} */ const replayImageOrLabelArgs = [];
                            let c, cc, chars, label, part;
                            if (strokeKey) for(c = 0, cc = parts.length; c < cc; ++c){
                                part = parts[c]; // x, y, anchorX, rotation, chunk
                                chars = /** @type {string} */ part[4];
                                label = this.createLabel(chars, textKey, '', strokeKey);
                                anchorX = /** @type {number} */ part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                                const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, (0, _canvasJs.defaultPadding), false, feature);
                                if (declutterTree && declutterTree.collides(dimensions.declutterBox)) break drawChars;
                                replayImageOrLabelArgs.push([
                                    context,
                                    contextScale,
                                    label,
                                    dimensions,
                                    1,
                                    null,
                                    null
                                ]);
                            }
                            if (fillKey) for(c = 0, cc = parts.length; c < cc; ++c){
                                part = parts[c]; // x, y, anchorX, rotation, chunk
                                chars = /** @type {string} */ part[4];
                                label = this.createLabel(chars, textKey, fillKey, '');
                                anchorX = /** @type {number} */ part[2];
                                anchorY = baseline * label.height - offsetY;
                                const dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, (0, _canvasJs.defaultPadding), false, feature);
                                if (declutterTree && declutterTree.collides(dimensions.declutterBox)) break drawChars;
                                replayImageOrLabelArgs.push([
                                    context,
                                    contextScale,
                                    label,
                                    dimensions,
                                    1,
                                    null,
                                    null
                                ]);
                            }
                            if (declutterTree) declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                            for(let i = 0, ii = replayImageOrLabelArgs.length; i < ii; ++i)this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i]);
                        }
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).END_GEOMETRY:
                    if (featureCallback !== undefined) {
                        feature = /** @type {import("../../Feature.js").FeatureLike} */ instruction[1];
                        const result = featureCallback(feature, currentGeometry);
                        if (result) return result;
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).FILL:
                    if (batchSize) pendingFill++;
                    else this.fill_(context);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).MOVE_TO_LINE_TO:
                    d = /** @type {number} */ instruction[1];
                    dd = /** @type {number} */ instruction[2];
                    x = pixelCoordinates[d];
                    y = pixelCoordinates[d + 1];
                    roundX = x + 0.5 | 0;
                    roundY = y + 0.5 | 0;
                    if (roundX !== prevX || roundY !== prevY) {
                        context.moveTo(x, y);
                        prevX = roundX;
                        prevY = roundY;
                    }
                    for(d += 2; d < dd; d += 2){
                        x = pixelCoordinates[d];
                        y = pixelCoordinates[d + 1];
                        roundX = x + 0.5 | 0;
                        roundY = y + 0.5 | 0;
                        if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                            context.lineTo(x, y);
                            prevX = roundX;
                            prevY = roundY;
                        }
                    }
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).SET_FILL_STYLE:
                    lastFillInstruction = instruction;
                    this.alignFill_ = instruction[2];
                    if (pendingFill) {
                        this.fill_(context);
                        pendingFill = 0;
                        if (pendingStroke) {
                            context.stroke();
                            pendingStroke = 0;
                        }
                    }
                    context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ instruction[1];
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).SET_STROKE_STYLE:
                    lastStrokeInstruction = instruction;
                    if (pendingStroke) {
                        context.stroke();
                        pendingStroke = 0;
                    }
                    this.setStrokeStyle_(context, /** @type {Array<*>} */ instruction);
                    ++i;
                    break;
                case (0, _instructionJsDefault.default).STROKE:
                    if (batchSize) pendingStroke++;
                    else context.stroke();
                    ++i;
                    break;
                default:
                    ++i;
                    break;
            }
        }
        if (pendingFill) this.fill_(context);
        if (pendingStroke) context.stroke();
        return undefined;
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */ execute(context, contextScale, transform, viewRotation, snapToPixel, declutterTree) {
        this.viewRotation_ = viewRotation;
        this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, declutterTree);
    }
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */ executeHitDetection(context, transform, viewRotation, featureCallback, hitExtent) {
        this.viewRotation_ = viewRotation;
        return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, featureCallback, hitExtent);
    }
}
exports.default = Executor;

},{"./Instruction.js":"9nhw8","./TextBuilder.js":"6mvke","../../transform.js":"1BqUf","../../extent.js":"6YrVc","../canvas.js":"e85iQ","../../geom/flat/textpath.js":"hYFQq","../../array.js":"1Fbic","../../geom/flat/length.js":"X5sUU","../../geom/flat/transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hYFQq":[function(require,module,exports,__globalThis) {
/**
 * @module ol/geom/flat/textpath
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>|null} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */ parcelHelpers.export(exports, "drawTextOnPath", ()=>drawTextOnPath);
var _mathJs = require("../../math.js");
var _transformJs = require("./transform.js");
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
    let x2 = flatCoordinates[offset];
    let y2 = flatCoordinates[offset + 1];
    let x1 = 0;
    let y1 = 0;
    let segmentLength = 0;
    let segmentM = 0;
    function advance() {
        x1 = x2;
        y1 = y2;
        offset += stride;
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        segmentM += segmentLength;
        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    do advance();
    while (offset < end - stride && segmentM + segmentLength < startM);
    let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
    const beginX = (0, _mathJs.lerp)(x1, x2, interpolate);
    const beginY = (0, _mathJs.lerp)(y1, y2, interpolate);
    const startOffset = offset - stride;
    const startLength = segmentM;
    const endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
    while(offset < end - stride && segmentM + segmentLength < endM)advance();
    interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
    const endX = (0, _mathJs.lerp)(x1, x2, interpolate);
    const endY = (0, _mathJs.lerp)(y1, y2, interpolate);
    // Keep text upright
    let reverse;
    if (rotation) {
        const flat = [
            beginX,
            beginY,
            endX,
            endY
        ];
        (0, _transformJs.rotate)(flat, 0, 4, 2, rotation, flat, flat);
        reverse = flat[0] > flat[2];
    } else reverse = beginX > endX;
    const PI = Math.PI;
    const result = [];
    const singleSegment = startOffset + stride === offset;
    offset = startOffset;
    segmentLength = 0;
    segmentM = startLength;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    let previousAngle;
    // All on the same segment
    if (singleSegment) {
        advance();
        previousAngle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) previousAngle += previousAngle > 0 ? -PI : PI;
        const x = (endX + beginX) / 2;
        const y = (endY + beginY) / 2;
        result[0] = [
            x,
            y,
            (endM - startM) / 2,
            previousAngle,
            text
        ];
        return result;
    }
    // rendering across line segments
    text = text.replace(/\n/g, ' '); // ensure rendering in single-line as all calculations below don't handle multi-lines
    for(let i = 0, ii = text.length; i < ii;){
        advance();
        let angle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) angle += angle > 0 ? -PI : PI;
        if (previousAngle !== undefined) {
            let delta = angle - previousAngle;
            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
            if (Math.abs(delta) > maxAngle) return null;
        }
        previousAngle = angle;
        const iStart = i;
        let charLength = 0;
        for(; i < ii; ++i){
            const index = reverse ? ii - i - 1 : i;
            const len = scale * measureAndCacheTextWidth(font, text[index], cache);
            if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) break;
            charLength += len;
        }
        if (i === iStart) continue;
        const chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
        interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
        const x = (0, _mathJs.lerp)(x1, x2, interpolate);
        const y = (0, _mathJs.lerp)(y1, y2, interpolate);
        result.push([
            x,
            y,
            charLength / 2,
            angle,
            chars
        ]);
        startM += charLength;
    }
    return result;
}

},{"../../math.js":"5jEFr","./transform.js":"cDA2L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hriIE":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/hitdetect
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HIT_DETECT_RESOLUTION", ()=>HIT_DETECT_RESOLUTION);
/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */ parcelHelpers.export(exports, "createHitDetectionImageData", ()=>createHitDetectionImageData);
/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<F>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<F>} Features.
 * @template {import("../../Feature.js").FeatureLike} F
 */ parcelHelpers.export(exports, "hitDetect", ()=>hitDetect);
var _immediateJs = require("./Immediate.js");
var _immediateJsDefault = parcelHelpers.interopDefault(_immediateJs);
var _styleJs = require("../../style.js");
var _arrayJs = require("../../array.js");
var _mathJs = require("../../math.js");
var _domJs = require("../../dom.js");
var _extentJs = require("../../extent.js");
const HIT_DETECT_RESOLUTION = 0.5;
function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
    const width = size[0] * HIT_DETECT_RESOLUTION;
    const height = size[1] * HIT_DETECT_RESOLUTION;
    const context = (0, _domJs.createCanvasContext2D)(width, height);
    context.imageSmoothingEnabled = false;
    const canvas = context.canvas;
    const renderer = new (0, _immediateJsDefault.default)(context, HIT_DETECT_RESOLUTION, extent, null, rotation);
    const featureCount = features.length;
    // Stretch hit detection index to use the whole available color range
    const indexFactor = Math.floor(16777215 / featureCount);
    const featuresByZIndex = {};
    for(let i = 1; i <= featureCount; ++i){
        const feature = features[i - 1];
        const featureStyleFunction = feature.getStyleFunction() || styleFunction;
        if (!featureStyleFunction) continue;
        let styles = featureStyleFunction(feature, resolution);
        if (!styles) continue;
        if (!Array.isArray(styles)) styles = [
            styles
        ];
        const index = i * indexFactor;
        const color = index.toString(16).padStart(7, '#00000');
        for(let j = 0, jj = styles.length; j < jj; ++j){
            const originalStyle = styles[j];
            const geometry = originalStyle.getGeometryFunction()(feature);
            if (!geometry || !(0, _extentJs.intersects)(extent, geometry.getExtent())) continue;
            const style = originalStyle.clone();
            const fill = style.getFill();
            if (fill) fill.setColor(color);
            const stroke = style.getStroke();
            if (stroke) {
                stroke.setColor(color);
                stroke.setLineDash(null);
            }
            style.setText(undefined);
            const image = originalStyle.getImage();
            if (image) {
                const imgSize = image.getImageSize();
                if (!imgSize) continue;
                const imgContext = (0, _domJs.createCanvasContext2D)(imgSize[0], imgSize[1], undefined, {
                    alpha: false
                });
                const img = imgContext.canvas;
                imgContext.fillStyle = color;
                imgContext.fillRect(0, 0, img.width, img.height);
                style.setImage(new (0, _styleJs.Icon)({
                    img: img,
                    anchor: image.getAnchor(),
                    anchorXUnits: 'pixels',
                    anchorYUnits: 'pixels',
                    offset: image.getOrigin(),
                    opacity: 1,
                    size: image.getSize(),
                    scale: image.getScale(),
                    rotation: image.getRotation(),
                    rotateWithView: image.getRotateWithView()
                }));
            }
            const zIndex = style.getZIndex() || 0;
            let byGeometryType = featuresByZIndex[zIndex];
            if (!byGeometryType) {
                byGeometryType = {};
                featuresByZIndex[zIndex] = byGeometryType;
                byGeometryType['Polygon'] = [];
                byGeometryType['Circle'] = [];
                byGeometryType['LineString'] = [];
                byGeometryType['Point'] = [];
            }
            const type = geometry.getType();
            if (type === 'GeometryCollection') {
                const geometries = /** @type {import("../../geom/GeometryCollection.js").default} */ geometry.getGeometriesArrayRecursive();
                for(let i = 0, ii = geometries.length; i < ii; ++i){
                    const geometry = geometries[i];
                    byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
                }
            } else byGeometryType[type.replace('Multi', '')].push(geometry, style);
        }
    }
    const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort((0, _arrayJs.ascending));
    for(let i = 0, ii = zIndexKeys.length; i < ii; ++i){
        const byGeometryType = featuresByZIndex[zIndexKeys[i]];
        for(const type in byGeometryType){
            const geomAndStyle = byGeometryType[type];
            for(let j = 0, jj = geomAndStyle.length; j < jj; j += 2){
                renderer.setStyle(geomAndStyle[j + 1]);
                for(let k = 0, kk = transforms.length; k < kk; ++k){
                    renderer.setTransform(transforms[k]);
                    renderer.drawGeometry(geomAndStyle[j]);
                }
            }
        }
    }
    return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
    /** @type {Array<F>} */ const resultFeatures = [];
    if (imageData) {
        const x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
        const y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
        // The pixel coordinate is clamped down to the hit-detect canvas' size to account
        // for browsers returning coordinates slightly larger than the actual canvas size
        // due to a non-integer pixel ratio.
        const index = ((0, _mathJs.clamp)(x, 0, imageData.width - 1) + (0, _mathJs.clamp)(y, 0, imageData.height - 1) * imageData.width) * 4;
        const r = imageData.data[index];
        const g = imageData.data[index + 1];
        const b = imageData.data[index + 2];
        const i = b + 256 * (g + 256 * r);
        const indexFactor = Math.floor(16777215 / features.length);
        if (i && i % indexFactor === 0) resultFeatures.push(features[i / indexFactor - 1]);
    }
    return resultFeatures;
}

},{"./Immediate.js":"j3fUk","../../style.js":"hEQxF","../../array.js":"1Fbic","../../math.js":"5jEFr","../../dom.js":"84QzQ","../../extent.js":"6YrVc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j3fUk":[function(require,module,exports,__globalThis) {
/**
 * @module ol/render/canvas/Immediate
 */ // FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _vectorContextJs = require("../VectorContext.js");
var _vectorContextJsDefault = parcelHelpers.interopDefault(_vectorContextJs);
var _colorlikeJs = require("../../colorlike.js");
var _transformJs = require("../../transform.js");
var _canvasJs = require("../canvas.js");
var _arrayJs = require("../../array.js");
var _extentJs = require("../../extent.js");
var _mathJs = require("../../math.js");
var _transformJs1 = require("../../geom/flat/transform.js");
var _simpleGeometryJs = require("../../geom/SimpleGeometry.js");
/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext~VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */ class CanvasImmediateRenderer extends (0, _vectorContextJsDefault.default) {
    /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */ constructor(context, pixelRatio, extent, transform, viewRotation, squaredTolerance, userTransform){
        super();
        /**
     * @private
     * @type {CanvasRenderingContext2D}
     */ this.context_ = context;
        /**
     * @private
     * @type {number}
     */ this.pixelRatio_ = pixelRatio;
        /**
     * @private
     * @type {import("../../extent.js").Extent}
     */ this.extent_ = extent;
        /**
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.transform_ = transform;
        /**
     * @private
     * @type {number}
     */ this.transformRotation_ = transform ? (0, _mathJs.toFixed)(Math.atan2(transform[1], transform[0]), 10) : 0;
        /**
     * @private
     * @type {number}
     */ this.viewRotation_ = viewRotation;
        /**
     * @private
     * @type {number}
     */ this.squaredTolerance_ = squaredTolerance;
        /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */ this.userTransform_ = userTransform;
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.contextFillState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.contextStrokeState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */ this.contextTextState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.fillState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.strokeState_ = null;
        /**
     * @private
     * @type {import('../../DataTile.js').ImageLike}
     */ this.image_ = null;
        /**
     * @private
     * @type {number}
     */ this.imageAnchorX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageAnchorY_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageHeight_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageOpacity_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageOriginX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.imageOriginY_ = 0;
        /**
     * @private
     * @type {boolean}
     */ this.imageRotateWithView_ = false;
        /**
     * @private
     * @type {number}
     */ this.imageRotation_ = 0;
        /**
     * @private
     * @type {import("../../size.js").Size}
     */ this.imageScale_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {number}
     */ this.imageWidth_ = 0;
        /**
     * @private
     * @type {string}
     */ this.text_ = '';
        /**
     * @private
     * @type {number}
     */ this.textOffsetX_ = 0;
        /**
     * @private
     * @type {number}
     */ this.textOffsetY_ = 0;
        /**
     * @private
     * @type {boolean}
     */ this.textRotateWithView_ = false;
        /**
     * @private
     * @type {number}
     */ this.textRotation_ = 0;
        /**
     * @private
     * @type {import("../../size.js").Size}
     */ this.textScale_ = [
            0,
            0
        ];
        /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */ this.textFillState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */ this.textStrokeState_ = null;
        /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */ this.textState_ = null;
        /**
     * @private
     * @type {Array<number>}
     */ this.pixelCoordinates_ = [];
        /**
     * @private
     * @type {import("../../transform.js").Transform}
     */ this.tmpLocalTransform_ = (0, _transformJs.create)();
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */ drawImages_(flatCoordinates, offset, end, stride) {
        if (!this.image_) return;
        const pixelCoordinates = (0, _transformJs1.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        const context = this.context_;
        const localTransform = this.tmpLocalTransform_;
        const alpha = context.globalAlpha;
        if (this.imageOpacity_ != 1) context.globalAlpha = alpha * this.imageOpacity_;
        let rotation = this.imageRotation_;
        if (this.transformRotation_ === 0) rotation -= this.viewRotation_;
        if (this.imageRotateWithView_) rotation += this.viewRotation_;
        for(let i = 0, ii = pixelCoordinates.length; i < ii; i += 2){
            const x = pixelCoordinates[i] - this.imageAnchorX_;
            const y = pixelCoordinates[i + 1] - this.imageAnchorY_;
            if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
                const centerX = x + this.imageAnchorX_;
                const centerY = y + this.imageAnchorY_;
                (0, _transformJs.compose)(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                context.save();
                context.transform.apply(context, localTransform);
                context.translate(centerX, centerY);
                context.scale(this.imageScale_[0], this.imageScale_[1]);
                context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                context.restore();
            } else context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
        }
        if (this.imageOpacity_ != 1) context.globalAlpha = alpha;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */ drawText_(flatCoordinates, offset, end, stride) {
        if (!this.textState_ || this.text_ === '') return;
        if (this.textFillState_) this.setContextFillState_(this.textFillState_);
        if (this.textStrokeState_) this.setContextStrokeState_(this.textStrokeState_);
        this.setContextTextState_(this.textState_);
        const pixelCoordinates = (0, _transformJs1.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        const context = this.context_;
        let rotation = this.textRotation_;
        if (this.transformRotation_ === 0) rotation -= this.viewRotation_;
        if (this.textRotateWithView_) rotation += this.viewRotation_;
        for(; offset < end; offset += stride){
            const x = pixelCoordinates[offset] + this.textOffsetX_;
            const y = pixelCoordinates[offset + 1] + this.textOffsetY_;
            if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
                context.save();
                context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
                context.rotate(rotation);
                context.translate(this.textOffsetX_, this.textOffsetY_);
                context.scale(this.textScale_[0], this.textScale_[1]);
                if (this.textStrokeState_) context.strokeText(this.text_, 0, 0);
                if (this.textFillState_) context.fillText(this.text_, 0, 0);
                context.restore();
            } else {
                if (this.textStrokeState_) context.strokeText(this.text_, x, y);
                if (this.textFillState_) context.fillText(this.text_, x, y);
            }
        }
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */ moveToLineTo_(flatCoordinates, offset, end, stride, close) {
        const context = this.context_;
        const pixelCoordinates = (0, _transformJs1.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
        let length = pixelCoordinates.length;
        if (close) length -= 2;
        for(let i = 2; i < length; i += 2)context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
        if (close) context.closePath();
        return end;
    }
    /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */ drawRings_(flatCoordinates, offset, ends, stride) {
        for(let i = 0, ii = ends.length; i < ii; ++i)offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
        return offset;
    }
    /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */ drawCircle(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/Circle.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.fillState_ || this.strokeState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            const pixelCoordinates = (0, _simpleGeometryJs.transformGeom2D)(geometry, this.transform_, this.pixelCoordinates_);
            const dx = pixelCoordinates[2] - pixelCoordinates[0];
            const dy = pixelCoordinates[3] - pixelCoordinates[1];
            const radius = Math.sqrt(dx * dx + dy * dy);
            const context = this.context_;
            context.beginPath();
            context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== '') this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
    /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */ setStyle(style) {
        this.setFillStrokeStyle(style.getFill(), style.getStroke());
        this.setImageStyle(style.getImage());
        this.setTextStyle(style.getText());
    }
    /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */ setTransform(transform) {
        this.transform_ = transform;
    }
    /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */ drawGeometry(geometry) {
        const type = geometry.getType();
        switch(type){
            case 'Point':
                this.drawPoint(/** @type {import("../../geom/Point.js").default} */ geometry);
                break;
            case 'LineString':
                this.drawLineString(/** @type {import("../../geom/LineString.js").default} */ geometry);
                break;
            case 'Polygon':
                this.drawPolygon(/** @type {import("../../geom/Polygon.js").default} */ geometry);
                break;
            case 'MultiPoint':
                this.drawMultiPoint(/** @type {import("../../geom/MultiPoint.js").default} */ geometry);
                break;
            case 'MultiLineString':
                this.drawMultiLineString(/** @type {import("../../geom/MultiLineString.js").default} */ geometry);
                break;
            case 'MultiPolygon':
                this.drawMultiPolygon(/** @type {import("../../geom/MultiPolygon.js").default} */ geometry);
                break;
            case 'GeometryCollection':
                this.drawGeometryCollection(/** @type {import("../../geom/GeometryCollection.js").default} */ geometry);
                break;
            case 'Circle':
                this.drawCircle(/** @type {import("../../geom/Circle.js").default} */ geometry);
                break;
            default:
        }
    }
    /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */ drawFeature(feature, style) {
        const geometry = style.getGeometryFunction()(feature);
        if (!geometry) return;
        this.setStyle(style);
        this.drawGeometry(geometry);
    }
    /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */ drawGeometryCollection(geometry) {
        const geometries = geometry.getGeometriesArray();
        for(let i = 0, ii = geometries.length; i < ii; ++i)this.drawGeometry(geometries[i]);
    }
    /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */ drawPoint(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/Point.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        if (this.text_ !== '') this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */ drawMultiPoint(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/MultiPoint.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        if (this.text_ !== '') this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
    /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */ drawLineString(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/LineString.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            const flatCoordinates = geometry.getFlatCoordinates();
            context.beginPath();
            this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
            context.stroke();
        }
        if (this.text_ !== '') {
            const flatMidpoint = geometry.getFlatMidpoint();
            this.drawText_(flatMidpoint, 0, 2, 2);
        }
    }
    /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */ drawMultiLineString(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        const geometryExtent = geometry.getExtent();
        if (!(0, _extentJs.intersects)(this.extent_, geometryExtent)) return;
        if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            const flatCoordinates = geometry.getFlatCoordinates();
            let offset = 0;
            const ends = /** @type {Array<number>} */ geometry.getEnds();
            const stride = geometry.getStride();
            context.beginPath();
            for(let i = 0, ii = ends.length; i < ii; ++i)offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
            context.stroke();
        }
        if (this.text_ !== '') {
            const flatMidpoints = geometry.getFlatMidpoints();
            this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
        }
    }
    /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */ drawPolygon(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/Polygon.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_ || this.fillState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            context.beginPath();
            this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, /** @type {Array<number>} */ geometry.getEnds(), geometry.getStride());
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== '') {
            const flatInteriorPoint = geometry.getFlatInteriorPoint();
            this.drawText_(flatInteriorPoint, 0, 2, 2);
        }
    }
    /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */ drawMultiPolygon(geometry) {
        if (this.squaredTolerance_) geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!(0, _extentJs.intersects)(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_ || this.fillState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            const context = this.context_;
            const flatCoordinates = geometry.getOrientedFlatCoordinates();
            let offset = 0;
            const endss = geometry.getEndss();
            const stride = geometry.getStride();
            context.beginPath();
            for(let i = 0, ii = endss.length; i < ii; ++i){
                const ends = endss[i];
                offset = this.drawRings_(flatCoordinates, offset, ends, stride);
            }
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== '') {
            const flatInteriorPoints = geometry.getFlatInteriorPoints();
            this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
        }
    }
    /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */ setContextFillState_(fillState) {
        const context = this.context_;
        const contextFillState = this.contextFillState_;
        if (!contextFillState) {
            context.fillStyle = fillState.fillStyle;
            this.contextFillState_ = {
                fillStyle: fillState.fillStyle
            };
        } else if (contextFillState.fillStyle != fillState.fillStyle) {
            contextFillState.fillStyle = fillState.fillStyle;
            context.fillStyle = fillState.fillStyle;
        }
    }
    /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */ setContextStrokeState_(strokeState) {
        const context = this.context_;
        const contextStrokeState = this.contextStrokeState_;
        if (!contextStrokeState) {
            context.lineCap = strokeState.lineCap;
            context.setLineDash(strokeState.lineDash);
            context.lineDashOffset = strokeState.lineDashOffset;
            context.lineJoin = strokeState.lineJoin;
            context.lineWidth = strokeState.lineWidth;
            context.miterLimit = strokeState.miterLimit;
            context.strokeStyle = strokeState.strokeStyle;
            this.contextStrokeState_ = {
                lineCap: strokeState.lineCap,
                lineDash: strokeState.lineDash,
                lineDashOffset: strokeState.lineDashOffset,
                lineJoin: strokeState.lineJoin,
                lineWidth: strokeState.lineWidth,
                miterLimit: strokeState.miterLimit,
                strokeStyle: strokeState.strokeStyle
            };
        } else {
            if (contextStrokeState.lineCap != strokeState.lineCap) {
                contextStrokeState.lineCap = strokeState.lineCap;
                context.lineCap = strokeState.lineCap;
            }
            if (!(0, _arrayJs.equals)(contextStrokeState.lineDash, strokeState.lineDash)) context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
            if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                context.lineDashOffset = strokeState.lineDashOffset;
            }
            if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                contextStrokeState.lineJoin = strokeState.lineJoin;
                context.lineJoin = strokeState.lineJoin;
            }
            if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                contextStrokeState.lineWidth = strokeState.lineWidth;
                context.lineWidth = strokeState.lineWidth;
            }
            if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                contextStrokeState.miterLimit = strokeState.miterLimit;
                context.miterLimit = strokeState.miterLimit;
            }
            if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                contextStrokeState.strokeStyle = strokeState.strokeStyle;
                context.strokeStyle = strokeState.strokeStyle;
            }
        }
    }
    /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */ setContextTextState_(textState) {
        const context = this.context_;
        const contextTextState = this.contextTextState_;
        const textAlign = textState.textAlign ? textState.textAlign : (0, _canvasJs.defaultTextAlign);
        if (!contextTextState) {
            context.font = textState.font;
            context.textAlign = textAlign;
            context.textBaseline = textState.textBaseline;
            this.contextTextState_ = {
                font: textState.font,
                textAlign: textAlign,
                textBaseline: textState.textBaseline
            };
        } else {
            if (contextTextState.font != textState.font) {
                contextTextState.font = textState.font;
                context.font = textState.font;
            }
            if (contextTextState.textAlign != textAlign) {
                contextTextState.textAlign = textAlign;
                context.textAlign = textAlign;
            }
            if (contextTextState.textBaseline != textState.textBaseline) {
                contextTextState.textBaseline = textState.textBaseline;
                context.textBaseline = textState.textBaseline;
            }
        }
    }
    /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */ setFillStrokeStyle(fillStyle, strokeStyle) {
        if (!fillStyle) this.fillState_ = null;
        else {
            const fillStyleColor = fillStyle.getColor();
            this.fillState_ = {
                fillStyle: (0, _colorlikeJs.asColorLike)(fillStyleColor ? fillStyleColor : (0, _canvasJs.defaultFillStyle))
            };
        }
        if (!strokeStyle) this.strokeState_ = null;
        else {
            const strokeStyleColor = strokeStyle.getColor();
            const strokeStyleLineCap = strokeStyle.getLineCap();
            const strokeStyleLineDash = strokeStyle.getLineDash();
            const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
            const strokeStyleLineJoin = strokeStyle.getLineJoin();
            const strokeStyleWidth = strokeStyle.getWidth();
            const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            const lineDash = strokeStyleLineDash ? strokeStyleLineDash : (0, _canvasJs.defaultLineDash);
            this.strokeState_ = {
                lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : (0, _canvasJs.defaultLineCap),
                lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n)=>n * this.pixelRatio_),
                lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : (0, _canvasJs.defaultLineDashOffset)) * this.pixelRatio_,
                lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : (0, _canvasJs.defaultLineJoin),
                lineWidth: (strokeStyleWidth !== undefined ? strokeStyleWidth : (0, _canvasJs.defaultLineWidth)) * this.pixelRatio_,
                miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : (0, _canvasJs.defaultMiterLimit),
                strokeStyle: (0, _colorlikeJs.asColorLike)(strokeStyleColor ? strokeStyleColor : (0, _canvasJs.defaultStrokeStyle))
            };
        }
    }
    /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */ setImageStyle(imageStyle) {
        let imageSize;
        if (!imageStyle || !(imageSize = imageStyle.getSize())) {
            this.image_ = null;
            return;
        }
        const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
        const imageAnchor = imageStyle.getAnchor();
        const imageOrigin = imageStyle.getOrigin();
        this.image_ = imageStyle.getImage(this.pixelRatio_);
        this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
        this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
        this.imageHeight_ = imageSize[1] * imagePixelRatio;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        const imageScale = imageStyle.getScaleArray();
        this.imageScale_ = [
            imageScale[0] * this.pixelRatio_ / imagePixelRatio,
            imageScale[1] * this.pixelRatio_ / imagePixelRatio
        ];
        this.imageWidth_ = imageSize[0] * imagePixelRatio;
    }
    /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */ setTextStyle(textStyle) {
        if (!textStyle) this.text_ = '';
        else {
            const textFillStyle = textStyle.getFill();
            if (!textFillStyle) this.textFillState_ = null;
            else {
                const textFillStyleColor = textFillStyle.getColor();
                this.textFillState_ = {
                    fillStyle: (0, _colorlikeJs.asColorLike)(textFillStyleColor ? textFillStyleColor : (0, _canvasJs.defaultFillStyle))
                };
            }
            const textStrokeStyle = textStyle.getStroke();
            if (!textStrokeStyle) this.textStrokeState_ = null;
            else {
                const textStrokeStyleColor = textStrokeStyle.getColor();
                const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                const textStrokeStyleWidth = textStrokeStyle.getWidth();
                const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                this.textStrokeState_ = {
                    lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : (0, _canvasJs.defaultLineCap),
                    lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : (0, _canvasJs.defaultLineDash),
                    lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : (0, _canvasJs.defaultLineDashOffset),
                    lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : (0, _canvasJs.defaultLineJoin),
                    lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : (0, _canvasJs.defaultLineWidth),
                    miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : (0, _canvasJs.defaultMiterLimit),
                    strokeStyle: (0, _colorlikeJs.asColorLike)(textStrokeStyleColor ? textStrokeStyleColor : (0, _canvasJs.defaultStrokeStyle))
                };
            }
            const textFont = textStyle.getFont();
            const textOffsetX = textStyle.getOffsetX();
            const textOffsetY = textStyle.getOffsetY();
            const textRotateWithView = textStyle.getRotateWithView();
            const textRotation = textStyle.getRotation();
            const textScale = textStyle.getScaleArray();
            const textText = textStyle.getText();
            const textTextAlign = textStyle.getTextAlign();
            const textTextBaseline = textStyle.getTextBaseline();
            this.textState_ = {
                font: textFont !== undefined ? textFont : (0, _canvasJs.defaultFont),
                textAlign: textTextAlign !== undefined ? textTextAlign : (0, _canvasJs.defaultTextAlign),
                textBaseline: textTextBaseline !== undefined ? textTextBaseline : (0, _canvasJs.defaultTextBaseline)
            };
            this.text_ = textText !== undefined ? Array.isArray(textText) ? textText.reduce((acc, t, i)=>acc += i % 2 ? ' ' : t, '') : textText : '';
            this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
            this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
            this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
            this.textRotation_ = textRotation !== undefined ? textRotation : 0;
            this.textScale_ = [
                this.pixelRatio_ * textScale[0],
                this.pixelRatio_ * textScale[1]
            ];
        }
    }
}
exports.default = CanvasImmediateRenderer;

},{"../VectorContext.js":"ezpza","../../colorlike.js":"ftcFo","../../transform.js":"1BqUf","../canvas.js":"e85iQ","../../array.js":"1Fbic","../../extent.js":"6YrVc","../../math.js":"5jEFr","../../geom/flat/transform.js":"cDA2L","../../geom/SimpleGeometry.js":"hLwk3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hEQxF":[function(require,module,exports,__globalThis) {
/**
 * @module ol/style
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Circle", ()=>(0, _circleJsDefault.default));
parcelHelpers.export(exports, "Fill", ()=>(0, _fillJsDefault.default));
parcelHelpers.export(exports, "Icon", ()=>(0, _iconJsDefault.default));
parcelHelpers.export(exports, "IconImage", ()=>(0, _iconImageJsDefault.default));
parcelHelpers.export(exports, "Image", ()=>(0, _imageJsDefault.default));
parcelHelpers.export(exports, "RegularShape", ()=>(0, _regularShapeJsDefault.default));
parcelHelpers.export(exports, "Stroke", ()=>(0, _strokeJsDefault.default));
parcelHelpers.export(exports, "Style", ()=>(0, _styleJsDefault.default));
parcelHelpers.export(exports, "Text", ()=>(0, _textJsDefault.default));
var _circleJs = require("./style/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("./style/Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _iconJs = require("./style/Icon.js");
var _iconJsDefault = parcelHelpers.interopDefault(_iconJs);
var _iconImageJs = require("./style/IconImage.js");
var _iconImageJsDefault = parcelHelpers.interopDefault(_iconImageJs);
var _imageJs = require("./style/Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _regularShapeJs = require("./style/RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
var _strokeJs = require("./style/Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _styleJs = require("./style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _textJs = require("./style/Text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);

},{"./style/Circle.js":false,"./style/Fill.js":false,"./style/Icon.js":"dJiIs","./style/IconImage.js":false,"./style/Image.js":false,"./style/RegularShape.js":false,"./style/Stroke.js":false,"./style/Style.js":false,"./style/Text.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"liv8a":[function(require,module,exports,__globalThis) {
/**
 * @module ol/renderer/vector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */ parcelHelpers.export(exports, "defaultOrder", ()=>defaultOrder);
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */ parcelHelpers.export(exports, "getSquaredTolerance", ()=>getSquaredTolerance);
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */ parcelHelpers.export(exports, "getTolerance", ()=>getTolerance);
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */ parcelHelpers.export(exports, "renderFeature", ()=>renderFeature);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _utilJs = require("../util.js");
/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */ /**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */ const SIMPLIFY_TOLERANCE = 0.5;
/**
 * @const
 * @type {Object<import("../geom/Geometry.js").Type,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */ const GEOMETRY_RENDERERS = {
    'Point': renderPointGeometry,
    'LineString': renderLineStringGeometry,
    'Polygon': renderPolygonGeometry,
    'MultiPoint': renderMultiPointGeometry,
    'MultiLineString': renderMultiLineStringGeometry,
    'MultiPolygon': renderMultiPolygonGeometry,
    'GeometryCollection': renderGeometryCollectionGeometry,
    'Circle': renderCircleGeometry
};
function defaultOrder(feature1, feature2) {
    return parseInt((0, _utilJs.getUid)(feature1), 10) - parseInt((0, _utilJs.getUid)(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
    const tolerance = getTolerance(resolution, pixelRatio);
    return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
    return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderCircleGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');
        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        circleReplay.drawCircle(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform, declutterBuilderGroup) {
    let loading = false;
    const imageStyle = style.getImage();
    if (imageStyle) {
        const imageState = imageStyle.getImageState();
        if (imageState == (0, _imageStateJsDefault.default).LOADED || imageState == (0, _imageStateJsDefault.default).ERROR) imageStyle.unlistenImageChange(listener);
        else {
            if (imageState == (0, _imageStateJsDefault.default).IDLE) imageStyle.load();
            imageStyle.listenImageChange(listener);
            loading = true;
        }
    }
    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutterBuilderGroup);
    return loading;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform, declutterBuilderGroup) {
    const geometry = style.getGeometryFunction()(feature);
    if (!geometry) return;
    const simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, transform);
    const renderer = style.getRenderer();
    if (renderer) renderGeometry(replayGroup, simplifiedGeometry, style, feature);
    else {
        const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, declutterBuilderGroup);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */ function renderGeometry(replayGroup, geometry, style, feature) {
    if (geometry.getType() == 'GeometryCollection') {
        const geometries = /** @type {import("../geom/GeometryCollection.js").default} */ geometry.getGeometries();
        for(let i = 0, ii = geometries.length; i < ii; ++i)renderGeometry(replayGroup, geometries[i], style, feature);
        return;
    }
    const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');
    replay.drawCustom(/** @type {import("../geom/SimpleGeometry.js").default} */ geometry, feature, style.getRenderer(), style.getHitDetectionRenderer());
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup) {
    const geometries = geometry.getGeometriesArray();
    let i, ii;
    for(i = 0, ii = geometries.length; i < ii; ++i){
        const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
        geometryRenderer(replayGroup, geometries[i], style, feature, declutterBuilderGroup);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const strokeStyle = style.getStroke();
    if (strokeStyle) {
        const lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawLineString(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const strokeStyle = style.getStroke();
    if (strokeStyle) {
        const lineStringReplay = builderGroup.getBuilder(style.getZIndex(), 'LineString');
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawMultiLineString(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (strokeStyle || fillStyle) {
        const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawMultiPolygon(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const imageStyle = style.getImage();
    const textStyle = style.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */ let declutterImageWithText;
    if (imageStyle) {
        if (imageStyle.getImageState() != (0, _imageStateJsDefault.default).LOADED) return;
        let imageBuilderGroup = builderGroup;
        if (declutterBuilderGroup) {
            const declutterMode = imageStyle.getDeclutterMode();
            if (declutterMode !== 'none') {
                imageBuilderGroup = declutterBuilderGroup;
                if (declutterMode === 'obstacle') {
                    // draw in non-declutter group:
                    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');
                    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
                    imageReplay.drawPoint(geometry, feature);
                } else if (textStyle && textStyle.getText()) declutterImageWithText = {};
            }
        }
        const imageReplay = imageBuilderGroup.getBuilder(style.getZIndex(), 'Image');
        imageReplay.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay.drawPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
        let textBuilderGroup = builderGroup;
        if (declutterBuilderGroup) textBuilderGroup = declutterBuilderGroup;
        const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const imageStyle = style.getImage();
    const textStyle = style.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */ let declutterImageWithText;
    if (imageStyle) {
        if (imageStyle.getImageState() != (0, _imageStateJsDefault.default).LOADED) return;
        let imageBuilderGroup = builderGroup;
        if (declutterBuilderGroup) {
            const declutterMode = imageStyle.getDeclutterMode();
            if (declutterMode !== 'none') {
                imageBuilderGroup = declutterBuilderGroup;
                if (declutterMode === 'obstacle') {
                    // draw in non-declutter group:
                    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');
                    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
                    imageReplay.drawMultiPoint(geometry, feature);
                } else if (textStyle && textStyle.getText()) declutterImageWithText = {};
            }
        }
        const imageReplay = imageBuilderGroup.getBuilder(style.getZIndex(), 'Image');
        imageReplay.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay.drawMultiPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
        let textBuilderGroup = builderGroup;
        if (declutterBuilderGroup) textBuilderGroup = declutterBuilderGroup;
        const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
 */ function renderPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawPolygon(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), 'Text');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}

},{"../ImageState.js":"c4jJS","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9w7Fr":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/Vector
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector~VectorSource} instances are instances of this
 * type.
 * @template {import("../Feature.js").FeatureLike} [FeatureClass=import("../Feature.js").default]
 */ parcelHelpers.export(exports, "VectorSourceEvent", ()=>VectorSourceEvent);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _rbushJs = require("../structs/RBush.js");
var _rbushJsDefault = parcelHelpers.interopDefault(_rbushJs);
var _featureJs = require("../render/Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _sourceJs = require("./Source.js");
var _sourceJsDefault = parcelHelpers.interopDefault(_sourceJs);
var _vectorEventTypeJs = require("./VectorEventType.js");
var _vectorEventTypeJsDefault = parcelHelpers.interopDefault(_vectorEventTypeJs);
var _functionsJs = require("../functions.js");
var _loadingstrategyJs = require("../loadingstrategy.js");
var _assertsJs = require("../asserts.js");
var _extentJs = require("../extent.js");
var _arrayJs = require("../array.js");
var _utilJs = require("../util.js");
var _objJs = require("../obj.js");
var _eventsJs = require("../events.js");
var _featureloaderJs = require("../featureloader.js");
class VectorSourceEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {string} type Type.
   * @param {FeatureClass} [feature] Feature.
   * @param {Array<FeatureClass>} [features] Features.
   */ constructor(type, feature, features){
        super(type);
        /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {FeatureClass|undefined}
     * @api
     */ this.feature = feature;
        /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<FeatureClass>|undefined}
     * @api
     */ this.features = features;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */ /**
 * @template {import("../Feature.js").FeatureLike} [FeatureClass=import("../Feature.js").default]
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<FeatureClass>|Collection<FeatureClass>} [features]
 * Features. If provided as {@link module:ol/Collection~Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import Vector from 'ol/source/Vector.js';
 * import GeoJSON from 'ol/format/GeoJSON.js';
 * import {bbox} from 'ol/loadingstrategy.js';
 *
 * const vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      const proj = projection.getCode();
 *      const url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      const xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      const onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          const features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox,
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection~Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180° and 180° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */ /**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../Feature.js").FeatureLike} [FeatureClass=import("../Feature.js").default]
 */ class VectorSource extends (0, _sourceJsDefault.default) {
    /**
   * @param {Options<FeatureClass>} [options] Vector source options.
   */ constructor(options){
        options = options || {};
        super({
            attributions: options.attributions,
            interpolate: true,
            projection: undefined,
            state: 'ready',
            wrapX: options.wrapX !== undefined ? options.wrapX : true
        });
        /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {VectorSourceOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {VectorSourceOnSignature<void>}
     */ this.un;
        /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */ this.loader_ = (0, _functionsJs.VOID);
        /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */ this.format_ = options.format;
        /**
     * @private
     * @type {boolean}
     */ this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
        /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */ this.url_ = options.url;
        if (options.loader !== undefined) this.loader_ = options.loader;
        else if (this.url_ !== undefined) {
            (0, _assertsJs.assert)(this.format_, '`format` must be set when `url` is set');
            // create a XHR feature loader for "url" and "format"
            this.loader_ = (0, _featureloaderJs.xhr)(this.url_, /** @type {import("../format/Feature.js").default} */ this.format_);
        }
        /**
     * @private
     * @type {LoadingStrategy}
     */ this.strategy_ = options.strategy !== undefined ? options.strategy : (0, _loadingstrategyJs.all);
        const useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
        /**
     * @private
     * @type {RBush<FeatureClass>}
     */ this.featuresRtree_ = useSpatialIndex ? new (0, _rbushJsDefault.default)() : null;
        /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */ this.loadedExtentsRtree_ = new (0, _rbushJsDefault.default)();
        /**
     * @type {number}
     * @private
     */ this.loadingExtentsCount_ = 0;
        /**
     * @private
     * @type {!Object<string, FeatureClass>}
     */ this.nullGeometryFeatures_ = {};
        /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, FeatureClass|Array<RenderFeature>>}
     */ this.idIndex_ = {};
        /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, FeatureClass>}
     */ this.uidIndex_ = {};
        /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */ this.featureChangeKeys_ = {};
        /**
     * @private
     * @type {Collection<FeatureClass>|null}
     */ this.featuresCollection_ = null;
        /** @type {Collection<FeatureClass>} */ let collection;
        /** @type {Array<FeatureClass>} */ let features;
        if (Array.isArray(options.features)) features = options.features;
        else if (options.features) {
            collection = options.features;
            features = collection.getArray();
        }
        if (!useSpatialIndex && collection === undefined) collection = new (0, _collectionJsDefault.default)(features);
        if (features !== undefined) this.addFeaturesInternal(features);
        if (collection !== undefined) this.bindFeaturesCollection_(collection);
    }
    /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureClass} feature Feature to add.
   * @api
   */ addFeature(feature) {
        this.addFeatureInternal(feature);
        this.changed();
    }
    /**
   * Add a feature without firing a `change` event.
   * @param {FeatureClass} feature Feature.
   * @protected
   */ addFeatureInternal(feature) {
        const featureKey = (0, _utilJs.getUid)(feature);
        if (!this.addToIndex_(featureKey, feature)) {
            if (this.featuresCollection_) this.featuresCollection_.remove(feature);
            return;
        }
        this.setupChangeEvents_(featureKey, feature);
        const geometry = feature.getGeometry();
        if (geometry) {
            const extent = geometry.getExtent();
            if (this.featuresRtree_) this.featuresRtree_.insert(extent, feature);
        } else this.nullGeometryFeatures_[featureKey] = feature;
        this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).ADDFEATURE, feature));
    }
    /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureClass} feature The feature.
   * @private
   */ setupChangeEvents_(featureKey, feature) {
        if (feature instanceof (0, _featureJsDefault.default)) return;
        this.featureChangeKeys_[featureKey] = [
            (0, _eventsJs.listen)(feature, (0, _eventTypeJsDefault.default).CHANGE, this.handleFeatureChange_, this),
            (0, _eventsJs.listen)(feature, (0, _objectEventTypeJsDefault.default).PROPERTYCHANGE, this.handleFeatureChange_, this)
        ];
    }
    /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureClass} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */ addToIndex_(featureKey, feature) {
        let valid = true;
        if (feature.getId() !== undefined) {
            const id = String(feature.getId());
            if (!(id in this.idIndex_)) this.idIndex_[id] = feature;
            else if (feature instanceof (0, _featureJsDefault.default)) {
                const indexedFeature = this.idIndex_[id];
                if (!(indexedFeature instanceof (0, _featureJsDefault.default))) valid = false;
                else if (!Array.isArray(indexedFeature)) this.idIndex_[id] = [
                    indexedFeature,
                    feature
                ];
                else indexedFeature.push(feature);
            } else valid = false;
        }
        if (valid) {
            (0, _assertsJs.assert)(!(featureKey in this.uidIndex_), 'The passed `feature` was already added to the source');
            this.uidIndex_[featureKey] = feature;
        }
        return valid;
    }
    /**
   * Add a batch of features to the source.
   * @param {Array<FeatureClass>} features Features to add.
   * @api
   */ addFeatures(features) {
        this.addFeaturesInternal(features);
        this.changed();
    }
    /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureClass>} features Features.
   * @protected
   */ addFeaturesInternal(features) {
        const extents = [];
        /** @type {Array<FeatureClass>} */ const newFeatures = [];
        /** @type Array<FeatureClass> */ const geometryFeatures = [];
        for(let i = 0, length = features.length; i < length; i++){
            const feature = features[i];
            const featureKey = (0, _utilJs.getUid)(feature);
            if (this.addToIndex_(featureKey, feature)) newFeatures.push(feature);
        }
        for(let i = 0, length = newFeatures.length; i < length; i++){
            const feature = newFeatures[i];
            const featureKey = (0, _utilJs.getUid)(feature);
            this.setupChangeEvents_(featureKey, feature);
            const geometry = feature.getGeometry();
            if (geometry) {
                const extent = geometry.getExtent();
                extents.push(extent);
                geometryFeatures.push(feature);
            } else this.nullGeometryFeatures_[featureKey] = feature;
        }
        if (this.featuresRtree_) this.featuresRtree_.load(extents, geometryFeatures);
        if (this.hasListener((0, _vectorEventTypeJsDefault.default).ADDFEATURE)) for(let i = 0, length = newFeatures.length; i < length; i++)this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).ADDFEATURE, newFeatures[i]));
    }
    /**
   * @param {!Collection<FeatureClass>} collection Collection.
   * @private
   */ bindFeaturesCollection_(collection) {
        let modifyingCollection = false;
        this.addEventListener((0, _vectorEventTypeJsDefault.default).ADDFEATURE, /**
       * @param {VectorSourceEvent<FeatureClass>} evt The vector source event
       */ function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.push(evt.feature);
                modifyingCollection = false;
            }
        });
        this.addEventListener((0, _vectorEventTypeJsDefault.default).REMOVEFEATURE, /**
       * @param {VectorSourceEvent<FeatureClass>} evt The vector source event
       */ function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.remove(evt.feature);
                modifyingCollection = false;
            }
        });
        collection.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, /**
       * @param {import("../Collection.js").CollectionEvent<FeatureClass>} evt The collection event
       */ (evt)=>{
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.addFeature(evt.element);
                modifyingCollection = false;
            }
        });
        collection.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, /**
       * @param {import("../Collection.js").CollectionEvent<FeatureClass>} evt The collection event
       */ (evt)=>{
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.removeFeature(evt.element);
                modifyingCollection = false;
            }
        });
        this.featuresCollection_ = collection;
    }
    /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */ clear(fast) {
        if (fast) {
            for(const featureId in this.featureChangeKeys_){
                const keys = this.featureChangeKeys_[featureId];
                keys.forEach((0, _eventsJs.unlistenByKey));
            }
            if (!this.featuresCollection_) {
                this.featureChangeKeys_ = {};
                this.idIndex_ = {};
                this.uidIndex_ = {};
            }
        } else if (this.featuresRtree_) {
            const removeAndIgnoreReturn = (feature)=>{
                this.removeFeatureInternal(feature);
            };
            this.featuresRtree_.forEach(removeAndIgnoreReturn);
            for(const id in this.nullGeometryFeatures_)this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
        if (this.featuresCollection_) this.featuresCollection_.clear();
        if (this.featuresRtree_) this.featuresRtree_.clear();
        this.nullGeometryFeatures_ = {};
        const clearEvent = new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).CLEAR);
        this.dispatchEvent(clearEvent);
        this.changed();
    }
    /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureClass): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeature(callback) {
        if (this.featuresRtree_) return this.featuresRtree_.forEach(callback);
        if (this.featuresCollection_) this.featuresCollection_.forEach(callback);
    }
    /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureClass): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */ forEachFeatureAtCoordinateDirect(coordinate, callback) {
        const extent = [
            coordinate[0],
            coordinate[1],
            coordinate[0],
            coordinate[1]
        ];
        return this.forEachFeatureInExtent(extent, function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof (0, _featureJsDefault.default) || geometry.intersectsCoordinate(coordinate)) return callback(feature);
            return undefined;
        });
    }
    /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureClass): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeatureInExtent(extent, callback) {
        if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(extent, callback);
        if (this.featuresCollection_) this.featuresCollection_.forEach(callback);
    }
    /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureClass): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */ forEachFeatureIntersectingExtent(extent, callback) {
        return this.forEachFeatureInExtent(extent, /**
       * @param {FeatureClass} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */ function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof (0, _featureJsDefault.default) || geometry.intersectsExtent(extent)) {
                const result = callback(feature);
                if (result) return result;
            }
        });
    }
    /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureClass>|null} The collection of features.
   * @api
   */ getFeaturesCollection() {
        return this.featuresCollection_;
    }
    /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureClass>} Features.
   * @api
   */ getFeatures() {
        let features;
        if (this.featuresCollection_) features = this.featuresCollection_.getArray().slice(0);
        else if (this.featuresRtree_) {
            features = this.featuresRtree_.getAll();
            if (!(0, _objJs.isEmpty)(this.nullGeometryFeatures_)) (0, _arrayJs.extend)(features, Object.values(this.nullGeometryFeatures_));
        }
        return features;
    }
    /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */ getFeaturesAtCoordinate(coordinate) {
        const features = [];
        this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
            features.push(feature);
        });
        return features;
    }
    /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureClass>} Features.
   * @api
   */ getFeaturesInExtent(extent, projection) {
        if (this.featuresRtree_) {
            const multiWorld = projection && projection.canWrapX() && this.getWrapX();
            if (!multiWorld) return this.featuresRtree_.getInExtent(extent);
            const extents = (0, _extentJs.wrapAndSliceX)(extent, projection);
            return [].concat(...extents.map((anExtent)=>this.featuresRtree_.getInExtent(anExtent)));
        }
        if (this.featuresCollection_) return this.featuresCollection_.getArray().slice(0);
        return [];
    }
    /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureClass):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureClass} Closest feature.
   * @api
   */ getClosestFeatureToCoordinate(coordinate, filter) {
        // Find the closest feature using branch and bound.  We start searching an
        // infinite extent, and find the distance from the first feature found.  This
        // becomes the closest feature.  We then compute a smaller extent which any
        // closer feature must intersect.  We continue searching with this smaller
        // extent, trying to find a closer feature.  Every time we find a closer
        // feature, we update the extent being searched so that any even closer
        // feature must intersect it.  We continue until we run out of features.
        const x = coordinate[0];
        const y = coordinate[1];
        let closestFeature = null;
        const closestPoint = [
            NaN,
            NaN
        ];
        let minSquaredDistance = Infinity;
        const extent = [
            -Infinity,
            -Infinity,
            Infinity,
            Infinity
        ];
        filter = filter ? filter : (0, _functionsJs.TRUE);
        this.featuresRtree_.forEachInExtent(extent, /**
       * @param {FeatureClass} feature Feature.
       */ function(feature) {
            if (filter(feature)) {
                const geometry = feature.getGeometry();
                const previousMinSquaredDistance = minSquaredDistance;
                minSquaredDistance = geometry instanceof (0, _featureJsDefault.default) ? 0 : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                if (minSquaredDistance < previousMinSquaredDistance) {
                    closestFeature = feature;
                    // This is sneaky.  Reduce the extent that it is currently being
                    // searched while the R-Tree traversal using this same extent object
                    // is still in progress.  This is safe because the new extent is
                    // strictly contained by the old extent.
                    const minDistance = Math.sqrt(minSquaredDistance);
                    extent[0] = x - minDistance;
                    extent[1] = y - minDistance;
                    extent[2] = x + minDistance;
                    extent[3] = y + minDistance;
                }
            }
        });
        return closestFeature;
    }
    /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */ getExtent(extent) {
        return this.featuresRtree_.getExtent(extent);
    }
    /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClass|Array<RenderFeature>|null} The feature (or `null` if not found).
   * @api
   */ getFeatureById(id) {
        const feature = this.idIndex_[id.toString()];
        return feature !== undefined ? feature : null;
    }
    /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureClass|null} The feature (or `null` if not found).
   */ getFeatureByUid(uid) {
        const feature = this.uidIndex_[uid];
        return feature !== undefined ? feature : null;
    }
    /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */ getFormat() {
        return this.format_;
    }
    /**
   * @return {boolean} The source can have overlapping geometries.
   */ getOverlaps() {
        return this.overlaps_;
    }
    /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */ getUrl() {
        return this.url_;
    }
    /**
   * @param {Event} event Event.
   * @private
   */ handleFeatureChange_(event) {
        const feature = /** @type {FeatureClass} */ event.target;
        const featureKey = (0, _utilJs.getUid)(feature);
        const geometry = feature.getGeometry();
        if (!geometry) {
            if (!(featureKey in this.nullGeometryFeatures_)) {
                if (this.featuresRtree_) this.featuresRtree_.remove(feature);
                this.nullGeometryFeatures_[featureKey] = feature;
            }
        } else {
            const extent = geometry.getExtent();
            if (featureKey in this.nullGeometryFeatures_) {
                delete this.nullGeometryFeatures_[featureKey];
                if (this.featuresRtree_) this.featuresRtree_.insert(extent, feature);
            } else if (this.featuresRtree_) this.featuresRtree_.update(extent, feature);
        }
        const id = feature.getId();
        if (id !== undefined) {
            const sid = id.toString();
            if (this.idIndex_[sid] !== feature) {
                this.removeFromIdIndex_(feature);
                this.idIndex_[sid] = feature;
            }
        } else {
            this.removeFromIdIndex_(feature);
            this.uidIndex_[featureKey] = feature;
        }
        this.changed();
        this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).CHANGEFEATURE, feature));
    }
    /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureClass} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */ hasFeature(feature) {
        const id = feature.getId();
        if (id !== undefined) return id in this.idIndex_;
        return (0, _utilJs.getUid)(feature) in this.uidIndex_;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        if (this.featuresRtree_) return this.featuresRtree_.isEmpty() && (0, _objJs.isEmpty)(this.nullGeometryFeatures_);
        if (this.featuresCollection_) return this.featuresCollection_.getLength() === 0;
        return true;
    }
    /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */ loadFeatures(extent, resolution, projection) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        const extentsToLoad = this.strategy_(extent, resolution, projection);
        for(let i = 0, ii = extentsToLoad.length; i < ii; ++i){
            const extentToLoad = extentsToLoad[i];
            const alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */ function(object) {
                return (0, _extentJs.containsExtent)(object.extent, extentToLoad);
            });
            if (!alreadyLoaded) {
                ++this.loadingExtentsCount_;
                this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).FEATURESLOADSTART));
                this.loader_.call(this, extentToLoad, resolution, projection, (features)=>{
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).FEATURESLOADEND, undefined, features));
                }, ()=>{
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).FEATURESLOADERROR));
                });
                loadedExtentsRtree.insert(extentToLoad, {
                    extent: extentToLoad.slice()
                });
            }
        }
        this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
    }
    refresh() {
        this.clear(true);
        this.loadedExtentsRtree_.clear();
        super.refresh();
    }
    /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */ removeLoadedExtent(extent) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        let obj;
        loadedExtentsRtree.forEachInExtent(extent, function(object) {
            if ((0, _extentJs.equals)(object.extent, extent)) {
                obj = object;
                return true;
            }
        });
        if (obj) loadedExtentsRtree.remove(obj);
    }
    /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {FeatureClass} feature Feature to remove.
   * @api
   */ removeFeature(feature) {
        if (!feature) return;
        const featureKey = (0, _utilJs.getUid)(feature);
        if (featureKey in this.nullGeometryFeatures_) delete this.nullGeometryFeatures_[featureKey];
        else if (this.featuresRtree_) this.featuresRtree_.remove(feature);
        const result = this.removeFeatureInternal(feature);
        if (result) this.changed();
    }
    /**
   * Remove feature without firing a `change` event.
   * @param {FeatureClass} feature Feature.
   * @return {FeatureClass|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */ removeFeatureInternal(feature) {
        const featureKey = (0, _utilJs.getUid)(feature);
        const featureChangeKeys = this.featureChangeKeys_[featureKey];
        if (!featureChangeKeys) return;
        featureChangeKeys.forEach((0, _eventsJs.unlistenByKey));
        delete this.featureChangeKeys_[featureKey];
        const id = feature.getId();
        if (id !== undefined) delete this.idIndex_[id.toString()];
        delete this.uidIndex_[featureKey];
        this.dispatchEvent(new VectorSourceEvent((0, _vectorEventTypeJsDefault.default).REMOVEFEATURE, feature));
        return feature;
    }
    /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureClass} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */ removeFromIdIndex_(feature) {
        let removed = false;
        for(const id in this.idIndex_){
            const indexedFeature = this.idIndex_[id];
            if (feature instanceof (0, _featureJsDefault.default) && Array.isArray(indexedFeature) && indexedFeature.includes(feature)) indexedFeature.splice(indexedFeature.indexOf(feature), 1);
            else if (this.idIndex_[id] === feature) {
                delete this.idIndex_[id];
                removed = true;
                break;
            }
        }
        return removed;
    }
    /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */ setLoader(loader) {
        this.loader_ = loader;
    }
    /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */ setUrl(url) {
        (0, _assertsJs.assert)(this.format_, '`format` must be set when `url` is set');
        this.url_ = url;
        this.setLoader((0, _featureloaderJs.xhr)(url, this.format_));
    }
}
exports.default = VectorSource;

},{"../Collection.js":"gReoh","../CollectionEventType.js":"82Ksf","../events/Event.js":"hwXQP","../events/EventType.js":"hrQJ6","../ObjectEventType.js":"f2U6i","../structs/RBush.js":"ewGrv","../render/Feature.js":"3Oc3i","./Source.js":"bgZ4G","./VectorEventType.js":"6IruY","../functions.js":"iqv8I","../loadingstrategy.js":"i1BBH","../asserts.js":"e4TiF","../extent.js":"6YrVc","../array.js":"1Fbic","../util.js":"pLBjQ","../obj.js":"3ssAG","../events.js":"dcspA","../featureloader.js":"csnhK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gReoh":[function(require,module,exports,__globalThis) {
/**
 * @module ol/Collection
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 * @template T
 */ parcelHelpers.export(exports, "CollectionEvent", ()=>CollectionEvent);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _collectionEventTypeJs = require("./CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
/**
 * @enum {string}
 * @private
 */ const Property = {
    LENGTH: 'length'
};
class CollectionEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */ constructor(type, element, index){
        super(type);
        /**
     * The element that is added to or removed from the collection.
     * @type {T}
     * @api
     */ this.element = element;
        /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */ this.index = index;
    }
}
/***
 * @template T
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */ /**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */ class Collection extends (0, _objectJsDefault.default) {
    /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */ constructor(array, options){
        super();
        /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */ this.on;
        /***
     * @type {CollectionOnSignature<T, import("./events").EventsKey>}
     */ this.once;
        /***
     * @type {CollectionOnSignature<T, void>}
     */ this.un;
        options = options || {};
        /**
     * @private
     * @type {boolean}
     */ this.unique_ = !!options.unique;
        /**
     * @private
     * @type {!Array<T>}
     */ this.array_ = array ? array : [];
        if (this.unique_) for(let i = 0, ii = this.array_.length; i < ii; ++i)this.assertUnique_(this.array_[i], i);
        this.updateLength_();
    }
    /**
   * Remove all elements from the collection.
   * @api
   */ clear() {
        while(this.getLength() > 0)this.pop();
    }
    /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */ extend(arr) {
        for(let i = 0, ii = arr.length; i < ii; ++i)this.push(arr[i]);
        return this;
    }
    /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */ forEach(f) {
        const array = this.array_;
        for(let i = 0, ii = array.length; i < ii; ++i)f(array[i], i, array);
    }
    /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */ getArray() {
        return this.array_;
    }
    /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */ item(index) {
        return this.array_[index];
    }
    /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */ getLength() {
        return this.get(Property.LENGTH);
    }
    /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */ insertAt(index, elem) {
        if (index < 0 || index > this.getLength()) throw new Error('Index out of bounds: ' + index);
        if (this.unique_) this.assertUnique_(elem);
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent((0, _collectionEventTypeJsDefault.default).ADD, elem, index));
    }
    /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */ pop() {
        return this.removeAt(this.getLength() - 1);
    }
    /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */ push(elem) {
        if (this.unique_) this.assertUnique_(elem);
        const n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
    }
    /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */ remove(elem) {
        const arr = this.array_;
        for(let i = 0, ii = arr.length; i < ii; ++i){
            if (arr[i] === elem) return this.removeAt(i);
        }
        return undefined;
    }
    /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */ removeAt(index) {
        if (index < 0 || index >= this.getLength()) return undefined;
        const prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(/** @type {CollectionEvent<T>} */ new CollectionEvent((0, _collectionEventTypeJsDefault.default).REMOVE, prev, index));
        return prev;
    }
    /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */ setAt(index, elem) {
        const n = this.getLength();
        if (index >= n) {
            this.insertAt(index, elem);
            return;
        }
        if (index < 0) throw new Error('Index out of bounds: ' + index);
        if (this.unique_) this.assertUnique_(elem, index);
        const prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(/** @type {CollectionEvent<T>} */ new CollectionEvent((0, _collectionEventTypeJsDefault.default).REMOVE, prev, index));
        this.dispatchEvent(/** @type {CollectionEvent<T>} */ new CollectionEvent((0, _collectionEventTypeJsDefault.default).ADD, elem, index));
    }
    /**
   * @private
   */ updateLength_() {
        this.set(Property.LENGTH, this.array_.length);
    }
    /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */ assertUnique_(elem, except) {
        for(let i = 0, ii = this.array_.length; i < ii; ++i){
            if (this.array_[i] === elem && i !== except) throw new Error('Duplicate item added to a unique collection');
        }
    }
}
exports.default = Collection;

},{"./Object.js":"1zG8z","./CollectionEventType.js":"82Ksf","./events/Event.js":"hwXQP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"82Ksf":[function(require,module,exports,__globalThis) {
/**
 * @module ol/CollectionEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */ ADD: 'add',
    /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */ REMOVE: 'remove'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ewGrv":[function(require,module,exports,__globalThis) {
/**
 * @module ol/structs/RBush
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rbush = require("rbush");
var _rbushDefault = parcelHelpers.interopDefault(_rbush);
var _extentJs = require("../extent.js");
var _utilJs = require("../util.js");
var _objJs = require("../obj.js");
/**
 * @typedef {Object} Entry
 * @property {number} minX MinX.
 * @property {number} minY MinY.
 * @property {number} maxX MaxX.
 * @property {number} maxY MaxY.
 * @property {Object} [value] Value.
 */ /**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */ class RBush {
    /**
   * @param {number} [maxEntries] Max entries.
   */ constructor(maxEntries){
        /**
     * @private
     */ this.rbush_ = new (0, _rbushDefault.default)(maxEntries);
        /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry>}
     */ this.items_ = {};
    }
    /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */ insert(extent, value) {
        /** @type {Entry} */ const item = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
            value: value
        };
        this.rbush_.insert(item);
        this.items_[(0, _utilJs.getUid)(value)] = item;
    }
    /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */ load(extents, values) {
        const items = new Array(values.length);
        for(let i = 0, l = values.length; i < l; i++){
            const extent = extents[i];
            const value = values[i];
            /** @type {Entry} */ const item = {
                minX: extent[0],
                minY: extent[1],
                maxX: extent[2],
                maxY: extent[3],
                value: value
            };
            items[i] = item;
            this.items_[(0, _utilJs.getUid)(value)] = item;
        }
        this.rbush_.load(items);
    }
    /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */ remove(value) {
        const uid = (0, _utilJs.getUid)(value);
        // get the object in which the value was wrapped when adding to the
        // internal rbush. then use that object to do the removal.
        const item = this.items_[uid];
        delete this.items_[uid];
        return this.rbush_.remove(item) !== null;
    }
    /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */ update(extent, value) {
        const item = this.items_[(0, _utilJs.getUid)(value)];
        const bbox = [
            item.minX,
            item.minY,
            item.maxX,
            item.maxY
        ];
        if (!(0, _extentJs.equals)(bbox, extent)) {
            this.remove(value);
            this.insert(extent, value);
        }
    }
    /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */ getAll() {
        const items = this.rbush_.all();
        return items.map(function(item) {
            return item.value;
        });
    }
    /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */ getInExtent(extent) {
        /** @type {Entry} */ const bbox = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3]
        };
        const items = this.rbush_.search(bbox);
        return items.map(function(item) {
            return item.value;
        });
    }
    /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */ forEach(callback) {
        return this.forEach_(this.getAll(), callback);
    }
    /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */ forEachInExtent(extent, callback) {
        return this.forEach_(this.getInExtent(extent), callback);
    }
    /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */ forEach_(values, callback) {
        let result;
        for(let i = 0, l = values.length; i < l; i++){
            result = callback(values[i]);
            if (result) return result;
        }
        return result;
    }
    /**
   * @return {boolean} Is empty.
   */ isEmpty() {
        return (0, _objJs.isEmpty)(this.items_);
    }
    /**
   * Remove all values from the RBush.
   */ clear() {
        this.rbush_.clear();
        this.items_ = {};
    }
    /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */ getExtent(extent) {
        const data = this.rbush_.toJSON();
        return (0, _extentJs.createOrUpdate)(data.minX, data.minY, data.maxX, data.maxY, extent);
    }
    /**
   * @param {RBush} rbush R-Tree.
   */ concat(rbush) {
        this.rbush_.load(rbush.rbush_.all());
        for(const i in rbush.items_)this.items_[i] = rbush.items_[i];
    }
}
exports.default = RBush;

},{"rbush":"k2VZu","../extent.js":"6YrVc","../util.js":"pLBjQ","../obj.js":"3ssAG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bgZ4G":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/Source
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _projJs = require("../proj.js");
/**
 * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */ /**
 * A function that takes a {@link import("../View.js").ViewStateLayerStateExtent} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../View.js").ViewStateLayerStateExtent): (string|Array<string>)} Attribution
 */ /**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'© Acme Inc.'`)
 * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */ /**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./Source.js").State} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
 * the nearest neighbor is used when resampling.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */ class Source extends (0, _objectJsDefault.default) {
    /**
   * @param {Options} options Source options.
   */ constructor(options){
        super();
        /**
     * @protected
     * @type {import("../proj/Projection.js").default|null}
     */ this.projection = (0, _projJs.get)(options.projection);
        /**
     * @private
     * @type {?Attribution}
     */ this.attributions_ = adaptAttributions(options.attributions);
        /**
     * @private
     * @type {boolean}
     */ this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;
        /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */ this.loading = false;
        /**
     * @private
     * @type {import("./Source.js").State}
     */ this.state_ = options.state !== undefined ? options.state : 'ready';
        /**
     * @private
     * @type {boolean}
     */ this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
        /**
     * @private
     * @type {boolean}
     */ this.interpolate_ = !!options.interpolate;
        /**
     * @protected
     * @type {function(import("../View.js").ViewOptions):void}
     */ this.viewResolver = null;
        /**
     * @protected
     * @type {function(Error):void}
     */ this.viewRejector = null;
        const self = this;
        /**
     * @private
     * @type {Promise<import("../View.js").ViewOptions>}
     */ this.viewPromise_ = new Promise(function(resolve, reject) {
            self.viewResolver = resolve;
            self.viewRejector = reject;
        });
    }
    /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */ getAttributions() {
        return this.attributions_;
    }
    /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */ getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
    }
    /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */ getProjection() {
        return this.projection;
    }
    /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */ getResolutions(projection) {
        return null;
    }
    /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */ getView() {
        return this.viewPromise_;
    }
    /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */ getState() {
        return this.state_;
    }
    /**
   * @return {boolean|undefined} Wrap X.
   */ getWrapX() {
        return this.wrapX_;
    }
    /**
   * @return {boolean} Use linear interpolation when resampling.
   */ getInterpolate() {
        return this.interpolate_;
    }
    /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */ refresh() {
        this.changed();
    }
    /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */ setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
    }
    /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */ setState(state) {
        this.state_ = state;
        this.changed();
    }
}
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {Attribution|null} An attribution function (or null).
 */ function adaptAttributions(attributionLike) {
    if (!attributionLike) return null;
    if (Array.isArray(attributionLike)) return function(frameState) {
        return attributionLike;
    };
    if (typeof attributionLike === 'function') return attributionLike;
    return function(frameState) {
        return [
            attributionLike
        ];
    };
}
exports.default = Source;

},{"../Object.js":"1zG8z","../proj.js":"SznqC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6IruY":[function(require,module,exports,__globalThis) {
/**
 * @module ol/source/VectorEventType
 */ /**
 * @enum {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */ ADDFEATURE: 'addfeature',
    /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */ CHANGEFEATURE: 'changefeature',
    /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */ CLEAR: 'clear',
    /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */ REMOVEFEATURE: 'removefeature',
    /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */ FEATURESLOADSTART: 'featuresloadstart',
    /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */ FEATURESLOADEND: 'featuresloadend',
    /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */ FEATURESLOADERROR: 'featuresloaderror'
}; /**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i1BBH":[function(require,module,exports,__globalThis) {
/**
 * @module ol/loadingstrategy
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */ parcelHelpers.export(exports, "all", ()=>all);
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */ parcelHelpers.export(exports, "bbox", ()=>bbox);
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */ parcelHelpers.export(exports, "tile", ()=>tile);
var _projJs = require("./proj.js");
function all(extent, resolution) {
    return [
        [
            -Infinity,
            -Infinity,
            Infinity,
            Infinity
        ]
    ];
}
function bbox(extent, resolution) {
    return [
        extent
    ];
}
function tile(tileGrid) {
    return(/**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */ function(extent, resolution, projection) {
        const z = tileGrid.getZForResolution((0, _projJs.fromUserResolution)(resolution, projection));
        const tileRange = tileGrid.getTileRangeForExtentAndZ((0, _projJs.fromUserExtent)(extent, projection), z);
        /** @type {Array<import("./extent.js").Extent>} */ const extents = [];
        /** @type {import("./tilecoord.js").TileCoord} */ const tileCoord = [
            z,
            0,
            0
        ];
        for(tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1])for(tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2])extents.push((0, _projJs.toUserExtent)(tileGrid.getTileCoordExtent(tileCoord), projection));
        return extents;
    });
}

},{"./proj.js":"SznqC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"csnhK":[function(require,module,exports,__globalThis) {
/**
 * @module ol/featureloader
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an
 * {@link module:ol/proj/Projection~Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:ol/source/Vector~VectorSource} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */ /**
 * {@link module:ol/source/Vector~VectorSource} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection~Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */ /**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */ parcelHelpers.export(exports, "loadFeaturesXhr", ()=>loadFeaturesXhr);
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */ parcelHelpers.export(exports, "xhr", ()=>xhr);
/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */ parcelHelpers.export(exports, "setWithCredentials", ()=>setWithCredentials);
var _functionsJs = require("./functions.js");
/**
 *
 * @type {boolean}
 * @private
 */ let withCredentials = false;
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
    if (format.getType() == 'arraybuffer') xhr.responseType = 'arraybuffer';
    xhr.withCredentials = withCredentials;
    /**
   * @param {Event} event Event.
   * @private
   */ xhr.onload = function(event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
            const type = format.getType();
            /** @type {Document|Node|Object|string|undefined} */ let source;
            if (type == 'json') source = JSON.parse(xhr.responseText);
            else if (type == 'text') source = xhr.responseText;
            else if (type == 'xml') {
                source = xhr.responseXML;
                if (!source) source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
            } else if (type == 'arraybuffer') source = /** @type {ArrayBuffer} */ xhr.response;
            if (source) success(/** @type {Array<import("./Feature.js").default>} */ format.readFeatures(source, {
                extent: extent,
                featureProjection: projection
            }), format.readProjection(source));
            else failure();
        } else failure();
    };
    /**
   * @private
   */ xhr.onerror = failure;
    xhr.send();
}
function xhr(url, format) {
    /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {function(Array<import("./Feature.js").default>): void} [success] Success
   *      Function called when loading succeeded.
   * @param {function(): void} [failure] Failure
   *      Function called when loading failed.
   */ return function(extent, resolution, projection, success, failure) {
        const source = /** @type {import("./source/Vector").default} */ this;
        loadFeaturesXhr(url, format, extent, resolution, projection, /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */ function(features, dataProjection) {
            source.addFeatures(features);
            if (success !== undefined) success(features);
        }, /* FIXME handle error */ failure ? failure : (0, _functionsJs.VOID));
    };
}
function setWithCredentials(xhrWithCredentials) {
    withCredentials = xhrWithCredentials;
}

},{"./functions.js":"iqv8I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iQTYY":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/condition
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */ /**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */ parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "altKeyOnly", ()=>altKeyOnly);
parcelHelpers.export(exports, "altShiftKeysOnly", ()=>altShiftKeysOnly);
parcelHelpers.export(exports, "focus", ()=>focus);
parcelHelpers.export(exports, "focusWithTabindex", ()=>focusWithTabindex);
parcelHelpers.export(exports, "always", ()=>always);
parcelHelpers.export(exports, "click", ()=>click);
parcelHelpers.export(exports, "mouseActionButton", ()=>mouseActionButton);
parcelHelpers.export(exports, "never", ()=>never);
parcelHelpers.export(exports, "pointerMove", ()=>pointerMove);
parcelHelpers.export(exports, "singleClick", ()=>singleClick);
parcelHelpers.export(exports, "doubleClick", ()=>doubleClick);
parcelHelpers.export(exports, "noModifierKeys", ()=>noModifierKeys);
parcelHelpers.export(exports, "platformModifierKeyOnly", ()=>platformModifierKeyOnly);
parcelHelpers.export(exports, "platformModifierKey", ()=>platformModifierKey);
parcelHelpers.export(exports, "shiftKeyOnly", ()=>shiftKeyOnly);
parcelHelpers.export(exports, "targetNotEditable", ()=>targetNotEditable);
parcelHelpers.export(exports, "mouseOnly", ()=>mouseOnly);
parcelHelpers.export(exports, "touchOnly", ()=>touchOnly);
parcelHelpers.export(exports, "penOnly", ()=>penOnly);
parcelHelpers.export(exports, "primaryAction", ()=>primaryAction);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _functionsJs = require("../functions.js");
var _hasJs = require("../has.js");
var _assertsJs = require("../asserts.js");
function all(var_args) {
    const conditions = arguments;
    /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} All conditions passed.
   */ return function(event) {
        let pass = true;
        for(let i = 0, ii = conditions.length; i < ii; ++i){
            pass = pass && conditions[i](event);
            if (!pass) break;
        }
        return pass;
    };
}
const altKeyOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const altShiftKeysOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const focus = function(event) {
    const targetElement = event.map.getTargetElement();
    const activeElement = event.map.getOwnerDocument().activeElement;
    return targetElement.contains(activeElement);
};
const focusWithTabindex = function(event) {
    return event.map.getTargetElement().hasAttribute('tabindex') ? focus(event) : true;
};
const always = (0, _functionsJs.TRUE);
const click = function(mapBrowserEvent) {
    return mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).CLICK;
};
const mouseActionButton = function(mapBrowserEvent) {
    const originalEvent = /** @type {MouseEvent} */ mapBrowserEvent.originalEvent;
    return originalEvent.button == 0 && !((0, _hasJs.WEBKIT) && (0, _hasJs.MAC) && originalEvent.ctrlKey);
};
const never = (0, _functionsJs.FALSE);
const pointerMove = function(mapBrowserEvent) {
    return mapBrowserEvent.type == 'pointermove';
};
const singleClick = function(mapBrowserEvent) {
    return mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).SINGLECLICK;
};
const doubleClick = function(mapBrowserEvent) {
    return mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).DBLCLICK;
};
const noModifierKeys = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const platformModifierKeyOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && ((0, _hasJs.MAC) ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const platformModifierKey = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return (0, _hasJs.MAC) ? originalEvent.metaKey : originalEvent.ctrlKey;
};
const shiftKeyOnly = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const targetNotEditable = function(mapBrowserEvent) {
    const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ mapBrowserEvent.originalEvent;
    const tagName = /** @type {Element} */ originalEvent.target.tagName;
    return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA' && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !originalEvent.target.isContentEditable;
};
const mouseOnly = function(mapBrowserEvent) {
    const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvent !== undefined, 'mapBrowserEvent must originate from a pointer event');
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvent.pointerType == 'mouse';
};
const touchOnly = function(mapBrowserEvent) {
    const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvt !== undefined, 'mapBrowserEvent must originate from a pointer event');
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === 'touch';
};
const penOnly = function(mapBrowserEvent) {
    const pointerEvt = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvt !== undefined, 'mapBrowserEvent must originate from a pointer event');
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === 'pen';
};
const primaryAction = function(mapBrowserEvent) {
    const pointerEvent = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    (0, _assertsJs.assert)(pointerEvent !== undefined, 'mapBrowserEvent must originate from a pointer event');
    return pointerEvent.isPrimary && pointerEvent.button === 0;
};

},{"../MapBrowserEventType.js":"fB9ae","../functions.js":"iqv8I","../has.js":"6BDNi","../asserts.js":"e4TiF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"agqRu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transactWFS", ()=>transactWFS);
var _wfs = require("ol/format/WFS");
var _wfsDefault = parcelHelpers.interopDefault(_wfs);
function parseWFSResponse(xmlString) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
    // Check for Exception
    const exception = xmlDoc.querySelector('ows\\:Exception, Exception');
    if (exception) return {
        status: 'error',
        message: exception.textContent.trim()
    };
    // Parse TransactionSummary
    const summary = xmlDoc.querySelector('wfs\\:TransactionSummary, TransactionSummary');
    if (summary) {
        const inserted = summary.querySelector('wfs\\:totalInserted, totalInserted')?.textContent || '0';
        const updated = summary.querySelector('wfs\\:totalUpdated, totalUpdated')?.textContent || '0';
        const deleted = summary.querySelector('wfs\\:totalDeleted, totalDeleted')?.textContent || '0';
        const insertResults = xmlDoc.querySelectorAll('wfs\\:InsertResults wfs\\:Feature wfs\\:FeatureId, InsertResults Feature FeatureId');
        const fids = Array.from(insertResults).map((el)=>el.getAttribute('fid'));
        return {
            status: 'success',
            totalInserted: parseInt(inserted),
            totalUpdated: parseInt(updated),
            totalDeleted: parseInt(deleted),
            insertedFIDs: fids
        };
    }
    // Fallback if structure is unexpected
    return {
        status: 'unknown',
        raw: xmlString
    };
}
async function transactWFS(type, features, workspace, layerName, srs = 'EPSG:3857', user, password, geoserverURL) {
    const formatWFS = new (0, _wfsDefault.default)();
    const node = formatWFS.writeTransaction(type === 'insert' ? features : [], type === 'update' ? features : [], type === 'delete' ? features : [], {
        featureType: layerName,
        featureNS: 'https://www.naturalearthdata.com',
        srsName: srs,
        featurePrefix: workspace
    });
    const serializer = new XMLSerializer();
    const payload = serializer.serializeToString(node);
    try {
        const url = geoserverURL + '/wfs';
        const res = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'text/xml',
                'Authorization': 'Basic ' + btoa(`${user}:${password}`)
            },
            body: payload
        });
        const responseText = await res.text();
        if (!res.ok) throw new Error(`WFS-T ${type} failed with status ${res.status}: ${responseText}`);
        const jsonResponse = parseWFSResponse(responseText);
        return jsonResponse;
    } catch (error) {
        console.error('WFS-T error:', error);
        throw error;
    }
}

},{"ol/format/WFS":"iT2A4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iT2A4":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/WFS
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Encode filter as WFS `Filter` and return the Node.
 *
 * @param {import("./filter/Filter.js").default} filter Filter.
 * @param {string} version WFS version. If not provided defaults to '1.1.0'
 * @return {Node} Result.
 * @api
 */ parcelHelpers.export(exports, "writeFilter", ()=>writeFilter);
var _gml2Js = require("./GML2.js");
var _gml2JsDefault = parcelHelpers.interopDefault(_gml2Js);
var _gml3Js = require("./GML3.js");
var _gml3JsDefault = parcelHelpers.interopDefault(_gml3Js);
var _gml32Js = require("./GML32.js");
var _gml32JsDefault = parcelHelpers.interopDefault(_gml32Js);
var _gmlbaseJs = require("./GMLBase.js");
var _gmlbaseJsDefault = parcelHelpers.interopDefault(_gmlbaseJs);
var _xmlfeatureJs = require("./XMLFeature.js");
var _xmlfeatureJsDefault = parcelHelpers.interopDefault(_xmlfeatureJs);
var _xmlJs = require("../xml.js");
var _filterJs = require("./filter.js");
var _assertsJs = require("../asserts.js");
var _projJs = require("../proj.js");
var _xsdJs = require("./xsd.js");
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ const FEATURE_COLLECTION_PARSERS = {
    'http://www.opengis.net/gml': {
        'boundedBy': (0, _xmlJs.makeObjectPropertySetter)((0, _gmlbaseJsDefault.default).prototype.readExtentElement, 'bounds')
    },
    'http://www.opengis.net/wfs/2.0': {
        'member': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readFeaturesInternal)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ const TRANSACTION_SUMMARY_PARSERS = {
    'http://www.opengis.net/wfs': {
        'totalInserted': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
        'totalUpdated': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
        'totalDeleted': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger))
    },
    'http://www.opengis.net/wfs/2.0': {
        'totalInserted': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
        'totalUpdated': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger)),
        'totalDeleted': (0, _xmlJs.makeObjectPropertySetter)((0, _xsdJs.readPositiveInteger))
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ const TRANSACTION_RESPONSE_PARSERS = {
    'http://www.opengis.net/wfs': {
        'TransactionSummary': (0, _xmlJs.makeObjectPropertySetter)(readTransactionSummary, 'transactionSummary'),
        'InsertResults': (0, _xmlJs.makeObjectPropertySetter)(readInsertResults, 'insertIds')
    },
    'http://www.opengis.net/wfs/2.0': {
        'TransactionSummary': (0, _xmlJs.makeObjectPropertySetter)(readTransactionSummary, 'transactionSummary'),
        'InsertResults': (0, _xmlJs.makeObjectPropertySetter)(readInsertResults, 'insertIds')
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ const QUERY_SERIALIZERS = {
    'http://www.opengis.net/wfs': {
        'PropertyName': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode))
    },
    'http://www.opengis.net/wfs/2.0': {
        'PropertyName': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode))
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ const TRANSACTION_SERIALIZERS = {
    'http://www.opengis.net/wfs': {
        'Insert': (0, _xmlJs.makeChildAppender)(writeFeature),
        'Update': (0, _xmlJs.makeChildAppender)(writeUpdate),
        'Delete': (0, _xmlJs.makeChildAppender)(writeDelete),
        'Property': (0, _xmlJs.makeChildAppender)(writeProperty),
        'Native': (0, _xmlJs.makeChildAppender)(writeNative)
    },
    'http://www.opengis.net/wfs/2.0': {
        'Insert': (0, _xmlJs.makeChildAppender)(writeFeature),
        'Update': (0, _xmlJs.makeChildAppender)(writeUpdate),
        'Delete': (0, _xmlJs.makeChildAppender)(writeDelete),
        'Property': (0, _xmlJs.makeChildAppender)(writeProperty),
        'Native': (0, _xmlJs.makeChildAppender)(writeNative)
    }
};
/**
 * @typedef {Object} Options
 * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.
 * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.
 * @property {GMLBase} [gmlFormat] The GML format to use to parse the response.
 * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.
 * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.
 * @property {string} [version='1.1.0'] WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.
 */ /**
 * @typedef {Object} WriteGetFeatureOptions
 * @property {string} featureNS The namespace URI used for features.
 * @property {string} featurePrefix The prefix for the feature namespace.
 * @property {Array<string|FeatureType>} featureTypes The feature type names or FeatureType objects to
 * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are
 * ignored.).
 * @property {string} [srsName] SRS name. No srsName attribute will be set on
 * geometries when this is not provided.
 * @property {string} [handle] Handle.
 * @property {string} [outputFormat] Output format.
 * @property {number} [maxFeatures] Maximum number of features to fetch.
 * @property {string} [geometryName] Geometry name to use in a BBOX filter.
 * @property {Array<string>} [propertyNames] Optional list of property names to serialize.
 * @property {string} [viewParams] viewParams GeoServer vendor parameter.
 * @property {number} [startIndex] Start index to use for WFS paging. This is a
 * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.
 * @property {number} [count] Number of features to retrieve when paging. This is a
 * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some
 * Web Feature Services have repurposed `maxfeatures` instead.
 * @property {import("../extent.js").Extent} [bbox] Extent to use for the BBOX filter. The `geometryName`
 * option must be set.
 * @property {import("./filter/Filter.js").default} [filter] Filter condition. See
 * {@link module:ol/format/filter} for more information.
 * @property {string} [resultType] Indicates what response should be returned,
 * e.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.
 */ /**
 * @typedef {Object} FeatureType
 * @property {!string} name The feature type name.
 * @property {!import("../extent.js").Extent} bbox Extent to use for the BBOX filter.
 * @property {!string} geometryName Geometry name to use in the BBOX filter.
 */ /**
 * @typedef {Object} WriteTransactionOptions
 * @property {string} featureNS The namespace URI used for features.
 * @property {string} featurePrefix The prefix for the feature namespace.
 * @property {string} featureType The feature type name.
 * @property {string} [srsName] SRS name. No srsName attribute will be set on
 * geometries when this is not provided.
 * @property {string} [handle] Handle.
 * @property {boolean} [hasZ] Must be set to true if the transaction is for
 * a 3D layer. This will allow the Z coordinate to be included in the transaction.
 * @property {Array<Object>} nativeElements Native elements. Currently not supported.
 * @property {import("./GMLBase.js").Options} [gmlOptions] GML options for the WFS transaction writer.
 * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.
 */ /**
 * Number of features; bounds/extent.
 * @typedef {Object} FeatureCollectionMetadata
 * @property {number} numberOfFeatures NumberOfFeatures.
 * @property {import("../extent.js").Extent} bounds Bounds.
 */ /**
 * Total deleted; total inserted; total updated; array of insert ids.
 * @typedef {Object} TransactionResponse
 * @property {number} totalDeleted TotalDeleted.
 * @property {number} totalInserted TotalInserted.
 * @property {number} totalUpdated TotalUpdated.
 * @property {Array<string>} insertIds InsertIds.
 */ /**
 * @type {string}
 */ const FEATURE_PREFIX = 'feature';
/**
 * @type {string}
 */ const XMLNS = 'http://www.w3.org/2000/xmlns/';
/**
 * @type {Object<string, string>}
 */ const OGCNS = {
    '2.0.0': 'http://www.opengis.net/ogc/1.1',
    '1.1.0': 'http://www.opengis.net/ogc',
    '1.0.0': 'http://www.opengis.net/ogc'
};
/**
 * @type {Object<string, string>}
 */ const WFSNS = {
    '2.0.0': 'http://www.opengis.net/wfs/2.0',
    '1.1.0': 'http://www.opengis.net/wfs',
    '1.0.0': 'http://www.opengis.net/wfs'
};
/**
 * @type {Object<string, string>}
 */ const FESNS = {
    '2.0.0': 'http://www.opengis.net/fes/2.0',
    '1.1.0': 'http://www.opengis.net/fes',
    '1.0.0': 'http://www.opengis.net/fes'
};
/**
 * @type {Object<string, string>}
 */ const SCHEMA_LOCATIONS = {
    '2.0.0': 'http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd',
    '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',
    '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'
};
/**
 * @type {Object<string, object>}
 */ const GML_FORMATS = {
    '2.0.0': (0, _gml32JsDefault.default),
    '1.1.0': (0, _gml3JsDefault.default),
    '1.0.0': (0, _gml2JsDefault.default)
};
/**
 * @const
 * @type {string}
 */ const DEFAULT_VERSION = '1.1.0';
/**
 * @classdesc
 * Feature format for reading and writing data in the WFS format.
 * By default, supports WFS version 1.1.0. You can pass a GML format
 * as option to override the default.
 * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.
 *
 * @api
 */ class WFS extends (0, _xmlfeatureJsDefault.default) {
    /**
   * @param {Options} [options] Optional configuration object.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @private
     * @type {string}
     */ this.version_ = options.version ? options.version : DEFAULT_VERSION;
        /**
     * @private
     * @type {Array<string>|string|undefined}
     */ this.featureType_ = options.featureType;
        /**
     * @private
     * @type {Object<string, string>|string|undefined}
     */ this.featureNS_ = options.featureNS;
        /**
     * @private
     * @type {GMLBase}
     */ this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[this.version_]();
        /**
     * @private
     * @type {string}
     */ this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[this.version_];
    }
    /**
   * @return {Array<string>|string|undefined} featureType
   */ getFeatureType() {
        return this.featureType_;
    }
    /**
   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
   */ setFeatureType(featureType) {
        this.featureType_ = featureType;
    }
    /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */ readFeaturesFromNode(node, options) {
        /** @type {import("../xml.js").NodeStackItem} */ const context = {
            node
        };
        Object.assign(context, {
            'featureType': this.featureType_,
            'featureNS': this.featureNS_
        });
        Object.assign(context, this.getReadOptions(node, options ? options : {}));
        const objectStack = [
            context
        ];
        let featuresNS;
        if (this.version_ === '2.0.0') featuresNS = FEATURE_COLLECTION_PARSERS;
        else featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
        let features = (0, _xmlJs.pushParseAndPop)([], featuresNS, node, objectStack, this.gmlFormat_);
        if (!features) features = [];
        return features;
    }
    /**
   * Read transaction response of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {TransactionResponse|undefined} Transaction response.
   * @api
   */ readTransactionResponse(source) {
        if (!source) return undefined;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readTransactionResponseFromDocument(doc);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readTransactionResponseFromDocument(/** @type {Document} */ source);
        return this.readTransactionResponseFromNode(/** @type {Element} */ source);
    }
    /**
   * Read feature collection metadata of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   * @api
   */ readFeatureCollectionMetadata(source) {
        if (!source) return undefined;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readFeatureCollectionMetadataFromDocument(doc);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readFeatureCollectionMetadataFromDocument(/** @type {Document} */ source);
        return this.readFeatureCollectionMetadataFromNode(/** @type {Element} */ source);
    }
    /**
   * @param {Document} doc Document.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */ readFeatureCollectionMetadataFromDocument(doc) {
        for(let n = /** @type {Node} */ doc.firstChild; n; n = n.nextSibling){
            if (n.nodeType == Node.ELEMENT_NODE) return this.readFeatureCollectionMetadataFromNode(/** @type {Element} */ n);
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */ readFeatureCollectionMetadataFromNode(node) {
        const result = {};
        const value = (0, _xsdJs.readNonNegativeIntegerString)(node.getAttribute('numberOfFeatures'));
        result['numberOfFeatures'] = value;
        return (0, _xmlJs.pushParseAndPop)(/** @type {FeatureCollectionMetadata} */ result, FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);
    }
    /**
   * @param {Document} doc Document.
   * @return {TransactionResponse|undefined} Transaction response.
   */ readTransactionResponseFromDocument(doc) {
        for(let n = /** @type {Node} */ doc.firstChild; n; n = n.nextSibling){
            if (n.nodeType == Node.ELEMENT_NODE) return this.readTransactionResponseFromNode(/** @type {Element} */ n);
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @return {TransactionResponse|undefined} Transaction response.
   */ readTransactionResponseFromNode(node) {
        return (0, _xmlJs.pushParseAndPop)(/** @type {TransactionResponse} */ {}, TRANSACTION_RESPONSE_PARSERS, node, []);
    }
    /**
   * Encode format as WFS `GetFeature` and return the Node.
   *
   * @param {WriteGetFeatureOptions} options Options.
   * @return {Node} Result.
   * @api
   */ writeGetFeature(options) {
        const node = (0, _xmlJs.createElementNS)(WFSNS[this.version_], 'GetFeature');
        node.setAttribute('service', 'WFS');
        node.setAttribute('version', this.version_);
        if (options.handle) node.setAttribute('handle', options.handle);
        if (options.outputFormat) node.setAttribute('outputFormat', options.outputFormat);
        if (options.maxFeatures !== undefined) node.setAttribute('maxFeatures', String(options.maxFeatures));
        if (options.resultType) node.setAttribute('resultType', options.resultType);
        if (options.startIndex !== undefined) node.setAttribute('startIndex', String(options.startIndex));
        if (options.count !== undefined) node.setAttribute('count', String(options.count));
        if (options.viewParams !== undefined) node.setAttribute('viewParams', options.viewParams);
        node.setAttributeNS((0, _xmlJs.XML_SCHEMA_INSTANCE_URI), 'xsi:schemaLocation', this.schemaLocation_);
        /** @type {import("../xml.js").NodeStackItem} */ const context = {
            node
        };
        Object.assign(context, {
            'version': this.version_,
            'srsName': options.srsName,
            'featureNS': options.featureNS ? options.featureNS : this.featureNS_,
            'featurePrefix': options.featurePrefix,
            'propertyNames': options.propertyNames ? options.propertyNames : []
        });
        (0, _assertsJs.assert)(Array.isArray(options.featureTypes), '`options.featureTypes` must be an Array');
        if (typeof options.featureTypes[0] === 'string') {
            let filter = options.filter;
            if (options.bbox) {
                (0, _assertsJs.assert)(options.geometryName, '`options.geometryName` must also be provided when `options.bbox` is set');
                filter = this.combineBboxAndFilter(options.geometryName, options.bbox, options.srsName, filter);
            }
            Object.assign(context, {
                'geometryName': options.geometryName,
                'filter': filter
            });
            writeGetFeature(node, /** @type {!Array<string>} */ options.featureTypes, [
                context
            ]);
        } else // Write one query node per element in featuresType.
        options.featureTypes.forEach((/** @type {FeatureType} */ featureType)=>{
            const completeFilter = this.combineBboxAndFilter(featureType.geometryName, featureType.bbox, options.srsName, options.filter);
            Object.assign(context, {
                'geometryName': featureType.geometryName,
                'filter': completeFilter
            });
            writeGetFeature(node, [
                featureType.name
            ], [
                context
            ]);
        });
        return node;
    }
    /**
   * Create a bbox filter and combine it with another optional filter.
   *
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   * @param {import("./filter/Filter.js").default} [filter] Filter condition.
   * @return {import("./filter/Filter.js").default} The filter.
   */ combineBboxAndFilter(geometryName, extent, srsName, filter) {
        const bboxFilter = (0, _filterJs.bbox)(geometryName, extent, srsName);
        if (filter) // if bbox and filter are both set, combine the two into a single filter
        return (0, _filterJs.and)(filter, bboxFilter);
        return bboxFilter;
    }
    /**
   * Encode format as WFS `Transaction` and return the Node.
   *
   * @param {Array<import("../Feature.js").default>} inserts The features to insert.
   * @param {Array<import("../Feature.js").default>} updates The features to update.
   * @param {Array<import("../Feature.js").default>} deletes The features to delete.
   * @param {WriteTransactionOptions} options Write options.
   * @return {Node} Result.
   * @api
   */ writeTransaction(inserts, updates, deletes, options) {
        const objectStack = [];
        const version = options.version ? options.version : this.version_;
        const node = (0, _xmlJs.createElementNS)(WFSNS[version], 'Transaction');
        node.setAttribute('service', 'WFS');
        node.setAttribute('version', version);
        let baseObj;
        /** @type {import("../xml.js").NodeStackItem} */ if (options) {
            baseObj = options.gmlOptions ? options.gmlOptions : {};
            if (options.handle) node.setAttribute('handle', options.handle);
        }
        node.setAttributeNS((0, _xmlJs.XML_SCHEMA_INSTANCE_URI), 'xsi:schemaLocation', SCHEMA_LOCATIONS[version]);
        const request = createTransactionRequest(node, baseObj, version, options);
        if (inserts) serializeTransactionRequest('Insert', inserts, objectStack, request);
        if (updates) serializeTransactionRequest('Update', updates, objectStack, request);
        if (deletes) serializeTransactionRequest('Delete', deletes, objectStack, request);
        if (options.nativeElements) serializeTransactionRequest('Native', options.nativeElements, objectStack, request);
        return node;
    }
    /**
   * @param {Document} doc Document.
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromDocument(doc) {
        for(let n = doc.firstChild; n; n = n.nextSibling){
            if (n.nodeType == Node.ELEMENT_NODE) return this.readProjectionFromNode(/** @type {Element} */ n);
        }
        return null;
    }
    /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromNode(node) {
        if (node.firstElementChild && node.firstElementChild.firstElementChild) {
            node = node.firstElementChild.firstElementChild;
            for(let n = node.firstElementChild; n; n = n.nextElementSibling)if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {
                const objectStack = [
                    {}
                ];
                this.gmlFormat_.readGeometryElement(n, objectStack);
                return (0, _projJs.get)(objectStack.pop().srsName);
            }
        }
        return null;
    }
}
/**
 * @param {Element} node Node.
 * @param {*} baseObj Base object.
 * @param {string} version Version.
 * @param {WriteTransactionOptions} options Options.
 * @return {Object} Request object.
 */ function createTransactionRequest(node, baseObj, version, options) {
    const featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;
    let gmlVersion;
    if (version === '1.0.0') gmlVersion = 2;
    else if (version === '1.1.0') gmlVersion = 3;
    else if (version === '2.0.0') gmlVersion = 3.2;
    const obj = Object.assign({
        node
    }, {
        version,
        'featureNS': options.featureNS,
        'featureType': options.featureType,
        'featurePrefix': featurePrefix,
        'gmlVersion': gmlVersion,
        'hasZ': options.hasZ,
        'srsName': options.srsName
    }, baseObj);
    return obj;
}
/**
 * @param {string} type Request type.
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {Array<*>} objectStack Object stack.
 * @param {Element} request Transaction Request.
 */ function serializeTransactionRequest(type, features, objectStack, request) {
    (0, _xmlJs.pushSerializeAndPop)(request, TRANSACTION_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)(type), features, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Object|undefined} Transaction Summary.
 */ function readTransactionSummary(node, objectStack) {
    return (0, _xmlJs.pushParseAndPop)({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ const OGC_FID_PARSERS = {
    'http://www.opengis.net/ogc': {
        'FeatureId': (0, _xmlJs.makeArrayPusher)(function(node, objectStack) {
            return node.getAttribute('fid');
        })
    },
    'http://www.opengis.net/ogc/1.1': {
        'FeatureId': (0, _xmlJs.makeArrayPusher)(function(node, objectStack) {
            return node.getAttribute('fid');
        })
    }
};
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 */ function fidParser(node, objectStack) {
    (0, _xmlJs.parseNode)(OGC_FID_PARSERS, node, objectStack);
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ const INSERT_RESULTS_PARSERS = {
    'http://www.opengis.net/wfs': {
        'Feature': fidParser
    },
    'http://www.opengis.net/wfs/2.0': {
        'Feature': fidParser
    }
};
/**
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @return {Array<string>|undefined} Insert results.
 */ function readInsertResults(node, objectStack) {
    return (0, _xmlJs.pushParseAndPop)([], INSERT_RESULTS_PARSERS, node, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */ function writeFeature(node, feature, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const featureType = context['featureType'];
    const featureNS = context['featureNS'];
    const gmlVersion = context['gmlVersion'];
    const child = (0, _xmlJs.createElementNS)(featureNS, featureType);
    node.appendChild(child);
    if (gmlVersion === 2) (0, _gml2JsDefault.default).prototype.writeFeatureElement(child, feature, objectStack);
    else if (gmlVersion === 3) (0, _gml3JsDefault.default).prototype.writeFeatureElement(child, feature, objectStack);
    else (0, _gml32JsDefault.default).prototype.writeFeatureElement(child, feature, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {number|string} fid Feature identifier.
 * @param {Array<*>} objectStack Node stack.
 */ function writeOgcFidFilter(node, fid, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const version = context['version'];
    const ns = OGCNS[version];
    const filter = (0, _xmlJs.createElementNS)(ns, 'Filter');
    const child = (0, _xmlJs.createElementNS)(ns, 'FeatureId');
    filter.appendChild(child);
    child.setAttribute('fid', /** @type {string} */ fid);
    node.appendChild(filter);
}
/**
 * @param {string|undefined} featurePrefix The prefix of the feature.
 * @param {string} featureType The type of the feature.
 * @return {string} The value of the typeName property.
 */ function getTypeName(featurePrefix, featureType) {
    featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;
    const prefix = featurePrefix + ':';
    // The featureType already contains the prefix.
    if (featureType.startsWith(prefix)) return featureType;
    return prefix + featureType;
}
/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */ function writeDelete(node, feature, objectStack) {
    const context = objectStack[objectStack.length - 1];
    (0, _assertsJs.assert)(feature.getId() !== undefined, 'Features must have an id set');
    const featureType = context['featureType'];
    const featurePrefix = context['featurePrefix'];
    const featureNS = context['featureNS'];
    const typeName = getTypeName(featurePrefix, featureType);
    node.setAttribute('typeName', typeName);
    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
    const fid = feature.getId();
    if (fid !== undefined) writeOgcFidFilter(node, fid, objectStack);
}
/**
 * @param {Element} node Node.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {Array<*>} objectStack Node stack.
 */ function writeUpdate(node, feature, objectStack) {
    const context = objectStack[objectStack.length - 1];
    (0, _assertsJs.assert)(feature.getId() !== undefined, 'Features must have an id set');
    const version = context['version'];
    const featureType = context['featureType'];
    const featurePrefix = context['featurePrefix'];
    const featureNS = context['featureNS'];
    const typeName = getTypeName(featurePrefix, featureType);
    const geometryName = feature.getGeometryName();
    node.setAttribute('typeName', typeName);
    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
    const fid = feature.getId();
    if (fid !== undefined) {
        const keys = feature.getKeys();
        const values = [];
        for(let i = 0, ii = keys.length; i < ii; i++){
            const value = feature.get(keys[i]);
            if (value !== undefined) {
                let name = keys[i];
                if (value && typeof /** @type {?} */ value.getSimplifiedGeometry === 'function') name = geometryName;
                values.push({
                    name: name,
                    value: value
                });
            }
        }
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ {
            version,
            'gmlVersion': context['gmlVersion'],
            node,
            'hasZ': context['hasZ'],
            'srsName': context['srsName']
        }, TRANSACTION_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)('Property'), values, objectStack);
        writeOgcFidFilter(node, fid, objectStack);
    }
}
/**
 * @param {Node} node Node.
 * @param {Object} pair Property name and value.
 * @param {Array<*>} objectStack Node stack.
 */ function writeProperty(node, pair, objectStack) {
    const context = objectStack[objectStack.length - 1];
    const version = context['version'];
    const ns = WFSNS[version];
    const tagName = version === '2.0.0' ? 'ValueReference' : 'Name';
    const name = (0, _xmlJs.createElementNS)(ns, tagName);
    const gmlVersion = context['gmlVersion'];
    node.appendChild(name);
    (0, _xsdJs.writeStringTextNode)(name, pair.name);
    if (pair.value !== undefined && pair.value !== null) {
        const value = (0, _xmlJs.createElementNS)(ns, 'Value');
        node.appendChild(value);
        if (pair.value && typeof /** @type {?} */ pair.value.getSimplifiedGeometry === 'function') {
            if (gmlVersion === 2) (0, _gml2JsDefault.default).prototype.writeGeometryElement(value, pair.value, objectStack);
            else if (gmlVersion === 3) (0, _gml3JsDefault.default).prototype.writeGeometryElement(value, pair.value, objectStack);
            else (0, _gml32JsDefault.default).prototype.writeGeometryElement(value, pair.value, objectStack);
        } else (0, _xsdJs.writeStringTextNode)(value, pair.value);
    }
}
/**
 * @param {Element} node Node.
 * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.
 * @param {Array<*>} objectStack Node stack.
 */ function writeNative(node, nativeElement, objectStack) {
    if (nativeElement.vendorId) node.setAttribute('vendorId', nativeElement.vendorId);
    if (nativeElement.safeToIgnore !== undefined) node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));
    if (nativeElement.value !== undefined) (0, _xsdJs.writeStringTextNode)(node, nativeElement.value);
}
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ const GETFEATURE_SERIALIZERS = {
    'http://www.opengis.net/wfs': {
        'Query': (0, _xmlJs.makeChildAppender)(writeQuery)
    },
    'http://www.opengis.net/wfs/2.0': {
        'Query': (0, _xmlJs.makeChildAppender)(writeQuery)
    },
    'http://www.opengis.net/ogc': {
        'During': (0, _xmlJs.makeChildAppender)(writeDuringFilter),
        'And': (0, _xmlJs.makeChildAppender)(writeLogicalFilter),
        'Or': (0, _xmlJs.makeChildAppender)(writeLogicalFilter),
        'Not': (0, _xmlJs.makeChildAppender)(writeNotFilter),
        'BBOX': (0, _xmlJs.makeChildAppender)(writeBboxFilter),
        'Contains': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'Intersects': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'Within': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'DWithin': (0, _xmlJs.makeChildAppender)(writeDWithinFilter),
        'PropertyIsEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsNotEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsLessThan': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsLessThanOrEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsGreaterThan': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsGreaterThanOrEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsNull': (0, _xmlJs.makeChildAppender)(writeIsNullFilter),
        'PropertyIsBetween': (0, _xmlJs.makeChildAppender)(writeIsBetweenFilter),
        'PropertyIsLike': (0, _xmlJs.makeChildAppender)(writeIsLikeFilter)
    },
    'http://www.opengis.net/fes/2.0': {
        'During': (0, _xmlJs.makeChildAppender)(writeDuringFilter),
        'And': (0, _xmlJs.makeChildAppender)(writeLogicalFilter),
        'Or': (0, _xmlJs.makeChildAppender)(writeLogicalFilter),
        'Not': (0, _xmlJs.makeChildAppender)(writeNotFilter),
        'BBOX': (0, _xmlJs.makeChildAppender)(writeBboxFilter),
        'Contains': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'Disjoint': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'Intersects': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'ResourceId': (0, _xmlJs.makeChildAppender)(writeResourceIdFilter),
        'Within': (0, _xmlJs.makeChildAppender)(writeSpatialFilter),
        'DWithin': (0, _xmlJs.makeChildAppender)(writeDWithinFilter),
        'PropertyIsEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsNotEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsLessThan': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsLessThanOrEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsGreaterThan': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsGreaterThanOrEqualTo': (0, _xmlJs.makeChildAppender)(writeComparisonFilter),
        'PropertyIsNull': (0, _xmlJs.makeChildAppender)(writeIsNullFilter),
        'PropertyIsBetween': (0, _xmlJs.makeChildAppender)(writeIsBetweenFilter),
        'PropertyIsLike': (0, _xmlJs.makeChildAppender)(writeIsLikeFilter)
    }
};
/**
 * @param {Element} node Node.
 * @param {string} featureType Feature type.
 * @param {Array<*>} objectStack Node stack.
 */ function writeQuery(node, featureType, objectStack) {
    const context = /** @type {Object} */ objectStack[objectStack.length - 1];
    const version = context['version'];
    const featurePrefix = context['featurePrefix'];
    const featureNS = context['featureNS'];
    const propertyNames = context['propertyNames'];
    const srsName = context['srsName'];
    let typeName;
    // If feature prefix is not defined, we must not use the default prefix.
    if (featurePrefix) typeName = getTypeName(featurePrefix, featureType);
    else typeName = featureType;
    let typeNameAttr;
    if (version === '2.0.0') typeNameAttr = 'typeNames';
    else typeNameAttr = 'typeName';
    node.setAttribute(typeNameAttr, typeName);
    if (srsName) node.setAttribute('srsName', srsName);
    if (featureNS) node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);
    const item = /** @type {import("../xml.js").NodeStackItem} */ Object.assign({}, context);
    item.node = node;
    (0, _xmlJs.pushSerializeAndPop)(item, QUERY_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)('PropertyName'), propertyNames, objectStack);
    const filter = context['filter'];
    if (filter) {
        const child = (0, _xmlJs.createElementNS)(getFilterNS(version), 'Filter');
        node.appendChild(child);
        writeFilterCondition(child, filter, objectStack);
    }
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/Filter.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeFilterCondition(node, filter, objectStack) {
    const context = /** @type {Object} */ objectStack[objectStack.length - 1];
    /** @type {import("../xml.js").NodeStackItem} */ const item = {
        node
    };
    Object.assign(item, {
        context
    });
    (0, _xmlJs.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)(filter.getTagName()), [
        filter
    ], objectStack);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/Bbox.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeBboxFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    parent['srsName'] = filter.srsName;
    const format = GML_FORMATS[version];
    writePropertyName(version, node, filter.geometryName);
    format.prototype.writeGeometryElement(node, filter.extent, objectStack);
}
/**
 * @param {Element} node Element.
 * @param {import("./filter/ResourceId.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeResourceIdFilter(node, filter, objectStack) {
    node.setAttribute('rid', /** @type {string} */ filter.rid);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/Spatial.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeSpatialFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    parent['srsName'] = filter.srsName;
    const format = GML_FORMATS[version];
    writePropertyName(version, node, filter.geometryName);
    format.prototype.writeGeometryElement(node, filter.geometry, objectStack);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/DWithin.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeDWithinFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    writeSpatialFilter(node, filter, objectStack);
    const distance = (0, _xmlJs.createElementNS)(getFilterNS(version), 'Distance');
    (0, _xsdJs.writeStringTextNode)(distance, filter.distance.toString());
    if (version === '2.0.0') distance.setAttribute('uom', filter.unit);
    else distance.setAttribute('units', filter.unit);
    node.appendChild(distance);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/During.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeDuringFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    writeExpression(FESNS[version], 'ValueReference', node, filter.propertyName);
    const timePeriod = (0, _xmlJs.createElementNS)((0, _gmlbaseJs.GMLNS), 'TimePeriod');
    node.appendChild(timePeriod);
    const begin = (0, _xmlJs.createElementNS)((0, _gmlbaseJs.GMLNS), 'begin');
    timePeriod.appendChild(begin);
    writeTimeInstant(begin, filter.begin);
    const end = (0, _xmlJs.createElementNS)((0, _gmlbaseJs.GMLNS), 'end');
    timePeriod.appendChild(end);
    writeTimeInstant(end, filter.end);
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/LogicalNary.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeLogicalFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    /** @type {import("../xml.js").NodeStackItem} */ const item = {
        node
    };
    Object.assign(item, {
        context
    });
    const conditions = filter.conditions;
    for(let i = 0, ii = conditions.length; i < ii; ++i){
        const condition = conditions[i];
        (0, _xmlJs.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)(condition.getTagName()), [
            condition
        ], objectStack);
    }
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/Not.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeNotFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    /** @type {import("../xml.js").NodeStackItem} */ const item = {
        node
    };
    Object.assign(item, {
        context
    });
    const condition = filter.condition;
    (0, _xmlJs.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)(condition.getTagName()), [
        condition
    ], objectStack);
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/ComparisonBinary.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeComparisonFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    if (filter.matchCase !== undefined) node.setAttribute('matchCase', filter.matchCase.toString());
    writePropertyName(version, node, filter.propertyName);
    writeLiteral(version, node, '' + filter.expression);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/IsNull.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeIsNullFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    writePropertyName(version, node, filter.propertyName);
}
/**
 * @param {Node} node Node.
 * @param {import("./filter/IsBetween.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeIsBetweenFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    const ns = getFilterNS(version);
    writePropertyName(version, node, filter.propertyName);
    const lowerBoundary = (0, _xmlJs.createElementNS)(ns, 'LowerBoundary');
    node.appendChild(lowerBoundary);
    writeLiteral(version, lowerBoundary, '' + filter.lowerBoundary);
    const upperBoundary = (0, _xmlJs.createElementNS)(ns, 'UpperBoundary');
    node.appendChild(upperBoundary);
    writeLiteral(version, upperBoundary, '' + filter.upperBoundary);
}
/**
 * @param {Element} node Node.
 * @param {import("./filter/IsLike.js").default} filter Filter.
 * @param {Array<*>} objectStack Node stack.
 */ function writeIsLikeFilter(node, filter, objectStack) {
    const parent = /** @type {Object} */ objectStack[objectStack.length - 1];
    const context = parent['context'];
    const version = context['version'];
    node.setAttribute('wildCard', filter.wildCard);
    node.setAttribute('singleChar', filter.singleChar);
    node.setAttribute('escapeChar', filter.escapeChar);
    if (filter.matchCase !== undefined) node.setAttribute('matchCase', filter.matchCase.toString());
    writePropertyName(version, node, filter.propertyName);
    writeLiteral(version, node, '' + filter.pattern);
}
/**
 * @param {string} ns Namespace.
 * @param {string} tagName Tag name.
 * @param {Node} node Node.
 * @param {string} value Value.
 */ function writeExpression(ns, tagName, node, value) {
    const property = (0, _xmlJs.createElementNS)(ns, tagName);
    (0, _xsdJs.writeStringTextNode)(property, value);
    node.appendChild(property);
}
/**
 * @param {string} version Version.
 * @param {Node} node Node.
 * @param {string} value PropertyName value.
 */ function writeLiteral(version, node, value) {
    writeExpression(getFilterNS(version), 'Literal', node, value);
}
/**
 * @param {string} version Version.
 * @param {Node} node Node.
 * @param {string} value PropertyName value.
 */ function writePropertyName(version, node, value) {
    if (version === '2.0.0') writeExpression(FESNS[version], 'ValueReference', node, value);
    else writeExpression(OGCNS[version], 'PropertyName', node, value);
}
/**
 * @param {Node} node Node.
 * @param {string} time PropertyName value.
 */ function writeTimeInstant(node, time) {
    const timeInstant = (0, _xmlJs.createElementNS)((0, _gmlbaseJs.GMLNS), 'TimeInstant');
    node.appendChild(timeInstant);
    const timePosition = (0, _xmlJs.createElementNS)((0, _gmlbaseJs.GMLNS), 'timePosition');
    timeInstant.appendChild(timePosition);
    (0, _xsdJs.writeStringTextNode)(timePosition, time);
}
function writeFilter(filter, version) {
    version = version || '1.1.0';
    const child = (0, _xmlJs.createElementNS)(getFilterNS(version), 'Filter');
    const context = {
        node: child
    };
    Object.assign(context, {
        'version': version,
        'filter': filter
    });
    writeFilterCondition(child, filter, [
        context
    ]);
    return child;
}
/**
 * @param {Element} node Node.
 * @param {Array<string>} featureTypes Feature types.
 * @param {Array<*>} objectStack Node stack.
 */ function writeGetFeature(node, featureTypes, objectStack) {
    const context = /** @type {Object} */ objectStack[objectStack.length - 1];
    const item = /** @type {import("../xml.js").NodeStackItem} */ Object.assign({}, context);
    item.node = node;
    (0, _xmlJs.pushSerializeAndPop)(item, GETFEATURE_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)('Query'), featureTypes, objectStack);
}
function getFilterNS(version) {
    let ns;
    if (version === '2.0.0') ns = FESNS[version];
    else ns = OGCNS[version];
    return ns;
}
exports.default = WFS;

},{"./GML2.js":"9tsJN","./GML3.js":"doSR5","./GML32.js":"dFH2d","./GMLBase.js":"9rBB8","./XMLFeature.js":"aeYmP","../xml.js":"kPa2a","./filter.js":"1wziX","../asserts.js":"e4TiF","../proj.js":"SznqC","./xsd.js":"8AOX3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9tsJN":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/GML2
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _gmlbaseJs = require("./GMLBase.js");
var _gmlbaseJsDefault = parcelHelpers.interopDefault(_gmlbaseJs);
var _xmlJs = require("../xml.js");
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _featureJs = require("./Feature.js");
var _xsdJs = require("./xsd.js");
/**
 * @const
 * @type {string}
 */ const schemaLocation = (0, _gmlbaseJs.GMLNS) + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';
/**
 * @const
 * @type {Object<string, string>}
 */ const MULTIGEOMETRY_TO_MEMBER_NODENAME = {
    'MultiLineString': 'lineStringMember',
    'MultiCurve': 'curveMember',
    'MultiPolygon': 'polygonMember',
    'MultiSurface': 'surfaceMember'
};
/**
 * @classdesc
 * Feature format for reading and writing data in the GML format,
 * version 2.1.2.
 *
 * @api
 */ class GML2 extends (0, _gmlbaseJsDefault.default) {
    /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */ constructor(options){
        options = options ? options : {};
        super(options);
        this.FEATURE_COLLECTION_PARSERS[0, _gmlbaseJs.GMLNS]['featureMember'] = (0, _xmlJs.makeArrayPusher)(this.readFeaturesInternal);
        /**
     * @type {string}
     */ this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
    }
    /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */ readFlatCoordinates(node, objectStack) {
        const s = (0, _xmlJs.getAllTextContent)(node, false).replace(/^\s*|\s*$/g, '');
        const context = /** @type {import("../xml.js").NodeStackItem} */ objectStack[0];
        const containerSrs = context['srsName'];
        let axisOrientation = 'enu';
        if (containerSrs) {
            const proj = (0, _projJs.get)(containerSrs);
            if (proj) axisOrientation = proj.getAxisOrientation();
        }
        const coordsGroups = s.trim().split(/\s+/);
        const flatCoordinates = [];
        for(let i = 0, ii = coordsGroups.length; i < ii; i++){
            const coords = coordsGroups[i].split(/,+/);
            const x = parseFloat(coords[0]);
            const y = parseFloat(coords[1]);
            const z = coords.length === 3 ? parseFloat(coords[2]) : 0;
            if (axisOrientation.substr(0, 2) === 'en') flatCoordinates.push(x, y, z);
            else flatCoordinates.push(y, x, z);
        }
        return flatCoordinates;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */ readBox(node, objectStack) {
        /** @type {Array<number>} */ const flatCoordinates = (0, _xmlJs.pushParseAndPop)([
            null
        ], this.BOX_PARSERS_, node, objectStack, this);
        return (0, _extentJs.createOrUpdate)(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ innerBoundaryIsParser(node, objectStack) {
        /** @type {Array<number>|undefined} */ const flatLinearRing = (0, _xmlJs.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */ objectStack[objectStack.length - 1];
            flatLinearRings.push(flatLinearRing);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ outerBoundaryIsParser(node, objectStack) {
        /** @type {Array<number>|undefined} */ const flatLinearRing = (0, _xmlJs.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */ objectStack[objectStack.length - 1];
            flatLinearRings[0] = flatLinearRing;
        }
    }
    /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */ GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {
        const context = objectStack[objectStack.length - 1];
        const multiSurface = context['multiSurface'];
        const surface = context['surface'];
        const multiCurve = context['multiCurve'];
        if (!Array.isArray(value)) {
            nodeName = /** @type {import("../geom/Geometry.js").default} */ value.getType();
            if (nodeName === 'MultiPolygon' && multiSurface === true) nodeName = 'MultiSurface';
            else if (nodeName === 'Polygon' && surface === true) nodeName = 'Surface';
            else if (nodeName === 'MultiLineString' && multiCurve === true) nodeName = 'MultiCurve';
        } else nodeName = 'Envelope';
        return (0, _xmlJs.createElementNS)('http://www.opengis.net/gml', nodeName);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */ writeFeatureElement(node, feature, objectStack) {
        const fid = feature.getId();
        if (fid) node.setAttribute('fid', /** @type {string} */ fid);
        const context = /** @type {Object} */ objectStack[objectStack.length - 1];
        const featureNS = context['featureNS'];
        const geometryName = feature.getGeometryName();
        if (!context.serializers) {
            context.serializers = {};
            context.serializers[featureNS] = {};
        }
        const keys = [];
        const values = [];
        if (feature.hasProperties()) {
            const properties = feature.getProperties();
            for(const key in properties){
                const value = properties[key];
                if (value !== null) {
                    keys.push(key);
                    values.push(value);
                    if (key == geometryName || typeof /** @type {?} */ value.getSimplifiedGeometry === 'function') {
                        if (!(key in context.serializers[featureNS])) context.serializers[featureNS][key] = (0, _xmlJs.makeChildAppender)(this.writeGeometryElement, this);
                    } else if (!(key in context.serializers[featureNS])) context.serializers[featureNS][key] = (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode));
                }
            }
        }
        const item = Object.assign({}, context);
        item.node = node;
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ item, context.serializers, (0, _xmlJs.makeSimpleNodeFactory)(undefined, featureNS), values, objectStack, keys);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeCurveOrLineString(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (node.nodeName !== 'LineStringSegment' && srsName) node.setAttribute('srsName', srsName);
        if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {
            const coordinates = this.createCoordinatesNode_(node.namespaceURI);
            node.appendChild(coordinates);
            this.writeCoordinates_(coordinates, geometry, objectStack);
        } else if (node.nodeName === 'Curve') {
            const segments = (0, _xmlJs.createElementNS)(node.namespaceURI, 'segments');
            node.appendChild(segments);
            this.writeCurveSegments_(segments, geometry, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeLineStringOrCurveMember(node, line, objectStack) {
        const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
        if (child) {
            node.appendChild(child);
            this.writeCurveOrLineString(child, line, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiCurveOrLineString(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        const curve = context['curve'];
        if (srsName) node.setAttribute('srsName', srsName);
        const lines = geometry.getLineStrings();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName,
            curve: curve
        }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);
    }
    /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeGeometryElement(node, geometry, objectStack) {
        const context = /** @type {import("./Feature.js").WriteOptions} */ objectStack[objectStack.length - 1];
        const item = Object.assign({}, context);
        item['node'] = node;
        let value;
        if (Array.isArray(geometry)) value = (0, _featureJs.transformExtentWithOptions)(/** @type {import("../extent.js").Extent} */ geometry, context);
        else value = (0, _featureJs.transformGeometryWithOptions)(/** @type {import("../geom/Geometry.js").default} */ geometry, true, context);
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [
            value
        ], objectStack, undefined, this);
    }
    /**
   * @param {string} namespaceURI XML namespace.
   * @return {Element} coordinates node.
   * @private
   */ createCoordinatesNode_(namespaceURI) {
        const coordinates = (0, _xmlJs.createElementNS)(namespaceURI, 'coordinates');
        coordinates.setAttribute('decimal', '.');
        coordinates.setAttribute('cs', ',');
        coordinates.setAttribute('ts', ' ');
        return coordinates;
    }
    /**
   * @param {Node} node Node.
   * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeCoordinates_(node, value, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        // only 2d for simple features profile
        const points = value.getCoordinates();
        const len = points.length;
        const parts = new Array(len);
        for(let i = 0; i < len; ++i){
            const point = points[i];
            parts[i] = this.getCoords_(point, srsName, hasZ);
        }
        (0, _xsdJs.writeStringTextNode)(node, parts.join(' '));
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeCurveSegments_(node, line, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'LineStringSegment');
        node.appendChild(child);
        this.writeCurveOrLineString(child, line, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeSurfaceOrPolygon(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        if (node.nodeName !== 'PolygonPatch' && srsName) node.setAttribute('srsName', srsName);
        if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {
            const rings = geometry.getLinearRings();
            (0, _xmlJs.pushSerializeAndPop)({
                node: node,
                hasZ: hasZ,
                srsName: srsName
            }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);
        } else if (node.nodeName === 'Surface') {
            const patches = (0, _xmlJs.createElementNS)(node.namespaceURI, 'patches');
            node.appendChild(patches);
            this.writeSurfacePatches_(patches, geometry, objectStack);
        }
    }
    /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */ RING_NODE_FACTORY_(value, objectStack, nodeName) {
        const context = objectStack[objectStack.length - 1];
        const parentNode = context.node;
        const exteriorWritten = context['exteriorWritten'];
        if (exteriorWritten === undefined) context['exteriorWritten'] = true;
        return (0, _xmlJs.createElementNS)(parentNode.namespaceURI, exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs');
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeSurfacePatches_(node, polygon, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'PolygonPatch');
        node.appendChild(child);
        this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeRing(node, ring, objectStack) {
        const linearRing = (0, _xmlJs.createElementNS)(node.namespaceURI, 'LinearRing');
        node.appendChild(linearRing);
        this.writeLinearRing(linearRing, ring, objectStack);
    }
    /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */ getCoords_(point, srsName, hasZ) {
        let axisOrientation = 'enu';
        if (srsName) axisOrientation = (0, _projJs.get)(srsName).getAxisOrientation();
        let coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ',' + point[1] : point[1] + ',' + point[0];
        if (hasZ) {
            // For newly created points, Z can be undefined.
            const z = point[2] || 0;
            coords += ',' + z;
        }
        return coords;
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writePoint(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const coordinates = this.createCoordinatesNode_(node.namespaceURI);
        node.appendChild(coordinates);
        const point = geometry.getCoordinates();
        const coord = this.getCoords_(point, srsName, hasZ);
        (0, _xsdJs.writeStringTextNode)(coordinates, coord);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiPoint(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const points = geometry.getPoints();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName
        }, this.POINTMEMBER_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)('pointMember'), points, objectStack, undefined, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writePointMember(node, point, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'Point');
        node.appendChild(child);
        this.writePoint(child, point, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeLinearRing(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const coordinates = this.createCoordinatesNode_(node.namespaceURI);
        node.appendChild(coordinates);
        this.writeCoordinates_(coordinates, geometry, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiSurfaceOrPolygon(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        const surface = context['surface'];
        if (srsName) node.setAttribute('srsName', srsName);
        const polygons = geometry.getPolygons();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName,
            surface: surface
        }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);
    }
    /**
   * @param {Node} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeSurfaceOrPolygonMember(node, polygon, objectStack) {
        const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
        if (child) {
            node.appendChild(child);
            this.writeSurfaceOrPolygon(child, polygon, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */ writeEnvelope(node, extent, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const keys = [
            'lowerCorner',
            'upperCorner'
        ];
        const values = [
            extent[0] + ' ' + extent[1],
            extent[2] + ' ' + extent[3]
        ];
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ {
            node: node
        }, this.ENVELOPE_SERIALIZERS, (0, _xmlJs.OBJECT_PROPERTY_NODE_FACTORY), values, objectStack, keys, this);
    }
    /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */ MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {
        const parentNode = objectStack[objectStack.length - 1].node;
        return (0, _xmlJs.createElementNS)('http://www.opengis.net/gml', MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    'http://www.opengis.net/gml': {
        'coordinates': (0, _xmlJs.makeReplacer)(GML2.prototype.readFlatCoordinates)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    'http://www.opengis.net/gml': {
        'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,
        'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML2.prototype.BOX_PARSERS_ = {
    'http://www.opengis.net/gml': {
        'coordinates': (0, _xmlJs.makeArrayPusher)(GML2.prototype.readFlatCoordinates)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML2.prototype.GEOMETRY_PARSERS = {
    'http://www.opengis.net/gml': {
        'Point': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPoint),
        'MultiPoint': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPoint),
        'LineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLineString),
        'MultiLineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiLineString),
        'LinearRing': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLinearRing),
        'Polygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPolygon),
        'MultiPolygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPolygon),
        'Box': (0, _xmlJs.makeReplacer)(GML2.prototype.readBox)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.GEOMETRY_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'Curve': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeCurveOrLineString),
        'MultiCurve': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeMultiCurveOrLineString),
        'Point': (0, _xmlJs.makeChildAppender)(GML2.prototype.writePoint),
        'MultiPoint': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeMultiPoint),
        'LineString': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeCurveOrLineString),
        'MultiLineString': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeMultiCurveOrLineString),
        'LinearRing': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeLinearRing),
        'Polygon': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygon),
        'MultiPolygon': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeMultiSurfaceOrPolygon),
        'Surface': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygon),
        'MultiSurface': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeMultiSurfaceOrPolygon),
        'Envelope': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeEnvelope)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'lineStringMember': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeLineStringOrCurveMember),
        'curveMember': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeLineStringOrCurveMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.RING_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'outerBoundaryIs': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeRing),
        'innerBoundaryIs': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeRing)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.POINTMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'pointMember': (0, _xmlJs.makeChildAppender)(GML2.prototype.writePointMember)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'surfaceMember': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygonMember),
        'polygonMember': (0, _xmlJs.makeChildAppender)(GML2.prototype.writeSurfaceOrPolygonMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML2.prototype.ENVELOPE_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'lowerCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode)),
        'upperCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode))
    }
};
exports.default = GML2;

},{"./GMLBase.js":"9rBB8","../xml.js":"kPa2a","../extent.js":"6YrVc","../proj.js":"SznqC","./Feature.js":"FZbV5","./xsd.js":"8AOX3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9rBB8":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/GMLBase
 */ // FIXME Envelopes should not be treated as geometries! readEnvelope_ is part
// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect
// envelopes/extents, only geometries!
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GMLNS", ()=>GMLNS);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geometryJs = require("../geom/Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _linearRingJs = require("../geom/LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPointJs = require("../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _xmlfeatureJs = require("./XMLFeature.js");
var _xmlfeatureJsDefault = parcelHelpers.interopDefault(_xmlfeatureJs);
var _arrayJs = require("../array.js");
var _xmlJs = require("../xml.js");
var _projJs = require("../proj.js");
var _featureJs1 = require("./Feature.js");
const GMLNS = 'http://www.opengis.net/gml';
/**
 * A regular expression that matches if a string only contains whitespace
 * characters. It will e.g. match `''`, `' '`, `'\n'` etc.
 *
 * @const
 * @type {RegExp}
 */ const ONLY_WHITESPACE_RE = /^\s*$/;
/**
 * @typedef {Object} Options
 * @property {Object<string, string>|string} [featureNS] Feature
 * namespace. If not defined will be derived from GML. If multiple
 * feature types have been configured which come from different feature
 * namespaces, this will be an object with the keys being the prefixes used
 * in the entries of featureType array. The values of the object will be the
 * feature namespaces themselves. So for instance there might be a featureType
 * item `topp:states` in the `featureType` array and then there will be a key
 * `topp` in the featureNS object with value `http://www.openplans.org/topp`.
 * @property {Array<string>|string} [featureType] Feature type(s) to parse.
 * If multiple feature types need to be configured
 * which come from different feature namespaces, `featureNS` will be an object
 * with the keys being the prefixes used in the entries of featureType array.
 * The values of the object will be the feature namespaces themselves.
 * So for instance there might be a featureType item `topp:states` and then
 * there will be a key named `topp` in the featureNS object with value
 * `http://www.openplans.org/topp`.
 * @property {string} [srsName] srsName to use when writing geometries.
 * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon
 * elements. This also affects the elements in multi-part geometries.
 * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString
 * elements. This also affects the elements in multi-part geometries.
 * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.
 * Since the latter is deprecated in GML 3.
 * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of
 * gml:MultiPolygon. Since the latter is deprecated in GML 3.
 * @property {string} [schemaLocation] Optional schemaLocation to use when
 * writing out the GML, this will override the default provided.
 * @property {boolean} [hasZ=false] If coordinates have a Z value.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Feature base format for reading and writing data in the GML format.
 * This class cannot be instantiated, it contains only base content that
 * is shared with versioned format classes GML2 and GML3.
 *
 * @abstract
 * @api
 */ class GMLBase extends (0, _xmlfeatureJsDefault.default) {
    /**
   * @param {Options} [options] Optional configuration object.
   */ constructor(options){
        super();
        options = options ? options : {};
        /**
     * @protected
     * @type {Array<string>|string|undefined}
     */ this.featureType = options.featureType;
        /**
     * @protected
     * @type {Object<string, string>|string|undefined}
     */ this.featureNS = options.featureNS;
        /**
     * @protected
     * @type {string|undefined}
     */ this.srsName = options.srsName;
        /**
     * @protected
     * @type {string}
     */ this.schemaLocation = '';
        /**
     * @type {Object<string, Object<string, Object>>}
     */ this.FEATURE_COLLECTION_PARSERS = {};
        this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
            'featureMember': (0, _xmlJs.makeArrayPusher)(this.readFeaturesInternal),
            'featureMembers': (0, _xmlJs.makeReplacer)(this.readFeaturesInternal)
        };
        this.supportedMediaTypes = [
            'application/gml+xml'
        ];
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<Feature> | undefined} Features.
   */ readFeaturesInternal(node, objectStack) {
        const localName = node.localName;
        let features = null;
        if (localName == 'FeatureCollection') features = (0, _xmlJs.pushParseAndPop)([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);
        else if (localName == 'featureMembers' || localName == 'featureMember' || localName == 'member') {
            const context = objectStack[0];
            let featureType = context['featureType'];
            let featureNS = context['featureNS'];
            const prefix = 'p';
            const defaultPrefix = 'p0';
            if (!featureType && node.childNodes) {
                featureType = [], featureNS = {};
                for(let i = 0, ii = node.childNodes.length; i < ii; ++i){
                    const child = /** @type {Element} */ node.childNodes[i];
                    if (child.nodeType === 1) {
                        const ft = child.nodeName.split(':').pop();
                        if (!featureType.includes(ft)) {
                            let key = '';
                            let count = 0;
                            const uri = child.namespaceURI;
                            for(const candidate in featureNS){
                                if (featureNS[candidate] === uri) {
                                    key = candidate;
                                    break;
                                }
                                ++count;
                            }
                            if (!key) {
                                key = prefix + count;
                                featureNS[key] = uri;
                            }
                            featureType.push(key + ':' + ft);
                        }
                    }
                }
                if (localName != 'featureMember') {
                    // recheck featureType for each featureMember
                    context['featureType'] = featureType;
                    context['featureNS'] = featureNS;
                }
            }
            if (typeof featureNS === 'string') {
                const ns = featureNS;
                featureNS = {};
                featureNS[defaultPrefix] = ns;
            }
            /** @type {Object<string, Object<string, import("../xml.js").Parser>>} */ const parsersNS = {};
            const featureTypes = Array.isArray(featureType) ? featureType : [
                featureType
            ];
            for(const p in featureNS){
                /** @type {Object<string, import("../xml.js").Parser>} */ const parsers = {};
                for(let i = 0, ii = featureTypes.length; i < ii; ++i){
                    const featurePrefix = featureTypes[i].includes(':') ? featureTypes[i].split(':')[0] : defaultPrefix;
                    if (featurePrefix === p) parsers[featureTypes[i].split(':').pop()] = localName == 'featureMembers' ? (0, _xmlJs.makeArrayPusher)(this.readFeatureElement, this) : (0, _xmlJs.makeReplacer)(this.readFeatureElement, this);
                }
                parsersNS[featureNS[p]] = parsers;
            }
            if (localName == 'featureMember' || localName == 'member') features = (0, _xmlJs.pushParseAndPop)(undefined, parsersNS, node, objectStack);
            else features = (0, _xmlJs.pushParseAndPop)([], parsersNS, node, objectStack);
        }
        if (features === null) features = [];
        return features;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
   */ readGeometryOrExtent(node, objectStack) {
        const context = /** @type {Object} */ objectStack[0];
        context['srsName'] = node.firstElementChild.getAttribute('srsName');
        context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');
        return (0, _xmlJs.pushParseAndPop)(null, this.GEOMETRY_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Geometry.
   */ readExtentElement(node, objectStack) {
        const context = /** @type {Object} */ objectStack[0];
        const extent = /** @type {import("../extent.js").Extent} */ this.readGeometryOrExtent(node, objectStack);
        return extent ? (0, _featureJs1.transformExtentWithOptions)(extent, context) : undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|undefined} Geometry.
   */ readGeometryElement(node, objectStack) {
        const context = /** @type {Object} */ objectStack[0];
        const geometry = /** @type {import("../geom/Geometry.js").default} */ this.readGeometryOrExtent(node, objectStack);
        return geometry ? (0, _featureJs1.transformGeometryWithOptions)(geometry, false, context) : undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {boolean} asFeature whether result should be wrapped as a feature.
   * @return {Feature|Object} Feature
   */ readFeatureElementInternal(node, objectStack, asFeature) {
        let geometryName;
        const values = {};
        for(let n = node.firstElementChild; n; n = n.nextElementSibling){
            let value;
            const localName = n.localName;
            // first, check if it is simple attribute
            if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {
                value = (0, _xmlJs.getAllTextContent)(n, false);
                if (ONLY_WHITESPACE_RE.test(value)) value = undefined;
            } else {
                if (asFeature) //if feature, try it as a geometry or extent
                value = localName === 'boundedBy' ? this.readExtentElement(n, objectStack) : this.readGeometryElement(n, objectStack);
                if (!value) //if not a geometry or not a feature, treat it as a complex attribute
                value = this.readFeatureElementInternal(n, objectStack, false);
                else if (localName !== 'boundedBy') // boundedBy is an extent and must not be considered as a geometry
                geometryName = localName;
            }
            const len = n.attributes.length;
            if (len > 0 && !(value instanceof (0, _geometryJsDefault.default))) {
                value = {
                    _content_: value
                };
                for(let i = 0; i < len; i++){
                    const attName = n.attributes[i].name;
                    value[attName] = n.attributes[i].value;
                }
            }
            if (values[localName]) {
                if (!(values[localName] instanceof Array)) values[localName] = [
                    values[localName]
                ];
                values[localName].push(value);
            } else values[localName] = value;
        }
        if (!asFeature) return values;
        const feature = new (0, _featureJsDefault.default)(values);
        if (geometryName) feature.setGeometryName(geometryName);
        const fid = node.getAttribute('fid') || (0, _xmlJs.getAttributeNS)(node, this.namespace, 'id');
        if (fid) feature.setId(fid);
        return feature;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Feature} Feature.
   */ readFeatureElement(node, objectStack) {
        return this.readFeatureElementInternal(node, objectStack, true);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Point|undefined} Point.
   */ readPoint(node, objectStack) {
        const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) return new (0, _pointJsDefault.default)(flatCoordinates, 'XYZ');
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPoint|undefined} MultiPoint.
   */ readMultiPoint(node, objectStack) {
        /** @type {Array<Array<number>>} */ const coordinates = (0, _xmlJs.pushParseAndPop)([], this.MULTIPOINT_PARSERS, node, objectStack, this);
        if (coordinates) return new (0, _multiPointJsDefault.default)(coordinates);
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */ readMultiLineString(node, objectStack) {
        /** @type {Array<LineString>} */ const lineStrings = (0, _xmlJs.pushParseAndPop)([], this.MULTILINESTRING_PARSERS, node, objectStack, this);
        if (lineStrings) return new (0, _multiLineStringJsDefault.default)(lineStrings);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */ readMultiPolygon(node, objectStack) {
        /** @type {Array<Polygon>} */ const polygons = (0, _xmlJs.pushParseAndPop)([], this.MULTIPOLYGON_PARSERS, node, objectStack, this);
        if (polygons) return new (0, _multiPolygonJsDefault.default)(polygons);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ pointMemberParser(node, objectStack) {
        (0, _xmlJs.parseNode)(this.POINTMEMBER_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ lineStringMemberParser(node, objectStack) {
        (0, _xmlJs.parseNode)(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ polygonMemberParser(node, objectStack) {
        (0, _xmlJs.parseNode)(this.POLYGONMEMBER_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */ readLineString(node, objectStack) {
        const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) {
            const lineString = new (0, _lineStringJsDefault.default)(flatCoordinates, 'XYZ');
            return lineString;
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} LinearRing flat coordinates.
   */ readFlatLinearRing(node, objectStack) {
        const ring = (0, _xmlJs.pushParseAndPop)(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
        if (ring) return ring;
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LinearRing|undefined} LinearRing.
   */ readLinearRing(node, objectStack) {
        const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);
        if (flatCoordinates) return new (0, _linearRingJsDefault.default)(flatCoordinates, 'XYZ');
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */ readPolygon(node, objectStack) {
        /** @type {Array<Array<number>>} */ const flatLinearRings = (0, _xmlJs.pushParseAndPop)([
            null
        ], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
        if (flatLinearRings && flatLinearRings[0]) {
            const flatCoordinates = flatLinearRings[0];
            const ends = [
                flatCoordinates.length
            ];
            let i, ii;
            for(i = 1, ii = flatLinearRings.length; i < ii; ++i){
                (0, _arrayJs.extend)(flatCoordinates, flatLinearRings[i]);
                ends.push(flatCoordinates.length);
            }
            return new (0, _polygonJsDefault.default)(flatCoordinates, 'XYZ', ends);
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>} Flat coordinates.
   */ readFlatCoordinatesFromNode(node, objectStack) {
        return (0, _xmlJs.pushParseAndPop)(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromNode(node, options) {
        const geometry = this.readGeometryElement(node, [
            this.getReadOptions(node, options ? options : {})
        ]);
        return geometry ? geometry : null;
    }
    /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */ readFeaturesFromNode(node, options) {
        const internalOptions = {
            featureType: this.featureType,
            featureNS: this.featureNS
        };
        if (internalOptions) Object.assign(internalOptions, this.getReadOptions(node, options));
        const features = this.readFeaturesInternal(node, [
            internalOptions
        ]);
        return features || [];
    }
    /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromNode(node) {
        return (0, _projJs.get)(this.srsName ? this.srsName : node.firstElementChild.getAttribute('srsName'));
    }
}
GMLBase.prototype.namespace = GMLNS;
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    'http://www.opengis.net/gml': {}
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    'http://www.opengis.net/gml': {}
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.GEOMETRY_PARSERS = {
    'http://www.opengis.net/gml': {}
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.MULTIPOINT_PARSERS = {
    'http://www.opengis.net/gml': {
        'pointMember': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.pointMemberParser),
        'pointMembers': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.pointMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.MULTILINESTRING_PARSERS = {
    'http://www.opengis.net/gml': {
        'lineStringMember': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.lineStringMemberParser),
        'lineStringMembers': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.lineStringMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.MULTIPOLYGON_PARSERS = {
    'http://www.opengis.net/gml': {
        'polygonMember': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.polygonMemberParser),
        'polygonMembers': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.polygonMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.POINTMEMBER_PARSERS = {
    'http://www.opengis.net/gml': {
        'Point': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.readFlatCoordinatesFromNode)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.LINESTRINGMEMBER_PARSERS = {
    'http://www.opengis.net/gml': {
        'LineString': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.readLineString)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.POLYGONMEMBER_PARSERS = {
    'http://www.opengis.net/gml': {
        'Polygon': (0, _xmlJs.makeArrayPusher)(GMLBase.prototype.readPolygon)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GMLBase.prototype.RING_PARSERS = {
    'http://www.opengis.net/gml': {
        'LinearRing': (0, _xmlJs.makeReplacer)(GMLBase.prototype.readFlatLinearRing)
    }
};
exports.default = GMLBase;

},{"../Feature.js":"liabO","../geom/Geometry.js":"4ya62","../geom/LineString.js":"jLUiq","../geom/LinearRing.js":"jg1hj","../geom/MultiLineString.js":"030lt","../geom/MultiPoint.js":"k4LcJ","../geom/MultiPolygon.js":"2XIqx","../geom/Point.js":"hx2Ar","../geom/Polygon.js":"cJuQF","./XMLFeature.js":"aeYmP","../array.js":"1Fbic","../xml.js":"kPa2a","../proj.js":"SznqC","./Feature.js":"FZbV5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aeYmP":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/XMLFeature
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _featureJs = require("../format/Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _utilJs = require("../util.js");
var _arrayJs = require("../array.js");
var _xmlJs = require("../xml.js");
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for XML feature formats.
 *
 * @abstract
 */ class XMLFeature extends (0, _featureJsDefault.default) {
    constructor(){
        super();
        /**
     * @type {XMLSerializer}
     * @private
     */ this.xmlSerializer_ = (0, _xmlJs.getXMLSerializer)();
    }
    /**
   * @return {import("./Feature.js").Type} Format.
   */ getType() {
        return 'xml';
    }
    /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */ readFeature(source, options) {
        if (!source) return null;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readFeatureFromDocument(doc, options);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readFeatureFromDocument(/** @type {Document} */ source, options);
        return this.readFeatureFromNode(/** @type {Element} */ source, options);
    }
    /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */ readFeatureFromDocument(doc, options) {
        const features = this.readFeaturesFromDocument(doc, options);
        if (features.length > 0) return features[0];
        return null;
    }
    /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */ readFeatureFromNode(node, options) {
        return null; // not implemented
    }
    /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */ readFeatures(source, options) {
        if (!source) return [];
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readFeaturesFromDocument(doc, options);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readFeaturesFromDocument(/** @type {Document} */ source, options);
        return this.readFeaturesFromNode(/** @type {Element} */ source, options);
    }
    /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */ readFeaturesFromDocument(doc, options) {
        /** @type {Array<import("../Feature.js").default>} */ const features = [];
        for(let n = doc.firstChild; n; n = n.nextSibling)if (n.nodeType == Node.ELEMENT_NODE) (0, _arrayJs.extend)(features, this.readFeaturesFromNode(/** @type {Element} */ n, options));
        return features;
    }
    /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */ readFeaturesFromNode(node, options) {
        return (0, _utilJs.abstract)();
    }
    /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometry(source, options) {
        if (!source) return null;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readGeometryFromDocument(doc, options);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readGeometryFromDocument(/** @type {Document} */ source, options);
        return this.readGeometryFromNode(/** @type {Element} */ source, options);
    }
    /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromDocument(doc, options) {
        return null; // not implemented
    }
    /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */ readGeometryFromNode(node, options) {
        return null; // not implemented
    }
    /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */ readProjection(source) {
        if (!source) return null;
        if (typeof source === 'string') {
            const doc = (0, _xmlJs.parse)(source);
            return this.readProjectionFromDocument(doc);
        }
        if ((0, _xmlJs.isDocument)(source)) return this.readProjectionFromDocument(/** @type {Document} */ source);
        return this.readProjectionFromNode(/** @type {Element} */ source);
    }
    /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromDocument(doc) {
        return this.dataProjection;
    }
    /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */ readProjectionFromNode(node) {
        return this.dataProjection;
    }
    /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   */ writeFeature(feature, options) {
        const node = this.writeFeatureNode(feature, options);
        return this.xmlSerializer_.serializeToString(node);
    }
    /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */ writeFeatureNode(feature, options) {
        return null; // not implemented
    }
    /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   */ writeFeatures(features, options) {
        const node = this.writeFeaturesNode(features, options);
        return this.xmlSerializer_.serializeToString(node);
    }
    /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */ writeFeaturesNode(features, options) {
        return null; // not implemented
    }
    /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   */ writeGeometry(geometry, options) {
        const node = this.writeGeometryNode(geometry, options);
        return this.xmlSerializer_.serializeToString(node);
    }
    /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */ writeGeometryNode(geometry, options) {
        return null; // not implemented
    }
}
exports.default = XMLFeature;

},{"../format/Feature.js":"FZbV5","../util.js":"pLBjQ","../array.js":"1Fbic","../xml.js":"kPa2a","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kPa2a":[function(require,module,exports,__globalThis) {
/**
 * @module ol/xml
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "XML_SCHEMA_INSTANCE_URI", ()=>XML_SCHEMA_INSTANCE_URI);
/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Element} Node.
 */ parcelHelpers.export(exports, "createElementNS", ()=>createElementNS);
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */ parcelHelpers.export(exports, "getAllTextContent", ()=>getAllTextContent);
/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array<string>} accumulator Accumulator.
 * @private
 * @return {Array<string>} Accumulator.
 */ parcelHelpers.export(exports, "getAllTextContent_", ()=>getAllTextContent_);
/**
 * @param {Object} object Object.
 * @return {boolean} Is a document.
 */ parcelHelpers.export(exports, "isDocument", ()=>isDocument);
/**
 * @param {Element} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */ parcelHelpers.export(exports, "getAttributeNS", ()=>getAttributeNS);
/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */ parcelHelpers.export(exports, "parse", ()=>parse);
/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array<*>): (Array<*>|undefined)} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */ parcelHelpers.export(exports, "makeArrayExtender", ()=>makeArrayExtender);
/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */ parcelHelpers.export(exports, "makeArrayPusher", ()=>makeArrayPusher);
/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array<*>): *} valueReader Value reader.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */ parcelHelpers.export(exports, "makeReplacer", ()=>makeReplacer);
/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [property] Property.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */ parcelHelpers.export(exports, "makeObjectPropertyPusher", ()=>makeObjectPropertyPusher);
/**
 * Make an object property setter function.
 * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
 * @param {string} [property] Property.
 * @param {T} [thisArg] The object to use as `this` in `valueReader`.
 * @return {Parser} Parser.
 * @template T
 */ parcelHelpers.export(exports, "makeObjectPropertySetter", ()=>makeObjectPropertySetter);
/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link module:ol/xml~NodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */ parcelHelpers.export(exports, "makeChildAppender", ()=>makeChildAppender);
/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link module:ol/xml.serialize}. This can be used by the parent writer to have the
 * `nodeWriter` called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Element, V, Array<*>): void} nodeWriter Node writer.
 * @param {T} [thisArg] The object to use as `this` in `nodeWriter`.
 * @return {Serializer} Serializer.
 * @template T, V
 */ parcelHelpers.export(exports, "makeArraySerializer", ()=>makeArraySerializer);
/**
 * Create a node factory which can use the `keys` passed to
 * {@link module:ol/xml.serialize} or {@link module:ol/xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string} [fixedNodeName] Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string} [fixedNamespaceURI] Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array<*>, string=): (Node|undefined)} Node factory.
 */ parcelHelpers.export(exports, "makeSimpleNodeFactory", ()=>makeSimpleNodeFactory);
parcelHelpers.export(exports, "OBJECT_PROPERTY_NODE_FACTORY", ()=>OBJECT_PROPERTY_NODE_FACTORY);
/**
 * Create an array of `values` to be used with {@link module:ol/xml.serialize} or
 * {@link module:ol/xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `key` argument.
 * @param {Object<string, *>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array<*>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 */ parcelHelpers.export(exports, "makeSequence", ()=>makeSequence);
/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object<string, T>} [structureNS] Namespaced structure to add to.
 * @return {Object<string, T>} Namespaced structure.
 * @template T
 */ parcelHelpers.export(exports, "makeStructureNS", ()=>makeStructureNS);
/**
 * Parse a node using the parsers and object stack.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [thisArg] The object to use as `this`.
 */ parcelHelpers.export(exports, "parseNode", ()=>parseNode);
/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object<string, Object<string, Parser>>} parsersNS
 *     Parsers by namespace.
 * @param {Element} node Node.
 * @param {Array<*>} objectStack Object stack.
 * @param {*} [thisArg] The object to use as `this`.
 * @return {T} Object.
 * @template T
 */ parcelHelpers.export(exports, "pushParseAndPop", ()=>pushParseAndPop);
/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:ol/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `keys` has
 *     to match the length of `values`. For serializing a sequence, `keys`
 *     determines the order of the sequence.
 * @param {T} [thisArg] The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */ parcelHelpers.export(exports, "serialize", ()=>serialize);
/**
 * @param {O} object Object.
 * @param {Object<string, Object<string, Serializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array<*>} values Values to serialize. An example would be an array
 *     of {@link module:ol/Feature~Feature} instances.
 * @param {Array<*>} objectStack Node stack.
 * @param {Array<string>} [keys] Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `keys` has
 *     to match the length of `values`. For serializing a sequence, `keys`
 *     determines the order of the sequence.
 * @param {T} [thisArg] The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */ parcelHelpers.export(exports, "pushSerializeAndPop", ()=>pushSerializeAndPop);
/**
 * Register a XMLSerializer. Can be used  to inject a XMLSerializer
 * where there is no globally available implementation.
 *
 * @param {XMLSerializer} xmlSerializer A XMLSerializer.
 * @api
 */ parcelHelpers.export(exports, "registerXMLSerializer", ()=>registerXMLSerializer);
/**
 * @return {XMLSerializer} The XMLSerializer.
 */ parcelHelpers.export(exports, "getXMLSerializer", ()=>getXMLSerializer);
/**
 * Register a Document to use when creating nodes for XML serializations. Can be used
 * to inject a Document where there is no globally available implementation.
 *
 * @param {Document} document A Document.
 * @api
 */ parcelHelpers.export(exports, "registerDocument", ()=>registerDocument);
/**
 * Get a document that should be used when creating nodes for XML serializations.
 * @return {Document} The document.
 */ parcelHelpers.export(exports, "getDocument", ()=>getDocument);
var _arrayJs = require("./array.js");
const XML_SCHEMA_INSTANCE_URI = 'http://www.w3.org/2001/XMLSchema-instance';
function createElementNS(namespaceURI, qualifiedName) {
    return getDocument().createElementNS(namespaceURI, qualifiedName);
}
function getAllTextContent(node, normalizeWhitespace) {
    return getAllTextContent_(node, normalizeWhitespace, []).join('');
}
function getAllTextContent_(node, normalizeWhitespace, accumulator) {
    if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
        if (normalizeWhitespace) accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
        else accumulator.push(node.nodeValue);
    } else {
        let n;
        for(n = node.firstChild; n; n = n.nextSibling)getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
    return accumulator;
}
function isDocument(object) {
    return 'documentElement' in object;
}
function getAttributeNS(node, namespaceURI, name) {
    return node.getAttributeNS(namespaceURI, name) || '';
}
function parse(xml) {
    return new DOMParser().parseFromString(xml, 'application/xml');
}
function makeArrayExtender(valueReader, thisArg) {
    return(/**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */ function(node, objectStack) {
        const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);
        if (value !== undefined) {
            const array = /** @type {Array<*>} */ objectStack[objectStack.length - 1];
            (0, _arrayJs.extend)(array, value);
        }
    });
}
function makeArrayPusher(valueReader, thisArg) {
    return(/**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */ function(node, objectStack) {
        const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);
        if (value !== undefined) {
            const array = /** @type {Array<*>} */ objectStack[objectStack.length - 1];
            array.push(value);
        }
    });
}
function makeReplacer(valueReader, thisArg) {
    return(/**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */ function(node, objectStack) {
        const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);
        if (value !== undefined) objectStack[objectStack.length - 1] = value;
    });
}
function makeObjectPropertyPusher(valueReader, property, thisArg) {
    return(/**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */ function(node, objectStack) {
        const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);
        if (value !== undefined) {
            const object = /** @type {!Object} */ objectStack[objectStack.length - 1];
            const name = property !== undefined ? property : node.localName;
            let array;
            if (name in object) array = object[name];
            else {
                array = [];
                object[name] = array;
            }
            array.push(value);
        }
    });
}
function makeObjectPropertySetter(valueReader, property, thisArg) {
    return(/**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */ function(node, objectStack) {
        const value = valueReader.call(thisArg !== undefined ? thisArg : this, node, objectStack);
        if (value !== undefined) {
            const object = /** @type {!Object} */ objectStack[objectStack.length - 1];
            const name = property !== undefined ? property : node.localName;
            object[name] = value;
        }
    });
}
function makeChildAppender(nodeWriter, thisArg) {
    return function(node, value, objectStack) {
        nodeWriter.call(thisArg !== undefined ? thisArg : this, node, value, objectStack);
        const parent = /** @type {NodeStackItem} */ objectStack[objectStack.length - 1];
        const parentNode = parent.node;
        parentNode.appendChild(node);
    };
}
function makeArraySerializer(nodeWriter, thisArg) {
    let serializersNS, nodeFactory;
    return function(node, value, objectStack) {
        if (serializersNS === undefined) {
            serializersNS = {};
            const serializers = {};
            serializers[node.localName] = nodeWriter;
            serializersNS[node.namespaceURI] = serializers;
            nodeFactory = makeSimpleNodeFactory(node.localName);
        }
        serialize(serializersNS, nodeFactory, value, objectStack);
    };
}
function makeSimpleNodeFactory(fixedNodeName, fixedNamespaceURI) {
    return(/**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */ function(value, objectStack, newNodeName) {
        const context = /** @type {NodeStackItem} */ objectStack[objectStack.length - 1];
        const node = context.node;
        let nodeName = fixedNodeName;
        if (nodeName === undefined) nodeName = newNodeName;
        const namespaceURI = fixedNamespaceURI !== undefined ? fixedNamespaceURI : node.namespaceURI;
        return createElementNS(namespaceURI, /** @type {string} */ nodeName);
    });
}
const OBJECT_PROPERTY_NODE_FACTORY = makeSimpleNodeFactory();
function makeSequence(object, orderedKeys) {
    const length = orderedKeys.length;
    const sequence = new Array(length);
    for(let i = 0; i < length; ++i)sequence[i] = object[orderedKeys[i]];
    return sequence;
}
function makeStructureNS(namespaceURIs, structure, structureNS) {
    structureNS = structureNS !== undefined ? structureNS : {};
    let i, ii;
    for(i = 0, ii = namespaceURIs.length; i < ii; ++i)structureNS[namespaceURIs[i]] = structure;
    return structureNS;
}
function parseNode(parsersNS, node, objectStack, thisArg) {
    let n;
    for(n = node.firstElementChild; n; n = n.nextElementSibling){
        const parsers = parsersNS[n.namespaceURI];
        if (parsers !== undefined) {
            const parser = parsers[n.localName];
            if (parser !== undefined) parser.call(thisArg, n, objectStack);
        }
    }
}
function pushParseAndPop(object, parsersNS, node, objectStack, thisArg) {
    objectStack.push(object);
    parseNode(parsersNS, node, objectStack, thisArg);
    return /** @type {T} */ objectStack.pop();
}
function serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg) {
    const length = (keys !== undefined ? keys : values).length;
    let value, node;
    for(let i = 0; i < length; ++i){
        value = values[i];
        if (value !== undefined) {
            node = nodeFactory.call(thisArg !== undefined ? thisArg : this, value, objectStack, keys !== undefined ? keys[i] : undefined);
            if (node !== undefined) serializersNS[node.namespaceURI][node.localName].call(thisArg, node, value, objectStack);
        }
    }
}
function pushSerializeAndPop(object, serializersNS, nodeFactory, values, objectStack, keys, thisArg) {
    objectStack.push(object);
    serialize(serializersNS, nodeFactory, values, objectStack, keys, thisArg);
    return /** @type {O|undefined} */ objectStack.pop();
}
let xmlSerializer_ = undefined;
function registerXMLSerializer(xmlSerializer) {
    xmlSerializer_ = xmlSerializer;
}
function getXMLSerializer() {
    if (xmlSerializer_ === undefined && typeof XMLSerializer !== 'undefined') xmlSerializer_ = new XMLSerializer();
    return xmlSerializer_;
}
let document_ = undefined;
function registerDocument(document1) {
    document_ = document1;
}
function getDocument() {
    if (document_ === undefined && typeof document !== 'undefined') document_ = document.implementation.createDocument('', '', null);
    return document_;
}

},{"./array.js":"1Fbic","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8AOX3":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/xsd
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Node} node Node.
 * @return {boolean|undefined} Boolean.
 */ parcelHelpers.export(exports, "readBoolean", ()=>readBoolean);
/**
 * @param {string} string String.
 * @return {boolean|undefined} Boolean.
 */ parcelHelpers.export(exports, "readBooleanString", ()=>readBooleanString);
/**
 * @param {Node} node Node.
 * @return {number|undefined} DateTime in seconds.
 */ parcelHelpers.export(exports, "readDateTime", ()=>readDateTime);
/**
 * @param {Node} node Node.
 * @return {number|undefined} Decimal.
 */ parcelHelpers.export(exports, "readDecimal", ()=>readDecimal);
/**
 * @param {string} string String.
 * @return {number|undefined} Decimal.
 */ parcelHelpers.export(exports, "readDecimalString", ()=>readDecimalString);
/**
 * @param {Node} node Node.
 * @return {number|undefined} Non negative integer.
 */ parcelHelpers.export(exports, "readPositiveInteger", ()=>readPositiveInteger);
/**
 * @param {string} string String.
 * @return {number|undefined} Non negative integer.
 */ parcelHelpers.export(exports, "readNonNegativeIntegerString", ()=>readNonNegativeIntegerString);
/**
 * @param {Node} node Node.
 * @return {string|undefined} String.
 */ parcelHelpers.export(exports, "readString", ()=>readString);
/**
 * @param {Node} node Node to append a TextNode with the boolean to.
 * @param {boolean} bool Boolean.
 */ parcelHelpers.export(exports, "writeBooleanTextNode", ()=>writeBooleanTextNode);
/**
 * @param {Node} node Node to append a CDATA Section with the string to.
 * @param {string} string String.
 */ parcelHelpers.export(exports, "writeCDATASection", ()=>writeCDATASection);
/**
 * @param {Node} node Node to append a TextNode with the dateTime to.
 * @param {number} dateTime DateTime in seconds.
 */ parcelHelpers.export(exports, "writeDateTimeTextNode", ()=>writeDateTimeTextNode);
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} decimal Decimal.
 */ parcelHelpers.export(exports, "writeDecimalTextNode", ()=>writeDecimalTextNode);
/**
 * @param {Node} node Node to append a TextNode with the decimal to.
 * @param {number} nonNegativeInteger Non negative integer.
 */ parcelHelpers.export(exports, "writeNonNegativeIntegerTextNode", ()=>writeNonNegativeIntegerTextNode);
/**
 * @param {Node} node Node to append a TextNode with the string to.
 * @param {string} string String.
 */ parcelHelpers.export(exports, "writeStringTextNode", ()=>writeStringTextNode);
var _xmlJs = require("../xml.js");
var _stringJs = require("../string.js");
function readBoolean(node) {
    const s = (0, _xmlJs.getAllTextContent)(node, false);
    return readBooleanString(s);
}
function readBooleanString(string) {
    const m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
    if (m) return m[1] !== undefined || false;
    return undefined;
}
function readDateTime(node) {
    const s = (0, _xmlJs.getAllTextContent)(node, false);
    const dateTime = Date.parse(s);
    return isNaN(dateTime) ? undefined : dateTime / 1000;
}
function readDecimal(node) {
    const s = (0, _xmlJs.getAllTextContent)(node, false);
    return readDecimalString(s);
}
function readDecimalString(string) {
    // FIXME check spec
    const m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
    if (m) return parseFloat(m[1]);
    return undefined;
}
function readPositiveInteger(node) {
    const s = (0, _xmlJs.getAllTextContent)(node, false);
    return readNonNegativeIntegerString(s);
}
function readNonNegativeIntegerString(string) {
    const m = /^\s*(\d+)\s*$/.exec(string);
    if (m) return parseInt(m[1], 10);
    return undefined;
}
function readString(node) {
    return (0, _xmlJs.getAllTextContent)(node, false).trim();
}
function writeBooleanTextNode(node, bool) {
    writeStringTextNode(node, bool ? '1' : '0');
}
function writeCDATASection(node, string) {
    node.appendChild((0, _xmlJs.getDocument)().createCDATASection(string));
}
function writeDateTimeTextNode(node, dateTime) {
    const date = new Date(dateTime * 1000);
    const string = date.getUTCFullYear() + '-' + (0, _stringJs.padNumber)(date.getUTCMonth() + 1, 2) + '-' + (0, _stringJs.padNumber)(date.getUTCDate(), 2) + 'T' + (0, _stringJs.padNumber)(date.getUTCHours(), 2) + ':' + (0, _stringJs.padNumber)(date.getUTCMinutes(), 2) + ':' + (0, _stringJs.padNumber)(date.getUTCSeconds(), 2) + 'Z';
    node.appendChild((0, _xmlJs.getDocument)().createTextNode(string));
}
function writeDecimalTextNode(node, decimal) {
    const string = decimal.toPrecision();
    node.appendChild((0, _xmlJs.getDocument)().createTextNode(string));
}
function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {
    const string = nonNegativeInteger.toString();
    node.appendChild((0, _xmlJs.getDocument)().createTextNode(string));
}
function writeStringTextNode(node, string) {
    node.appendChild((0, _xmlJs.getDocument)().createTextNode(string));
}

},{"../xml.js":"kPa2a","../string.js":"fIYwS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"doSR5":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/GML3
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _gml2Js = require("./GML2.js");
var _gml2JsDefault = parcelHelpers.interopDefault(_gml2Js);
var _gmlbaseJs = require("./GMLBase.js");
var _gmlbaseJsDefault = parcelHelpers.interopDefault(_gmlbaseJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _xmlJs = require("../xml.js");
var _extentJs = require("../extent.js");
var _arrayJs = require("../array.js");
var _projJs = require("../proj.js");
var _xsdJs = require("./xsd.js");
var _featureJs = require("./Feature.js");
/**
 * @const
 * @type {string}
 * @private
 */ const schemaLocation = (0, _gmlbaseJs.GMLNS) + ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' + '1.0.0/gmlsf.xsd';
/**
 * @const
 * @type {Object<string, string>}
 */ const MULTIGEOMETRY_TO_MEMBER_NODENAME = {
    'MultiLineString': 'lineStringMember',
    'MultiCurve': 'curveMember',
    'MultiPolygon': 'polygonMember',
    'MultiSurface': 'surfaceMember'
};
/**
 * @classdesc
 * Feature format for reading and writing data in the GML format
 * version 3.1.1.
 * Currently only supports GML 3.1.1 Simple Features profile.
 *
 * @api
 */ class GML3 extends (0, _gmlbaseJsDefault.default) {
    /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */ constructor(options){
        options = options ? options : {};
        super(options);
        /**
     * @private
     * @type {boolean}
     */ this.surface_ = options.surface !== undefined ? options.surface : false;
        /**
     * @private
     * @type {boolean}
     */ this.curve_ = options.curve !== undefined ? options.curve : false;
        /**
     * @private
     * @type {boolean}
     */ this.multiCurve_ = options.multiCurve !== undefined ? options.multiCurve : true;
        /**
     * @private
     * @type {boolean}
     */ this.multiSurface_ = options.multiSurface !== undefined ? options.multiSurface : true;
        /**
     * @type {string}
     */ this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;
        /**
     * @private
     * @type {boolean}
     */ this.hasZ = options.hasZ !== undefined ? options.hasZ : false;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */ readMultiCurve(node, objectStack) {
        /** @type {Array<LineString>} */ const lineStrings = (0, _xmlJs.pushParseAndPop)([], this.MULTICURVE_PARSERS, node, objectStack, this);
        if (lineStrings) {
            const multiLineString = new (0, _multiLineStringJsDefault.default)(lineStrings);
            return multiLineString;
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Polygon.
   */ readFlatCurveRing(node, objectStack) {
        /** @type {Array<LineString>} */ const lineStrings = (0, _xmlJs.pushParseAndPop)([], this.MULTICURVE_PARSERS, node, objectStack, this);
        const flatCoordinates = [];
        for(let i = 0, ii = lineStrings.length; i < ii; ++i)(0, _arrayJs.extend)(flatCoordinates, lineStrings[i].getFlatCoordinates());
        return flatCoordinates;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */ readMultiSurface(node, objectStack) {
        /** @type {Array<Polygon>} */ const polygons = (0, _xmlJs.pushParseAndPop)([], this.MULTISURFACE_PARSERS, node, objectStack, this);
        if (polygons) return new (0, _multiPolygonJsDefault.default)(polygons);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ curveMemberParser(node, objectStack) {
        (0, _xmlJs.parseNode)(this.CURVEMEMBER_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ surfaceMemberParser(node, objectStack) {
        (0, _xmlJs.parseNode)(this.SURFACEMEMBER_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */ readPatch(node, objectStack) {
        return (0, _xmlJs.pushParseAndPop)([
            null
        ], this.PATCHES_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */ readSegment(node, objectStack) {
        return (0, _xmlJs.pushParseAndPop)([], this.SEGMENTS_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */ readPolygonPatch(node, objectStack) {
        return (0, _xmlJs.pushParseAndPop)([
            null
        ], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */ readLineStringSegment(node, objectStack) {
        return (0, _xmlJs.pushParseAndPop)([
            null
        ], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ interiorParser(node, objectStack) {
        /** @type {Array<number>|undefined} */ const flatLinearRing = (0, _xmlJs.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */ objectStack[objectStack.length - 1];
            flatLinearRings.push(flatLinearRing);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */ exteriorParser(node, objectStack) {
        /** @type {Array<number>|undefined} */ const flatLinearRing = (0, _xmlJs.pushParseAndPop)(undefined, this.RING_PARSERS, node, objectStack, this);
        if (flatLinearRing) {
            const flatLinearRings = /** @type {Array<Array<number>>} */ objectStack[objectStack.length - 1];
            flatLinearRings[0] = flatLinearRing;
        }
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */ readSurface(node, objectStack) {
        /** @type {Array<Array<number>>} */ const flatLinearRings = (0, _xmlJs.pushParseAndPop)([
            null
        ], this.SURFACE_PARSERS, node, objectStack, this);
        if (flatLinearRings && flatLinearRings[0]) {
            const flatCoordinates = flatLinearRings[0];
            const ends = [
                flatCoordinates.length
            ];
            let i, ii;
            for(i = 1, ii = flatLinearRings.length; i < ii; ++i){
                (0, _arrayJs.extend)(flatCoordinates, flatLinearRings[i]);
                ends.push(flatCoordinates.length);
            }
            return new (0, _polygonJsDefault.default)(flatCoordinates, 'XYZ', ends);
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */ readCurve(node, objectStack) {
        /** @type {Array<number>} */ const flatCoordinates = (0, _xmlJs.pushParseAndPop)([
            null
        ], this.CURVE_PARSERS, node, objectStack, this);
        if (flatCoordinates) {
            const lineString = new (0, _lineStringJsDefault.default)(flatCoordinates, 'XYZ');
            return lineString;
        }
        return undefined;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */ readEnvelope(node, objectStack) {
        /** @type {Array<number>} */ const flatCoordinates = (0, _xmlJs.pushParseAndPop)([
            null
        ], this.ENVELOPE_PARSERS, node, objectStack, this);
        return (0, _extentJs.createOrUpdate)(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);
    }
    /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */ readFlatPos(node, objectStack) {
        let s = (0, _xmlJs.getAllTextContent)(node, false);
        const re = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
        /** @type {Array<number>} */ const flatCoordinates = [];
        let m;
        while(m = re.exec(s)){
            flatCoordinates.push(parseFloat(m[1]));
            s = s.substr(m[0].length);
        }
        if (s !== '') return undefined;
        const context = objectStack[0];
        const containerSrs = context['srsName'];
        let axisOrientation = 'enu';
        if (containerSrs) {
            const proj = (0, _projJs.get)(containerSrs);
            axisOrientation = proj.getAxisOrientation();
        }
        if (axisOrientation === 'neu') {
            let i, ii;
            for(i = 0, ii = flatCoordinates.length; i < ii; i += 3){
                const y = flatCoordinates[i];
                const x = flatCoordinates[i + 1];
                flatCoordinates[i] = x;
                flatCoordinates[i + 1] = y;
            }
        }
        const len = flatCoordinates.length;
        if (len == 2) flatCoordinates.push(0);
        if (len === 0) return undefined;
        return flatCoordinates;
    }
    /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */ readFlatPosList(node, objectStack) {
        const s = (0, _xmlJs.getAllTextContent)(node, false).replace(/^\s*|\s*$/g, '');
        const context = objectStack[0];
        const containerSrs = context['srsName'];
        const contextDimension = context['srsDimension'];
        let axisOrientation = 'enu';
        if (containerSrs) {
            const proj = (0, _projJs.get)(containerSrs);
            axisOrientation = proj.getAxisOrientation();
        }
        const coords = s.split(/\s+/);
        // The "dimension" attribute is from the GML 3.0.1 spec.
        let dim = 2;
        if (node.getAttribute('srsDimension')) dim = (0, _xsdJs.readNonNegativeIntegerString)(node.getAttribute('srsDimension'));
        else if (node.getAttribute('dimension')) dim = (0, _xsdJs.readNonNegativeIntegerString)(node.getAttribute('dimension'));
        else if (/** @type {Element} */ node.parentNode.getAttribute('srsDimension')) dim = (0, _xsdJs.readNonNegativeIntegerString)(/** @type {Element} */ node.parentNode.getAttribute('srsDimension'));
        else if (contextDimension) dim = (0, _xsdJs.readNonNegativeIntegerString)(contextDimension);
        let x, y, z;
        const flatCoordinates = [];
        for(let i = 0, ii = coords.length; i < ii; i += dim){
            x = parseFloat(coords[i]);
            y = parseFloat(coords[i + 1]);
            z = dim === 3 ? parseFloat(coords[i + 2]) : 0;
            if (axisOrientation.substr(0, 2) === 'en') flatCoordinates.push(x, y, z);
            else flatCoordinates.push(y, x, z);
        }
        return flatCoordinates;
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} value Point geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writePos_(node, value, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsDimension = hasZ ? '3' : '2';
        node.setAttribute('srsDimension', srsDimension);
        const srsName = context['srsName'];
        let axisOrientation = 'enu';
        if (srsName) axisOrientation = (0, _projJs.get)(srsName).getAxisOrientation();
        const point = value.getCoordinates();
        let coords;
        // only 2d for simple features profile
        if (axisOrientation.substr(0, 2) === 'en') coords = point[0] + ' ' + point[1];
        else coords = point[1] + ' ' + point[0];
        if (hasZ) {
            // For newly created points, Z can be undefined.
            const z = point[2] || 0;
            coords += ' ' + z;
        }
        (0, _xsdJs.writeStringTextNode)(node, coords);
    }
    /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */ getCoords_(point, srsName, hasZ) {
        let axisOrientation = 'enu';
        if (srsName) axisOrientation = (0, _projJs.get)(srsName).getAxisOrientation();
        let coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ' ' + point[1] : point[1] + ' ' + point[0];
        if (hasZ) {
            // For newly created points, Z can be undefined.
            const z = point[2] || 0;
            coords += ' ' + z;
        }
        return coords;
    }
    /**
   * @param {Element} node Node.
   * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writePosList_(node, value, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsDimension = hasZ ? '3' : '2';
        node.setAttribute('srsDimension', srsDimension);
        const srsName = context['srsName'];
        // only 2d for simple features profile
        const points = value.getCoordinates();
        const len = points.length;
        const parts = new Array(len);
        let point;
        for(let i = 0; i < len; ++i){
            point = points[i];
            parts[i] = this.getCoords_(point, srsName, hasZ);
        }
        (0, _xsdJs.writeStringTextNode)(node, parts.join(' '));
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writePoint(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const pos = (0, _xmlJs.createElementNS)(node.namespaceURI, 'pos');
        node.appendChild(pos);
        this.writePos_(pos, geometry, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */ writeEnvelope(node, extent, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const keys = [
            'lowerCorner',
            'upperCorner'
        ];
        const values = [
            extent[0] + ' ' + extent[1],
            extent[2] + ' ' + extent[3]
        ];
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ {
            node: node
        }, this.ENVELOPE_SERIALIZERS, (0, _xmlJs.OBJECT_PROPERTY_NODE_FACTORY), values, objectStack, keys, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeLinearRing(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (srsName) node.setAttribute('srsName', srsName);
        const posList = (0, _xmlJs.createElementNS)(node.namespaceURI, 'posList');
        node.appendChild(posList);
        this.writePosList_(posList, geometry, objectStack);
    }
    /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */ RING_NODE_FACTORY_(value, objectStack, nodeName) {
        const context = objectStack[objectStack.length - 1];
        const parentNode = context.node;
        const exteriorWritten = context['exteriorWritten'];
        if (exteriorWritten === undefined) context['exteriorWritten'] = true;
        return (0, _xmlJs.createElementNS)(parentNode.namespaceURI, exteriorWritten !== undefined ? 'interior' : 'exterior');
    }
    /**
   * @param {Element} node Node.
   * @param {Polygon} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeSurfaceOrPolygon(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        if (node.nodeName !== 'PolygonPatch' && srsName) node.setAttribute('srsName', srsName);
        if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {
            const rings = geometry.getLinearRings();
            (0, _xmlJs.pushSerializeAndPop)({
                node: node,
                hasZ: hasZ,
                srsName: srsName
            }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);
        } else if (node.nodeName === 'Surface') {
            const patches = (0, _xmlJs.createElementNS)(node.namespaceURI, 'patches');
            node.appendChild(patches);
            this.writeSurfacePatches_(patches, geometry, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {LineString} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeCurveOrLineString(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        if (node.nodeName !== 'LineStringSegment' && srsName) node.setAttribute('srsName', srsName);
        if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {
            const posList = (0, _xmlJs.createElementNS)(node.namespaceURI, 'posList');
            node.appendChild(posList);
            this.writePosList_(posList, geometry, objectStack);
        } else if (node.nodeName === 'Curve') {
            const segments = (0, _xmlJs.createElementNS)(node.namespaceURI, 'segments');
            node.appendChild(segments);
            this.writeCurveSegments_(segments, geometry, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {MultiPolygon} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiSurfaceOrPolygon(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        const surface = context['surface'];
        if (srsName) node.setAttribute('srsName', srsName);
        const polygons = geometry.getPolygons();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName,
            surface: surface
        }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiPoint(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const srsName = context['srsName'];
        const hasZ = context['hasZ'];
        if (srsName) node.setAttribute('srsName', srsName);
        const points = geometry.getPoints();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName
        }, this.POINTMEMBER_SERIALIZERS, (0, _xmlJs.makeSimpleNodeFactory)('pointMember'), points, objectStack, undefined, this);
    }
    /**
   * @param {Element} node Node.
   * @param {MultiLineString} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeMultiCurveOrLineString(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        const hasZ = context['hasZ'];
        const srsName = context['srsName'];
        const curve = context['curve'];
        if (srsName) node.setAttribute('srsName', srsName);
        const lines = geometry.getLineStrings();
        (0, _xmlJs.pushSerializeAndPop)({
            node: node,
            hasZ: hasZ,
            srsName: srsName,
            curve: curve
        }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeRing(node, ring, objectStack) {
        const linearRing = (0, _xmlJs.createElementNS)(node.namespaceURI, 'LinearRing');
        node.appendChild(linearRing);
        this.writeLinearRing(linearRing, ring, objectStack);
    }
    /**
   * @param {Node} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeSurfaceOrPolygonMember(node, polygon, objectStack) {
        const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
        if (child) {
            node.appendChild(child);
            this.writeSurfaceOrPolygon(child, polygon, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writePointMember(node, point, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'Point');
        node.appendChild(child);
        this.writePoint(child, point, objectStack);
    }
    /**
   * @param {Node} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeLineStringOrCurveMember(node, line, objectStack) {
        const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
        if (child) {
            node.appendChild(child);
            this.writeCurveOrLineString(child, line, objectStack);
        }
    }
    /**
   * @param {Element} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeSurfacePatches_(node, polygon, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'PolygonPatch');
        node.appendChild(child);
        this.writeSurfaceOrPolygon(child, polygon, objectStack);
    }
    /**
   * @param {Element} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeCurveSegments_(node, line, objectStack) {
        const child = (0, _xmlJs.createElementNS)(node.namespaceURI, 'LineStringSegment');
        node.appendChild(child);
        this.writeCurveOrLineString(child, line, objectStack);
    }
    /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeGeometryElement(node, geometry, objectStack) {
        const context = /** @type {import("./Feature.js").WriteOptions} */ objectStack[objectStack.length - 1];
        const item = Object.assign({}, context);
        item['node'] = node;
        let value;
        if (Array.isArray(geometry)) value = (0, _featureJs.transformExtentWithOptions)(/** @type {import("../extent.js").Extent} */ geometry, context);
        else value = (0, _featureJs.transformGeometryWithOptions)(/** @type {import("../geom/Geometry.js").default} */ geometry, true, context);
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [
            value
        ], objectStack, undefined, this);
    }
    /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */ writeFeatureElement(node, feature, objectStack) {
        const fid = feature.getId();
        if (fid) node.setAttribute('fid', /** @type {string} */ fid);
        const context = /** @type {Object} */ objectStack[objectStack.length - 1];
        const featureNS = context['featureNS'];
        const geometryName = feature.getGeometryName();
        if (!context.serializers) {
            context.serializers = {};
            context.serializers[featureNS] = {};
        }
        const keys = [];
        const values = [];
        if (feature.hasProperties()) {
            const properties = feature.getProperties();
            for(const key in properties){
                const value = properties[key];
                if (value !== null) {
                    keys.push(key);
                    values.push(value);
                    if (key == geometryName || typeof /** @type {?} */ value.getSimplifiedGeometry === 'function') {
                        if (!(key in context.serializers[featureNS])) context.serializers[featureNS][key] = (0, _xmlJs.makeChildAppender)(this.writeGeometryElement, this);
                    } else if (!(key in context.serializers[featureNS])) context.serializers[featureNS][key] = (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode));
                }
            }
        }
        const item = Object.assign({}, context);
        item.node = node;
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ item, context.serializers, (0, _xmlJs.makeSimpleNodeFactory)(undefined, featureNS), values, objectStack, keys);
    }
    /**
   * @param {Node} node Node.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */ writeFeatureMembers_(node, features, objectStack) {
        const context = /** @type {Object} */ objectStack[objectStack.length - 1];
        const featureType = context['featureType'];
        const featureNS = context['featureNS'];
        /** @type {Object<string, Object<string, import("../xml.js").Serializer>>} */ const serializers = {};
        serializers[featureNS] = {};
        serializers[featureNS][featureType] = (0, _xmlJs.makeChildAppender)(this.writeFeatureElement, this);
        const item = Object.assign({}, context);
        item.node = node;
        (0, _xmlJs.pushSerializeAndPop)(/** @type {import("../xml.js").NodeStackItem} */ item, serializers, (0, _xmlJs.makeSimpleNodeFactory)(featureType, featureNS), features, objectStack);
    }
    /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */ MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {
        const parentNode = objectStack[objectStack.length - 1].node;
        return (0, _xmlJs.createElementNS)(this.namespace, MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);
    }
    /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */ GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {
        const context = objectStack[objectStack.length - 1];
        const multiSurface = context['multiSurface'];
        const surface = context['surface'];
        const curve = context['curve'];
        const multiCurve = context['multiCurve'];
        if (!Array.isArray(value)) {
            nodeName = /** @type {import("../geom/Geometry.js").default} */ value.getType();
            if (nodeName === 'MultiPolygon' && multiSurface === true) nodeName = 'MultiSurface';
            else if (nodeName === 'Polygon' && surface === true) nodeName = 'Surface';
            else if (nodeName === 'LineString' && curve === true) nodeName = 'Curve';
            else if (nodeName === 'MultiLineString' && multiCurve === true) nodeName = 'MultiCurve';
        } else nodeName = 'Envelope';
        return (0, _xmlJs.createElementNS)(this.namespace, nodeName);
    }
    /**
   * Encode a geometry in GML 3.1.1 Simple Features.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */ writeGeometryNode(geometry, options) {
        options = this.adaptOptions(options);
        const geom = (0, _xmlJs.createElementNS)(this.namespace, 'geom');
        const context = {
            node: geom,
            hasZ: this.hasZ,
            srsName: this.srsName,
            curve: this.curve_,
            surface: this.surface_,
            multiSurface: this.multiSurface_,
            multiCurve: this.multiCurve_
        };
        if (options) Object.assign(context, options);
        this.writeGeometryElement(geom, geometry, [
            context
        ]);
        return geom;
    }
    /**
   * Encode an array of features in the GML 3.1.1 format as an XML node.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Element} Node.
   * @api
   */ writeFeaturesNode(features, options) {
        options = this.adaptOptions(options);
        const node = (0, _xmlJs.createElementNS)(this.namespace, 'featureMembers');
        node.setAttributeNS((0, _xmlJs.XML_SCHEMA_INSTANCE_URI), 'xsi:schemaLocation', this.schemaLocation);
        const context = {
            srsName: this.srsName,
            hasZ: this.hasZ,
            curve: this.curve_,
            surface: this.surface_,
            multiSurface: this.multiSurface_,
            multiCurve: this.multiCurve_,
            featureNS: this.featureNS,
            featureType: this.featureType
        };
        if (options) Object.assign(context, options);
        this.writeFeatureMembers_(node, features, [
            context
        ]);
        return node;
    }
}
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    'http://www.opengis.net/gml': {
        'pos': (0, _xmlJs.makeReplacer)(GML3.prototype.readFlatPos),
        'posList': (0, _xmlJs.makeReplacer)(GML3.prototype.readFlatPosList),
        'coordinates': (0, _xmlJs.makeReplacer)((0, _gml2JsDefault.default).prototype.readFlatCoordinates)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    'http://www.opengis.net/gml': {
        'interior': GML3.prototype.interiorParser,
        'exterior': GML3.prototype.exteriorParser
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.GEOMETRY_PARSERS = {
    'http://www.opengis.net/gml': {
        'Point': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPoint),
        'MultiPoint': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPoint),
        'LineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLineString),
        'MultiLineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiLineString),
        'LinearRing': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLinearRing),
        'Polygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPolygon),
        'MultiPolygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPolygon),
        'Surface': (0, _xmlJs.makeReplacer)(GML3.prototype.readSurface),
        'MultiSurface': (0, _xmlJs.makeReplacer)(GML3.prototype.readMultiSurface),
        'Curve': (0, _xmlJs.makeReplacer)(GML3.prototype.readCurve),
        'MultiCurve': (0, _xmlJs.makeReplacer)(GML3.prototype.readMultiCurve),
        'Envelope': (0, _xmlJs.makeReplacer)(GML3.prototype.readEnvelope)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.MULTICURVE_PARSERS = {
    'http://www.opengis.net/gml': {
        'curveMember': (0, _xmlJs.makeArrayPusher)(GML3.prototype.curveMemberParser),
        'curveMembers': (0, _xmlJs.makeArrayPusher)(GML3.prototype.curveMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.MULTISURFACE_PARSERS = {
    'http://www.opengis.net/gml': {
        'surfaceMember': (0, _xmlJs.makeArrayPusher)(GML3.prototype.surfaceMemberParser),
        'surfaceMembers': (0, _xmlJs.makeArrayPusher)(GML3.prototype.surfaceMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.CURVEMEMBER_PARSERS = {
    'http://www.opengis.net/gml': {
        'LineString': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readLineString),
        'Curve': (0, _xmlJs.makeArrayPusher)(GML3.prototype.readCurve)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.SURFACEMEMBER_PARSERS = {
    'http://www.opengis.net/gml': {
        'Polygon': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readPolygon),
        'Surface': (0, _xmlJs.makeArrayPusher)(GML3.prototype.readSurface)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.SURFACE_PARSERS = {
    'http://www.opengis.net/gml': {
        'patches': (0, _xmlJs.makeReplacer)(GML3.prototype.readPatch)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.CURVE_PARSERS = {
    'http://www.opengis.net/gml': {
        'segments': (0, _xmlJs.makeReplacer)(GML3.prototype.readSegment)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.ENVELOPE_PARSERS = {
    'http://www.opengis.net/gml': {
        'lowerCorner': (0, _xmlJs.makeArrayPusher)(GML3.prototype.readFlatPosList),
        'upperCorner': (0, _xmlJs.makeArrayPusher)(GML3.prototype.readFlatPosList)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.PATCHES_PARSERS = {
    'http://www.opengis.net/gml': {
        'PolygonPatch': (0, _xmlJs.makeReplacer)(GML3.prototype.readPolygonPatch)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML3.prototype.SEGMENTS_PARSERS = {
    'http://www.opengis.net/gml': {
        'LineStringSegment': (0, _xmlJs.makeArrayExtender)(GML3.prototype.readLineStringSegment)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ (0, _gmlbaseJsDefault.default).prototype.RING_PARSERS = {
    'http://www.opengis.net/gml': {
        'LinearRing': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readFlatLinearRing),
        'Ring': (0, _xmlJs.makeReplacer)(GML3.prototype.readFlatCurveRing)
    }
};
/**
 * Encode an array of features in GML 3.1.1 Simple Features.
 *
 * @function
 * @param {Array<import("../Feature.js").default>} features Features.
 * @param {import("./Feature.js").WriteOptions} [options] Options.
 * @return {string} Result.
 * @api
 */ GML3.prototype.writeFeatures;
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.RING_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'exterior': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeRing),
        'interior': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeRing)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.ENVELOPE_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'lowerCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode)),
        'upperCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode))
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'surfaceMember': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygonMember),
        'polygonMember': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygonMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.POINTMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'pointMember': (0, _xmlJs.makeChildAppender)(GML3.prototype.writePointMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'lineStringMember': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeLineStringOrCurveMember),
        'curveMember': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeLineStringOrCurveMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML3.prototype.GEOMETRY_SERIALIZERS = {
    'http://www.opengis.net/gml': {
        'Curve': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeCurveOrLineString),
        'MultiCurve': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeMultiCurveOrLineString),
        'Point': (0, _xmlJs.makeChildAppender)(GML3.prototype.writePoint),
        'MultiPoint': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeMultiPoint),
        'LineString': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeCurveOrLineString),
        'MultiLineString': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeMultiCurveOrLineString),
        'LinearRing': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeLinearRing),
        'Polygon': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygon),
        'MultiPolygon': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeMultiSurfaceOrPolygon),
        'Surface': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeSurfaceOrPolygon),
        'MultiSurface': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeMultiSurfaceOrPolygon),
        'Envelope': (0, _xmlJs.makeChildAppender)(GML3.prototype.writeEnvelope)
    }
};
exports.default = GML3;

},{"./GML2.js":"9tsJN","./GMLBase.js":"9rBB8","../geom/LineString.js":"jLUiq","../geom/MultiLineString.js":"030lt","../geom/MultiPolygon.js":"2XIqx","../geom/Polygon.js":"cJuQF","../xml.js":"kPa2a","../extent.js":"6YrVc","../array.js":"1Fbic","../proj.js":"SznqC","./xsd.js":"8AOX3","./Feature.js":"FZbV5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dFH2d":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/GML32
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _gml2Js = require("./GML2.js");
var _gml2JsDefault = parcelHelpers.interopDefault(_gml2Js);
var _gml3Js = require("./GML3.js");
var _gml3JsDefault = parcelHelpers.interopDefault(_gml3Js);
var _gmlbaseJs = require("./GMLBase.js");
var _gmlbaseJsDefault = parcelHelpers.interopDefault(_gmlbaseJs);
var _xmlJs = require("../xml.js");
var _xsdJs = require("../format/xsd.js");
/**
 * @classdesc Feature format for reading and writing data in the GML format
 *            version 3.2.1.
 * @api
 */ class GML32 extends (0, _gml3JsDefault.default) {
    /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */ constructor(options){
        options = options ? options : {};
        super(options);
        /**
     * @type {string}
     */ this.schemaLocation = options.schemaLocation ? options.schemaLocation : this.namespace + ' http://schemas.opengis.net/gml/3.2.1/gml.xsd';
    }
    /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */ writeGeometryElement(node, geometry, objectStack) {
        const context = objectStack[objectStack.length - 1];
        objectStack[objectStack.length - 1] = Object.assign({
            multiCurve: true,
            multiSurface: true
        }, context);
        super.writeGeometryElement(node, geometry, objectStack);
    }
}
GML32.prototype.namespace = 'http://www.opengis.net/gml/3.2';
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'pos': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readFlatPos),
        'posList': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readFlatPosList),
        'coordinates': (0, _xmlJs.makeReplacer)((0, _gml2JsDefault.default).prototype.readFlatCoordinates)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.FLAT_LINEAR_RINGS_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'interior': (0, _gml3JsDefault.default).prototype.interiorParser,
        'exterior': (0, _gml3JsDefault.default).prototype.exteriorParser
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.GEOMETRY_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'Point': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPoint),
        'MultiPoint': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPoint),
        'LineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLineString),
        'MultiLineString': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiLineString),
        'LinearRing': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readLinearRing),
        'Polygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readPolygon),
        'MultiPolygon': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readMultiPolygon),
        'Surface': (0, _xmlJs.makeReplacer)(GML32.prototype.readSurface),
        'MultiSurface': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readMultiSurface),
        'Curve': (0, _xmlJs.makeReplacer)(GML32.prototype.readCurve),
        'MultiCurve': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readMultiCurve),
        'Envelope': (0, _xmlJs.makeReplacer)(GML32.prototype.readEnvelope)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.MULTICURVE_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'curveMember': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.curveMemberParser),
        'curveMembers': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.curveMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.MULTISURFACE_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'surfaceMember': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.surfaceMemberParser),
        'surfaceMembers': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.surfaceMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.CURVEMEMBER_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'LineString': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readLineString),
        'Curve': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.readCurve)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.SURFACEMEMBER_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'Polygon': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readPolygon),
        'Surface': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.readSurface)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.SURFACE_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'patches': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readPatch)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.CURVE_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'segments': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readSegment)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.ENVELOPE_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'lowerCorner': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.readFlatPosList),
        'upperCorner': (0, _xmlJs.makeArrayPusher)((0, _gml3JsDefault.default).prototype.readFlatPosList)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.PATCHES_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'PolygonPatch': (0, _xmlJs.makeReplacer)((0, _gml3JsDefault.default).prototype.readPolygonPatch)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.SEGMENTS_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'LineStringSegment': (0, _xmlJs.makeArrayExtender)((0, _gml3JsDefault.default).prototype.readLineStringSegment)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.MULTIPOINT_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'pointMember': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.pointMemberParser),
        'pointMembers': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.pointMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.MULTILINESTRING_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'lineStringMember': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.lineStringMemberParser),
        'lineStringMembers': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.lineStringMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.MULTIPOLYGON_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'polygonMember': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.polygonMemberParser),
        'polygonMembers': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.polygonMemberParser)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.POINTMEMBER_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'Point': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readFlatCoordinatesFromNode)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.LINESTRINGMEMBER_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'LineString': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readLineString)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.POLYGONMEMBER_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'Polygon': (0, _xmlJs.makeArrayPusher)((0, _gmlbaseJsDefault.default).prototype.readPolygon)
    }
};
/**
 * @const
 * @type {Object<string, Object<string, import("../xml.js").Parser>>}
 */ GML32.prototype.RING_PARSERS = {
    'http://www.opengis.net/gml/3.2': {
        'LinearRing': (0, _xmlJs.makeReplacer)((0, _gmlbaseJsDefault.default).prototype.readFlatLinearRing),
        'Ring': (0, _xmlJs.makeReplacer)(GML32.prototype.readFlatCurveRing)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.RING_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'exterior': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeRing),
        'interior': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeRing)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.ENVELOPE_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'lowerCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode)),
        'upperCorner': (0, _xmlJs.makeChildAppender)((0, _xsdJs.writeStringTextNode))
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'surfaceMember': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeSurfaceOrPolygonMember),
        'polygonMember': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeSurfaceOrPolygonMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.POINTMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'pointMember': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writePointMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'lineStringMember': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeLineStringOrCurveMember),
        'curveMember': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeLineStringOrCurveMember)
    }
};
/**
 * @type {Object<string, Object<string, import("../xml.js").Serializer>>}
 */ GML32.prototype.GEOMETRY_SERIALIZERS = {
    'http://www.opengis.net/gml/3.2': {
        'Curve': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeCurveOrLineString),
        'MultiCurve': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeMultiCurveOrLineString),
        'Point': (0, _xmlJs.makeChildAppender)(GML32.prototype.writePoint),
        'MultiPoint': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeMultiPoint),
        'LineString': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeCurveOrLineString),
        'MultiLineString': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeMultiCurveOrLineString),
        'LinearRing': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeLinearRing),
        'Polygon': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeSurfaceOrPolygon),
        'MultiPolygon': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeMultiSurfaceOrPolygon),
        'Surface': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeSurfaceOrPolygon),
        'MultiSurface': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeMultiSurfaceOrPolygon),
        'Envelope': (0, _xmlJs.makeChildAppender)((0, _gml3JsDefault.default).prototype.writeEnvelope)
    }
};
exports.default = GML32;

},{"./GML2.js":"9tsJN","./GML3.js":"doSR5","./GMLBase.js":"9rBB8","../xml.js":"kPa2a","../format/xsd.js":"8AOX3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1wziX":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a logical `<And>` operator between two or more filter conditions.
 *
 * @param {...import("./filter/Filter.js").default} conditions Filter conditions.
 * @return {!And} `<And>` operator.
 * @api
 */ parcelHelpers.export(exports, "and", ()=>and);
/**
 * Create a logical `<Or>` operator between two or more filter conditions.
 *
 * @param {...import("./filter/Filter.js").default} conditions Filter conditions.
 * @return {!Or} `<Or>` operator.
 * @api
 */ parcelHelpers.export(exports, "or", ()=>or);
/**
 * Represents a logical `<Not>` operator for a filter condition.
 *
 * @param {!import("./filter/Filter.js").default} condition Filter condition.
 * @return {!Not} `<Not>` operator.
 * @api
 */ parcelHelpers.export(exports, "not", ()=>not);
/**
 * Create a `<BBOX>` operator to test whether a geometry-valued property
 * intersects a fixed bounding box
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../extent.js").Extent} extent Extent.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Bbox} `<BBOX>` operator.
 * @api
 */ parcelHelpers.export(exports, "bbox", ()=>bbox);
/**
 * Create a `<Contains>` operator to test whether a geometry-valued property
 * contains a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Contains} `<Contains>` operator.
 * @api
 */ parcelHelpers.export(exports, "contains", ()=>contains);
/**
 * Create a `<Intersects>` operator to test whether a geometry-valued property
 * intersects a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Intersects} `<Intersects>` operator.
 * @api
 */ parcelHelpers.export(exports, "intersects", ()=>intersects);
/**
 * Create a `<Disjoint>` operator to test whether a geometry-valued property
 * is disjoint to a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Disjoint} `<Disjoint>` operator.
 * @api
 */ parcelHelpers.export(exports, "disjoint", ()=>disjoint);
/**
 * Create a `<Within>` operator to test whether a geometry-valued property
 * is within a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!Within} `<Within>` operator.
 * @api
 */ parcelHelpers.export(exports, "within", ()=>within);
/**
 * Create a `<DWithin>` operator to test whether a geometry-valued property
 * is within a distance to a given geometry.
 *
 * @param {!string} geometryName Geometry name to use.
 * @param {!import("../geom/Geometry.js").default} geometry Geometry.
 * @param {!number} distance Distance.
 * @param {!string} unit Unit.
 * @param {string} [srsName] SRS name. No srsName attribute will be
 *    set on geometries when this is not provided.
 * @return {!DWithin} `<DWithin>` operator.
 * @api
 */ parcelHelpers.export(exports, "dwithin", ()=>dwithin);
/**
 * Creates a `<PropertyIsEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!(string|number)} expression The value to compare.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!EqualTo} `<PropertyIsEqualTo>` operator.
 * @api
 */ parcelHelpers.export(exports, "equalTo", ()=>equalTo);
/**
 * Creates a `<PropertyIsNotEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!(string|number)} expression The value to compare.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.
 * @api
 */ parcelHelpers.export(exports, "notEqualTo", ()=>notEqualTo);
/**
 * Creates a `<PropertyIsLessThan>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!LessThan} `<PropertyIsLessThan>` operator.
 * @api
 */ parcelHelpers.export(exports, "lessThan", ()=>lessThan);
/**
 * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.
 * @api
 */ parcelHelpers.export(exports, "lessThanOrEqualTo", ()=>lessThanOrEqualTo);
/**
 * Creates a `<PropertyIsGreaterThan>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!GreaterThan} `<PropertyIsGreaterThan>` operator.
 * @api
 */ parcelHelpers.export(exports, "greaterThan", ()=>greaterThan);
/**
 * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} expression The value to compare.
 * @return {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.
 * @api
 */ parcelHelpers.export(exports, "greaterThanOrEqualTo", ()=>greaterThanOrEqualTo);
/**
 * Creates a `<PropertyIsNull>` comparison operator to test whether a property value
 * is null.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @return {!IsNull} `<PropertyIsNull>` operator.
 * @api
 */ parcelHelpers.export(exports, "isNull", ()=>isNull);
/**
 * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression
 * value lies within a range given by a lower and upper bound (inclusive).
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!number} lowerBoundary The lower bound of the range.
 * @param {!number} upperBoundary The upper bound of the range.
 * @return {!IsBetween} `<PropertyIsBetween>` operator.
 * @api
 */ parcelHelpers.export(exports, "between", ()=>between);
/**
 * Represents a `<PropertyIsLike>` comparison operator that matches a string property
 * value against a text pattern.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!string} pattern Text pattern.
 * @param {string} [wildCard] Pattern character which matches any sequence of
 *    zero or more string characters. Default is '*'.
 * @param {string} [singleChar] pattern character which matches any single
 *    string character. Default is '.'.
 * @param {string} [escapeChar] Escape character which can be used to escape
 *    the pattern characters. Default is '!'.
 * @param {boolean} [matchCase] Case-sensitive?
 * @return {!IsLike} `<PropertyIsLike>` operator.
 * @api
 */ parcelHelpers.export(exports, "like", ()=>like);
/**
 * Create a `<During>` temporal operator.
 *
 * @param {!string} propertyName Name of the context property to compare.
 * @param {!string} begin The begin date in ISO-8601 format.
 * @param {!string} end The end date in ISO-8601 format.
 * @return {!During} `<During>` operator.
 * @api
 */ parcelHelpers.export(exports, "during", ()=>during);
parcelHelpers.export(exports, "resourceId", ()=>resourceId);
var _andJs = require("./filter/And.js");
var _andJsDefault = parcelHelpers.interopDefault(_andJs);
var _bboxJs = require("./filter/Bbox.js");
var _bboxJsDefault = parcelHelpers.interopDefault(_bboxJs);
var _containsJs = require("./filter/Contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _dwithinJs = require("./filter/DWithin.js");
var _dwithinJsDefault = parcelHelpers.interopDefault(_dwithinJs);
var _disjointJs = require("./filter/Disjoint.js");
var _disjointJsDefault = parcelHelpers.interopDefault(_disjointJs);
var _duringJs = require("./filter/During.js");
var _duringJsDefault = parcelHelpers.interopDefault(_duringJs);
var _equalToJs = require("./filter/EqualTo.js");
var _equalToJsDefault = parcelHelpers.interopDefault(_equalToJs);
var _greaterThanJs = require("./filter/GreaterThan.js");
var _greaterThanJsDefault = parcelHelpers.interopDefault(_greaterThanJs);
var _greaterThanOrEqualToJs = require("./filter/GreaterThanOrEqualTo.js");
var _greaterThanOrEqualToJsDefault = parcelHelpers.interopDefault(_greaterThanOrEqualToJs);
var _intersectsJs = require("./filter/Intersects.js");
var _intersectsJsDefault = parcelHelpers.interopDefault(_intersectsJs);
var _isBetweenJs = require("./filter/IsBetween.js");
var _isBetweenJsDefault = parcelHelpers.interopDefault(_isBetweenJs);
var _isLikeJs = require("./filter/IsLike.js");
var _isLikeJsDefault = parcelHelpers.interopDefault(_isLikeJs);
var _isNullJs = require("./filter/IsNull.js");
var _isNullJsDefault = parcelHelpers.interopDefault(_isNullJs);
var _lessThanJs = require("./filter/LessThan.js");
var _lessThanJsDefault = parcelHelpers.interopDefault(_lessThanJs);
var _lessThanOrEqualToJs = require("./filter/LessThanOrEqualTo.js");
var _lessThanOrEqualToJsDefault = parcelHelpers.interopDefault(_lessThanOrEqualToJs);
var _notJs = require("./filter/Not.js");
var _notJsDefault = parcelHelpers.interopDefault(_notJs);
var _notEqualToJs = require("./filter/NotEqualTo.js");
var _notEqualToJsDefault = parcelHelpers.interopDefault(_notEqualToJs);
var _orJs = require("./filter/Or.js");
var _orJsDefault = parcelHelpers.interopDefault(_orJs);
var _resourceIdJs = require("./filter/ResourceId.js");
var _resourceIdJsDefault = parcelHelpers.interopDefault(_resourceIdJs);
var _withinJs = require("./filter/Within.js");
var _withinJsDefault = parcelHelpers.interopDefault(_withinJs);
function and(conditions) {
    const params = [
        null
    ].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply((0, _andJsDefault.default), params))();
}
function or(conditions) {
    const params = [
        null
    ].concat(Array.prototype.slice.call(arguments));
    return new (Function.prototype.bind.apply((0, _orJsDefault.default), params))();
}
function not(condition) {
    return new (0, _notJsDefault.default)(condition);
}
function bbox(geometryName, extent, srsName) {
    return new (0, _bboxJsDefault.default)(geometryName, extent, srsName);
}
function contains(geometryName, geometry, srsName) {
    return new (0, _containsJsDefault.default)(geometryName, geometry, srsName);
}
function intersects(geometryName, geometry, srsName) {
    return new (0, _intersectsJsDefault.default)(geometryName, geometry, srsName);
}
function disjoint(geometryName, geometry, srsName) {
    return new (0, _disjointJsDefault.default)(geometryName, geometry, srsName);
}
function within(geometryName, geometry, srsName) {
    return new (0, _withinJsDefault.default)(geometryName, geometry, srsName);
}
function dwithin(geometryName, geometry, distance, unit, srsName) {
    return new (0, _dwithinJsDefault.default)(geometryName, geometry, distance, unit, srsName);
}
function equalTo(propertyName, expression, matchCase) {
    return new (0, _equalToJsDefault.default)(propertyName, expression, matchCase);
}
function notEqualTo(propertyName, expression, matchCase) {
    return new (0, _notEqualToJsDefault.default)(propertyName, expression, matchCase);
}
function lessThan(propertyName, expression) {
    return new (0, _lessThanJsDefault.default)(propertyName, expression);
}
function lessThanOrEqualTo(propertyName, expression) {
    return new (0, _lessThanOrEqualToJsDefault.default)(propertyName, expression);
}
function greaterThan(propertyName, expression) {
    return new (0, _greaterThanJsDefault.default)(propertyName, expression);
}
function greaterThanOrEqualTo(propertyName, expression) {
    return new (0, _greaterThanOrEqualToJsDefault.default)(propertyName, expression);
}
function isNull(propertyName) {
    return new (0, _isNullJsDefault.default)(propertyName);
}
function between(propertyName, lowerBoundary, upperBoundary) {
    return new (0, _isBetweenJsDefault.default)(propertyName, lowerBoundary, upperBoundary);
}
function like(propertyName, pattern, wildCard, singleChar, escapeChar, matchCase) {
    return new (0, _isLikeJsDefault.default)(propertyName, pattern, wildCard, singleChar, escapeChar, matchCase);
}
function during(propertyName, begin, end) {
    return new (0, _duringJsDefault.default)(propertyName, begin, end);
}
function resourceId(rid) {
    return new (0, _resourceIdJsDefault.default)(rid);
}

},{"./filter/And.js":"5Km50","./filter/Bbox.js":"fsLvq","./filter/Contains.js":"3Q4Ih","./filter/DWithin.js":"hFzF8","./filter/Disjoint.js":"kcn9V","./filter/During.js":"6JO93","./filter/EqualTo.js":"51YHK","./filter/GreaterThan.js":"llXFh","./filter/GreaterThanOrEqualTo.js":"937X1","./filter/Intersects.js":"jnyMS","./filter/IsBetween.js":"HwUSr","./filter/IsLike.js":"gPLua","./filter/IsNull.js":"PZrU8","./filter/LessThan.js":"gVmUr","./filter/LessThanOrEqualTo.js":"eKJYO","./filter/Not.js":"i3NA6","./filter/NotEqualTo.js":"3xut8","./filter/Or.js":"a4RLU","./filter/ResourceId.js":"2SAIn","./filter/Within.js":"6seAC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Km50":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/And
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _logicalNaryJs = require("./LogicalNary.js");
var _logicalNaryJsDefault = parcelHelpers.interopDefault(_logicalNaryJs);
/**
 * @classdesc
 * Represents a logical `<And>` operator between two or more filter conditions.
 *
 * @abstract
 */ class And extends (0, _logicalNaryJsDefault.default) {
    /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */ constructor(conditions){
        super('And', Array.prototype.slice.call(arguments));
    }
}
exports.default = And;

},{"./LogicalNary.js":"gd0CR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gd0CR":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/LogicalNary
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
var _assertsJs = require("../../asserts.js");
/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature n-ary logical filters.
 *
 * @abstract
 */ class LogicalNary extends (0, _filterJsDefault.default) {
    /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {Array<import("./Filter.js").default>} conditions Conditions.
   */ constructor(tagName, conditions){
        super(tagName);
        /**
     * @type {Array<import("./Filter.js").default>}
     */ this.conditions = conditions;
        (0, _assertsJs.assert)(this.conditions.length >= 2, 'At least 2 conditions are required');
    }
}
exports.default = LogicalNary;

},{"./Filter.js":"bsJCi","../../asserts.js":"e4TiF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bsJCi":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Filter
 */ /**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature filters.
 *
 * @abstract
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class Filter {
    /**
   * @param {!string} tagName The XML tag name for this filter.
   */ constructor(tagName){
        /**
     * @private
     * @type {!string}
     */ this.tagName_ = tagName;
    }
    /**
   * The XML tag name for a filter.
   * @return {!string} Name.
   */ getTagName() {
        return this.tagName_;
    }
}
exports.default = Filter;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fsLvq":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Bbox
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
/**
 * @classdesc
 * Represents a `<BBOX>` operator to test whether a geometry-valued property
 * intersects a fixed bounding box
 *
 * @api
 */ class Bbox extends (0, _filterJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be set
   * on geometries when this is not provided.
   */ constructor(geometryName, extent, srsName){
        super('BBOX');
        /**
     * @type {!string}
     */ this.geometryName = geometryName;
        /**
     * @type {import("../../extent.js").Extent}
     */ this.extent = extent;
        if (extent.length !== 4) throw new Error('Expected an extent with four values ([minX, minY, maxX, maxY])');
        /**
     * @type {string|undefined}
     */ this.srsName = srsName;
    }
}
exports.default = Bbox;

},{"./Filter.js":"bsJCi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Q4Ih":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Contains
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spatialJs = require("./Spatial.js");
var _spatialJsDefault = parcelHelpers.interopDefault(_spatialJs);
/**
 * @classdesc
 * Represents a `<Contains>` operator to test whether a geometry-valued property
 * contains a given geometry.
 * @api
 */ class Contains extends (0, _spatialJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(geometryName, geometry, srsName){
        super('Contains', geometryName, geometry, srsName);
    }
}
exports.default = Contains;

},{"./Spatial.js":"7G2Mu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7G2Mu":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Spatial
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Represents a spatial operator to test whether a geometry-valued property
 * relates to a given geometry.
 *
 * @abstract
 */ class Spatial extends (0, _filterJsDefault.default) {
    /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(tagName, geometryName, geometry, srsName){
        super(tagName);
        /**
     * @type {!string}
     */ this.geometryName = geometryName || 'the_geom';
        /**
     * @type {import("../../geom/Geometry.js").default}
     */ this.geometry = geometry;
        /**
     * @type {string|undefined}
     */ this.srsName = srsName;
    }
}
exports.default = Spatial;

},{"./Filter.js":"bsJCi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hFzF8":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/DWithin
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spatialJs = require("./Spatial.js");
var _spatialJsDefault = parcelHelpers.interopDefault(_spatialJs);
/**
 * @classdesc
 * Represents a `<DWithin>` operator to test whether a geometry-valued property
 * is within a distance to a given geometry.
 * @api
 */ class DWithin extends (0, _spatialJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {!number} distance Distance.
   * @param {!string} unit Unit.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(geometryName, geometry, distance, unit, srsName){
        super('DWithin', geometryName, geometry, srsName);
        /**
     * @public
     * @type {!number}
     */ this.distance = distance;
        /**
     * @public
     * @type {!string}
     */ this.unit = unit;
    }
}
exports.default = DWithin;

},{"./Spatial.js":"7G2Mu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kcn9V":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Disjoint
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spatialJs = require("./Spatial.js");
var _spatialJsDefault = parcelHelpers.interopDefault(_spatialJs);
/**
 * @classdesc
 * Represents a `<Disjoint>` operator to test whether a geometry-valued property
 * is disjoint to a given geometry.
 * @api
 */ class Disjoint extends (0, _spatialJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(geometryName, geometry, srsName){
        super('Disjoint', geometryName, geometry, srsName);
    }
}
exports.default = Disjoint;

},{"./Spatial.js":"7G2Mu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6JO93":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/During
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonJs = require("./Comparison.js");
var _comparisonJsDefault = parcelHelpers.interopDefault(_comparisonJs);
/**
 * @classdesc
 * Represents a `<During>` comparison operator.
 * @api
 */ class During extends (0, _comparisonJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!string} begin The begin date in ISO-8601 format.
   * @param {!string} end The end date in ISO-8601 format.
   */ constructor(propertyName, begin, end){
        super('During', propertyName);
        /**
     * @type {!string}
     */ this.begin = begin;
        /**
     * @type {!string}
     */ this.end = end;
    }
}
exports.default = During;

},{"./Comparison.js":"aAd75","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aAd75":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Comparison
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature property comparison filters.
 *
 * @abstract
 */ class Comparison extends (0, _filterJsDefault.default) {
    /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} propertyName Name of the context property to compare.
   */ constructor(tagName, propertyName){
        super(tagName);
        /**
     * @type {!string}
     */ this.propertyName = propertyName;
    }
}
exports.default = Comparison;

},{"./Filter.js":"bsJCi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"51YHK":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/EqualTo
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsEqualTo>` comparison operator.
 * @api
 */ class EqualTo extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [matchCase] Case-sensitive?
   */ constructor(propertyName, expression, matchCase){
        super('PropertyIsEqualTo', propertyName, expression, matchCase);
    }
}
exports.default = EqualTo;

},{"./ComparisonBinary.js":"lIyLn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lIyLn":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/ComparisonBinary
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonJs = require("./Comparison.js");
var _comparisonJsDefault = parcelHelpers.interopDefault(_comparisonJs);
/**
 * @classdesc
 * Abstract class; normally only used for creating subclasses and not instantiated in apps.
 * Base class for WFS GetFeature property binary comparison filters.
 *
 * @abstract
 */ class ComparisonBinary extends (0, _comparisonJsDefault.default) {
    /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [matchCase] Case-sensitive?
   */ constructor(tagName, propertyName, expression, matchCase){
        super(tagName, propertyName);
        /**
     * @type {!(string|number)}
     */ this.expression = expression;
        /**
     * @type {boolean|undefined}
     */ this.matchCase = matchCase;
    }
}
exports.default = ComparisonBinary;

},{"./Comparison.js":"aAd75","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llXFh":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/GreaterThan
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsGreaterThan>` comparison operator.
 * @api
 */ class GreaterThan extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */ constructor(propertyName, expression){
        super('PropertyIsGreaterThan', propertyName, expression);
    }
}
exports.default = GreaterThan;

},{"./ComparisonBinary.js":"lIyLn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"937X1":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/GreaterThanOrEqualTo
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.
 * @api
 */ class GreaterThanOrEqualTo extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */ constructor(propertyName, expression){
        super('PropertyIsGreaterThanOrEqualTo', propertyName, expression);
    }
}
exports.default = GreaterThanOrEqualTo;

},{"./ComparisonBinary.js":"lIyLn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jnyMS":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Intersects
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spatialJs = require("./Spatial.js");
var _spatialJsDefault = parcelHelpers.interopDefault(_spatialJs);
/**
 * @classdesc
 * Represents a `<Intersects>` operator to test whether a geometry-valued property
 * intersects a given geometry.
 * @api
 */ class Intersects extends (0, _spatialJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(geometryName, geometry, srsName){
        super('Intersects', geometryName, geometry, srsName);
    }
}
exports.default = Intersects;

},{"./Spatial.js":"7G2Mu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"HwUSr":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/IsBetween
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonJs = require("./Comparison.js");
var _comparisonJsDefault = parcelHelpers.interopDefault(_comparisonJs);
/**
 * @classdesc
 * Represents a `<PropertyIsBetween>` comparison operator.
 * @api
 */ class IsBetween extends (0, _comparisonJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} lowerBoundary The lower bound of the range.
   * @param {!number} upperBoundary The upper bound of the range.
   */ constructor(propertyName, lowerBoundary, upperBoundary){
        super('PropertyIsBetween', propertyName);
        /**
     * @type {!number}
     */ this.lowerBoundary = lowerBoundary;
        /**
     * @type {!number}
     */ this.upperBoundary = upperBoundary;
    }
}
exports.default = IsBetween;

},{"./Comparison.js":"aAd75","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gPLua":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/IsLike
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonJs = require("./Comparison.js");
var _comparisonJsDefault = parcelHelpers.interopDefault(_comparisonJs);
/**
 * @classdesc
 * Represents a `<PropertyIsLike>` comparison operator.
 * @api
 */ class IsLike extends (0, _comparisonJsDefault.default) {
    /**
   * [constructor description]
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!string} pattern Text pattern.
   * @param {string} [wildCard] Pattern character which matches any sequence of
   *    zero or more string characters. Default is '*'.
   * @param {string} [singleChar] pattern character which matches any single
   *    string character. Default is '.'.
   * @param {string} [escapeChar] Escape character which can be used to escape
   *    the pattern characters. Default is '!'.
   * @param {boolean} [matchCase] Case-sensitive?
   */ constructor(propertyName, pattern, wildCard, singleChar, escapeChar, matchCase){
        super('PropertyIsLike', propertyName);
        /**
     * @type {!string}
     */ this.pattern = pattern;
        /**
     * @type {!string}
     */ this.wildCard = wildCard !== undefined ? wildCard : '*';
        /**
     * @type {!string}
     */ this.singleChar = singleChar !== undefined ? singleChar : '.';
        /**
     * @type {!string}
     */ this.escapeChar = escapeChar !== undefined ? escapeChar : '!';
        /**
     * @type {boolean|undefined}
     */ this.matchCase = matchCase;
    }
}
exports.default = IsLike;

},{"./Comparison.js":"aAd75","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"PZrU8":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/IsNull
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonJs = require("./Comparison.js");
var _comparisonJsDefault = parcelHelpers.interopDefault(_comparisonJs);
/**
 * @classdesc
 * Represents a `<PropertyIsNull>` comparison operator.
 * @api
 */ class IsNull extends (0, _comparisonJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   */ constructor(propertyName){
        super('PropertyIsNull', propertyName);
    }
}
exports.default = IsNull;

},{"./Comparison.js":"aAd75","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gVmUr":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/LessThan
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsLessThan>` comparison operator.
 * @api
 */ class LessThan extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */ constructor(propertyName, expression){
        super('PropertyIsLessThan', propertyName, expression);
    }
}
exports.default = LessThan;

},{"./ComparisonBinary.js":"lIyLn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eKJYO":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/LessThanOrEqualTo
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsLessThanOrEqualTo>` comparison operator.
 * @api
 */ class LessThanOrEqualTo extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!number} expression The value to compare.
   */ constructor(propertyName, expression){
        super('PropertyIsLessThanOrEqualTo', propertyName, expression);
    }
}
exports.default = LessThanOrEqualTo;

},{"./ComparisonBinary.js":"lIyLn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i3NA6":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Not
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
/**
 * @classdesc
 * Represents a logical `<Not>` operator for a filter condition.
 * @api
 */ class Not extends (0, _filterJsDefault.default) {
    /**
   * @param {!import("./Filter.js").default} condition Filter condition.
   */ constructor(condition){
        super('Not');
        /**
     * @type {!import("./Filter.js").default}
     */ this.condition = condition;
    }
}
exports.default = Not;

},{"./Filter.js":"bsJCi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3xut8":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/NotEqualTo
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _comparisonBinaryJs = require("./ComparisonBinary.js");
var _comparisonBinaryJsDefault = parcelHelpers.interopDefault(_comparisonBinaryJs);
/**
 * @classdesc
 * Represents a `<PropertyIsNotEqualTo>` comparison operator.
 * @api
 */ class NotEqualTo extends (0, _comparisonBinaryJsDefault.default) {
    /**
   * @param {!string} propertyName Name of the context property to compare.
   * @param {!(string|number)} expression The value to compare.
   * @param {boolean} [matchCase] Case-sensitive?
   */ constructor(propertyName, expression, matchCase){
        super('PropertyIsNotEqualTo', propertyName, expression, matchCase);
    }
}
exports.default = NotEqualTo;

},{"./ComparisonBinary.js":"lIyLn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a4RLU":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Or
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _logicalNaryJs = require("./LogicalNary.js");
var _logicalNaryJsDefault = parcelHelpers.interopDefault(_logicalNaryJs);
/**
 * @classdesc
 * Represents a logical `<Or>` operator between two or more filter conditions.
 * @api
 */ class Or extends (0, _logicalNaryJsDefault.default) {
    /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */ constructor(conditions){
        super('Or', Array.prototype.slice.call(arguments));
    }
}
exports.default = Or;

},{"./LogicalNary.js":"gd0CR","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2SAIn":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/ResourceId
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _filterJs = require("./Filter.js");
var _filterJsDefault = parcelHelpers.interopDefault(_filterJs);
/**
 * @classdesc
 *
 * @abstract
 */ class ResourceId extends (0, _filterJsDefault.default) {
    /**
   * @param {!string} rid Resource ID.
   */ constructor(rid){
        super('ResourceId');
        /**
     * @type {!string}
     */ this.rid = rid;
    }
}
exports.default = ResourceId;

},{"./Filter.js":"bsJCi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6seAC":[function(require,module,exports,__globalThis) {
/**
 * @module ol/format/filter/Within
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spatialJs = require("./Spatial.js");
var _spatialJsDefault = parcelHelpers.interopDefault(_spatialJs);
/**
 * @classdesc
 * Represents a `<Within>` operator to test whether a geometry-valued property
 * is within a given geometry.
 * @api
 */ class Within extends (0, _spatialJsDefault.default) {
    /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../geom/Geometry.js").default} geometry Geometry.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   */ constructor(geometryName, geometry, srsName){
        super('Within', geometryName, geometry, srsName);
    }
}
exports.default = Within;

},{"./Spatial.js":"7G2Mu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4T7TT":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Modify
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth] Depth.
 * @property {Feature} feature Feature.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} [index] Index.
 * @property {Array<Array<number>>} segment Segment.
 * @property {Array<SegmentData>} [featureSegments] FeatureSegments.
 */ /**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition.primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition.singleClick} with
 * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex should be added to the sketch
 * features. Default is {@link module:ol/events/condition.always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike} [style]
 * Style used for the modification point or vertex. For linestrings and polygons, this will
 * be the affected vertex, for circles a point along the circle, and for points the actual
 * point. If not configured, the default edit style is used (see {@link module:ol/style/Style~Style}).
 * When using a style function, the point feature passed to the function will have a `features`
 * property - an array whose entries are the features that are being modified, and a `geometries`
 * property - an array whose entries are the geometries that are being modified. Both arrays are
 * in the same order. The `geometries` are only useful when modifying geometry collections, where
 * the geometry will be the particular geometry from the collection that is being modified.
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the `features` option.
 * @property {boolean|import("../layer/BaseVector").default} [hitDetection] When configured, point
 * features will be considered for modification based on their visual appearance, instead of being within
 * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector~BaseVectorLayer} is
 * provided, only the rendered representation of the features on that layer will be considered.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the `source` option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the
 * pointer coordinate when clicked within the `pixelTolerance`.
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */ parcelHelpers.export(exports, "ModifyEvent", ()=>ModifyEvent);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _rbushJs = require("../structs/RBush.js");
var _rbushJsDefault = parcelHelpers.interopDefault(_rbushJs);
var _vectorEventTypeJs = require("../source/VectorEventType.js");
var _vectorEventTypeJsDefault = parcelHelpers.interopDefault(_vectorEventTypeJs);
var _vectorJs = require("../layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _vectorJs1 = require("../source/Vector.js");
var _vectorJsDefault1 = parcelHelpers.interopDefault(_vectorJs1);
var _conditionJs = require("../events/condition.js");
var _extentJs = require("../extent.js");
var _coordinateJs = require("../coordinate.js");
var _styleJs = require("../style/Style.js");
var _arrayJs = require("../array.js");
var _polygonJs = require("../geom/Polygon.js");
var _projJs = require("../proj.js");
var _utilJs = require("../util.js");
/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */ const CIRCLE_CENTER_INDEX = 0;
/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */ const CIRCLE_CIRCUMFERENCE_INDEX = 1;
const tempExtent = [
    0,
    0,
    0,
    0
];
const tempSegment = [];
/**
 * @enum {string}
 */ const ModifyEventType = {
    /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */ MODIFYSTART: 'modifystart',
    /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */ MODIFYEND: 'modifyend'
};
class ModifyEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */ constructor(type, features, mapBrowserEvent){
        super(type);
        /**
     * The features being modified.
     * @type {Collection<Feature>}
     * @api
     */ this.features = features;
        /**
     * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */ this.mapBrowserEvent = mapBrowserEvent;
    }
}
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature
 */ /**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * Cartesian distance from the pointer is used to determine the features that
 * will be modified. This means that geometries will only be considered for
 * modification when they are within the configured `pixelTolerance`. For point
 * geometries, the `hitDetection` option can be used to match their visual
 * appearance.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */ class Modify extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} options Options.
   */ constructor(options){
        super(/** @type {import("./Pointer.js").Options} */ options);
        /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {ModifyOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {ModifyOnSignature<void>}
     */ this.un;
        /** @private */ this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this);
        /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */ this.condition_ = options.condition ? options.condition : (0, _conditionJs.primaryAction);
        /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */ this.defaultDeleteCondition_ = function(mapBrowserEvent) {
            return (0, _conditionJs.altKeyOnly)(mapBrowserEvent) && (0, _conditionJs.singleClick)(mapBrowserEvent);
        };
        /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */ this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : this.defaultDeleteCondition_;
        /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */ this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : (0, _conditionJs.always);
        /**
     * Editing vertex.
     * @type {Feature<Point>}
     * @private
     */ this.vertexFeature_ = null;
        /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */ this.vertexSegments_ = null;
        /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */ this.lastPixel_ = [
            0,
            0
        ];
        /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */ this.ignoreNextSingleClick_ = false;
        /**
     * @type {Collection<Feature>}
     * @private
     */ this.featuresBeingModified_ = null;
        /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */ this.rBush_ = new (0, _rbushJsDefault.default)();
        /**
     * @type {number}
     * @private
     */ this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
        /**
     * @type {boolean}
     * @private
     */ this.snappedToVertex_ = false;
        /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */ this.changingFeature_ = false;
        /**
     * @type {Array}
     * @private
     */ this.dragSegments_ = [];
        /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */ this.overlay_ = new (0, _vectorJsDefault.default)({
            source: new (0, _vectorJsDefault1.default)({
                useSpatialIndex: false,
                wrapX: !!options.wrapX
            }),
            style: options.style ? options.style : getDefaultStyleFunction(),
            updateWhileAnimating: true,
            updateWhileInteracting: true
        });
        /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
     */ this.SEGMENT_WRITERS_ = {
            'Point': this.writePointGeometry_.bind(this),
            'LineString': this.writeLineStringGeometry_.bind(this),
            'LinearRing': this.writeLineStringGeometry_.bind(this),
            'Polygon': this.writePolygonGeometry_.bind(this),
            'MultiPoint': this.writeMultiPointGeometry_.bind(this),
            'MultiLineString': this.writeMultiLineStringGeometry_.bind(this),
            'MultiPolygon': this.writeMultiPolygonGeometry_.bind(this),
            'Circle': this.writeCircleGeometry_.bind(this),
            'GeometryCollection': this.writeGeometryCollectionGeometry_.bind(this)
        };
        /**
     * @type {VectorSource}
     * @private
     */ this.source_ = null;
        /**
     * @type {boolean|import("../layer/BaseVector").default}
     */ this.hitDetection_ = null;
        /** @type {Collection<Feature>} */ let features;
        if (options.features) features = options.features;
        else if (options.source) {
            this.source_ = options.source;
            features = new (0, _collectionJsDefault.default)(this.source_.getFeatures());
            this.source_.addEventListener((0, _vectorEventTypeJsDefault.default).ADDFEATURE, this.handleSourceAdd_.bind(this));
            this.source_.addEventListener((0, _vectorEventTypeJsDefault.default).REMOVEFEATURE, this.handleSourceRemove_.bind(this));
        }
        if (!features) throw new Error('The modify interaction requires features, a source or a layer');
        if (options.hitDetection) this.hitDetection_ = options.hitDetection;
        /**
     * @type {Collection<Feature>}
     * @private
     */ this.features_ = features;
        this.features_.forEach(this.addFeature_.bind(this));
        this.features_.addEventListener((0, _collectionEventTypeJsDefault.default).ADD, this.handleFeatureAdd_.bind(this));
        this.features_.addEventListener((0, _collectionEventTypeJsDefault.default).REMOVE, this.handleFeatureRemove_.bind(this));
        /**
     * @type {import("../MapBrowserEvent.js").default}
     * @private
     */ this.lastPointerEvent_ = null;
        /**
     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.
     * @type {Array<number>}
     */ this.delta_ = [
            0,
            0
        ];
        /**
     * @private
     */ this.snapToPointer_ = options.snapToPointer === undefined ? !this.hitDetection_ : options.snapToPointer;
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ addFeature_(feature) {
        const geometry = feature.getGeometry();
        if (geometry) {
            const writer = this.SEGMENT_WRITERS_[geometry.getType()];
            if (writer) writer(feature, geometry);
        }
        const map = this.getMap();
        if (map && map.isRendered() && this.getActive()) this.handlePointerAtPixel_(this.lastPixel_, map);
        feature.addEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleFeatureChange_);
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */ willModifyFeatures_(evt, segments) {
        if (!this.featuresBeingModified_) {
            this.featuresBeingModified_ = new (0, _collectionJsDefault.default)();
            const features = this.featuresBeingModified_.getArray();
            for(let i = 0, ii = segments.length; i < ii; ++i){
                const segment = segments[i];
                for(let s = 0, ss = segment.length; s < ss; ++s){
                    const feature = segment[s].feature;
                    if (feature && !features.includes(feature)) this.featuresBeingModified_.push(feature);
                }
            }
            if (this.featuresBeingModified_.getLength() === 0) this.featuresBeingModified_ = null;
            else this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
        }
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ removeFeature_(feature) {
        this.removeFeatureSegmentData_(feature);
        // Remove the vertex feature if the collection of candidate features is empty.
        if (this.vertexFeature_ && this.features_.getLength() === 0) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
        feature.removeEventListener((0, _eventTypeJsDefault.default).CHANGE, this.boundHandleFeatureChange_);
    }
    /**
   * @param {Feature} feature Feature.
   * @private
   */ removeFeatureSegmentData_(feature) {
        const rBush = this.rBush_;
        /** @type {Array<SegmentData>} */ const nodesToRemove = [];
        rBush.forEach(/**
       * @param {SegmentData} node RTree node.
       */ function(node) {
            if (feature === node.feature) nodesToRemove.push(node);
        });
        for(let i = nodesToRemove.length - 1; i >= 0; --i){
            const nodeToRemove = nodesToRemove[i];
            for(let j = this.dragSegments_.length - 1; j >= 0; --j)if (this.dragSegments_[j][0] === nodeToRemove) this.dragSegments_.splice(j, 1);
            rBush.remove(nodeToRemove);
        }
    }
    /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */ setActive(active) {
        if (this.vertexFeature_ && !active) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
        super.setActive(active);
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */ setMap(map) {
        this.overlay_.setMap(map);
        super.setMap(map);
    }
    /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */ getOverlay() {
        return this.overlay_;
    }
    /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */ handleSourceAdd_(event) {
        if (event.feature) this.features_.push(event.feature);
    }
    /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */ handleSourceRemove_(event) {
        if (event.feature) this.features_.remove(event.feature);
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */ handleFeatureAdd_(evt) {
        this.addFeature_(evt.element);
    }
    /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */ handleFeatureChange_(evt) {
        if (!this.changingFeature_) {
            const feature = /** @type {Feature} */ evt.target;
            this.removeFeature_(feature);
            this.addFeature_(feature);
        }
    }
    /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */ handleFeatureRemove_(evt) {
        this.removeFeature_(evt.element);
    }
    /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */ writePointGeometry_(feature, geometry) {
        const coordinates = geometry.getCoordinates();
        /** @type {SegmentData} */ const segmentData = {
            feature: feature,
            geometry: geometry,
            segment: [
                coordinates,
                coordinates
            ]
        };
        this.rBush_.insert(geometry.getExtent(), segmentData);
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */ writeMultiPointGeometry_(feature, geometry) {
        const points = geometry.getCoordinates();
        for(let i = 0, ii = points.length; i < ii; ++i){
            const coordinates = points[i];
            /** @type {SegmentData} */ const segmentData = {
                feature: feature,
                geometry: geometry,
                depth: [
                    i
                ],
                index: i,
                segment: [
                    coordinates,
                    coordinates
                ]
            };
            this.rBush_.insert(geometry.getExtent(), segmentData);
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */ writeLineStringGeometry_(feature, geometry) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
            const segment = coordinates.slice(i, i + 2);
            /** @type {SegmentData} */ const segmentData = {
                feature: feature,
                geometry: geometry,
                index: i,
                segment: segment
            };
            this.rBush_.insert((0, _extentJs.boundingExtent)(segment), segmentData);
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */ writeMultiLineStringGeometry_(feature, geometry) {
        const lines = geometry.getCoordinates();
        for(let j = 0, jj = lines.length; j < jj; ++j){
            const coordinates = lines[j];
            for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
                const segment = coordinates.slice(i, i + 2);
                /** @type {SegmentData} */ const segmentData = {
                    feature: feature,
                    geometry: geometry,
                    depth: [
                        j
                    ],
                    index: i,
                    segment: segment
                };
                this.rBush_.insert((0, _extentJs.boundingExtent)(segment), segmentData);
            }
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */ writePolygonGeometry_(feature, geometry) {
        const rings = geometry.getCoordinates();
        for(let j = 0, jj = rings.length; j < jj; ++j){
            const coordinates = rings[j];
            for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
                const segment = coordinates.slice(i, i + 2);
                /** @type {SegmentData} */ const segmentData = {
                    feature: feature,
                    geometry: geometry,
                    depth: [
                        j
                    ],
                    index: i,
                    segment: segment
                };
                this.rBush_.insert((0, _extentJs.boundingExtent)(segment), segmentData);
            }
        }
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */ writeMultiPolygonGeometry_(feature, geometry) {
        const polygons = geometry.getCoordinates();
        for(let k = 0, kk = polygons.length; k < kk; ++k){
            const rings = polygons[k];
            for(let j = 0, jj = rings.length; j < jj; ++j){
                const coordinates = rings[j];
                for(let i = 0, ii = coordinates.length - 1; i < ii; ++i){
                    const segment = coordinates.slice(i, i + 2);
                    /** @type {SegmentData} */ const segmentData = {
                        feature: feature,
                        geometry: geometry,
                        depth: [
                            j,
                            k
                        ],
                        index: i,
                        segment: segment
                    };
                    this.rBush_.insert((0, _extentJs.boundingExtent)(segment), segmentData);
                }
            }
        }
    }
    /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */ writeCircleGeometry_(feature, geometry) {
        const coordinates = geometry.getCenter();
        /** @type {SegmentData} */ const centerSegmentData = {
            feature: feature,
            geometry: geometry,
            index: CIRCLE_CENTER_INDEX,
            segment: [
                coordinates,
                coordinates
            ]
        };
        /** @type {SegmentData} */ const circumferenceSegmentData = {
            feature: feature,
            geometry: geometry,
            index: CIRCLE_CIRCUMFERENCE_INDEX,
            segment: [
                coordinates,
                coordinates
            ]
        };
        const featureSegments = [
            centerSegmentData,
            circumferenceSegmentData
        ];
        centerSegmentData.featureSegments = featureSegments;
        circumferenceSegmentData.featureSegments = featureSegments;
        this.rBush_.insert((0, _extentJs.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
        let circleGeometry = /** @type {import("../geom/Geometry.js").default} */ geometry;
        const userProjection = (0, _projJs.getUserProjection)();
        if (userProjection && this.getMap()) {
            const projection = this.getMap().getView().getProjection();
            circleGeometry = circleGeometry.clone().transform(userProjection, projection);
            circleGeometry = (0, _polygonJs.fromCircle)(/** @type {import("../geom/Circle.js").default} */ circleGeometry).transform(projection, userProjection);
        }
        this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
    }
    /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */ writeGeometryCollectionGeometry_(feature, geometry) {
        const geometries = geometry.getGeometriesArray();
        for(let i = 0; i < geometries.length; ++i){
            const geometry = geometries[i];
            const writer = this.SEGMENT_WRITERS_[geometry.getType()];
            writer(feature, geometry);
        }
    }
    /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */ createOrUpdateVertexFeature_(coordinates, features, geometries) {
        let vertexFeature = this.vertexFeature_;
        if (!vertexFeature) {
            vertexFeature = new (0, _featureJsDefault.default)(new (0, _pointJsDefault.default)(coordinates));
            this.vertexFeature_ = vertexFeature;
            this.overlay_.getSource().addFeature(vertexFeature);
        } else {
            const geometry = vertexFeature.getGeometry();
            geometry.setCoordinates(coordinates);
        }
        vertexFeature.set('features', features);
        vertexFeature.set('geometries', geometries);
        return vertexFeature;
    }
    /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */ handleEvent(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) return true;
        this.lastPointerEvent_ = mapBrowserEvent;
        let handled;
        if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).POINTERMOVE && !this.handlingDownUpSequence) this.handlePointerMove_(mapBrowserEvent);
        if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
            if (mapBrowserEvent.type != (0, _mapBrowserEventTypeJsDefault.default).SINGLECLICK || !this.ignoreNextSingleClick_) handled = this.removePoint();
            else handled = true;
        }
        if (mapBrowserEvent.type == (0, _mapBrowserEventTypeJsDefault.default).SINGLECLICK) this.ignoreNextSingleClick_ = false;
        return super.handleEvent(mapBrowserEvent) && !handled;
    }
    /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */ handleDragEvent(evt) {
        this.ignoreNextSingleClick_ = false;
        this.willModifyFeatures_(evt, this.dragSegments_);
        const vertex = [
            evt.coordinate[0] + this.delta_[0],
            evt.coordinate[1] + this.delta_[1]
        ];
        const features = [];
        const geometries = [];
        for(let i = 0, ii = this.dragSegments_.length; i < ii; ++i){
            const dragSegment = this.dragSegments_[i];
            const segmentData = dragSegment[0];
            const feature = segmentData.feature;
            if (!features.includes(feature)) features.push(feature);
            const geometry = segmentData.geometry;
            if (!geometries.includes(geometry)) geometries.push(geometry);
            const depth = segmentData.depth;
            let coordinates;
            const segment = segmentData.segment;
            const index = dragSegment[1];
            while(vertex.length < geometry.getStride())vertex.push(segment[index][vertex.length]);
            switch(geometry.getType()){
                case 'Point':
                    coordinates = vertex;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    break;
                case 'MultiPoint':
                    coordinates = geometry.getCoordinates();
                    coordinates[segmentData.index] = vertex;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    break;
                case 'LineString':
                    coordinates = geometry.getCoordinates();
                    coordinates[segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'MultiLineString':
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'Polygon':
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'MultiPolygon':
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case 'Circle':
                    segment[0] = vertex;
                    segment[1] = vertex;
                    if (segmentData.index === CIRCLE_CENTER_INDEX) {
                        this.changingFeature_ = true;
                        geometry.setCenter(vertex);
                        this.changingFeature_ = false;
                    } else {
                        // We're dragging the circle's circumference:
                        this.changingFeature_ = true;
                        const projection = evt.map.getView().getProjection();
                        let radius = (0, _coordinateJs.distance)((0, _projJs.fromUserCoordinate)(geometry.getCenter(), projection), (0, _projJs.fromUserCoordinate)(vertex, projection));
                        const userProjection = (0, _projJs.getUserProjection)();
                        if (userProjection) {
                            const circleGeometry = geometry.clone().transform(userProjection, projection);
                            circleGeometry.setRadius(radius);
                            radius = circleGeometry.transform(projection, userProjection).getRadius();
                        }
                        geometry.setRadius(radius);
                        this.changingFeature_ = false;
                    }
                    break;
                default:
            }
            if (coordinates) this.setGeometryCoordinates_(geometry, coordinates);
        }
        this.createOrUpdateVertexFeature_(vertex, features, geometries);
    }
    /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */ handleDownEvent(evt) {
        if (!this.condition_(evt)) return false;
        const pixelCoordinate = evt.coordinate;
        this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
        this.dragSegments_.length = 0;
        this.featuresBeingModified_ = null;
        const vertexFeature = this.vertexFeature_;
        if (vertexFeature) {
            const projection = evt.map.getView().getProjection();
            const insertVertices = [];
            const vertex = vertexFeature.getGeometry().getCoordinates();
            const vertexExtent = (0, _extentJs.boundingExtent)([
                vertex
            ]);
            const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
            const componentSegments = {};
            segmentDataMatches.sort(compareIndexes);
            for(let i = 0, ii = segmentDataMatches.length; i < ii; ++i){
                const segmentDataMatch = segmentDataMatches[i];
                const segment = segmentDataMatch.segment;
                let uid = (0, _utilJs.getUid)(segmentDataMatch.geometry);
                const depth = segmentDataMatch.depth;
                if (depth) uid += '-' + depth.join('-'); // separate feature components
                if (!componentSegments[uid]) componentSegments[uid] = new Array(2);
                if (segmentDataMatch.geometry.getType() === 'Circle' && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                    const closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);
                    if ((0, _coordinateJs.equals)(closestVertex, vertex) && !componentSegments[uid][0]) {
                        this.dragSegments_.push([
                            segmentDataMatch,
                            0
                        ]);
                        componentSegments[uid][0] = segmentDataMatch;
                    }
                    continue;
                }
                if ((0, _coordinateJs.equals)(segment[0], vertex) && !componentSegments[uid][0]) {
                    this.dragSegments_.push([
                        segmentDataMatch,
                        0
                    ]);
                    componentSegments[uid][0] = segmentDataMatch;
                    continue;
                }
                if ((0, _coordinateJs.equals)(segment[1], vertex) && !componentSegments[uid][1]) {
                    if (componentSegments[uid][0] && componentSegments[uid][0].index === 0) {
                        let coordinates = segmentDataMatch.geometry.getCoordinates();
                        switch(segmentDataMatch.geometry.getType()){
                            // prevent dragging closed linestrings by the connecting node
                            case 'LineString':
                            case 'MultiLineString':
                                continue;
                            // if dragging the first vertex of a polygon, ensure the other segment
                            // belongs to the closing vertex of the linear ring
                            case 'MultiPolygon':
                                coordinates = coordinates[depth[1]];
                            /* falls through */ case 'Polygon':
                                if (segmentDataMatch.index !== coordinates[depth[0]].length - 2) continue;
                                break;
                            default:
                        }
                    }
                    this.dragSegments_.push([
                        segmentDataMatch,
                        1
                    ]);
                    componentSegments[uid][1] = segmentDataMatch;
                    continue;
                }
                if ((0, _utilJs.getUid)(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1] && this.insertVertexCondition_(evt)) insertVertices.push(segmentDataMatch);
            }
            if (insertVertices.length) this.willModifyFeatures_(evt, [
                insertVertices
            ]);
            for(let j = insertVertices.length - 1; j >= 0; --j)this.insertVertex_(insertVertices[j], vertex);
        }
        return !!this.vertexFeature_;
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(evt) {
        for(let i = this.dragSegments_.length - 1; i >= 0; --i){
            const segmentData = this.dragSegments_[i][0];
            const geometry = segmentData.geometry;
            if (geometry.getType() === 'Circle') {
                // Update a circle object in the R* bush:
                const coordinates = geometry.getCenter();
                const centerSegmentData = segmentData.featureSegments[0];
                const circumferenceSegmentData = segmentData.featureSegments[1];
                centerSegmentData.segment[0] = coordinates;
                centerSegmentData.segment[1] = coordinates;
                circumferenceSegmentData.segment[0] = coordinates;
                circumferenceSegmentData.segment[1] = coordinates;
                this.rBush_.update((0, _extentJs.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
                let circleGeometry = geometry;
                const userProjection = (0, _projJs.getUserProjection)();
                if (userProjection) {
                    const projection = evt.map.getView().getProjection();
                    circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                    circleGeometry = (0, _polygonJs.fromCircle)(circleGeometry).transform(projection, userProjection);
                }
                this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
            } else this.rBush_.update((0, _extentJs.boundingExtent)(segmentData.segment), segmentData);
        }
        if (this.featuresBeingModified_) {
            this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
            this.featuresBeingModified_ = null;
        }
        return false;
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */ handlePointerMove_(evt) {
        this.lastPixel_ = evt.pixel;
        this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
    }
    /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../Map.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate} [coordinate] The pixel Coordinate.
   * @private
   */ handlePointerAtPixel_(pixel, map, coordinate) {
        const pixelCoordinate = coordinate || map.getCoordinateFromPixel(pixel);
        const projection = map.getView().getProjection();
        const sortByDistance = function(a, b) {
            return projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection);
        };
        /** @type {Array<SegmentData>|undefined} */ let nodes;
        /** @type {Point|undefined} */ let hitPointGeometry;
        if (this.hitDetection_) {
            const layerFilter = typeof this.hitDetection_ === 'object' ? (layer)=>layer === this.hitDetection_ : undefined;
            map.forEachFeatureAtPixel(pixel, (feature, layer, geometry)=>{
                if (geometry && geometry.getType() === 'Point') geometry = new (0, _pointJsDefault.default)((0, _projJs.toUserCoordinate)(geometry.getCoordinates(), projection));
                const geom = geometry || feature.getGeometry();
                if (feature instanceof (0, _featureJsDefault.default) && this.features_.getArray().includes(feature)) {
                    hitPointGeometry = /** @type {Point} */ geom;
                    const coordinate = /** @type {Point} */ feature.getGeometry().getFlatCoordinates().slice(0, 2);
                    nodes = [
                        {
                            feature,
                            geometry: hitPointGeometry,
                            segment: [
                                coordinate,
                                coordinate
                            ]
                        }
                    ];
                }
                return true;
            }, {
                layerFilter
            });
        }
        if (!nodes) {
            const viewExtent = (0, _projJs.fromUserExtent)((0, _extentJs.createOrUpdateFromCoordinate)(pixelCoordinate, tempExtent), projection);
            const buffer = map.getView().getResolution() * this.pixelTolerance_;
            const box = (0, _projJs.toUserExtent)((0, _extentJs.buffer)(viewExtent, buffer, tempExtent), projection);
            nodes = this.rBush_.getInExtent(box);
        }
        if (nodes && nodes.length > 0) {
            const node = nodes.sort(sortByDistance)[0];
            const closestSegment = node.segment;
            let vertex = closestOnSegmentData(pixelCoordinate, node, projection);
            const vertexPixel = map.getPixelFromCoordinate(vertex);
            let dist = (0, _coordinateJs.distance)(pixel, vertexPixel);
            if (hitPointGeometry || dist <= this.pixelTolerance_) {
                /** @type {Object<string, boolean>} */ const vertexSegments = {};
                vertexSegments[(0, _utilJs.getUid)(closestSegment)] = true;
                if (!this.snapToPointer_) {
                    this.delta_[0] = vertex[0] - pixelCoordinate[0];
                    this.delta_[1] = vertex[1] - pixelCoordinate[1];
                }
                if (node.geometry.getType() === 'Circle' && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                    this.snappedToVertex_ = true;
                    this.createOrUpdateVertexFeature_(vertex, [
                        node.feature
                    ], [
                        node.geometry
                    ]);
                } else {
                    const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                    const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                    const squaredDist1 = (0, _coordinateJs.squaredDistance)(vertexPixel, pixel1);
                    const squaredDist2 = (0, _coordinateJs.squaredDistance)(vertexPixel, pixel2);
                    dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                    this.snappedToVertex_ = dist <= this.pixelTolerance_;
                    if (this.snappedToVertex_) vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                    this.createOrUpdateVertexFeature_(vertex, [
                        node.feature
                    ], [
                        node.geometry
                    ]);
                    const geometries = {};
                    geometries[(0, _utilJs.getUid)(node.geometry)] = true;
                    for(let i = 1, ii = nodes.length; i < ii; ++i){
                        const segment = nodes[i].segment;
                        if ((0, _coordinateJs.equals)(closestSegment[0], segment[0]) && (0, _coordinateJs.equals)(closestSegment[1], segment[1]) || (0, _coordinateJs.equals)(closestSegment[0], segment[1]) && (0, _coordinateJs.equals)(closestSegment[1], segment[0])) {
                            const geometryUid = (0, _utilJs.getUid)(nodes[i].geometry);
                            if (!(geometryUid in geometries)) {
                                geometries[geometryUid] = true;
                                vertexSegments[(0, _utilJs.getUid)(segment)] = true;
                            }
                        } else break;
                    }
                }
                this.vertexSegments_ = vertexSegments;
                return;
            }
        }
        if (this.vertexFeature_) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
    }
    /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */ insertVertex_(segmentData, vertex) {
        const segment = segmentData.segment;
        const feature = segmentData.feature;
        const geometry = segmentData.geometry;
        const depth = segmentData.depth;
        const index = segmentData.index;
        let coordinates;
        while(vertex.length < geometry.getStride())vertex.push(0);
        switch(geometry.getType()){
            case 'MultiLineString':
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
            case 'Polygon':
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
            case 'MultiPolygon':
                coordinates = geometry.getCoordinates();
                coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
                break;
            case 'LineString':
                coordinates = geometry.getCoordinates();
                coordinates.splice(index + 1, 0, vertex);
                break;
            default:
                return;
        }
        this.setGeometryCoordinates_(geometry, coordinates);
        const rTree = this.rBush_;
        rTree.remove(segmentData);
        this.updateSegmentIndices_(geometry, index, depth, 1);
        /** @type {SegmentData} */ const newSegmentData = {
            segment: [
                segment[0],
                vertex
            ],
            feature: feature,
            geometry: geometry,
            depth: depth,
            index: index
        };
        rTree.insert((0, _extentJs.boundingExtent)(newSegmentData.segment), newSegmentData);
        this.dragSegments_.push([
            newSegmentData,
            1
        ]);
        /** @type {SegmentData} */ const newSegmentData2 = {
            segment: [
                vertex,
                segment[1]
            ],
            feature: feature,
            geometry: geometry,
            depth: depth,
            index: index + 1
        };
        rTree.insert((0, _extentJs.boundingExtent)(newSegmentData2.segment), newSegmentData2);
        this.dragSegments_.push([
            newSegmentData2,
            0
        ]);
        this.ignoreNextSingleClick_ = true;
    }
    /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */ removePoint() {
        if (this.lastPointerEvent_ && this.lastPointerEvent_.type != (0, _mapBrowserEventTypeJsDefault.default).POINTERDRAG) {
            const evt = this.lastPointerEvent_;
            this.willModifyFeatures_(evt, this.dragSegments_);
            const removed = this.removeVertex_();
            if (this.featuresBeingModified_) this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
            this.featuresBeingModified_ = null;
            return removed;
        }
        return false;
    }
    /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */ removeVertex_() {
        const dragSegments = this.dragSegments_;
        const segmentsByFeature = {};
        let deleted = false;
        let component, coordinates, dragSegment, geometry, i, index, left;
        let newIndex, right, segmentData, uid;
        for(i = dragSegments.length - 1; i >= 0; --i){
            dragSegment = dragSegments[i];
            segmentData = dragSegment[0];
            uid = (0, _utilJs.getUid)(segmentData.feature);
            if (segmentData.depth) // separate feature components
            uid += '-' + segmentData.depth.join('-');
            if (!(uid in segmentsByFeature)) segmentsByFeature[uid] = {};
            if (dragSegment[1] === 0) {
                segmentsByFeature[uid].right = segmentData;
                segmentsByFeature[uid].index = segmentData.index;
            } else if (dragSegment[1] == 1) {
                segmentsByFeature[uid].left = segmentData;
                segmentsByFeature[uid].index = segmentData.index + 1;
            }
        }
        for(uid in segmentsByFeature){
            right = segmentsByFeature[uid].right;
            left = segmentsByFeature[uid].left;
            index = segmentsByFeature[uid].index;
            newIndex = index - 1;
            if (left !== undefined) segmentData = left;
            else segmentData = right;
            if (newIndex < 0) newIndex = 0;
            geometry = segmentData.geometry;
            coordinates = geometry.getCoordinates();
            component = coordinates;
            deleted = false;
            switch(geometry.getType()){
                case 'MultiLineString':
                    if (coordinates[segmentData.depth[0]].length > 2) {
                        coordinates[segmentData.depth[0]].splice(index, 1);
                        deleted = true;
                    }
                    break;
                case 'LineString':
                    if (coordinates.length > 2) {
                        coordinates.splice(index, 1);
                        deleted = true;
                    }
                    break;
                case 'MultiPolygon':
                    component = component[segmentData.depth[1]];
                /* falls through */ case 'Polygon':
                    component = component[segmentData.depth[0]];
                    if (component.length > 4) {
                        if (index == component.length - 1) index = 0;
                        component.splice(index, 1);
                        deleted = true;
                        if (index === 0) {
                            // close the ring again
                            component.pop();
                            component.push(component[0]);
                            newIndex = component.length - 1;
                        }
                    }
                    break;
                default:
            }
            if (deleted) {
                this.setGeometryCoordinates_(geometry, coordinates);
                const segments = [];
                if (left !== undefined) {
                    this.rBush_.remove(left);
                    segments.push(left.segment[0]);
                }
                if (right !== undefined) {
                    this.rBush_.remove(right);
                    segments.push(right.segment[1]);
                }
                if (left !== undefined && right !== undefined) {
                    /** @type {SegmentData} */ const newSegmentData = {
                        depth: segmentData.depth,
                        feature: segmentData.feature,
                        geometry: segmentData.geometry,
                        index: newIndex,
                        segment: segments
                    };
                    this.rBush_.insert((0, _extentJs.boundingExtent)(newSegmentData.segment), newSegmentData);
                }
                this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
                if (this.vertexFeature_) {
                    this.overlay_.getSource().removeFeature(this.vertexFeature_);
                    this.vertexFeature_ = null;
                }
                dragSegments.length = 0;
            }
        }
        return deleted;
    }
    /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */ setGeometryCoordinates_(geometry, coordinates) {
        this.changingFeature_ = true;
        geometry.setCoordinates(coordinates);
        this.changingFeature_ = false;
    }
    /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */ updateSegmentIndices_(geometry, index, depth, delta) {
        this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
            if (segmentDataMatch.geometry === geometry && (depth === undefined || segmentDataMatch.depth === undefined || (0, _arrayJs.equals)(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) segmentDataMatch.index += delta;
        });
    }
}
/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */ function compareIndexes(a, b) {
    return a.index - b.index;
}
/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {number} The square of the distance between a point and a line segment.
 */ function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
    const geometry = segmentData.geometry;
    if (geometry.getType() === 'Circle') {
        let circleGeometry = /** @type {import("../geom/Circle.js").default} */ geometry;
        if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
            const userProjection = (0, _projJs.getUserProjection)();
            if (userProjection) circleGeometry = /** @type {import("../geom/Circle.js").default} */ circleGeometry.clone().transform(userProjection, projection);
            const distanceToCenterSquared = (0, _coordinateJs.squaredDistance)(circleGeometry.getCenter(), (0, _projJs.fromUserCoordinate)(pointCoordinates, projection));
            const distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
            return distanceToCircumference * distanceToCircumference;
        }
    }
    const coordinate = (0, _projJs.fromUserCoordinate)(pointCoordinates, projection);
    tempSegment[0] = (0, _projJs.fromUserCoordinate)(segmentData.segment[0], projection);
    tempSegment[1] = (0, _projJs.fromUserCoordinate)(segmentData.segment[1], projection);
    return (0, _coordinateJs.squaredDistanceToSegment)(coordinate, tempSegment);
}
/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */ function closestOnSegmentData(pointCoordinates, segmentData, projection) {
    const geometry = segmentData.geometry;
    if (geometry.getType() === 'Circle' && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
        let circleGeometry = /** @type {import("../geom/Circle.js").default} */ geometry;
        const userProjection = (0, _projJs.getUserProjection)();
        if (userProjection) circleGeometry = /** @type {import("../geom/Circle.js").default} */ circleGeometry.clone().transform(userProjection, projection);
        return (0, _projJs.toUserCoordinate)(circleGeometry.getClosestPoint((0, _projJs.fromUserCoordinate)(pointCoordinates, projection)), projection);
    }
    const coordinate = (0, _projJs.fromUserCoordinate)(pointCoordinates, projection);
    tempSegment[0] = (0, _projJs.fromUserCoordinate)(segmentData.segment[0], projection);
    tempSegment[1] = (0, _projJs.fromUserCoordinate)(segmentData.segment[1], projection);
    return (0, _projJs.toUserCoordinate)((0, _coordinateJs.closestOnSegment)(coordinate, tempSegment), projection);
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    const style = (0, _styleJs.createEditingStyle)();
    return function(feature, resolution) {
        return style['Point'];
    };
}
exports.default = Modify;

},{"../Collection.js":"gReoh","../CollectionEventType.js":"82Ksf","../events/Event.js":"hwXQP","../events/EventType.js":"hrQJ6","../Feature.js":"liabO","../MapBrowserEventType.js":"fB9ae","../geom/Point.js":"hx2Ar","./Pointer.js":"1GIxf","../structs/RBush.js":"ewGrv","../source/VectorEventType.js":"6IruY","../layer/Vector.js":"iTrAy","../source/Vector.js":"9w7Fr","../events/condition.js":"iQTYY","../extent.js":"6YrVc","../coordinate.js":"85Vu7","../style/Style.js":"fW7vC","../array.js":"1Fbic","../geom/Polygon.js":"cJuQF","../proj.js":"SznqC","../util.js":"pLBjQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"0zhsh":[function(require,module,exports,__globalThis) {
/**
 * @module ol/interaction/Snap
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _rbushJs = require("../structs/RBush.js");
var _rbushJsDefault = parcelHelpers.interopDefault(_rbushJs);
var _vectorEventTypeJs = require("../source/VectorEventType.js");
var _vectorEventTypeJsDefault = parcelHelpers.interopDefault(_vectorEventTypeJs);
var _functionsJs = require("../functions.js");
var _snapEventJs = require("../events/SnapEvent.js");
var _extentJs = require("../extent.js");
var _coordinateJs = require("../coordinate.js");
var _polygonJs = require("../geom/Polygon.js");
var _projJs = require("../proj.js");
var _utilJs = require("../util.js");
var _eventsJs = require("../events.js");
/**
 * @typedef {Object} Result
 * @property {import("../coordinate.js").Coordinate|null} vertex Vertex.
 * @property {import("../pixel.js").Pixel|null} vertexPixel VertexPixel.
 * @property {import("../Feature.js").default|null} feature Feature.
 * @property {Array<import("../coordinate.js").Coordinate>|null} segment Segment, or `null` if snapped to a vertex.
 */ /**
 * @typedef {Object} SegmentData
 * @property {import("../Feature.js").default} feature Feature.
 * @property {Array<import("../coordinate.js").Coordinate>} segment Segment.
 */ /**
 * @typedef {Object} Options
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features] Snap to these features. Either this option or source should be provided.
 * @property {boolean} [edge=true] Snap to edges.
 * @property {boolean} [vertex=true] Snap to vertices.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
 * vertex for snapping.
 * @property {import("../source/Vector.js").default} [source] Snap to features from this source. Either this option or features should be provided
 */ /**
 * @param  {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
 * @return {import("../Feature.js").default|null} Feature.
 */ function getFeatureFromEvent(evt) {
    if (/** @type {import("../source/Vector.js").VectorSourceEvent} */ evt.feature) return /** @type {import("../source/Vector.js").VectorSourceEvent} */ evt.feature;
    if (/** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */ evt.element) return /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */ evt.element;
    return null;
}
const tempSegment = [];
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'snap', SnapEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'snap', Return>} SnapOnSignature
 */ /**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:ol/source/Vector~VectorSource} or {@link module:ol/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Example:
 *
 *     import Snap from 'ol/interaction/Snap.js';
 *
 *     const snap = new Snap({
 *       source: source
 *     });
 *
 *     map.addInteraction(snap);
 *
 * @fires SnapEvent
 * @api
 */ class Snap extends (0, _pointerJsDefault.default) {
    /**
   * @param {Options} [options] Options.
   */ constructor(options){
        options = options ? options : {};
        const pointerOptions = /** @type {import("./Pointer.js").Options} */ options;
        if (!pointerOptions.handleDownEvent) pointerOptions.handleDownEvent = (0, _functionsJs.TRUE);
        if (!pointerOptions.stopDown) pointerOptions.stopDown = (0, _functionsJs.FALSE);
        super(pointerOptions);
        /***
     * @type {SnapOnSignature<import("../events").EventsKey>}
     */ this.on;
        /***
     * @type {SnapOnSignature<import("../events").EventsKey>}
     */ this.once;
        /***
     * @type {SnapOnSignature<void>}
     */ this.un;
        /**
     * @type {import("../source/Vector.js").default|null}
     * @private
     */ this.source_ = options.source ? options.source : null;
        /**
     * @private
     * @type {boolean}
     */ this.vertex_ = options.vertex !== undefined ? options.vertex : true;
        /**
     * @private
     * @type {boolean}
     */ this.edge_ = options.edge !== undefined ? options.edge : true;
        /**
     * @type {import("../Collection.js").default<import("../Feature.js").default>|null}
     * @private
     */ this.features_ = options.features ? options.features : null;
        /**
     * @type {Array<import("../events.js").EventsKey>}
     * @private
     */ this.featuresListenerKeys_ = [];
        /**
     * @type {Object<string, import("../events.js").EventsKey>}
     * @private
     */ this.featureChangeListenerKeys_ = {};
        /**
     * Extents are preserved so indexed segment can be quickly removed
     * when its feature geometry changes
     * @type {Object<string, import("../extent.js").Extent>}
     * @private
     */ this.indexedFeaturesExtents_ = {};
        /**
     * If a feature geometry changes while a pointer drag|move event occurs, the
     * feature doesn't get updated right away.  It will be at the next 'pointerup'
     * event fired.
     * @type {!Object<string, import("../Feature.js").default>}
     * @private
     */ this.pendingFeatures_ = {};
        /**
     * @type {number}
     * @private
     */ this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
        /**
     * Segment RTree for each layer
     * @type {import("../structs/RBush.js").default<SegmentData>}
     * @private
     */ this.rBush_ = new (0, _rbushJsDefault.default)();
        /**
     * @const
     * @private
     * @type {Object<string, function(Array<Array<import('../coordinate.js').Coordinate>>, import("../geom/Geometry.js").default): void>}
     */ this.GEOMETRY_SEGMENTERS_ = {
            'Point': this.segmentPointGeometry_.bind(this),
            'LineString': this.segmentLineStringGeometry_.bind(this),
            'LinearRing': this.segmentLineStringGeometry_.bind(this),
            'Polygon': this.segmentPolygonGeometry_.bind(this),
            'MultiPoint': this.segmentMultiPointGeometry_.bind(this),
            'MultiLineString': this.segmentMultiLineStringGeometry_.bind(this),
            'MultiPolygon': this.segmentMultiPolygonGeometry_.bind(this),
            'GeometryCollection': this.segmentGeometryCollectionGeometry_.bind(this),
            'Circle': this.segmentCircleGeometry_.bind(this)
        };
    }
    /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean} [register] Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */ addFeature(feature, register) {
        register = register !== undefined ? register : true;
        const feature_uid = (0, _utilJs.getUid)(feature);
        const geometry = feature.getGeometry();
        if (geometry) {
            const segmenter = this.GEOMETRY_SEGMENTERS_[geometry.getType()];
            if (segmenter) {
                this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent((0, _extentJs.createEmpty)());
                const segments = /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ [];
                segmenter(segments, geometry);
                if (segments.length === 1) this.rBush_.insert((0, _extentJs.boundingExtent)(segments[0]), {
                    feature: feature,
                    segment: segments[0]
                });
                else if (segments.length > 1) {
                    const extents = segments.map((s)=>(0, _extentJs.boundingExtent)(s));
                    const segmentsData = segments.map((segment)=>({
                            feature: feature,
                            segment: segment
                        }));
                    this.rBush_.load(extents, segmentsData);
                }
            }
        }
        if (register) this.featureChangeListenerKeys_[feature_uid] = (0, _eventsJs.listen)(feature, (0, _eventTypeJsDefault.default).CHANGE, this.handleFeatureChange_, this);
    }
    /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */ getFeatures_() {
        /** @type {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} */ let features;
        if (this.features_) features = this.features_;
        else if (this.source_) features = this.source_.getFeatures();
        return features;
    }
    /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */ handleEvent(evt) {
        const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
        if (result) {
            evt.coordinate = result.vertex.slice(0, 2);
            evt.pixel = result.vertexPixel;
            this.dispatchEvent(new (0, _snapEventJs.SnapEvent)((0, _snapEventJs.SnapEventType).SNAP, {
                vertex: evt.coordinate,
                vertexPixel: evt.pixel,
                feature: result.feature,
                segment: result.segment
            }));
        }
        return super.handleEvent(evt);
    }
    /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */ handleFeatureAdd_(evt) {
        const feature = getFeatureFromEvent(evt);
        if (feature) this.addFeature(feature);
    }
    /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */ handleFeatureRemove_(evt) {
        const feature = getFeatureFromEvent(evt);
        if (feature) this.removeFeature(feature);
    }
    /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */ handleFeatureChange_(evt) {
        const feature = /** @type {import("../Feature.js").default} */ evt.target;
        if (this.handlingDownUpSequence) {
            const uid = (0, _utilJs.getUid)(feature);
            if (!(uid in this.pendingFeatures_)) this.pendingFeatures_[uid] = feature;
        } else this.updateFeature_(feature);
    }
    /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */ handleUpEvent(evt) {
        const featuresToUpdate = Object.values(this.pendingFeatures_);
        if (featuresToUpdate.length) {
            featuresToUpdate.forEach(this.updateFeature_.bind(this));
            this.pendingFeatures_ = {};
        }
        return false;
    }
    /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean} [unlisten] Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */ removeFeature(feature, unlisten) {
        const unregister = unlisten !== undefined ? unlisten : true;
        const feature_uid = (0, _utilJs.getUid)(feature);
        const extent = this.indexedFeaturesExtents_[feature_uid];
        if (extent) {
            const rBush = this.rBush_;
            const nodesToRemove = [];
            rBush.forEachInExtent(extent, function(node) {
                if (feature === node.feature) nodesToRemove.push(node);
            });
            for(let i = nodesToRemove.length - 1; i >= 0; --i)rBush.remove(nodesToRemove[i]);
        }
        if (unregister) {
            (0, _eventsJs.unlistenByKey)(this.featureChangeListenerKeys_[feature_uid]);
            delete this.featureChangeListenerKeys_[feature_uid];
        }
    }
    /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */ setMap(map) {
        const currentMap = this.getMap();
        const keys = this.featuresListenerKeys_;
        const features = /** @type {Array<import("../Feature.js").default>} */ this.getFeatures_();
        if (currentMap) {
            keys.forEach((0, _eventsJs.unlistenByKey));
            keys.length = 0;
            this.rBush_.clear();
            Object.values(this.featureChangeListenerKeys_).forEach((0, _eventsJs.unlistenByKey));
            this.featureChangeListenerKeys_ = {};
        }
        super.setMap(map);
        if (map) {
            if (this.features_) keys.push((0, _eventsJs.listen)(this.features_, (0, _collectionEventTypeJsDefault.default).ADD, this.handleFeatureAdd_, this), (0, _eventsJs.listen)(this.features_, (0, _collectionEventTypeJsDefault.default).REMOVE, this.handleFeatureRemove_, this));
            else if (this.source_) keys.push((0, _eventsJs.listen)(this.source_, (0, _vectorEventTypeJsDefault.default).ADDFEATURE, this.handleFeatureAdd_, this), (0, _eventsJs.listen)(this.source_, (0, _vectorEventTypeJsDefault.default).REMOVEFEATURE, this.handleFeatureRemove_, this));
            features.forEach((feature)=>this.addFeature(feature));
        }
    }
    /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../Map.js").default} map Map.
   * @return {Result|null} Snap result
   */ snapTo(pixel, pixelCoordinate, map) {
        const projection = map.getView().getProjection();
        const projectedCoordinate = (0, _projJs.fromUserCoordinate)(pixelCoordinate, projection);
        const box = (0, _projJs.toUserExtent)((0, _extentJs.buffer)((0, _extentJs.boundingExtent)([
            projectedCoordinate
        ]), map.getView().getResolution() * this.pixelTolerance_), projection);
        const segments = this.rBush_.getInExtent(box);
        const segmentsLength = segments.length;
        if (segmentsLength === 0) return null;
        let closestVertex;
        let minSquaredDistance = Infinity;
        let closestFeature;
        let closestSegment = null;
        const squaredPixelTolerance = this.pixelTolerance_ * this.pixelTolerance_;
        const getResult = ()=>{
            if (closestVertex) {
                const vertexPixel = map.getPixelFromCoordinate(closestVertex);
                const squaredPixelDistance = (0, _coordinateJs.squaredDistance)(pixel, vertexPixel);
                if (squaredPixelDistance <= squaredPixelTolerance) return {
                    vertex: closestVertex,
                    vertexPixel: [
                        Math.round(vertexPixel[0]),
                        Math.round(vertexPixel[1])
                    ],
                    feature: closestFeature,
                    segment: closestSegment
                };
            }
            return null;
        };
        if (this.vertex_) {
            for(let i = 0; i < segmentsLength; ++i){
                const segmentData = segments[i];
                if (segmentData.feature.getGeometry().getType() !== 'Circle') segmentData.segment.forEach((vertex)=>{
                    const tempVertexCoord = (0, _projJs.fromUserCoordinate)(vertex, projection);
                    const delta = (0, _coordinateJs.squaredDistance)(projectedCoordinate, tempVertexCoord);
                    if (delta < minSquaredDistance) {
                        closestVertex = vertex;
                        minSquaredDistance = delta;
                        closestFeature = segmentData.feature;
                    }
                });
            }
            const result = getResult();
            if (result) return result;
        }
        if (this.edge_) {
            for(let i = 0; i < segmentsLength; ++i){
                let vertex = null;
                const segmentData = segments[i];
                if (segmentData.feature.getGeometry().getType() === 'Circle') {
                    let circleGeometry = segmentData.feature.getGeometry();
                    const userProjection = (0, _projJs.getUserProjection)();
                    if (userProjection) circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                    vertex = (0, _coordinateJs.closestOnCircle)(projectedCoordinate, /** @type {import("../geom/Circle.js").default} */ circleGeometry);
                } else {
                    const [segmentStart, segmentEnd] = segmentData.segment;
                    // points have only one coordinate
                    if (segmentEnd) {
                        tempSegment[0] = (0, _projJs.fromUserCoordinate)(segmentStart, projection);
                        tempSegment[1] = (0, _projJs.fromUserCoordinate)(segmentEnd, projection);
                        vertex = (0, _coordinateJs.closestOnSegment)(projectedCoordinate, tempSegment);
                    }
                }
                if (vertex) {
                    const delta = (0, _coordinateJs.squaredDistance)(projectedCoordinate, vertex);
                    if (delta < minSquaredDistance) {
                        closestVertex = (0, _projJs.toUserCoordinate)(vertex, projection);
                        closestSegment = segmentData.feature.getGeometry().getType() === 'Circle' ? null : segmentData.segment;
                        minSquaredDistance = delta;
                    }
                }
            }
            const result = getResult();
            if (result) return result;
        }
        return null;
    }
    /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */ updateFeature_(feature) {
        this.removeFeature(feature, false);
        this.addFeature(feature, false);
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */ segmentCircleGeometry_(segments, geometry) {
        const projection = this.getMap().getView().getProjection();
        let circleGeometry = geometry;
        const userProjection = (0, _projJs.getUserProjection)();
        if (userProjection) circleGeometry = /** @type {import("../geom/Circle.js").default} */ circleGeometry.clone().transform(userProjection, projection);
        const polygon = (0, _polygonJs.fromCircle)(circleGeometry);
        if (userProjection) polygon.transform(projection, userProjection);
        const coordinates = polygon.getCoordinates()[0];
        for(let i = 0, ii = coordinates.length - 1; i < ii; ++i)segments.push(coordinates.slice(i, i + 2));
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */ segmentGeometryCollectionGeometry_(segments, geometry) {
        const geometries = geometry.getGeometriesArray();
        for(let i = 0; i < geometries.length; ++i){
            const segmenter = this.GEOMETRY_SEGMENTERS_[geometries[i].getType()];
            if (segmenter) segmenter(segments, geometries[i]);
        }
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */ segmentLineStringGeometry_(segments, geometry) {
        const coordinates = geometry.getCoordinates();
        for(let i = 0, ii = coordinates.length - 1; i < ii; ++i)segments.push(coordinates.slice(i, i + 2));
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */ segmentMultiLineStringGeometry_(segments, geometry) {
        const lines = geometry.getCoordinates();
        for(let j = 0, jj = lines.length; j < jj; ++j){
            const coordinates = lines[j];
            for(let i = 0, ii = coordinates.length - 1; i < ii; ++i)segments.push(coordinates.slice(i, i + 2));
        }
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */ segmentMultiPointGeometry_(segments, geometry) {
        geometry.getCoordinates().forEach((point)=>{
            segments.push([
                point
            ]);
        });
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */ segmentMultiPolygonGeometry_(segments, geometry) {
        const polygons = geometry.getCoordinates();
        for(let k = 0, kk = polygons.length; k < kk; ++k){
            const rings = polygons[k];
            for(let j = 0, jj = rings.length; j < jj; ++j){
                const coordinates = rings[j];
                for(let i = 0, ii = coordinates.length - 1; i < ii; ++i)segments.push(coordinates.slice(i, i + 2));
            }
        }
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */ segmentPointGeometry_(segments, geometry) {
        segments.push([
            geometry.getCoordinates()
        ]);
    }
    /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */ segmentPolygonGeometry_(segments, geometry) {
        const rings = geometry.getCoordinates();
        for(let j = 0, jj = rings.length; j < jj; ++j){
            const coordinates = rings[j];
            for(let i = 0, ii = coordinates.length - 1; i < ii; ++i)segments.push(coordinates.slice(i, i + 2));
        }
    }
}
exports.default = Snap;

},{"../CollectionEventType.js":"82Ksf","../events/EventType.js":"hrQJ6","./Pointer.js":"1GIxf","../structs/RBush.js":"ewGrv","../source/VectorEventType.js":"6IruY","../functions.js":"iqv8I","../events/SnapEvent.js":"gGFkS","../extent.js":"6YrVc","../coordinate.js":"85Vu7","../geom/Polygon.js":"cJuQF","../proj.js":"SznqC","../util.js":"pLBjQ","../events.js":"dcspA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gGFkS":[function(require,module,exports,__globalThis) {
/**
 * @module ol/events/SnapEvent
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SnapEventType", ()=>SnapEventType);
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Snap~Snap} instances are instances of this
 */ parcelHelpers.export(exports, "SnapEvent", ()=>SnapEvent);
var _eventJs = require("./Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
const SnapEventType = {
    /**
   * Triggered upon snapping to vertex or edge
   * @event SnapEvent#snap
   * @api
   */ SNAP: 'snap'
};
class SnapEvent extends (0, _eventJsDefault.default) {
    /**
   * @param {SnapEventType} type Type.
   * @param {Object} options Options.
   * @param {import("../coordinate.js").Coordinate} options.vertex The snapped vertex.
   * @param {import("../coordinate.js").Coordinate} options.vertexPixel The pixel of the snapped vertex.
   * @param {import("../Feature.js").default} options.feature The feature being snapped.
   * @param {Array<import("../coordinate.js").Coordinate>|null} options.segment Segment, or `null` if snapped to a vertex.
   */ constructor(type, options){
        super(type);
        /**
     * The Map coordinate of the snapped point.
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */ this.vertex = options.vertex;
        /**
     * The Map pixel of the snapped point.
     * @type {Array<number>&Array<number>}
     * @api
     */ this.vertexPixel = options.vertexPixel;
        /**
     * The feature closest to the snapped point.
     * @type {import("../Feature.js").default<import("../geom/Geometry.js").default>}
     * @api
     */ this.feature = options.feature;
        /**
     * The segment closest to the snapped point, if snapped to a segment.
     * @type {Array<import("../coordinate.js").Coordinate>|null}
     * @api
     */ this.segment = options.segment;
    }
}

},{"./Event.js":"hwXQP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fii18":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RelateOp", ()=>(0, _relateOpJsDefault.default));
var _relateOpJs = require("./relate/RelateOp.js");
var _relateOpJsDefault = parcelHelpers.interopDefault(_relateOpJs);

},{"./relate/RelateOp.js":"dMiTv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dMiTv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _relateComputerJs = require("./RelateComputer.js");
var _relateComputerJsDefault = parcelHelpers.interopDefault(_relateComputerJs);
var _geometryGraphOperationJs = require("../GeometryGraphOperation.js");
var _geometryGraphOperationJsDefault = parcelHelpers.interopDefault(_geometryGraphOperationJs);
var _rectangleContainsJs = require("../predicate/RectangleContains.js");
var _rectangleContainsJsDefault = parcelHelpers.interopDefault(_rectangleContainsJs);
var _rectangleIntersectsJs = require("../predicate/RectangleIntersects.js");
var _rectangleIntersectsJsDefault = parcelHelpers.interopDefault(_rectangleIntersectsJs);
class RelateOp extends (0, _geometryGraphOperationJsDefault.default) {
    constructor(){
        super();
        RelateOp.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._relate = null;
        if (arguments.length === 2) {
            const g0 = arguments[0], g1 = arguments[1];
            (0, _geometryGraphOperationJsDefault.default).constructor_.call(this, g0, g1);
            this._relate = new (0, _relateComputerJsDefault.default)(this._arg);
        } else if (arguments.length === 3) {
            const g0 = arguments[0], g1 = arguments[1], boundaryNodeRule = arguments[2];
            (0, _geometryGraphOperationJsDefault.default).constructor_.call(this, g0, g1, boundaryNodeRule);
            this._relate = new (0, _relateComputerJsDefault.default)(this._arg);
        }
    }
    static equalsTopo(g1, g2) {
        if (!g1.getEnvelopeInternal().equals(g2.getEnvelopeInternal())) return false;
        return RelateOp.relate(g1, g2).isEquals(g1.getDimension(), g2.getDimension());
    }
    static relate() {
        if (arguments.length === 2) {
            const a = arguments[0], b = arguments[1];
            const relOp = new RelateOp(a, b);
            const im = relOp.getIntersectionMatrix();
            return im;
        } else if (arguments.length === 3) {
            const a = arguments[0], b = arguments[1], boundaryNodeRule = arguments[2];
            const relOp = new RelateOp(a, b, boundaryNodeRule);
            const im = relOp.getIntersectionMatrix();
            return im;
        }
    }
    static overlaps(g1, g2) {
        if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
        return new RelateOp(g1, g2).getIntersectionMatrix().isOverlaps(g1.getDimension(), g2.getDimension());
    }
    static disjoint(g1, g2) {
        return !RelateOp.intersects(g1, g2);
    }
    static covers(g1, g2) {
        if (g2.getDimension() === 2 && g1.getDimension() < 2) return false;
        if (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) return false;
        if (!g1.getEnvelopeInternal().covers(g2.getEnvelopeInternal())) return false;
        if (g1.isRectangle()) return true;
        return new RelateOp(g1, g2).getIntersectionMatrix().isCovers();
    }
    static intersects(g1, g2) {
        if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
        if (g1.isRectangle()) return (0, _rectangleIntersectsJsDefault.default).intersects(g1, g2);
        if (g2.isRectangle()) return (0, _rectangleIntersectsJsDefault.default).intersects(g2, g1);
        if (g1.isGeometryCollection() || g2.isGeometryCollection()) {
            const r = false;
            for(let i = 0; i < g1.getNumGeometries(); i++)for(let j = 0; j < g2.getNumGeometries(); j++)if (RelateOp.intersects(g1.getGeometryN(i), g2.getGeometryN(j))) return true;
            return false;
        }
        return new RelateOp(g1, g2).getIntersectionMatrix().isIntersects();
    }
    static touches(g1, g2) {
        if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
        return new RelateOp(g1, g2).getIntersectionMatrix().isTouches(g1.getDimension(), g2.getDimension());
    }
    static crosses(g1, g2) {
        if (!g1.getEnvelopeInternal().intersects(g2.getEnvelopeInternal())) return false;
        return new RelateOp(g1, g2).getIntersectionMatrix().isCrosses(g1.getDimension(), g2.getDimension());
    }
    static contains(g1, g2) {
        if (g2.getDimension() === 2 && g1.getDimension() < 2) return false;
        if (g2.getDimension() === 1 && g1.getDimension() < 1 && g2.getLength() > 0.0) return false;
        if (!g1.getEnvelopeInternal().contains(g2.getEnvelopeInternal())) return false;
        if (g1.isRectangle()) return (0, _rectangleContainsJsDefault.default).contains(g1, g2);
        return new RelateOp(g1, g2).getIntersectionMatrix().isContains();
    }
    getIntersectionMatrix() {
        return this._relate.computeIM();
    }
}
exports.default = RelateOp;

},{"./RelateComputer.js":"giirF","../GeometryGraphOperation.js":"6c8UI","../predicate/RectangleContains.js":"ck2Ir","../predicate/RectangleIntersects.js":"irBEY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"giirF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _intersectionMatrixJs = require("../../geom/IntersectionMatrix.js");
var _intersectionMatrixJsDefault = parcelHelpers.interopDefault(_intersectionMatrixJs);
var _edgeEndBuilderJs = require("./EdgeEndBuilder.js");
var _edgeEndBuilderJsDefault = parcelHelpers.interopDefault(_edgeEndBuilderJs);
var _nodeMapJs = require("../../geomgraph/NodeMap.js");
var _nodeMapJsDefault = parcelHelpers.interopDefault(_nodeMapJs);
var _relateNodeFactoryJs = require("./RelateNodeFactory.js");
var _relateNodeFactoryJsDefault = parcelHelpers.interopDefault(_relateNodeFactoryJs);
var _assertJs = require("../../util/Assert.js");
var _assertJsDefault = parcelHelpers.interopDefault(_assertJs);
var _pointLocatorJs = require("../../algorithm/PointLocator.js");
var _pointLocatorJsDefault = parcelHelpers.interopDefault(_pointLocatorJs);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _robustLineIntersectorJs = require("../../algorithm/RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
class RelateComputer {
    constructor(){
        RelateComputer.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._ptLocator = new (0, _pointLocatorJsDefault.default)();
        this._arg = null;
        this._nodes = new (0, _nodeMapJsDefault.default)(new (0, _relateNodeFactoryJsDefault.default)());
        this._im = null;
        this._isolatedEdges = new (0, _arrayListJsDefault.default)();
        this._invalidPoint = null;
        const arg = arguments[0];
        this._arg = arg;
    }
    insertEdgeEnds(ee) {
        for(let i = ee.iterator(); i.hasNext();){
            const e = i.next();
            this._nodes.add(e);
        }
    }
    computeProperIntersectionIM(intersector, im) {
        const dimA = this._arg[0].getGeometry().getDimension();
        const dimB = this._arg[1].getGeometry().getDimension();
        const hasProper = intersector.hasProperIntersection();
        const hasProperInterior = intersector.hasProperInteriorIntersection();
        if (dimA === 2 && dimB === 2) {
            if (hasProper) im.setAtLeast('212101212');
        } else if (dimA === 2 && dimB === 1) {
            if (hasProper) im.setAtLeast('FFF0FFFF2');
            if (hasProperInterior) im.setAtLeast('1FFFFF1FF');
        } else if (dimA === 1 && dimB === 2) {
            if (hasProper) im.setAtLeast('F0FFFFFF2');
            if (hasProperInterior) im.setAtLeast('1F1FFFFFF');
        } else if (dimA === 1 && dimB === 1) {
            if (hasProperInterior) im.setAtLeast('0FFFFFFFF');
        }
    }
    labelIsolatedEdges(thisIndex, targetIndex) {
        for(let ei = this._arg[thisIndex].getEdgeIterator(); ei.hasNext();){
            const e = ei.next();
            if (e.isIsolated()) {
                this.labelIsolatedEdge(e, targetIndex, this._arg[targetIndex].getGeometry());
                this._isolatedEdges.add(e);
            }
        }
    }
    labelIsolatedEdge(e, targetIndex, target) {
        if (target.getDimension() > 0) {
            const loc = this._ptLocator.locate(e.getCoordinate(), target);
            e.getLabel().setAllLocations(targetIndex, loc);
        } else e.getLabel().setAllLocations(targetIndex, (0, _locationJsDefault.default).EXTERIOR);
    }
    computeIM() {
        const im = new (0, _intersectionMatrixJsDefault.default)();
        im.set((0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).EXTERIOR, 2);
        if (!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal())) {
            this.computeDisjointIM(im);
            return im;
        }
        this._arg[0].computeSelfNodes(this._li, false);
        this._arg[1].computeSelfNodes(this._li, false);
        const intersector = this._arg[0].computeEdgeIntersections(this._arg[1], this._li, false);
        this.computeIntersectionNodes(0);
        this.computeIntersectionNodes(1);
        this.copyNodesAndLabels(0);
        this.copyNodesAndLabels(1);
        this.labelIsolatedNodes();
        this.computeProperIntersectionIM(intersector, im);
        const eeBuilder = new (0, _edgeEndBuilderJsDefault.default)();
        const ee0 = eeBuilder.computeEdgeEnds(this._arg[0].getEdgeIterator());
        this.insertEdgeEnds(ee0);
        const ee1 = eeBuilder.computeEdgeEnds(this._arg[1].getEdgeIterator());
        this.insertEdgeEnds(ee1);
        this.labelNodeEdges();
        this.labelIsolatedEdges(0, 1);
        this.labelIsolatedEdges(1, 0);
        this.updateIM(im);
        return im;
    }
    labelNodeEdges() {
        for(let ni = this._nodes.iterator(); ni.hasNext();){
            const node = ni.next();
            node.getEdges().computeLabelling(this._arg);
        }
    }
    copyNodesAndLabels(argIndex) {
        for(let i = this._arg[argIndex].getNodeIterator(); i.hasNext();){
            const graphNode = i.next();
            const newNode = this._nodes.addNode(graphNode.getCoordinate());
            newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));
        }
    }
    labelIntersectionNodes(argIndex) {
        for(let i = this._arg[argIndex].getEdgeIterator(); i.hasNext();){
            const e = i.next();
            const eLoc = e.getLabel().getLocation(argIndex);
            for(let eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();){
                const ei = eiIt.next();
                const n = this._nodes.find(ei.coord);
                if (n.getLabel().isNull(argIndex)) {
                    if (eLoc === (0, _locationJsDefault.default).BOUNDARY) n.setLabelBoundary(argIndex);
                    else n.setLabel(argIndex, (0, _locationJsDefault.default).INTERIOR);
                }
            }
        }
    }
    labelIsolatedNode(n, targetIndex) {
        const loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());
        n.getLabel().setAllLocations(targetIndex, loc);
    }
    computeIntersectionNodes(argIndex) {
        for(let i = this._arg[argIndex].getEdgeIterator(); i.hasNext();){
            const e = i.next();
            const eLoc = e.getLabel().getLocation(argIndex);
            for(let eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext();){
                const ei = eiIt.next();
                const n = this._nodes.addNode(ei.coord);
                if (eLoc === (0, _locationJsDefault.default).BOUNDARY) n.setLabelBoundary(argIndex);
                else if (n.getLabel().isNull(argIndex)) n.setLabel(argIndex, (0, _locationJsDefault.default).INTERIOR);
            }
        }
    }
    labelIsolatedNodes() {
        for(let ni = this._nodes.iterator(); ni.hasNext();){
            const n = ni.next();
            const label = n.getLabel();
            (0, _assertJsDefault.default).isTrue(label.getGeometryCount() > 0, 'node with empty label found');
            if (n.isIsolated()) {
                if (label.isNull(0)) this.labelIsolatedNode(n, 0);
                else this.labelIsolatedNode(n, 1);
            }
        }
    }
    updateIM(im) {
        for(let ei = this._isolatedEdges.iterator(); ei.hasNext();){
            const e = ei.next();
            e.updateIM(im);
        }
        for(let ni = this._nodes.iterator(); ni.hasNext();){
            const node = ni.next();
            node.updateIM(im);
            node.updateIMFromEdges(im);
        }
    }
    computeDisjointIM(im) {
        const ga = this._arg[0].getGeometry();
        if (!ga.isEmpty()) {
            im.set((0, _locationJsDefault.default).INTERIOR, (0, _locationJsDefault.default).EXTERIOR, ga.getDimension());
            im.set((0, _locationJsDefault.default).BOUNDARY, (0, _locationJsDefault.default).EXTERIOR, ga.getBoundaryDimension());
        }
        const gb = this._arg[1].getGeometry();
        if (!gb.isEmpty()) {
            im.set((0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).INTERIOR, gb.getDimension());
            im.set((0, _locationJsDefault.default).EXTERIOR, (0, _locationJsDefault.default).BOUNDARY, gb.getBoundaryDimension());
        }
    }
}
exports.default = RelateComputer;

},{"../../geom/IntersectionMatrix.js":"8dTUp","./EdgeEndBuilder.js":"4pSY8","../../geomgraph/NodeMap.js":"i6KqO","./RelateNodeFactory.js":"cFJHs","../../util/Assert.js":"ePbcB","../../algorithm/PointLocator.js":"5OxlZ","../../geom/Location.js":"71R1B","../../../../../java/util/ArrayList.js":"g8omH","../../algorithm/RobustLineIntersector.js":"fBBRl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4pSY8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeEndJs = require("../../geomgraph/EdgeEnd.js");
var _edgeEndJsDefault = parcelHelpers.interopDefault(_edgeEndJs);
var _labelJs = require("../../geomgraph/Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
class EdgeEndBuilder {
    computeEdgeEnds() {
        if (arguments.length === 1) {
            const edges = arguments[0];
            const l = new (0, _arrayListJsDefault.default)();
            for(let i = edges; i.hasNext();){
                const e = i.next();
                this.computeEdgeEnds(e, l);
            }
            return l;
        } else if (arguments.length === 2) {
            const edge = arguments[0], l = arguments[1];
            const eiList = edge.getEdgeIntersectionList();
            eiList.addEndpoints();
            const it = eiList.iterator();
            let eiPrev = null;
            let eiCurr = null;
            if (!it.hasNext()) return null;
            let eiNext = it.next();
            do {
                eiPrev = eiCurr;
                eiCurr = eiNext;
                eiNext = null;
                if (it.hasNext()) eiNext = it.next();
                if (eiCurr !== null) {
                    this.createEdgeEndForPrev(edge, l, eiCurr, eiPrev);
                    this.createEdgeEndForNext(edge, l, eiCurr, eiNext);
                }
            }while (eiCurr !== null);
        }
    }
    createEdgeEndForNext(edge, l, eiCurr, eiNext) {
        const iNext = eiCurr.segmentIndex + 1;
        if (iNext >= edge.getNumPoints() && eiNext === null) return null;
        let pNext = edge.getCoordinate(iNext);
        if (eiNext !== null && eiNext.segmentIndex === eiCurr.segmentIndex) pNext = eiNext.coord;
        const e = new (0, _edgeEndJsDefault.default)(edge, eiCurr.coord, pNext, new (0, _labelJsDefault.default)(edge.getLabel()));
        l.add(e);
    }
    createEdgeEndForPrev(edge, l, eiCurr, eiPrev) {
        let iPrev = eiCurr.segmentIndex;
        if (eiCurr.dist === 0.0) {
            if (iPrev === 0) return null;
            iPrev--;
        }
        let pPrev = edge.getCoordinate(iPrev);
        if (eiPrev !== null && eiPrev.segmentIndex >= iPrev) pPrev = eiPrev.coord;
        const label = new (0, _labelJsDefault.default)(edge.getLabel());
        label.flip();
        const e = new (0, _edgeEndJsDefault.default)(edge, eiCurr.coord, pPrev, label);
        l.add(e);
    }
}
exports.default = EdgeEndBuilder;

},{"../../geomgraph/EdgeEnd.js":"fJOZ9","../../geomgraph/Label.js":"2NrfJ","../../../../../java/util/ArrayList.js":"g8omH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cFJHs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeEndBundleStarJs = require("./EdgeEndBundleStar.js");
var _edgeEndBundleStarJsDefault = parcelHelpers.interopDefault(_edgeEndBundleStarJs);
var _relateNodeJs = require("./RelateNode.js");
var _relateNodeJsDefault = parcelHelpers.interopDefault(_relateNodeJs);
var _nodeFactoryJs = require("../../geomgraph/NodeFactory.js");
var _nodeFactoryJsDefault = parcelHelpers.interopDefault(_nodeFactoryJs);
class RelateNodeFactory extends (0, _nodeFactoryJsDefault.default) {
    constructor(){
        super();
    }
    createNode(coord) {
        return new (0, _relateNodeJsDefault.default)(coord, new (0, _edgeEndBundleStarJsDefault.default)());
    }
}
exports.default = RelateNodeFactory;

},{"./EdgeEndBundleStar.js":"dulGD","./RelateNode.js":"8IMp3","../../geomgraph/NodeFactory.js":"ig4eg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dulGD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _edgeEndStarJs = require("../../geomgraph/EdgeEndStar.js");
var _edgeEndStarJsDefault = parcelHelpers.interopDefault(_edgeEndStarJs);
var _edgeEndBundleJs = require("./EdgeEndBundle.js");
var _edgeEndBundleJsDefault = parcelHelpers.interopDefault(_edgeEndBundleJs);
class EdgeEndBundleStar extends (0, _edgeEndStarJsDefault.default) {
    constructor(){
        super();
    }
    updateIM(im) {
        for(let it = this.iterator(); it.hasNext();){
            const esb = it.next();
            esb.updateIM(im);
        }
    }
    insert(e) {
        let eb = this._edgeMap.get(e);
        if (eb === null) {
            eb = new (0, _edgeEndBundleJsDefault.default)(e);
            this.insertEdgeEnd(e, eb);
        } else eb.insert(e);
    }
}
exports.default = EdgeEndBundleStar;

},{"../../geomgraph/EdgeEndStar.js":"4v1Qe","./EdgeEndBundle.js":"oC1qp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"oC1qp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _locationJs = require("../../geom/Location.js");
var _locationJsDefault = parcelHelpers.interopDefault(_locationJs);
var _edgeEndJs = require("../../geomgraph/EdgeEnd.js");
var _edgeEndJsDefault = parcelHelpers.interopDefault(_edgeEndJs);
var _positionJs = require("../../geomgraph/Position.js");
var _positionJsDefault = parcelHelpers.interopDefault(_positionJs);
var _geometryGraphJs = require("../../geomgraph/GeometryGraph.js");
var _geometryGraphJsDefault = parcelHelpers.interopDefault(_geometryGraphJs);
var _labelJs = require("../../geomgraph/Label.js");
var _labelJsDefault = parcelHelpers.interopDefault(_labelJs);
var _arrayListJs = require("../../../../../java/util/ArrayList.js");
var _arrayListJsDefault = parcelHelpers.interopDefault(_arrayListJs);
var _edgeJs = require("../../geomgraph/Edge.js");
var _edgeJsDefault = parcelHelpers.interopDefault(_edgeJs);
class EdgeEndBundle extends (0, _edgeEndJsDefault.default) {
    constructor(){
        super();
        EdgeEndBundle.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._edgeEnds = new (0, _arrayListJsDefault.default)();
        if (arguments.length === 1) {
            const e = arguments[0];
            EdgeEndBundle.constructor_.call(this, null, e);
        } else if (arguments.length === 2) {
            const boundaryNodeRule = arguments[0], e = arguments[1];
            (0, _edgeEndJsDefault.default).constructor_.call(this, e.getEdge(), e.getCoordinate(), e.getDirectedCoordinate(), new (0, _labelJsDefault.default)(e.getLabel()));
            this.insert(e);
        }
    }
    insert(e) {
        this._edgeEnds.add(e);
    }
    print(out) {
        out.println('EdgeEndBundle--> Label: ' + this._label);
        for(let it = this.iterator(); it.hasNext();){
            const ee = it.next();
            ee.print(out);
            out.println();
        }
    }
    iterator() {
        return this._edgeEnds.iterator();
    }
    getEdgeEnds() {
        return this._edgeEnds;
    }
    computeLabelOn(geomIndex, boundaryNodeRule) {
        let boundaryCount = 0;
        let foundInterior = false;
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            const loc = e.getLabel().getLocation(geomIndex);
            if (loc === (0, _locationJsDefault.default).BOUNDARY) boundaryCount++;
            if (loc === (0, _locationJsDefault.default).INTERIOR) foundInterior = true;
        }
        let loc = (0, _locationJsDefault.default).NONE;
        if (foundInterior) loc = (0, _locationJsDefault.default).INTERIOR;
        if (boundaryCount > 0) loc = (0, _geometryGraphJsDefault.default).determineBoundary(boundaryNodeRule, boundaryCount);
        this._label.setLocation(geomIndex, loc);
    }
    computeLabelSide(geomIndex, side) {
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            if (e.getLabel().isArea()) {
                const loc = e.getLabel().getLocation(geomIndex, side);
                if (loc === (0, _locationJsDefault.default).INTERIOR) {
                    this._label.setLocation(geomIndex, side, (0, _locationJsDefault.default).INTERIOR);
                    return null;
                } else if (loc === (0, _locationJsDefault.default).EXTERIOR) this._label.setLocation(geomIndex, side, (0, _locationJsDefault.default).EXTERIOR);
            }
        }
    }
    getLabel() {
        return this._label;
    }
    computeLabelSides(geomIndex) {
        this.computeLabelSide(geomIndex, (0, _positionJsDefault.default).LEFT);
        this.computeLabelSide(geomIndex, (0, _positionJsDefault.default).RIGHT);
    }
    updateIM(im) {
        (0, _edgeJsDefault.default).updateIM(this._label, im);
    }
    computeLabel(boundaryNodeRule) {
        let isArea = false;
        for(let it = this.iterator(); it.hasNext();){
            const e = it.next();
            if (e.getLabel().isArea()) isArea = true;
        }
        if (isArea) this._label = new (0, _labelJsDefault.default)((0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE, (0, _locationJsDefault.default).NONE);
        else this._label = new (0, _labelJsDefault.default)((0, _locationJsDefault.default).NONE);
        for(let i = 0; i < 2; i++){
            this.computeLabelOn(i, boundaryNodeRule);
            if (isArea) this.computeLabelSides(i);
        }
    }
}
exports.default = EdgeEndBundle;

},{"../../geom/Location.js":"71R1B","../../geomgraph/EdgeEnd.js":"fJOZ9","../../geomgraph/Position.js":"929cL","../../geomgraph/GeometryGraph.js":"3WOZk","../../geomgraph/Label.js":"2NrfJ","../../../../../java/util/ArrayList.js":"g8omH","../../geomgraph/Edge.js":"5KXFs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8IMp3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nodeJs = require("../../geomgraph/Node.js");
var _nodeJsDefault = parcelHelpers.interopDefault(_nodeJs);
class RelateNode extends (0, _nodeJsDefault.default) {
    constructor(){
        super();
        RelateNode.constructor_.apply(this, arguments);
    }
    static constructor_() {
        const coord = arguments[0], edges = arguments[1];
        (0, _nodeJsDefault.default).constructor_.call(this, coord, edges);
    }
    computeIM(im) {
        im.setAtLeastIfValid(this._label.getLocation(0), this._label.getLocation(1), 0);
    }
    updateIMFromEdges(im) {
        this._edges.updateIM(im);
    }
}
exports.default = RelateNode;

},{"../../geomgraph/Node.js":"fKSwC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ck2Ir":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lineStringJs = require("../../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _polygonJs = require("../../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _pointJs = require("../../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
class RectangleContains {
    constructor(){
        RectangleContains.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._rectEnv = null;
        const rectangle = arguments[0];
        this._rectEnv = rectangle.getEnvelopeInternal();
    }
    static contains(rectangle, b) {
        const rc = new RectangleContains(rectangle);
        return rc.contains(b);
    }
    isContainedInBoundary(geom) {
        if (geom instanceof (0, _polygonJsDefault.default)) return false;
        if (geom instanceof (0, _pointJsDefault.default)) return this.isPointContainedInBoundary(geom);
        if (geom instanceof (0, _lineStringJsDefault.default)) return this.isLineStringContainedInBoundary(geom);
        for(let i = 0; i < geom.getNumGeometries(); i++){
            const comp = geom.getGeometryN(i);
            if (!this.isContainedInBoundary(comp)) return false;
        }
        return true;
    }
    isLineSegmentContainedInBoundary(p0, p1) {
        if (p0.equals(p1)) return this.isPointContainedInBoundary(p0);
        if (p0.x === p1.x) {
            if (p0.x === this._rectEnv.getMinX() || p0.x === this._rectEnv.getMaxX()) return true;
        } else if (p0.y === p1.y) {
            if (p0.y === this._rectEnv.getMinY() || p0.y === this._rectEnv.getMaxY()) return true;
        }
        return false;
    }
    isLineStringContainedInBoundary(line) {
        const seq = line.getCoordinateSequence();
        const p0 = new (0, _coordinateJsDefault.default)();
        const p1 = new (0, _coordinateJsDefault.default)();
        for(let i = 0; i < seq.size() - 1; i++){
            seq.getCoordinate(i, p0);
            seq.getCoordinate(i + 1, p1);
            if (!this.isLineSegmentContainedInBoundary(p0, p1)) return false;
        }
        return true;
    }
    isPointContainedInBoundary() {
        if (arguments[0] instanceof (0, _pointJsDefault.default)) {
            const point = arguments[0];
            return this.isPointContainedInBoundary(point.getCoordinate());
        } else if (arguments[0] instanceof (0, _coordinateJsDefault.default)) {
            const pt = arguments[0];
            return pt.x === this._rectEnv.getMinX() || pt.x === this._rectEnv.getMaxX() || pt.y === this._rectEnv.getMinY() || pt.y === this._rectEnv.getMaxY();
        }
    }
    contains(geom) {
        if (!this._rectEnv.contains(geom.getEnvelopeInternal())) return false;
        if (this.isContainedInBoundary(geom)) return false;
        return true;
    }
}
exports.default = RectangleContains;

},{"../../geom/LineString.js":"1Hc8p","../../geom/Polygon.js":"jawWe","../../geom/Coordinate.js":"3REUb","../../geom/Point.js":"i9MoJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"irBEY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _polygonJs = require("../../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _rectangleLineIntersectorJs = require("../../algorithm/RectangleLineIntersector.js");
var _rectangleLineIntersectorJsDefault = parcelHelpers.interopDefault(_rectangleLineIntersectorJs);
var _shortCircuitedGeometryVisitorJs = require("../../geom/util/ShortCircuitedGeometryVisitor.js");
var _shortCircuitedGeometryVisitorJsDefault = parcelHelpers.interopDefault(_shortCircuitedGeometryVisitorJs);
var _simplePointInAreaLocatorJs = require("../../algorithm/locate/SimplePointInAreaLocator.js");
var _simplePointInAreaLocatorJsDefault = parcelHelpers.interopDefault(_simplePointInAreaLocatorJs);
var _linearComponentExtracterJs = require("../../geom/util/LinearComponentExtracter.js");
var _linearComponentExtracterJsDefault = parcelHelpers.interopDefault(_linearComponentExtracterJs);
class RectangleIntersects {
    constructor(){
        RectangleIntersects.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._rectangle = null;
        this._rectEnv = null;
        const rectangle = arguments[0];
        this._rectangle = rectangle;
        this._rectEnv = rectangle.getEnvelopeInternal();
    }
    static intersects(rectangle, b) {
        const rp = new RectangleIntersects(rectangle);
        return rp.intersects(b);
    }
    intersects(geom) {
        if (!this._rectEnv.intersects(geom.getEnvelopeInternal())) return false;
        const visitor = new EnvelopeIntersectsVisitor(this._rectEnv);
        visitor.applyTo(geom);
        if (visitor.intersects()) return true;
        const ecpVisitor = new GeometryContainsPointVisitor(this._rectangle);
        ecpVisitor.applyTo(geom);
        if (ecpVisitor.containsPoint()) return true;
        const riVisitor = new RectangleIntersectsSegmentVisitor(this._rectangle);
        riVisitor.applyTo(geom);
        if (riVisitor.intersects()) return true;
        return false;
    }
}
exports.default = RectangleIntersects;
class EnvelopeIntersectsVisitor extends (0, _shortCircuitedGeometryVisitorJsDefault.default) {
    constructor(){
        super();
        EnvelopeIntersectsVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._rectEnv = null;
        this._intersects = false;
        const rectEnv = arguments[0];
        this._rectEnv = rectEnv;
    }
    intersects() {
        return this._intersects;
    }
    visit(element) {
        const elementEnv = element.getEnvelopeInternal();
        if (!this._rectEnv.intersects(elementEnv)) return null;
        if (this._rectEnv.contains(elementEnv)) {
            this._intersects = true;
            return null;
        }
        if (elementEnv.getMinX() >= this._rectEnv.getMinX() && elementEnv.getMaxX() <= this._rectEnv.getMaxX()) {
            this._intersects = true;
            return null;
        }
        if (elementEnv.getMinY() >= this._rectEnv.getMinY() && elementEnv.getMaxY() <= this._rectEnv.getMaxY()) {
            this._intersects = true;
            return null;
        }
    }
    isDone() {
        return this._intersects === true;
    }
}
class GeometryContainsPointVisitor extends (0, _shortCircuitedGeometryVisitorJsDefault.default) {
    constructor(){
        super();
        GeometryContainsPointVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._rectSeq = null;
        this._rectEnv = null;
        this._containsPoint = false;
        const rectangle = arguments[0];
        this._rectSeq = rectangle.getExteriorRing().getCoordinateSequence();
        this._rectEnv = rectangle.getEnvelopeInternal();
    }
    visit(geom) {
        if (!(geom instanceof (0, _polygonJsDefault.default))) return null;
        const elementEnv = geom.getEnvelopeInternal();
        if (!this._rectEnv.intersects(elementEnv)) return null;
        const rectPt = new (0, _coordinateJsDefault.default)();
        for(let i = 0; i < 4; i++){
            this._rectSeq.getCoordinate(i, rectPt);
            if (!elementEnv.contains(rectPt)) continue;
            if ((0, _simplePointInAreaLocatorJsDefault.default).containsPointInPolygon(rectPt, geom)) {
                this._containsPoint = true;
                return null;
            }
        }
    }
    containsPoint() {
        return this._containsPoint;
    }
    isDone() {
        return this._containsPoint === true;
    }
}
class RectangleIntersectsSegmentVisitor extends (0, _shortCircuitedGeometryVisitorJsDefault.default) {
    constructor(){
        super();
        RectangleIntersectsSegmentVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._rectEnv = null;
        this._rectIntersector = null;
        this._hasIntersection = false;
        this._p0 = new (0, _coordinateJsDefault.default)();
        this._p1 = new (0, _coordinateJsDefault.default)();
        const rectangle = arguments[0];
        this._rectEnv = rectangle.getEnvelopeInternal();
        this._rectIntersector = new (0, _rectangleLineIntersectorJsDefault.default)(this._rectEnv);
    }
    intersects() {
        return this._hasIntersection;
    }
    isDone() {
        return this._hasIntersection === true;
    }
    visit(geom) {
        const elementEnv = geom.getEnvelopeInternal();
        if (!this._rectEnv.intersects(elementEnv)) return null;
        const lines = (0, _linearComponentExtracterJsDefault.default).getLines(geom);
        this.checkIntersectionWithLineStrings(lines);
    }
    checkIntersectionWithLineStrings(lines) {
        for(let i = lines.iterator(); i.hasNext();){
            const testLine = i.next();
            this.checkIntersectionWithSegments(testLine);
            if (this._hasIntersection) return null;
        }
    }
    checkIntersectionWithSegments(testLine) {
        const seq1 = testLine.getCoordinateSequence();
        for(let j = 1; j < seq1.size(); j++){
            seq1.getCoordinate(j - 1, this._p0);
            seq1.getCoordinate(j, this._p1);
            if (this._rectIntersector.intersects(this._p0, this._p1)) {
                this._hasIntersection = true;
                return null;
            }
        }
    }
}

},{"../../geom/Coordinate.js":"3REUb","../../geom/Polygon.js":"jawWe","../../algorithm/RectangleLineIntersector.js":"b0GZL","../../geom/util/ShortCircuitedGeometryVisitor.js":"3CaZT","../../algorithm/locate/SimplePointInAreaLocator.js":"cLho6","../../geom/util/LinearComponentExtracter.js":"3pr36","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b0GZL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coordinateJs = require("../geom/Coordinate.js");
var _coordinateJsDefault = parcelHelpers.interopDefault(_coordinateJs);
var _robustLineIntersectorJs = require("./RobustLineIntersector.js");
var _robustLineIntersectorJsDefault = parcelHelpers.interopDefault(_robustLineIntersectorJs);
var _envelopeJs = require("../geom/Envelope.js");
var _envelopeJsDefault = parcelHelpers.interopDefault(_envelopeJs);
class RectangleLineIntersector {
    constructor(){
        RectangleLineIntersector.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._li = new (0, _robustLineIntersectorJsDefault.default)();
        this._rectEnv = null;
        this._diagUp0 = null;
        this._diagUp1 = null;
        this._diagDown0 = null;
        this._diagDown1 = null;
        const rectEnv = arguments[0];
        this._rectEnv = rectEnv;
        this._diagUp0 = new (0, _coordinateJsDefault.default)(rectEnv.getMinX(), rectEnv.getMinY());
        this._diagUp1 = new (0, _coordinateJsDefault.default)(rectEnv.getMaxX(), rectEnv.getMaxY());
        this._diagDown0 = new (0, _coordinateJsDefault.default)(rectEnv.getMinX(), rectEnv.getMaxY());
        this._diagDown1 = new (0, _coordinateJsDefault.default)(rectEnv.getMaxX(), rectEnv.getMinY());
    }
    intersects(p0, p1) {
        const segEnv = new (0, _envelopeJsDefault.default)(p0, p1);
        if (!this._rectEnv.intersects(segEnv)) return false;
        if (this._rectEnv.intersects(p0)) return true;
        if (this._rectEnv.intersects(p1)) return true;
        if (p0.compareTo(p1) > 0) {
            const tmp = p0;
            p0 = p1;
            p1 = tmp;
        }
        let isSegUpwards = false;
        if (p1.y > p0.y) isSegUpwards = true;
        if (isSegUpwards) this._li.computeIntersection(p0, p1, this._diagDown0, this._diagDown1);
        else this._li.computeIntersection(p0, p1, this._diagUp0, this._diagUp1);
        if (this._li.hasIntersection()) return true;
        return false;
    }
}
exports.default = RectangleLineIntersector;

},{"../geom/Coordinate.js":"3REUb","./RobustLineIntersector.js":"fBBRl","../geom/Envelope.js":"ha5UZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3CaZT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryCollectionJs = require("../GeometryCollection.js");
var _geometryCollectionJsDefault = parcelHelpers.interopDefault(_geometryCollectionJs);
class ShortCircuitedGeometryVisitor {
    constructor(){
        ShortCircuitedGeometryVisitor.constructor_.apply(this, arguments);
    }
    static constructor_() {
        this._isDone = false;
    }
    applyTo(geom) {
        for(let i = 0; i < geom.getNumGeometries() && !this._isDone; i++){
            const element = geom.getGeometryN(i);
            if (!(element instanceof (0, _geometryCollectionJsDefault.default))) {
                this.visit(element);
                if (this.isDone()) {
                    this._isDone = true;
                    return null;
                }
            } else this.applyTo(element);
        }
    }
}
exports.default = ShortCircuitedGeometryVisitor;

},{"../GeometryCollection.js":"9xeCT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["eOIEV"], null, "parcelRequired761", {})

//# sourceMappingURL=draw.a9b6d309.js.map
